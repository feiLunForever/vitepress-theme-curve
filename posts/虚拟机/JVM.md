# JVM

## JVM、JDK、JRE

- Java 虚拟机（JVM）是运行 Java 字节码的虚拟机

  - JVM 有针对不同系统的特定实现，目的是使用相同的字节码，它们都会给出相同的结果。
  - 字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。
- JRE 是 Java 运行时环境。

  - 它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。
  - 但是，它不能用于创建新程序
- JDK 是功能齐全的 Java SDK。

  - 它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。
  - 它能够创建和编译程序。

## JVM 组成架构

### 类加载子系统

> 加载编译后 class 文件

- 类加载器
- 双亲委派模型
- 类加载过程

### 执行引擎子系统

- 将加载进内存的 class 字节码指令“翻译”成机器语言交由硬件执行

### 运行时数据区

> 开发者编写的所有代码最终都会被加载在这里之后再开始执行。同时，Java 为何能够避免像 C 那样，需要手动管理内存的原因之一也在于这块区域。

- PC 程序计数器
- 本地方法栈
- 虚拟机栈
- 元数据空间(方法区)
- 堆

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231451198.png" alt="image-20250613231451198" style="zoom:60%;" />

### 垃圾回收子系统

- 垃圾回收器
- 垃圾回收算法
- GC 调优

### 本地接口和本地方法库

- native 方法

## 类加载子系统

### 类的加载过程(类的生命周期)

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231523933.png" alt="image-20250613231523933" style="zoom:50%;" />

#### 加载

- 查找并加载类的二进制数据
- 在方法区中生成运行时的数据结构
- 在堆中生成一个 java.lang.Class 对象，这样便可以通过该对象访问方法区中的这些数据

#### 连接

##### 验证

确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查。

- **文件格式验证**：验证字节流是否符合 Class 文件格式的规范

  - 例如：是否以 0xCAFEBABE 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- **元数据验证**：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求

  - 检查是否继承了不允许被继承的类 final
- **字节码验证**：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。

  - 比如任意时刻的操作数栈和指令代码是否都能配合使用
- **符号引用验证**：确保解析动作能正确执行

##### 准备

正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。

1. 这时候进行内存分配的仅包括 `类变量（static）`，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
2. 这里所设置的初始值"通常情况"下是数据类型默认的 `零值`（如 0、0L、null、false 等）

   - 比如 `public static int value=111` ，那么 value 变量在准备阶段的初始值就是 ` 0` 而不是 111（初始化阶段才会赋值）。
   - 特殊情况：`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

##### 解析

符号引用转换为直接引用。

> 符号引用比如 `import java.util.ArrayList ` 这就算符号引用，直接引用就是指针或者对象地址

- 在编译的时候一个每个 java 类都会被编译成一个 class 文件，但在编译的时候，被引用的类、方法或者变量还没有被加载到内存中，虚拟机并不知道所引用类的地址。
- 暂时用符号（比如 com.example.Test）引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。

#### 初始化

在 Java 中 `对类变量进行初始值设定` 有两种方式：

> 1. 声明类变量是指定初始值
> 2. 使用静态代码块为类变量指定初始值

```
 JVM初始化步骤
```

> 1. 假如这个类还没有被加载和连接，则程序先加载并连接该类
> 2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类
> 3. 假如类中有初始化语句，则系统依次执行这些初始化语句

```
类初始化时机
```

只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：

> 1. 创建类的实例，也就是 new 的方式
> 2. 访问某个类或接口的静态变量，或者对该静态变量赋值
> 3. 调用类的静态方法
> 4. 反射（如 Class.forName(“com.shengsiyuan.Test”)）
> 5. 初始化某个类的子类，则其父类也会被初始化
> 6. Java 虚拟机启动时被标明为启动类的类（Java Test），直接使用 java.exe 命令来运行某个主类

`注意以下几种情况不会执行类初始化`：

> 1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
> 2. 定义对象数组，不会触发该类的初始化。
> 3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
> 4. 通过类名获取 Class 对象，不会触发类的初始化。
> 5. 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
> 6. 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。

#### 卸载

而当一个 Class 对象不再被任何一处位置引用，即不可触及时，Class 就会结束生命周期，该类加载的数据也会被卸载。

卸载类需要满足 3 个要求:

- 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象
- 该类没有在其他任何地方被引用
- 该类的类加载器的实例已被 GC

所以，在 JVM 生命周期类，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，jdk 自带的 BootstrapClassLoader,ExtClassLoader,AppClassLoader 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

### 类加载器

#### 类加载器类型

##### BootstrapClassLoader(启动类加载器)

- `<JAVA_HOME>\lib` 下的核心库

##### ExtensionClassLoader(扩展类加载器)

- `<JAVA_HOME>\lib\ext` 下

##### AppClassLoader(应用程序类加载器)

- `java -classpath` 下

##### Custom ClassLoader

- 当 class 文件不在 classpath 路径下时，需要自定义类加载器加载特定路径下的 class
- 当一个 class 文件是通过网络传输过来的并经过了加密处理，需要首先对 class 文件做了对应的解密处理后再加载到内存中时，需要自定义类加载器
- 线上环境不能停机时，要动态更改某块代码，这种情况下需要自定义类加载器
- 继承 ClassLoader 需要自己重写 findClass()方法并编写加载逻辑

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231600088.png" alt="image-20250613231600088" style="zoom:70%;" />

#### 双亲委派

##### 核心思想

- 自下向上检查类是否已经被加载
- 从上至下尝试加载类

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231624973.png" alt="image-20250613231624973" style="zoom:50%;" />

##### 为什么需要双亲委派

- 避免类的重复加载

  - 通过这种层级关可以避免类的重复加载，当⽗亲已经加载了该类时，就没有必要⼦ ClassLoader 再加载⼀次
- 防⽌核⼼ API 库被随意篡改

  - 假设通过⽹络传递⼀个名为 java.lang.Integer 的类，通过双亲委托模式传递到启动类加载器，⽽启动类加载器在核⼼ Java API 发现这个名字的类，发现该类已被加载，并不会重新加载⽹络传递的过来的 java.lang.Integer，⽽直接返回已加载过的 Integer.class，这样便可以防⽌核⼼ API 库被随意篡改。

##### 为什么要打破双亲委派

- 官方为我们提供了很多 `SPI` 接口，例如 JDBC，官方往往只会定义规范，具体的实现则是由第三方来完成的
- 这些 SPI 接口直接由 Java 核心库来提供，一般位于 `rt.jar` 包中，是由 `Bootstrap` 类加载器完成加载的
- 而第三方实现的具体代码库则一般被放在 `classpath` 的路径下，则是 `App类加载器` 进行加载的
- 在 SPI 接口中，会经常调用实现者的代码，所以一般会需要先去加载自己的实现类，但实现类并不在 `Bootstrap类加载器` 的加载范围内
- 双亲委派是指子类加载器可以将类加载请求委托给父类加载器进行加载，但这个过程是不可逆的
- 只能通过打破双亲委派机制来加载 SPI 接口的实现类

###### jdbc

> - 在 `DriverManager` 类的静态代码块中调用了 `loadInitialDrivers()` 方法
> - 该方法会通过 `ServiceLoader` 查找服务接口的实现类
> - 通过该 jar 包 `META-INF/services/` 里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入

我们先来看看 Java 中 SPI 定义的一个核心类：`DriverManager`，该类位于 `rt.jar` 包中，是 Java 中用于管理不同数据库厂商实现的驱动，同时这些各厂商实现的 Driver 驱动类，都继承自 Java 的核心类 `java.sql.Driver`，如 MySQL 的 `com.mysql.cj.jdbc.Driver` 的驱动类。先看看 `DriverManager` 的源码，如下：

```java
// rt.jar包 → DriverManager类
public class DriverManager {
    // .......
    
    // 静态代码块
    static {
        // 加载并初始化驱动
        loadInitialDrivers();
        println("JDBC DriverManager initialized");
    }

// DriverManager类 → loadInitialDrivers()方法
 private static void loadInitialDrivers() {
    // 先读取系统属性 jdbc.drivers
    String drivers;
    try {
        drivers = AccessController.doPrivileged(new PrivilegedAction<String>() {
            public String run() {
                return System.getProperty("jdbc.drivers");
            }
        });
    } catch (Exception ex) {
        drivers = null;
    }
    
    AccessController.doPrivileged(new PrivilegedAction<Void>() {
        public Void run() {
            //通过ServiceLoader类查找驱动类的文件位置并加载
            ServiceLoader<Driver> loadedDrivers =
            ServiceLoader.load(Driver.class);
            //省略......
        }
    });
    //省略......
}
```

在 `DriverManager` 类的静态代码块中调用了 `loadInitialDrivers()` 方法，该方法中，会通过 `ServiceLoader` 查找服务接口的实现类。前面分析 Java 的 SPI 机制时，曾提到过：Java 的 SPI 存在一种动态的服务发现机制，在程序启动时，会自动去 jar 包中的 `META-INF/services/` 目录查找以服务命名的文件，mysql-connector-java-6.0.6.jar 包文件目录如下：

![image-20250613231645530](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231645530.png)

观察如上工程结构，我们明确可以看到，在 MySQL 的 jar 包中存在一个 `META-INF/services/` 目录，而在该目录下，存在一个 `java.sql.Driver` 文件，该文件中指定了 MySQL 驱动 `Driver` 类的路径，该类源码如下：

```java
// com.mysql.cj.jdbc.Driver类
public class Driver extends NonRegisteringDriver 
                        implements java.sql.Driver {
    public Driver() throws SQLException {
    }
    // 省略.....
}
```

可以看到，该类是实现了 Java 定义的 SPI 接口 `java.sql.Driver` 的，所以在启动时，SPI 的动态服务发现机制可以发现指定的位置下的驱动类。

最终来看看 SPI 机制是如何加载对应实现类的，`ServiceLoader.load()` 源码如下：

```java
// ServiceLoader类 → load()方法
public static <S> ServiceLoader<S> load(Class<S> service) {
    // 获取线程上下文类加载器
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    // 使用线程上下文类加载器对驱动类进行加载
    return ServiceLoader.load(service, cl);
}
```

通过如上源码可以清晰的看见：最终是通过 `Thread.currentThread().getContextClassLoader()` 获取的当前执行线程的线程上下文类加载器对 SPI 接口的实现类进行了加载。

#### 热部署

- 全限定名相同的一个类被加载过之后，第二次需要用到该类时，会直接在类加载器的命名空间（可以理解为缓存）中进行查找，而不会二次加载此类
- 销毁自定义 classloader(被该加载器加载的 class 也会自动卸载)
- 更新 class
- 使用新的 ClassLoader 去加载 class

## 运行时的数据区域

![image-20250613231659141](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231659141.png)

### 线程私有

对于每条线程而言，在创建它们时，JVM 都会为它们分配的区域，这些内存区域的生命周期会随着 `线程` 的启动、死亡而创建和销毁。这些区域创建后，其他线程是不可见的，只有当前线程自身可以访问。

运行时数据区中的线程私有区域主要包含：`程序计数器`、`虚拟机栈` 以及 `本地方法栈`。

#### 程序计数器

> 生命周期随着 `线程` 创建而创建，结束而死亡

- 字节码解释器通过程序计数器依次读取指令(顺序执行、循环)
- 记录当前线程执行的位置，上下文切换

#### 虚拟机栈

> 负责程序运行时具体如何执行、如何处理数据
> 生命周期与线程一致，每个线程创建时都会为之创建一个虚拟机栈

一个栈帧中主要包含**局部变量表、操作数栈、动态链接、方法出口**等信息。

##### 局部变量表

- 一个由 `槽（slot）` 组成的数组，用于存储`方法参数`和方法内部定义的`局部变量`
- 表中存储的数据只对于当前方法中有效
- 局部变量表中的每个元素都可以存储一个数据值，数据类型可以是基本数据类型或者引用类型。
- 方法执行结束后，局部变量表会随着栈帧的的出栈/销毁而随之销毁

局部变量的存储位置：

- 对于基本数据类型的局部变量，它们的值直接存储在局部变量表中。
- 对于引用类型的局部变量，局部变量表中存储的是对象的引用，而对象的实际数据存储在堆内存中。

##### 操作数栈

- 用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间

##### 动态链接

- 在 Java 源文件被编译成 Class 文件时，类中所有的变量、方法调用都会化为符号引用，然后保存在 class 文件的常量池中
- 常量池中，在 class 文件中描述一个方法调用另一个方法时，就使用常量池中指向方法的符号引用来表示的
- 动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用(方法在实际运行时的内存布局中的入口地址)

```java
public class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog says: Woof!");
    }
  
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.makeSound();
    }
}
```

以下是当`Dog`类的`main`方法被执行时，动态链接是如何工作的：

1. **创建对象**：

    - `Animal myDog = new Dog();`这行代码在堆上创建了一个`Dog`对象，并在栈上为`myDog`变量分配了一个引用。
2. **方法调用**：

    - 当执行到`myDog.makeSound();`这行代码时，JVM将`makeSound`方法的符号引用压入操作数栈。
3. **动态链接解析**：

    - JVM执行`invokevirtual`指令，这是用于调用实例方法的指令。
    - `invokevirtual`指令会查找`myDog`引用的实际类型（即`Dog`类型），而不是声明类型（即`Animal`类型）。
    - JVM在`Dog`类的运行时常量池中查找`makeSound`方法的符号引用。
    - 如果是第一次调用，JVM会将符号引用解析为直接引用，即`Dog`类中`makeSound`方法在内存中的实际地址。
    - 解析后，JVM会调用`Dog`类的`makeSound`方法，而不是`Animal`类的`makeSound`方法。
4. **执行方法**：

    - 一旦解析完成，JVM跳转到`Dog`类的`makeSound`方法的代码，并执行它。
    - 结果是输出：“Dog says: Woof!”

###### 动态链接的重要性

在这个例子中，动态链接允许我们在运行时确定调用哪个方法。由于`myDog`变量的声明类型是`Animal`，但实际类型是`Dog`，动态链接确保了正确的`makeSound`方法被调用，这就是多态性的体现。

如果没有动态链接，Java的多态性将无法实现，因为方法调用将基于变量的声明类型而不是实际类型，这将导致`Animal`类的`makeSound`方法被调用，输出将是“Animal makes a sound”，而不是期望的“Dog says: Woof!”。

###### 虚方法表

在面向对象的编程中，动态分派使用频繁，每次动态分派的过程中，都要重新在类的元数据中搜索合适的目标的话就可能影响到执行效率，为此，虚拟机在类的方法区建立了一个虚方法表来实现使用索引表来代替查找。每个类都有一个自己的虚方法表，存放的是方法的实际入口地址（就是方法的直接引用）。虚方法表会在类加载的链接阶段创建并开始初始化，类的变量值初始完成之后，虚方法表也会初始完成。  

![image-20250613231750425](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231750425.png)

**虚方法表中存放着各个方法的实际入口地址，如果某个方法在子类没有被重写，那么该方法在子类和父类的虚方法表中的实际入口地址是一样的，都指向父类的入口，如果重写了，子类虚方法表的地址就会被替换为重写的方法入口地址，** 如上图，Son 类重写了 Father 的全部方法，所以 Son 类的方法表没有指向 Father 的类型数据(方法的直接引用存于方法去类型数据下)，而 Son 和 Father 都没有重写 Object 的方法，所以虚方法表中没有重写的方法都指向了 Object 的类型数据。

##### 方法出口

- 正常时，返回调用者的程序计数器
- 异常时由异常处理器来确定

> 一个方法当开始被执行引擎执行时，只有两种情况会导致方法退出，一种是在执行过程中遇到了正常返回的字节码指令，如：ireturn、lreturn、dreturn、areturn、return，释义如下：
>
> - ireturn：返回值为 int、byte、char、short、boolean 类型时使用该指令返回
> - lreturn：返回值为 long 类型时使用该指令返回
> - dreturn：返回值为 double 类型时使用该指令返回
> - areturn：返回值为引用类型时使用该指令返回
> - return：无返回 void、类或接口初始化方法时使用该指令返回
>
> 方法正常执行完成后退出的情况被称为**正常完成出口**，一般执行返回的字节码指令时，调用者的程序计数器会被作为返回的地址。
> 除开正常执行完成后退出的情况外，还有一种情况也会导致方法的退出，那就是方法执行过程中出现了异常，并且在方法体中没有处理该异常（没有 try/catch），此时也会导致方法退出，这种情况下被称为**异常完成出口**，返回地址则需要通过异常处理器表来确定。
> 当一个方法执行结束退出时，会执行如下步骤：
>
> - ① 复原上层方法的局部变量表以及操作数栈。
> - ② 如果当前方法有返回值的情况下，把返回值压入调用者方法栈帧的操作数栈中。
> - ③ 将 PC 计数器的地址指向改为方法下一条指令的位置，从而使得调用者正常工作。
> - PS：异常退出的情况下，是不会给上层调用者返回任何值的。

#### 本地方法栈

本地方法栈和虚拟机栈差不多是类似的，区别在于虚拟机栈是用于执行 Java 方法的，而本地方法栈则是用于执行 C 所编写的 Native 本地方法。在程序运行之初，首先会在本地方法栈中登记 Native 本地方法，在执行引擎执行时，保存本地方法的相关数据（参数、局部变量等）。

#### 程序计数器，操作数栈，局部变量表 协调工作

```java
public int calc() {
        int a = 100;
        int b = 200;
        int c = 300;
        return (a + b) * c;
    }
```

![image-20250613231804557](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231804557.png)

### 线程共享

在运行时，这些区域对于程序中的所有线程而言都是可见的，这些区域的状态不会因为某一条线程的死亡而发生改变，这些区域创建后是与 JVM 同级别的，伴随 JVM 的生命周期共生共死。

运行时数据区中的线程共享去主要包含：`堆空间`、`元数据空间（方法区）` 以及 `直接内存` 这三大块。

#### 堆

Java 堆的作用与前面分析的 Java 栈不同，栈主要是作为运行时的单位，用于临时存储运行时需要以及产生的数据，而 Java 堆是存储的单位，主要解决的问题是数据存储问题，重点关注的领域是数据怎么存，放哪里，怎么放等。

##### 堆和栈的区别

1. 内存分别
   - 堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。
   - 栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。

2. 存放的内容
   - 堆存放的是对象的实例和数组。因此该区更关注的是数据的存储
   - 栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。

> - 静态变量放在方法区
> - 静态的对象还是放在堆
> - 如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上。
> - 如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。
> - 对象的成员变量与对象本身一起存储在堆上, 不管成员变量的类型是原生数值，还是对象引用。
> - 类的静态变量则和类定义一样都保存在方法区中。

3. 程序的可见度
   - 堆对于整个应用程序都是共享、可见的。
   - 栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。

##### 为什么把堆和栈区分出来

- 栈代表处理逻辑
  堆代表数据
- 比较符合面向对象的设计，栈和堆配合使用

> 1. 从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。
> 2. 堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。
> 3. 栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。
> 4. 面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。

#### 元数据空间(原方法区)

- 类的元数据、VM 内部表、类的层级信息/方法信息/字段信息、方法的编译信息和字节码数据、静态变量、常量池以及符号引用

#### 直接内存

直接向操作系统申请内存空间，属于直接使用物理内存的一块区域，也被称为“堆外空间”。

对比堆空间而言，访问直接内存的速度会超出堆内存，也就是读写性能优于 Java 堆，来源于 Java 的 `NIO` 库，Java 的 `NIO` 可以允许 Java 程序直接使用本地的直接内存存储数据缓冲，因为如果把一些文件数据转为对象存储在堆中时，很容易导致堆空间负载过重而 OOM。所以出于 `性能` 和 `稳定性` 两方面的考虑，一般对于一些 `读写频繁` 的场景或 `读取/写出大文件` 时的场景都可以使用直接内存进行操作。

##### 直接内存（堆外内存）与堆内存比较

- 直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显
- 直接内存 IO 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显

### 内存泄漏与内存溢出

- 内存溢出：程序分配到了 `10MB` 内存，但运行过程中产生了 `11MB` 数据写入到该空间，这叫做内存溢出
- 内存泄漏：是没有完全回收掉之前申请的内存

### OOM

#### 原因

- 内存中加载数据量过于庞大导致 OOM，如一次性从数据库中查询出几千万条数据导致创建出一个超大型的数据数组
- JVM 启动时，使用参数为其分配的堆空间过小，导致程序正常运行的内存都不足够
- 系统流量超出原有的预估值，导致大量请求进入系统，创建大量对象，内存过小 OOM
- 代码中存在逻辑不正确的循环导致在特定情况下产生了大量重复的对象实例，比如 for 循环创建大量对象

#### 排查

- 利用 top 命令获取相应 pid，“-H”代表 thread 模式，你可以配合 grep 命令更精准定位。

```shell
top –H
```

- 然后转换成为 16 进制。

```shell
printf "%x" your_pid
```

- 最后利用 jstack 获取的线程栈，对比相应的 ID 即可。

## Java 对象分析

### Java 对象内存布局

Java 对象一般在内存中的布局通常由对象头、实例数据、对齐填充三部分组成，如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231819575.png" alt="image-20250613231819575" style="zoom:50%;" />

32 位/64 位的对象头信息，对象头结构及存储大小说明如下：

|虚拟机|对象头结构信息|说明|大小|
| ------| ------------------------------| --------------------------------------------------------------------| -----------|
|32 位|MarkWord|HashCode、分代年龄、是否偏向锁和锁标记位|4byte/32bit|
|32 位|ClassMetadataAddress/KlassWord|类型指针指向对象的类元数据，JVM 通过这个指针确定该对象是哪个类的实例|4byte/32bit|
|32 位|ArrayLenght|如果是数组对象存储数组长度，非数组对象不存在|4byte/32bit|

|虚拟机|对象头结构信息|说明|大小||
| ------| ------------------------------| --------------------------------------------------------------------| -----------| ----------------------------------|
|64 位|MarkWord|unused、HashCode、分代年龄、是否偏向锁和锁标记位|8byte/64bit||
|64 位|ClassMetadataAddress/KlassWord|类型指针指向对象的类元数据，JVM 通过这个指针确定该对象是哪个类的实例|8byte/64bit|开启指针压缩的情况下为 4byte/32bit|
|64 位|ArrayLenght|如果是数组对象存储数组长度，非数组对象不存在|4byte/32bit||

#### 对象头

##### MarkWord

存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231836492.png" alt="image-20250613231836492" style="zoom:80%;" />

##### 类型指针

对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。在 32 位系统占 4 字节，在 64 位系统中占 8 字节。

##### Length

只在数组对象中存在，用来记录数组的长度，占用 4 字节

#### 实例数据

实例数据，对象实际数据，对象实际数据包括了对象的所有成员变量，其大小由各个成员变量的大小决定。(这里不包括静态成员变量，因为其是在方法区维护的)

#### 对齐填充

Java 对象占用空间是 8 字节对齐的，即所有 Java 对象占用 bytes 数必须是 8 的倍数，因为当我们从磁盘中取一个数据时，不会说我想取一个字节就是一个字节，都是按照一块儿一块儿来取的，这一块大小是 8 个字节，所以为了完整，padding 的作用就是补充字节，**保证对象是 8 字节的整数倍**

### 对象大小计算

```
在Java中创建一个Object对象会占用多少内存呢？
public static void main(String[] args){
    Object obj = new Object();
    System.out.println(ClassLayout.parseInstance(obj).toPrintable());
}
```

可以来进行初步计算，对象头大小应该理论上为 `mrakword`+`klassword`=`16bytes`，同时 Object 类中是没有定义任何属性的，所以不存在实例数据。但如果在开启指针压缩的情况下，只会有 `12bytes`，因为对象头中的类元指针会被压缩一半，所以会出现 4bytes 的对齐填充，最终不管是否开启了指针压缩，大小应该为 `16字节`。

结果运行如下：

```powershell
java.lang.Object object internals:
OFFSET  SIZE   TYPE DESCRIPTION            VALUE
0     4        (object header)        ......  
4     4        (object header)        ...... 
8     4        (object header)        ......  
12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
```

从结果中可以很明显的看到，0–12byte 为对象头，12–16byte 为对齐填充数据，最终大小为 `16bytes`，与上述的推测无误，在开启指针压缩的环境下，会出现 `4bytes` 的对齐填充数据。

```
上述简单分析了Object对象的大小之后，我们再来看一个案例，如下：
public static void main(String[] args){
    Object obj = new int[9];
    System.out.println(ClassLayout.parseInstance(obj).toPrintable());
}
```

此时大小又为多少呢？因为该数组为 int 数组，而 int 类型的大小为 32bit/4bytes，所以理论上它的大小为：`(12bytes对象头+9*4=36bytes数组空间) = 48bytes`，对吗？先看看运行结果：

```powershell
[I object internals:
 OFFSET  SIZE   TYPE DESCRIPTION          VALUE
      0     4        (object header)      .....
      4     4        (object header)      .....
      8     4        (object header)      .....
     12     4        (object header)      .....
     16    36    int [I.<elements>        N/A
     52     4        (loss due to the next object alignment)
Instance size: 56 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
```

从结果中可以看出最终大小为 `56bytes`，实际的大小与前面的推断存在明显出入，为什么呢？这是因为目前的 obj 对象是一个数组对象，在前面分析对象头构成的时候曾分析过，如果一个对象是数组对象，那么它的对象头中也会使用 `4bytes` 存储数组的长度，所以此时的 obj 对象头大小为 16bytes，其中 12~16bytes 用于存储数组的长度，再加上 9 个 int 类型的数组空间 36bytes，大小为 52bytes，因为 52 不为 8 的整数倍，所以 JVM 会为其补充 `4bytes` 的 `对齐填充` 数据，最终大小就成了上述运行结果中的 `56bytes`。

### java 对象分配过程

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231855261.png" alt="image-20250613231855261" style="zoom:60%;" />

#### 类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

#### 分配内存

Java 的对象并不是直接一开始就尝试在堆上进行分配的，分配过程如下：

![image-20250613231912204](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231912204.png)

##### 首先尝试栈上分配

如果对象被分配在栈上，那么该对象就无需 GC 机制回收它，该对象会随着方法栈帧的销毁随之自动回收。但如果一个对象大小超过了栈可用空间（栈总大小-已使用空间），那么此时就不会尝试将对象进行栈上分配。

在 `hotspot 逃逸分析` 的基础上，使用 `标量替换` 拆解聚合量，以基本量代替对象，然后最终做到将对象拆散分配在虚拟机栈的局部变量表中，从而减少对象实例的产生，减少堆内存的使用以及 GC 次数。

> - `逃逸分析`：逃逸分析是建立在方法为单位之上的，如果一个成员在方法体中产生，但是直至方法结束也没有走出方法体的作用域，那么该成员就可以被理解为未逃逸。反之，如果一个成员在方法最后被 return 出去了或在方法体的逻辑中被赋值给了外部成员，那么则代表着该成员逃逸了。
> - `标量替换`：建立在逃逸分析的基础上使用基本量标量代替对象这种聚合量，标量泛指不可再拆解的数据，八大基本数据类型就是典型的标量。

##### 尝试 TLAB 分配

在 Eden 区为每条线程划分的一块私有缓冲内存。

> 大部分的 Java 对象是会被分配在堆上的，但也说到过堆是线程共享的，那么此时就会出现一个问题：当 JVM 运行时，如果出现两条线程选择了同一块内存区域分配对象时，不可避免的肯定会发生竞争，这样就导致了分配速度下降。
>
> 虚拟机为了根治这个问题，为每条线程专门分配一块内存区域，这块区域就被称为 TLAB 区，当一条线程尝试为一个对象分配内存时，如果开启了 TLAB 分配的情况下，那么会先尝试在 TLAB 区域进行分配。
>
> 一般情况只有当 TLAB 区分配失败时才会开始尝试在堆上分配。

##### 年老代分配

初次分配时，`大对象` 直接进入年老代。  
一般对象进入年老代的情况只有三种：`大对象`、`长期存活对象` 以及`动态年龄判断符合条件的对象`。

> 动态年龄符合条件的对象：sum(Survivor 区中相同年龄的所有对象大小) > Survivor 空间 / 2

##### 新生代分配

如果栈上分配、TLAB 分配、年老代分配都未成功，此时就会来到 Eden 区尝试新生代分配。而在新生代分配时，会存在两种分配方式：

- `指针碰撞`：如果 Java 堆的内存是规整，即所有用过的内存放在一边，而空闲的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。
- `空闲列表`：如果 Java 堆的内存不是规整的，则需要由虚拟机维护一个列表来记录 那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。

###### **内存分配并发问题**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

- **CAS+ 失败重试**： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性**。
- **TLAB**： 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。

#### 初始化（设置零值）

经过内存分配的步骤之后，当前创建的 Java 对象会在内存中被分配到一块区域，接着则会初始化分配到的这块空间，JVM 会将分配到的内存空间（不包括对象头）都初始化为零值。

这样做的好处在于：可以保证对象的实例字段在 Java 代码中不赋初始值就直接使用，程序可以访问到字段对应数据类型所对应的零值，避免不赋值直接访问导致的空指针异常。

> - 如果对象是被分配在栈上，那所有数据都会被分配在栈帧中的局部变量表中。
> - 如果对象是 TLAB 分配，那么初始化内存这步操作会被提前到内存分配的阶段进行。

#### 设置对象头

- 当初始化零值完成后，紧接着会对于对象的对象头进行设置。首先会将对象的原始哈希码、GC 年龄、锁标志、锁信息组装成 `MrakWord` 放入对象头中
- 然后会将指向当前对象类元数据的类型指针 `KlassWord` 也加入对象头中
- 如果当前对象是数组对象，那么还会将编码时指定的数组长度 ArrayLength 放入对象中

#### 执行 <init> 函数

最后会执行 <init> 函数，也就是构造函数，经过这个步骤之后才能够在真正意义上构建出一个可用对象。

### 对象引用类型

#### 强引用

以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 下例中，b 就是强引用。

```java
public static void main(String[] args) {
    Object a = new Object();
    Object b = a;
    a = null;
    System.out.println(b); //java.lang.Object@4554617c
}
```

#### 软引用

> 内存不够就回收

#### 弱引用

> 一定回收

```java
public static void weakReferenceTest() {
    Object a = new Object();
    ReferenceQueue < Object > queue = new ReferenceQueue < > ();
    WeakReference < Object > weakReference = new WeakReference < > (a, queue);
    System.out.println(a); //java.lang.Object@4554617c
    System.out.println(weakReference.get()); //java.lang.Object@4554617c
    System.out.println(queue.poll()); //null
    System.out.println("-------------------");
    a = null;
    System.gc();
    System.out.println(a); //null
    System.out.println(weakReference.get()); //null
    //虚引用在回收之前被加入到了引用队列中
    System.out.println(queue.poll()); //java.lang.ref.WeakReference@74a14482
}
```

#### 虚引用

> 一定回收，get 出来就是 null，引用形同虚设，主要和引用队列联合使用，在 finalize 之前会被放到引用队列中

```java
public static void phantomReferenceTest() {
    Object a = new Object();
    ReferenceQueue < Object > queue = new ReferenceQueue < > ();
    PhantomReference < Object > phantomReference = new PhantomReference < > (a, queue);
    System.out.println(a); //java.lang.Object@4554617c
    System.out.println(phantomReference.get()); //null
    System.out.println(queue.poll()); //null
    System.out.println("-------------------");
    a = null;
    System.gc();
    System.out.println(a); //null
    System.out.println(phantomReference.get()); //null
    //引用在回收之前被加入到了引用队列中
    System.out.println(queue.poll()); //java.lang.ref.WeakReference@74a14482
}
```

## 垃圾回收子系统

### GC 基础篇

#### 判断存活对象

##### 引用计数法

当 Object 的对象实例被创建出来后，计数器会被初始化为 `1`，因为局部变量 obj 的指针引用了该实例对象。而后续执行过程中，又有另外一个变量引用该实例时，该对象的引用计数器会 `+1`。而当方法执行结束，栈帧中局部变量表中引用该对象的指针随之销毁时，当前对象的引用计数器会 `-1`。当一个对象的计数器为 `0` 时，代表当前对象已经没有指针引用它了，那么在 GC 发生时，该对象会被判定为“`垃圾`”，然后会被回收。

```
优缺点
```

- 方法实现简单，效率高
- 无法解决循环引用问题

> 比如两个**对象循环引用**，a 对象引用了 b 对象，b 对象也引用了 a 对象，a、b 对象却没有再被其他对象所引用了，其实正常来说这两个对象已经是垃圾了，因为没有其他对象在使用了，但是计数器内的数值却不是 0，所以引用计数算法就无法回收它们。

###### `Recycler`**试验删除算法**

虽然循环引用的问题可通过 `Recycler` 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较  
低，早期的编程语言会采用此算法。

当出现环状引用结构或者自引用结构的时候，导致垃圾回收器无法回收这部分内存，为了解决这个问题，业界出现的最普遍的最广泛认可的是**试验删除算法**。

试验删除算法的思想是：

- 在环状垃圾指针结构内部，所有对象的引用计数都由其内部对象之间的指针产生。
- 只有在删除某一对象的某个引用之后，该对象的引用计数扔大于零时，才有可能出现环状垃圾。
- 有了这两条，可以使用部分追踪(partial tracing)从一个可能是垃圾的对象开始进行子图追踪。对于每一个候选垃圾对象，算法将对其进行试验删除，从而移除由内部指针产生的引用计数。追踪完成后，如果某个对象的引用计数仍然不为0，那么肯定存在一个外部对象引用了该对象。

> 使用recycler算法可以实现这个思想，它主要分为以下三个阶段：
>
> - 回收器从某个可能是环状垃圾成员的对象出发进行子图追踪，同时减少由内部指针产生的引用计数。算法通过 三色标记法（后面会讲到） 将遍历到的对象设为灰色。
> - 对子图中所有对象进行检测，如果某一对象的引用计数不是零，则该对象必然被子图外的其他对象引用。此时需要对第一阶段的试验删除操作进行修正，算法将存活的灰色对象重新设为黑色，同时将其他灰色对象设为白色。
> - 子图中依然为白色的对象必然是垃圾，算法可以将其回收。

##### 可达性分析

会以这些 GCRoots 作为根节点，然后从上至下的方式进行搜索分析，当一个对象没有任何引用链相连时，则会被判定为该对象是不可达的，即代表着此对象不可用，最终该对象会被判定为“垃圾”对象等待回收。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231933464.png" alt="image-20250613231933464" style="zoom:50%;" />

###### GC root

- 虚拟机栈(栈帧中的本地变量表)中引用的对象

  - 譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等

```java
public class StackLocalParameter {
       public StackLocalParameter(String name){}
}
public static void testGC(){
       StackLocalParameter s = new StackLocalParameter("localParameter");
       s = null; 
}
```

> 此时的 s，即为 GC Root，当 s 置空时，localParameter 对象也断掉了与 GC Root 的引⽤链，将被回收。

- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象

  - 譬如 Java 类的引用静态变量
- 方法区中常量引用的对象

  - 譬如字符串常量池中的引用
- Java 虚拟机内部的引用

  - 如基本数据类型对应的 Class 对象
  - 一些常驻的异常对象(空指针异常、OOM 等)
  - 还有类加载器
- 所有被 Synchronized 持有的对象

###### 临时 GC Roots

- 目前的垃圾回收大部分都是分代收集和局部回收，如果只针对某一部分区域进行局部回收，那么就必须要考虑的当前区域的对象有可能正被其他区域的对象所引用，这时候就要将这部分关联的对象也添加到 GC Roots 中去来确保根可达算法的准确性。

#### STW

在发生 GC 时会停下所有的用户线程，从而导致 Java 程序出现全局停顿的无响应情况，而这种情况则被称为 STW（Stop The World）世界暂停。

- 避免产生浮动垃圾

  - 刚刚标记完成一块区域中的对象，但转眼用户线程又在该区域中产生了新的“垃圾”
- 确保内存一致

  - 可达性分析算法的工作必须要在一个能够确保一致性的内存快照中进行
  - 不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果的准确性无法得到保证

#### gc 类型划分

##### young gc

在 JVM 中，发生次数最多的也就是新生代 GC，毕竟新生代中的对象都是朝生夕死的，也是分配最为频繁的，所以新生代 GC 也是触发最频繁的。

- `eden区` 满了触发，`survivor满` 不会触发

##### old gc

当老年代满时会触发 old gc，但一般而言，年老代 GC 触发时往往都会伴随新生代 GC 一起发生，只有 CMS 收集器会有单独收集年老代空间的行为，其他收集器均无此行为。

##### full gc

全面收集也被称为 FullGC，是所有 GC 类型中，耗时最长、停顿最久的 GC，FullGC 会对于所有可发生 GC 的区域进行全面回收，其中涵盖新生代、年老代以及元数据空间。

一般触发 FullGC 的原因有如下几种：

- 调用 `system.gc()`，JVM 在内存占用较多时会尝试发生 FullGC，但并非 100% 触发
- 老年代不足
- 元空间不足
- 对象晋升时年老代空间无法承载晋升对象
- `担保机制` 失败

  - 老年代为新生代提供担保
  - 老年代最大可用的连续空间是否大于新生代所有对象总空间
  - 如果不成立，检查是否允许担保失败

    - 如果允许，检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小

      - 如果大于，尝试进行一次 young gc
      - 如果小于，或者不允许冒险，full gc

#### 垃圾回收算法

##### 标记清除

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231949368.png" alt="image-20250613231949368" style="zoom:50%;" />

- 从 `gcroot` 开始标记，记录在 `markword` 中
- 标记完，所有不可达对象，就需要被清除掉

> 注：关于 GC 标记到底在哪儿？其实在上一章节中就已经分析过了，在对象头中存在一个 markword 字段，而 GC 标志位就存在其内部。
>
> 同时，清除阶段并不是简单的置空内存，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够就存放。

```
缺点
```

- 额外维持一个内存的空闲列表
- 效率问题，随着对象越来越多，那么所需要消耗的时间就会越来越多
- 空间问题（标记清除后会产生大量不连续的碎片）

##### 标记复制

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232003347.png" alt="image-20250613232003347" style="zoom:50%;" />

在发生 GC 时，首先会将左侧这块内存区域中的存活对象移动到右侧这块空闲内存中，如下：

![image-20250613232026428](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232026428.png)

然后会对于左侧这块内存所有区域进行统一回收，如下：

![image-20250613232037307](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232037307.png)

```
缺点
```

- 浪费过多的内存，使现有的可用空间变为原先的一半

##### 标记整理

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232046679.png" alt="image-20250613232046679" style="zoom:70%;" />

标记跟标-清一样，整理是将存活对象移动到一端

- 在标记阶段时也会基于 GcRoots 节点遍历整个内存中的所有对象，然后对所有存活对象做一次标记。
- 在整理阶段该算法并不会和标-清算法一样简单的清理内存，而是会将所有存活对象移动（压缩）到内存的一端，然后对于存活对象边界之外的内存进行统一回收。

```
缺点
```

- 收集效率并不高

  - 因为标-整算法不仅仅要标记对象，同时还要移动存活对象，所以整个 GC 过程下来，它所需要耗费的时间资源开销必然是不小的。

##### 分代收集

- 新生代 - 复制算法
- 老年代 - 标-整 / 标 - 清

#### 完整的 GC 流程

![image-20250613232118606](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232118606.png)

![image-20250613232143825](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232143825.png)

- 如果对象在 Eden 出生，并经过第一次 Minor GC 后仍然存活，并且被 Survivor 容纳的话，年龄设为 1
- 当 Eden 区的空间满了， Java 虚拟机会触发一次 Minor GC，`Eden`区和当前的 `from`区中存活的对象会被复制到空闲的 `to`区。**复制完成后，****`from区`****和** **`Eden区`****的内容被清空，这两个区域的角色互换**，即原来的 `to区`变为新的 `from区`，原来的 `from`区变为新的 `to区`。
- 每熬过一次 Minor GC，年龄 +1，若年龄超过一定限制 (15)，则被晋升到老年态
- 老年代满了而无法容纳更多的对象，Minor GC 之后通常就会进行 Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代
- 大对象(需要大量连续内存空间的 Java 对象，如那种很长的字符串)直接进入老年态

#### 什么对象会进入老年代

初次分配时，`大对象` 直接进入年老代。  
一般对象进入年老代的情况只有三种：`大对象`、`长期存活对象` 以及`动态年龄判断符合条件的对象`。

> 动态年龄符合条件的对象：sum(Survivor 区中相同年龄的所有对象大小) > Survivor 空间 / 2

#### 担保机制

- 老年代为新生代提供担保
- 老年代最大可用的连续空间是否大于新生代所有对象总空间
- 如果不成立，检查是否允许担保失败

  - 如果允许，检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小

    - 如果大于，尝试进行一次 young gc
    - 如果小于，或者不允许冒险，full gc

### gc 收集器

#### 分代收集器

##### 新生代

###### Serial 收集器（单线程）

![image-20250613232159221](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232159221.png)

- 串行 GC，单线程
- 采用算法：`复制算法`
- GC 时，停掉用户线程，同时，在 `STW` 的时候**只会有一条线程**去进行垃圾收集的工作
- `-XX:+UseSerialGC `

###### ParNew 收集器（多线程）

![image-20250613232208842](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232208842.png)

- 并行 GC，多线程
- 采用算法：`复制算法`
- GC 过程发生在 `STW` 中，采用多线程回收
- 可以被称为 `Serial` 收集器的 `多线程` 版本
- `-XX:+UseParNewGC`

###### Parallel Scavenge

![image-20250613232219041](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232219041.png)

- 并行 GC，多线程
- 采用算法：`复制算法`
- GC 过程发生在 `STW` 中，采用多线程回收
- `-XX:+UseParallelGC`

> - ParNew 通过控制 GC 线程数量来缩短程序暂停时间（一个CPU核，就创建一个线程），更关心程序的响应时间
> - ParallelScavenge 更关心的是程序运行的吞吐量（固定线程，允许用户设置目标吞吐量，并尽可能达到这个目标）

##### 老年代

###### Serial Old（MSC） （单线程）

![image-20250613232229711](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232229711.png)

- 串行 GC，单线程
- `标记-整理算法`
- GC 过程发生在 `STW` 中，采用单线程执行串行回收
- `-XX:+UseSerialGC`

###### Parallel Old （多线程）

![image-20250613232239539](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232239539.png)并行 GC，多线程

- `标记-整理算法 `
- GC 过程发生在 `STW` 中，采用多线程回收
- `-XX:+UseParallelOldGC`

###### CMS

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232255724.png" alt="image-20250613232255724" style="zoom:80%;" />

- 并发 GC，多线程并行执行
- `标记-清除算法 `
- GC 过程会发生 `STW`，但并非整个 GC 过程都在 STW 中执行，采用多线程回收
- `-XX:+UseConcMarkSweepGC`
- `缺点`

  - 无法回收浮动垃圾
  - 对 CPU 资源非常依赖
  - GC 完成后会造成大量内存碎片

> - ① CMS 是一款完全基于多线程环境研发的收集器，默认情况下，回收过程中开启的线程数为(CPU 核数 +3)/4，也就代表着：一台八核的机器至少要开启 2~3 条 GC 线程。而当 CPU 核数少于 4 时，CMS 的 GC 线程则会对用户线程性能造成很大影响，因为需要让出一半的 CPU 运算资源去执行 GC 回收工作。
> - ② 由于 CMS 收集器的回收工作是并发清除垃圾对象的，因此，在清除阶段用户线程依旧在执行，而用户线程执行就必然会造成新的垃圾产生，但这部分新产生的垃圾对象是无法标记的，所以只能等到下次 GC 发生时才可回收，而这部分垃圾则被称为“`浮动垃圾`”。
> - ③ 因为 CMS 采用的是标记-清除算法，所以在回收工作结束之后会造成大量的内存碎片。
> - 为何不采用标-整算法呢？因为 CMS 是并发执行的，所以如果将存活对象压缩到内存一端，那么用户线程中的所有对象引用都需改变，实现起来及其复杂且影响效率。

CMS收集器的整个事件如下所示:

```yaml
2024-07-01T16:23:07.321-0200: 64.425: [GC (CMS Initial Mark) [1 CMS-initial-mark: 10812086K(11901376K)] 10887844K(12514816K), 0.0001997 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2024-07-01T16:23:07.321-0200: 64.425: [CMS-concurrent-mark-start]
2024-07-01T16:23:07.357-0200: 64.460: [CMS-concurrent-mark: 0.035/0.035 secs] [Times: user=0.07 sys=0.00, real=0.03 secs]
2024-07-01T16:23:07.357-0200: 64.460: [CMS-concurrent-preclean-start]
2024-07-01T16:23:07.373-0200: 64.476: [CMS-concurrent-preclean: 0.016/0.016 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]
2024-07-01T16:23:07.373-0200: 64.476: [CMS-concurrent-abortable-preclean-start]
2024-07-01T16:23:08.446-0200: 65.550: [CMS-concurrent-abortable-preclean: 0.167/1.074 secs] [Times: user=0.20 sys=0.00, real=1.07 secs]
2024-07-01T16:23:08.447-0200: 65.550: [GC (CMS Final Remark) [YG occupancy: 387920 K (613440 K)]65.550: [Rescan (parallel) , 0.0085125 secs]65.559: [weak refs processing, 0.0000243 secs]65.559: [class unloading, 0.0013120 secs]65.560: [scrub symbol table, 0.0008345 secs]65.561: [scrub string table, 0.0001759 secs][1 CMS-remark: 10812086K(11901376K)] 11200006K(12514816K), 0.0110730 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]
2024-07-01T16:23:08.458-0200: 65.561: [CMS-concurrent-sweep-start]
2024-07-01T16:23:08.485-0200: 65.588: [CMS-concurrent-sweep: 0.027/0.027 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]
2024-07-01T16:23:08.485-0200: 65.589: [CMS-concurrent-reset-start]
2024-07-01T16:23:08.497-0200: 65.601: [CMS-concurrent-reset: 0.012/0.012 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
```

`阶段 1：`**`Initial Mark 初始标记`**

- 仅标记 `GcRoot` 节点直接关联的对象，很快
- `STW`

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232312176.png" alt="image-20250613232312176" style="zoom:80%;" />

```yaml
2024-07-01T16:23:07.321-0200: 64.421: [GC (CMS Initial Mark2[1 CMS-initial-
mark: 10812086K3(11901376K)4] 10887844K5(12514816K)6, 0.0001997 secs] [Times: user=0.00 
sys=0.00, real=0.00 secs]7

1.  2024-07-01T16:23:07.321-0200: 64.42 – GC 事件启动的时间，包括时钟时间和相对于JVM 启动的时间。对于接下来的阶段，在整个事件中都使用相同的概念。
2.  CMS Initial Mark – 收集阶段(此处为“初始标记”)，即收集所有 GC 根。
3.  10812086K – 当前 Old Generation 内存使用情况.
4.  (11901376K) – 年老代中的总可用内存。
5.  10887844K – 当前使用的堆情况
6.  (12514816K) – 总可用对大小
7.  0.0001997 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] – 阶段的持续时间，也可以在user 、sys 和 real 中测量。
```

`阶段 2 ：`**`Concurrent Mark 并发标记`**

- 该阶段主要是做 GC 溯源工作（GcTracing），从根节点出发，对整个堆空间进行可达性分析，找出所有存活对象
- 该阶段的 GC 线程会与用户线程同时执行

```yaml
2024-07-01T16:23:07.321-0200: 64.425: [CMS-concurrent-mark-start]

2024-07-01T16:23:07.357-0200: 64.460: [CMS-concurrent-mark1: 035/0.035 secs2] [Times: user=0.07 sys=0.00, real=0.03 secs]3

1.  CMS-concurrent-mark – 收集阶段——此处为“并发标记”——遍历年老代并标记所有活动对象。
2.  035/0.035 secs – 相位的持续时间，相应地显示流逝时间和挂钟时间。
3.  [Times: user=0.07 sys=0.00, real=0.03 secs] – “时间”部分对于并发标记阶段来说没那么有意义，因为它是从并发标记开始度量的，并且不仅仅包括为并发标记所做的工作。
```

`阶段 3：`**`Concurrent Preclean 并发预清理`**

- 这一步是可选的，可以通过参数 CMSPrecleaningEnabled 参数可以启用或关闭该阶段，默认是开启的。
- 在并发标记阶段，由于引用的变更，可能会产生一些 dirty page，这一阶段的主要工作就就是处理这些脏页，虽然在后面的重新标记阶段也拥有处理脏页的逻辑，但重新标记阶段会 Stop The World，所以这一阶段的核心仍然是让停顿时间尽量缩短
- 该阶段的 GC 线程会与用户线程同时执行

> 一些引用发生了更改。当发生这种情况时，JVM 将包含变化对象的堆区域(称为“Card”)标记为“脏”(这称为卡片标记)，Card 是典型的采用空间换时间的逻辑，因为不需要扫描整个Heap 空间，从而可以有效的降低 GC 耗时。
>
> <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232330600.png" alt="image-20250613232330600" style="zoom:60%;" />
>
> 在预清理阶段，这些脏对象会被计算在内，并且还会标记从这些脏对象可以到达的对象。这一步完成后，卡片将被清洗。
>
> <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232347506.png" alt="image-20250613232347506" style="zoom:60%;" />

```yaml
2024-07-01T16:23:07.357-0200: 64.460: [CMS-concurrent-preclean-start]

2024-07-01T16:23:07.373-0200: 64.476: [CMS-concurrent-preclean1: 0.016/0.016 secs2] [Times: user=0.02 sys=0.00, real=0.02 secs]3

1.  CMS-concurrent-preclean – 收集阶段 – “并发预清理”，主要考虑在前一个标记阶段更改的引用。
2.  0.016/0.016 secs – 同上
3.  [Times: user=0.02 sys=0.00, real=0.02 secs] – 同上
```

`阶段 4：`**`Concurrent Abortable Preclean 并发可终止的预清理阶段`**

- 这一阶段的主要工作是处理新生代指向老年代的新引用，从而让老年代的一些未被标记的对象成为活跃对象。
- 同样，在重新标记阶段也会处理这样的情况，这一阶段仍然是为了缩短停顿时间而进行的。

> 显然，在这一阶段中要识别新生代对象对老年代对象的新引用，那么就必须扫描整个新生代，这显然是一项很耗时的操作，但由于新生代的对象大多是朝生夕死的，所以如果在一次 minorGC 之后紧接着进行一次预清理，新生代中需要扫描的对象就会所剩无几了。
>
> CMS 通过 CMSScavengeBeforeRemark 参数强制在可中断的并发预清理阶段执行一次 minorGC，虽然 minorGC 也会让用户线程短暂停顿，但这样可以缩短下一阶段的停顿时间，整体上还是利大于弊的。

```yaml
2024-07-01T16:23:07.373-0200: 64.476: [CMS-concurrent-abortable-preclean-start]

2024-07-01T16:23:08.446-0200: 65.550: [CMS-concurrent-abortable-preclean1: 0.167/1.074 secs2] [Times: user=0.20 sys=0.00, real=1.07 secs]3

1.  CMS-concurrent-abortable-preclean – 收集阶段，并发可终止的预清理
2.  0.167/1.074 secs – 相位持续时间，分别显示流逝时间和挂钟时间。有意思的是，报告的用户时间要比时钟时间小得多。通常我们看到实时时间比用户时间短，也就意味着一些工作是并行完成的，因此经过的时钟时间比使用的 CPU 时间短。这里有少量的工作——0.167 秒的 CPU 时间，垃圾收集器线程做了大量的等待。从本质上说，他们试图在必须暂停 STW 之前尽可能长时间地避开。默认情况下，此阶段最多可持续 5 秒钟。
```

`阶段 5：`**`Final Remark 重新标记`**

- 这个阶段主要是为了 `修正`“并发标记”阶段由于用户线程执行造成的 GC 标记变动的那部分对象
- 该阶段需要在 `STW` 中执行，并且该阶段的停顿时间会比初始阶段要长不少

> CMS 的第二个 STW 事件。这个 STW 阶段的目标是完成对年老代所有活动对象的标记。
>
> 由于以前的 preclean 阶段是并发的，它们可能无法跟上应用程序的变化速度。为了完成这个工作，所以必须再次进行 STW。

```yaml
2024-07-01T16:23:08.447-0200: 65.5501: [GC (CMS Final Remark2) [YG occupancy: 387920 K (613440 K)3]65.550: [Rescan (parallel) , 0.0085125 secs]465.559: [weak refs processing, 0.0000243 secs]65.5595: [class unloading, 0.0013120 secs]65.5606: [scrub string table, 0.0001759 secs7][1 CMS-remark: 10812086K(11901376K)8] 11200006K(12514816K) 9, 0.0110730 secs10] [[Times: user=0.06 sys=0.00, real=0.01 secs]11

1.  2024-07-01T16:23:08.447-0200: 65.550 –GC事件启动的时间，包括时钟时间和相对于JVM启动时间的时间。
2.  CMS Final Remark – 收集阶段–最终重新标记 –标记了年老代中的所有活动对象，包括在先前的并发标记阶段中创建/修改的引用。
3.  YG occupancy: 387920 K (613440 K) – 年轻代占用和容量
4.  [Rescan (parallel) , 0.0085125 secs] – “重新扫描”在应用程序停止时完成活动对象的标记。在本例中，重新扫描是并行进行的，耗时 0.0085125 秒。
5.  weak refs processing, 0.0000243 secs]65.559 – 第一个子阶段，正在处理弱引用以及该阶段的持续时间和时间戳。
6.  class unloading, 0.0013120 secs]65.560 – 下一个子阶段，正在卸载未使用的类，并带有该阶段的持续时间和时间戳。
7.  scrub string table, 0.0001759 secs – 最后一个子阶段，清理符号和字符串表，它们分别保存了类级别的元数据和字符串内部池，暂停的时钟时间也包括在内。
8.  10812086K(11901376K) – 年老代情况
9.  11200006K(12514816K) – 堆使用情况
10.  0.0110730 secs – 持续时间
```

在五个标记阶段之后，年老代的所有活对象都被标记，现在垃圾收集器将通过清除年老代来回收所有未引用的对象

`阶段 6：`**`Concurrent Sweep 并发清除`**

- 在该阶段主要是对存活对象之外的垃圾对象进行清除
- 不需要停止用户线程，是并发执行的

`阶段 7：`**`Concurrent Reset 并发重置`**

并行执行阶段，重置 CMS 算法的内部数据结构，并为下一个周期做好准备。

#### 分区收集器

##### G1

###### 特点

- ① 与 CMS 收集器一样，能够与用户线程同时执行，完成并发收集。
- ②GC 过程会有整理内存的过程，不会产生内存碎片，并且整理空闲内存速度更快。
- ③GC 发生时，停顿时间可控，可以让程序更大程度上追求低延迟。
- ④ 采用 `复制算法`，region -> region

  - 每个 Region 区角度看来是采用的 `复制算法`，但从堆空间整体看来，则是采用了 `标-整` 算法，这也是所谓的“`局部复制，全局标-整`”
- ⑤ 后台维护一个 CSet 优先列表，记录了 gc 要收集的 region 集合（可任意年代），gc 回收时，根据用户指的的期望停顿时间，优先从列表中回收价值最大的 region 区域，g1 的由来

###### 内存划分

![image-20250613232409391](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232409391.png)

G1 将 Java 堆划分为多个大小相等的独立的 `Region` 区域，一般 `Region` 区的大小等于堆空间的总大小除以 `2048`，比如目前的堆空间总大小为 8GB，就是 8192MB/2048=4MB，那么最终每个 `Region` 区的大小为 4MB。

新生代中的 `Eden` 区和 `Survivor` 区对应的 Region 区比例也跟之前一样，默认 `8:1:1`，假设新生代现在有 400 个 Region，那么整个新生代的占比则为 `Eden`=320,`S0/From`=40,`S1/To`=40。

G1 中的年老代晋升条件和之前的无差，达到 `年龄阈值` 的对象会被转入 `年老代` 的 `Region` 区中，不同的是对于大对象的分配，在 G1 中不会让大对象进入年老代，在 G1 中由专门存放大对象的 Region 区叫做 `Humongous` 区，如果在分配对象时，判定出一个对象属于大对象，那么则会直接将其放入 `Humongous` 区存储。

> 对象大小是否超过单个普通 `Region` 区的 `50%`，如果超过则代表当前对象为大对象，那么该对象会被直接放入 `Humongous` 区。
>
> 可以避免一些“短命”的巨型对象直接进入年老代，节约年老代的内存空间，可以有效避免年老代因空间不足时的 GC 开销

###### gc 类型

G1 中主要存在 `YoungGC`、`MixedGC` 以及 `FullGC` 三种 GC 类型，这三种 GC 类型分别会在不同情景下被触发。

- young gc

> - 在 G1 中，当新生代区域被用完时，G1 首先会大概计算一下回收当前的新生代空间需要花费多少时间，如果回收时间远远小于参数 `-XX:MaxGCPauseMills` 设定的值，那么不会触发 `YoungGC`，而是会继续为新生代增加新的 `Region` 区用于存放新分配的对象实例。
> - 直至某次 `Eden` 区空间再次被放满并经过计算后，此次回收的耗时接近 `-XX:MaxGCPauseMills` 参数设定的值，那么才会触发 `YoungGC`。
> - 当 `YoungGC` 被触发时，首先会将目标 `Region` 区中的存活对象移动至幸存区空间（被打着 `Survivor-from` 区标志的 `Region`）。同时达到晋升年龄标准的对象也会被移入至年老代 `Region` 中存储。

- mixed gc

> - 当整个堆中年老代的区域占有率达到参数设定的值
> - 回收所有 `新生代Region区`、部分 `年老代Region区`（会根据期望的 GC 停顿时间选择合适的年老代 Region 区 `优先` 回收）以及 `大对象Humongous区`

- full gc

> - MixedGC 时，如果发现没有足够空闲的 `region` 区去拷贝对象，触发 fullgc
> - 首先会 `停止` 系统所有用户线程
> - 然后采用 `单线程` 进行 `标记`、`清理` 和 `压缩整理` 内存，以便于清理出足够多的空闲 `Region` 来供下一次 `MixedGC` 使用

###### 过程

![image-20250613232423043](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232423043.png)

`阶段 1：`**`Initial Mark 初始标记`**

- `STW`，`单线程` GC 线程快速标记 `GCRoots` 直连的对象

```yaml
1.631: [GC pause (G1 Evacuation Pause) (young) **(initial-mark)** , 0.0062656 secs]
```

`阶段 2：`**`Root Region Scan 根区域扫描`**

- G1扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一个过程**必须在Young GC之前完成（因为Young GC会操作Survivor区中的对象）** 。

```yaml
1.362: [GC concurrent-root-region-scan-start]
1.364: [GC concurrent-root-region-scan-end, 0.0028513 secs]
```

`阶段 3：`**`Concurrent Mark 并发标记`**

- 与 CMS 的并发标记过程一致，采用多条 GC 线程与用户线程共同执行，根据 `Root` 根节点标记所有对象。

```yaml
1.364: [GC concurrent-mark-start]
1.645: [GC concurrent-mark-end, 0.2803470 secs]
```

`阶段 4：`**`Remark 最终标记`**

- `STW`，同 CMS 的重新标记阶段，主要是为了 `纠正` 并发标记阶段因用户操作导致的 `错标`、`误标`、`漏标` 对象

```yaml
1.645: [GC remark 1.645: [Finalize Marking, 0.0009461 secs] 1.646: [GC ref-proc, 
0.0000417 secs] 1.646: [Unloading, 0.0011301 secs], 0.0074056 secs]
[Times: user=0.01 sys=0.00, real=0.01 secs]
```

`阶段 5：`**`Cleanup 筛选回收`**

- 先对各个 `Region` 区的回收价值和成本进行 `排序`，找出「回收价值最大」的 `Region` 优先回收
- `STW`，多线程并行回收，停顿时间可控，回收效率高

```yaml
1.652: [GC cleanup 1213M->1213M(1885M), 0.0030492 secs]
[Times: user=0.01 sys=0.00, real=0.00 secs]
```

###### 适用场景

- 采用原本分代收集器 GC 时间会长达 1s+ 的应用
- 至少 8GB 以上堆内存的应用
- 追求停顿时间在 500ms 以内的应用

###### 性能问题

初始标记因为只标记 GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。

因此，G1 停顿时间的瓶颈主要是标记 - 复制中的转移阶段 STW。为什么转移阶段不能和标记阶段一样并发执行呢？**主要是 G1 未能解决转移过程中准确定位对象地址的问题。**

G1 的 Young GC 和 CMS 的 Young GC，其标记 - 复制全过程 STW，这里不再详细阐述。

##### ZGC

###### 分区

在 ZGC 中，也会把堆空间划分为一个个的 `Region` 区域，但 ZGC 中的 `Region` 区不存在 `分代` 的概念，它仅仅只是简单的将所有 `Region` 区分为了 `大`、`中`、`小` 三个等级，

![image-20250613232437487](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232437487.png)

- 小型区/页(`Small`)：固定大小为 2MB，用于分配小于 256KB 的对象。
- 中型区/页(`Medium`)：固定大小为 32MB，用于分配 >=256KB ~ <=4MB 的对象。
- 大型区/页(`Large`)：没有固定大小，容量可以动态变化，但是大小必须为 2MB 的整数倍，专门用于存放 >4MB 的巨型对象。
- 过程

  - 标记：从根节点出发标记所有存活对象
  - 转移：将需要回收区域中的存活对象转移到新的分区中
  - 重定位：将所有指向转移前地址的指针更改为指向转移后的地址

与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用**标记 - 复制算法**，不过 ZGC 对该算法做了重大改进：ZGC 在`标记`、`转移`和`重定位`阶段几乎都是并发的，这是 ZGC 实现停顿时间小于 10ms 目标的最关键原因。

###### 三大重要特性

**1. 内存多重映射**

内存多重映射，就是使用 mmap 把不同的虚拟内存地址映射到同一个物理内存地址上。如下图：

![image-20250613232449555](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232449555.png)

ZGC 为了更灵活高效地管理内存，使用了内存多重映射，把同一块儿物理内存映射为 Marked0、Marked1 和 Remapped 三个虚拟内存。

当应用程序创建对象时，会在堆上申请一个虚拟地址，这时 ZGC 会为这个对象在 Marked0、Marked1 和 Remapped 这三个视图空间分别申请一个虚拟地址，这三个虚拟地址映射到同一个物理地址。

Marked0、Marked1 和 Remapped 这三个虚拟内存作为 ZGC 的三个视图空间，在同一个时间点内只能有一个有效。ZGC 就是通过这三个视图空间的切换，来完成并发的垃圾回收。

**2.染色指针**

我们知道 G1 垃圾收集器使用了三色标记，这里先做一个回顾。下面是一个三色标记过程中的对象引用示例图：

![image-20250613232500879](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232500879.png)

总共有三种颜色，说明如下：

- 白色：本对象还没有被标记线程访问过。
- 灰色：本对象已经被访问过，但是本对象引用的其他对象还没有被全部访问。
- 黑色：本对象已经被访问过，并且本对象引用的其他对象也都被访问过了。

三色标记的过程如下：

1. 初始阶段，所有对象都是白色。
2. 将 GC Roots 直接引用的对象标记为灰色。
3. 处理灰色对象，把当前灰色对象引用的所有对象都变成灰色，之后将当前灰色对象变成黑色。
4. 重复步骤 3，直到不存在灰色对象为止。

三色标记结束后，白色对象就是没有被引用的对象（比如上图中的 H  和 G），可以被回收了。

那什么是**染色指针**呢？

ZGC 出现之前， GC 信息保存在对象头的 Mark Word 中。比如 64 位的 JVM，对象头的 Mark Word 中保存的信息如下图：

![image-20250613232513294](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232513294.png)

前 62位保存了 GC 信息，最后两位保存了锁标志。

> 这种记录方式在**有对象访问的场景下**是很自然流畅的，不会有什么额外负担。但如果有一些对象根本就不会去访问它，但又希望得知该对象的某些信息的场景呢？
>
> 我们就有这样的场景——追踪式收集算法的标记阶段就可能存在**只跟指针打交道而不必涉及指针所引用的对象本身的场景**。
>
> - 例如 对象标记的过程中需要给对象打上三色标记，这些标记本质上就只和对象的引用有关，而与对象本身无关——某个对象只有它的引用关系能决定它存活与否，对象上其他所有的属性都不能够影响它的存活判定结果
> - ZGC的染色指针**直接把标记信息记在引用对象的指针上**

ZGC 的一大创举是将 GC 信息保存在了染色指针上。**染色指针是一种将少量信息直接存储在指针上的技术**。在 64 位 JVM  中，对象指针是 64 位，如下图：

![image-20250613232524854](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232524854.png)

‍

在这个 64 位的指针上，高 16 位都是 0，暂时不用来寻址。剩下的 48 位支持的内存可以达到 256 TB（2 ^48）,这可以满足多数大型服务器的需要了。不过 ZGC 并没有把 48 位都用来保存对象信息，而是用高 4 位保存了四个标志位，这样 ZGC 可以管理的最大内存可以达到 16 TB（2 ^ 44）。

通过这四个标志位，JVM 可以从指针上直接看到对象的三色标记状态（Marked0、Marked1）、是否进入了重分配集（Remapped）、是否需要通过 finalize 方法来访问到（Finalizable）。

无需进行对象访问就可以获得 GC 信息，这大大提高了 GC 效率。

**3.读屏障**

读屏障类似于 Spring AOP 的前置增强，是 JVM 向应用代码中插入一小段代码，当应用线程从堆中读取对象的引用时，会先执行这段代码。**注意：只有从堆内存中读取对象的引用时，才会执行这个代码**。下面代码只有第一行需要加入读屏障。

```java
Object o = obj.FieldA // 从堆中读取引用，需要加入屏障
<Load barrier>
Object p = o // 无需加入屏障，因为不是从堆中读取引用
o.dosomething() // 无需加入屏障，因为不是从堆中读取引用
int i = obj.FieldB //无需加入屏障，因为不是对象引用
```

**ZGC 中读屏障的代码作用**：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。

> 读屏障会对应用程序的性能有一定影响，据测试，对性能的最高影响达到 4%，但提高了 GC 并发能力，降低了 STW。

> 着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；而在 ZGC 中，只需要设置指针地址的第 42~45 位即可，并且因为是寄存器访问，所以速度比访问内存更快。

> ZGC 通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着 GC 线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。
>
> 而在 ZGC 中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新  
> 到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM 是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。

###### gc 过程

前面已经讲过，ZGC 使用内存多重映射技术，把物理内存映射为 Marked0、Marked1 和 Remapped 三个地址视图，利用地址视图的切换，ZGC 实现了高效的并发收集。

ZGC 的垃圾收集过程包括标记、转移和重定位三个阶段。如下图：

![image-20250613232538841](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232538841.png)

ZGC 初始化后，整个内存空间的地址视图被设置为 Remapped。

**1. 初始标记**

从 GC Roots 出发，找出 GC Roots 直接引用的对象，放入活跃对象集合，这个过程需要 STW，不过 **STW 的时间跟 GC Roots 数量成正比**，耗时比较短。

**2. 并发标记**

并发标记过程中，GC 线程和 Java 应用线程会并行运行。这个过程需要注意下面几点：

- GC 标记线程访问对象时，如果对象地址视图是 `Remapped`，就把对象地址视图切换到 `Marked0`，如果对象地址视图已经是 `Marked0`，说明已经被其他标记线程访问过了，跳过不处理。
- 标记过程中Java 应用线程新创建的对象会直接进入 `Marked0 视图`。
- 标记结束后，如果对象地址视图是 `Marked0`，那就是活跃的，如果对象地址视图是 `Remapped`，那就是不活跃的。

**标记阶段的活跃视图也可能是 Marked1，为什么会采用两个视图呢？** 

这里采用两个视图是为了区分前一次标记和这一次标记。如果这次标记的视图是 Marked0，那下一次并发标记就会把视图切换到 Marked1。这样做可以配合 ZGC 按照页回收垃圾的做法。如下图：

![image-20250613232552070](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232552070.png)

第二次标记的时候，如果还是切换到 `Marked0`，那么 2 这个对象区分不出是活跃的还是上次标记过的。如果第二次标记切换到 `Marked1`，就可以区分出了。

这时 `Marked0` 这个视图的对象就是上次标记过程被标记过活跃，转移的时候没有被转移，但这次标记没有被标记为活跃的对象。`Marked1` 视图的对象是这次标记被标记为活跃的对象。

`Remapped` 视图的对象是上次垃圾回收发生转移或者是被 Java 应用线程访问过，本次垃圾回收中被标记为不活跃的对象。

![image-20250613232603596](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232603596.png)

**3. 再标记**

并发标记阶段 GC 线程和 Java 应用线程并发执行，标记过程中可能会有引用关系发生变化而导致的漏标记问题。再标记阶段重新标记**并发标记阶段**发生变化的对象，还会对非强引用（软应用，虚引用等）进行并行标记。

这个阶段需要 STW，但是需要标记的对象少，耗时很短。

**4. 初始转移**

**转移就是把活跃对象复制到新的内存，之前的内存空间可以被回收。**

初始转移需要扫描 GC Roots 直接引用的对象并进行转移，这个过程需要 STW，STW 时间跟 GC Roots 成正比。

**5. 并发转移**

并发转移过程 GC 线程和 Java 线程是并发进行的。上面已经讲过，转移过程中对象视图会被切回 Remapped 。转移过程需要注意以下几点：

- 如果 GC 线程访问对象的视图是 `Marked0`，则转移对象，并把对象视图设置成 `Remapped`。
- 如果 GC 线程访问对象的视图是 `Remapped`，说明被其他 GC 线程处理过，跳过不再处理。
- 并发转移过程中 Java 应用线程创建的新对象地址视图是 `Remapped`。
- 如果 Java 应用线程访问的对象被标记为活跃并且对象视图是 Marked0，则转移对象，并把对象视图设置成 Remapped。

**6.重定位**

转移过程对象的地址发生了变化，在这个阶段，把所有指向对象旧地址的指针调整到对象的新地址上。

#### 跨代引用

- 新生代 GC 时都会通过根可达算法先判断垃圾对象，年老代引用了新生代对象
- G1 记忆集 Rset

  - （HashTable），Key 为其他引用当前区内对象的 Region 起始地址，Value 则是一个集合，里面的元素为其他 Region 中每个引用当前区内对象的地址
- CMS 卡表

  - 一个字节数组，数组中每个元素对应着其标识的内存区域，称为卡页，hotSpot 使用的卡页大小为 2^9 即 512 字节，也就是说内存中每连续的 512 字节会被当作一个卡页作为卡表的一个元素。
  - 如果有年老代的对象引用了新生代的对象，那么该新生代对象所在区域对应的卡页元素设置为 1，反之则为 0

#### 三色标记法

三色标记算法是自 CMS 收集器后，应用比较广泛的一种并发标记算法，它可以让 `JVM` 在发生 `GC` 时，只发生短暂的 `STW` 即可实现存活对象标记的一种算法。

##### 定义

- 白：未曾标记过的对象，或不具备引用的对象（垃圾对象）
- 灰：当前对象已经被标记完成，但关联节点（属性成员）还未标记的对象
- 黑：已经被标记完成，且依旧存活的对象

##### 过程

![image-20250613232617973](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232617973.png)

- 最开始，所有对象都属于 `白色` 集合
- 在 GC 发生时，发生短暂的 `STW`，将所有与 `GcRoots` 直接相连的对象转入 `灰色` 集合中
- 之后并发执行，对灰色集合中的对象进行遍历，根据 `可达性分析` 算法进行对象存活 `标记`，当一个对象的 `所有成员` 全部被标记完成后，该对象则会被移入到 `黑色` 集合中。同时，也会将该对象中被标记的成员从 `白色` 集合移入 `灰色` 集合中
- 不断重复上一步操作，直至灰色集合彻底没了对象为止
- 标记完成所有对象后，再次触发 `STW`，通过 `write-barrier写屏障` 检测对象是否有变化，如果发生了改变则 `重新标记`，纠正并发标记期间的“误标”
- 并发执行清除工作，将 `白色` 集合中的所有对象全部回收（因为根据 GCRoots 节点进行可达性分析后，所有的存活对象都会从白色集合移入到黑色集合中，所以依旧留在白色集合中的对象必然为垃圾对象，这些对象就是需要被回收的对象）
- 最终等待清除工作完成后，代表着整个 GC 过程结束，再把 `标记复位`，将所有的对象再次放入白色集合中，等待迎接下次 GC 的到来

##### 问题

###### 并发标记导致的错标

- 被标记为黑色的对象，被引用的关系突然断开了，成为了垃圾

> 这种情况则被称为三色标记导致的“错标/误标/多标”，也被称为并发标记产生的**浮动垃圾**。
>
> 后面早晚被干掉，问题不大

###### 发执行导致漏标

- ① 白色对象断开灰色对象的引用，但又与黑色对象建立引用

![image-20250613232630026](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232630026.png)

- 白色对象断开灰色对象的引用，后面又重新建立了引用

> 一条用户线程在执行过程中，正好在 GC 线程标记时，将一个灰色对象与一个未标记的白色对象之间的引用连接断开了，然后当 GC 标记完成这个灰色对象，将其标记为黑色后，之前断开的白色对象又重新与之建立起了引用关系。

![image-20250613232640349](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232640349.png)

而当出现这两种情况时，因为重新建立引用的 `白色` 对象“`父节点`”已经被标记 `黑色` 了，所以 GC 线程不会再次标记该对象以及其成员对象，所以这些 `白色` 对象会被一直停留在白色集合中。最终导致的结果就是这些依旧存在引用的存活对象会被“`误判`”为垃圾对象 `清除掉`。

这种情况会直接影响到应用程序的正确性，是 `不可接受` 的。

###### 如何解决漏标问题

先来思考一下引起漏标问题的原因：

> - 条件一：`灰色` 对象 `断开` 了与 `白色` 对象的引用（直接引用或间接引用都可）。
> - 条件二：已经标为 `黑色` 的对象 `重新` 与 `白色` 对象建立了引用关系。

只有当一个对象同时满足了如上两个条件时才可发生漏标问题。

```
CMS解决漏标问题：增量更新 + 写屏障
```

- 写屏障

> 所谓的写屏障，则是指在赋值操作前后加入一些逻辑处理（类似于 SpringAOP 面向切面前后置处理的思想）
>
> 而 CMS 收集器则是通过在写屏障的后置处理中，实现了增量更新的逻辑，从而解决了漏标问题。

- 增量更新

> - 当一个未标记的白色对象，被其他对象重新引用时，白色对象会被记录下
> - 等并发标记阶段的 `GCRoots` 遍历标记完成后，在重新标记阶段会去找到集合里面的引用，再把 `源头` 标记为 `灰色`，然后重新去扫描标记这些对象。

> CMS 通过写屏障 + 增量更新这种手段，破坏了之前分析漏标问题时的第二个条件：已经标为黑色的对象重新与白色对象建立了引用关系。
>
> 通过增量更新的手段，会将这些重新建立了引用的“源头”再次恢复为灰色对象，然后在重新标记阶段会再次标记，同时为了避免重新标记阶段时再次发生漏标问题，所以重新标记阶段是必须要发生 STW 的。

```
G1解决漏标问题：STAB + 写屏障
```

> - GC 开始前，会生成一份原始快照，并发标记过程会以最初的对象关系进行访问，也就是说，不管怎么变，都以最初的引用关系进行标记
> - G1 是通过破坏「条件一：灰色对象断开了与白色对象的引用。」解决了漏标问题。

### gc问题判断

在做 GC 问题排查和优化之前，我们需要先来明确下到底是不是 GC 直接导致的问题，或者应用代码导致的 GC 异常，最终出现问题。

#### 判断 GC 有没有问题

##### 设定评价标准

评判 GC 的两个核心指标：

- 也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大。
- 应 用 系 统 的 生 命 周 期 内， 由 于 GC 线 程 会 占 用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。

简而言之，即为 **一次停顿的时间不超过应用服务的 TP9999，GC的吞吐量不小于99.99%** 。

举个例子，假设某个服务 A 的 TP9999 为 80 ms，平均 GC 停顿为 30ms，那么该服务的最大停顿时间最好不要超过 80 ms，GC 频次控制在 5 min 以上一次。如果满足不了，那就需要调优或者通过更多资源来进行并联冗余。（大家可以先停下来，看看监控平台上面的 gc.meantime 分钟级别指标，如果超过了 6 ms 那单机 GC 吞吐量就达不到 4 个 9 了。）

##### 读懂 GC Cause

拿到 GC 日志，我们就可以简单分析 GC 情况了，通过一些工具，我们可以比较直观地看到 Cause 的分布情况，如下图就是使用 gceasy 绘制的图表：

![image-20250613232701539](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232701539.png)

如上图所示，我们很清晰的就能知道是什么原因引起的 GC，以及每次的时间花费情况，但是要分析 GC 的问题，先要读懂 GC Cause，即 JVM 什么样的条件下选择进行 GC 操作，具体 Cause 的分类可以看一下 Hotspot 源码：src/share/vm/gc/shared/gcCause.hpp 和 src/share/vm/gc/shared/gcCause.cpp 中。

重点需要关注的几个 GC Cause：

- **System.gc()** ：手动触发 GC 操作。
- **CMS**：CMS GC 在执行过程中的一些动作，重点关注 CMS Initial Mark 和 CMS Final Remark 两个 STW 阶段。
- **Promotion Failure**：Old 区没有足够的空间分配给 Young 区晋升的对象（即使总可用内存足够大）。
- **Concurrent Mode Failure**：CMS GC 运行期间，Old 区预留的空间不足以分配给新的对象，此时收集器会发生退化，严重影响 GC 性能，下面的一个案例即为这种场景。
- **GCLocker Initiated GC**：如果线程执行在 JNI 临界区时，刚好需要进行GC，此时 GC Locker 将会阻止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。

#### 判断是不是GC引发的问题

到底是结果（现象）还是原因，在一次 GC 问题处理的过程中，如何判断是 GC 导致的故障，还是系统本身引发 GC 问题。这里继续拿在本文开头提到的一个 Case：“GC 耗时增大、线程 Block 增多、慢查询增多、CPU 负载高等四个表象，如何判断哪个是根因？”，笔者这里根据自己的经验大致整理了四种判断方法供参考：

- **时序分析：** 先发生的事件是根因的概率更大，通过监控手段分析各个指标的异常时间点，还原事件时间线，如先观察到 CPU 负载高（要有足够的时间Gap），那么整个问题影响链就可能是：CPU 负载高 -> 慢查询增多 -> GC 耗时增大 -> 线程 Block 增多 -> RT 上涨。

- **概率分析：** 使用统计概率学，结合历史问题的经验进行推断，由近到远按类型分析，如过往慢查的问题比较多，那么整个问题影响链就可能是：慢查询增多 -> GC 耗时增大 -> CPU 负载高 -> 线程 Block 增多 -> RT 上涨。
- **实验分析：** 通过故障演练等方式对问题现场进行模拟，触发其中部分条件（一个或多个），观察是否会发生问题，如只触发线程 Block 就会发生问题，那么整个问题影响链就可能是：线程 Block 增多 -> CPU 负载高 -> 慢查询增多  
  -> GC 耗时增大 -> RT 上涨。
- **反证分析：** 对其中某一表象进行反证分析，即判断表象的发不发生跟结果是否有相关性，例如我们从整个集群的角度观察到某些节点慢查和 CPU 都正常，但也出了问题，那么整个问题影响链就可能是：GC 耗时增大 -> 线程 Block  
  增多 -> RT 上涨。

不同的根因，后续的分析方法是完全不同的。如果是 CPU 负载高那可能需要用火焰图看下热点、如果是慢查询增多那可能需要看下 DB 情况、如果是线程 Block 引起那可能需要看下锁竞争的情况，最后如果各个表象证明都没有问题，那可能 GC 确实存在问题，可以继续分析 GC 问题了。

#### 常见场景分析与解决

##### 动态扩容引起的空间动荡

###### 现象

服务 **刚刚启动时 GC 次数较多** ，最大空间剩余很多但是依然发生 GC，这种情况我们可以通过观察 GC 日志或者通过监控工具来观察堆的空间变化情况即可。GC Cause一般为 Allocation Failure，且在 GC 日志中会观察到经历一次 GC ，堆内各个空间的大小会被调整，如下图所示：

![image-20250613232715125](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232715125.png)

###### 原因

在 JVM 的参数中 -Xms 和 -Xmx 设置的不一致，在初始化时只会初始 -Xms 大小的空间存储信息，每当空间不够用时再向操作系统申请，这样的话必然要进行一次GC。

另外，如果空间剩余很多时也会进行缩容操作，JVM 通过 -XX:MinHeapFreeRatio 和 -XX:MaxHeapFreeRatio 来控制扩容和缩容的比例，调节这两个值也可以控制伸缩的时机。

整个伸缩的模型理解可以看这个图，当 committed 的空间大小超过了低水位 / 高水位的大小，capacity 也会随之调整：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232726031.png" alt="image-20250613232726031" style="zoom:70%;" />

###### 解决方案

尽量 将成对出现的空间大小配置参数设置成固定的值，如 -Xms 和 -Xmx，-XX:-MaxNewSize 和 -XX:NewSize，-XX:MetaSpaceSize 和 -XX:MaxMetaSpace-Size 等。

##### 显式 GC 的去与留

###### 现象

除了扩容缩容会触发 CMS GC 之外，还有 Old 区达到回收阈值、MetaSpace 空间不足、Young 区晋升失败、大对象担保失败等几种触发条件，如果这些情况都没有发生却触发了 GC ？

这种情况有可能是代码中手动调用了 `System.gc` 方法，此时可以找到 GC 日志中的 GC Cause 确认下。

那么这种 GC 到底有没有问题，翻看网上的一些资料，有人说可以添加 `-XX:+DisableExplicitGC` 参数来避免这种 GC，  
也有人说不能加这个参数，加了就会影响 `Native Memory` 的回收。

先说结论，笔者这里建议保留 `System.gc`，那为什么要保留？我们一起来分析下。

###### 原因

找到 `System.gc` 在 `Hotspot` 中 的 源 码， 可以发现增加 `-XX:+DisableExplicitGC`参数后，这个方法变成了一个空方法，如果没有加的话便会调用 `Universe::heap()::collect` 方法，继续跟进到这个方法中，发现 `System.gc`会引发一次 STW 的 `Full GC`，对整个堆做收集。

```c++
JVM_ENTRY_NO_ENV(void, JVM_GC(void))
    JVMWrapper("JVM_GC");
    if (!DisableExplicitGC) {
       Universe::heap()->collect(GCCause::_java_lang_system_gc);
    }
JVM_END
void GenCollectedHeap::collect(GCCause::Cause cause) {
    if (cause == GCCause::_wb_young_gc) {
       // Young collection for the WhiteBox API.
       collect(cause, YoungGen);
    } else {
    #ifdef ASSERT
       if (cause == GCCause::_scavenge_alot) {
          // Young collection only.
          collect(cause, YoungGen);
       } else {
          // Stop-the-world full collection.
          collect(cause, OldGen);
       }
    #else
       // Stop-the-world full collection.
       collect(cause, OldGen);
    #endif
    }
}
```

###### 保留 System.gc

此处补充一个知识点，**CMS GC** 共分为 **Background** 和 **Foreground** 两种模式，前者就是我们常规理解中的并发收集，可以不影响正常的业务线程运行，但**Foreground Collector** 却有很大的差异，他会进行一次压缩式 GC。

使用 Foreground Collector 时将会带来非常长的 STW。如果在应用程序中 System.gc 被频繁调用，那就非常危险了。

###### 去掉 System.gc

如果禁用掉的话就会带来另外一个内存泄漏问题，此时就需要说一下Direct-ByteBuffer，它有着零拷贝等特点，被 Netty 等各种 NIO 框架使用，会使用到堆外内存。堆内存由 JVM 自己管理，堆外内存必须要手动释放，DirectByteBuffer 没有  
Finalizer，它的 Native Memory 的清理工作是通过 sun.misc.Cleaner 自动完成的，是一种基于 PhantomReference（虚引用） 的清理工具，比普通的 Finalizer 轻量些。

为 DirectByteBuffer 分配空间过程中会显式调用 System.gc ，希望通过 Full GC 来强迫已经无用的 DirectByteBuffer 对象释放掉它们关联的 Native Memory。

HotSpot VM 只会在 Old GC 的时候才会对 Old 中的对象做 Reference Processing，而在 Young GC 时只会对 Young 里的对象做 Reference Processing。Young 中的 DirectByteBuffer 对象会在 Young GC 时被处理，也就是说，做 CMS  
GC 的 话 会 对 Old 做 Reference Processing， 进而能触发 Cleaner 对已死的DirectByteBuffer 对象做清理工作。但如果很长一段时间里没做过 GC 或者只做了Young GC 的话则不会在 Old 触发 Cleaner 的工作，那么就可能让本来已经死亡，  
但已经晋升到 Old 的 DirectByteBuffer 关联的 Native Memory 得不到及时释放。

这几个实现特征使得依赖于 System.gc 触发 GC 来保证 DirectByteMemory 的清理工作能及时完成。如果打开了 -XX:+DisableExplicitGC，清理工作就可能得不到及时完成，于是就有发生 Direct Memory 的 OOM。

###### 解决方案

通过上面的分析看到，无论是保留还是去掉都会有一定的风险点，不过目前互联网中的 RPC 通信会大量使用 NIO，所以笔者在这里建议保留。此外 JVM 还提供了-XX:+ExplicitGCInvokesConcurrent 和 -XX:+ExplicitGCInvokesCon-  
currentAndUnloadsClasses 参数来将 System.gc 的触发类型从 Foreground 改为 Background，同时 Background 也会做 Reference Processing，这样的话就能大幅降低了 STW 开销，同时也不会发生 NIO Direct Memory OOM。

##### MetaSpace 区 OOM

###### 现象

JVM 在启动后或者某个时间点开始，MetaSpace的已使用大小在持续增加，同时每次 GC 也无法完全释放，调大 MetaSpace 空间也无法彻底解决。

###### 原因

在讨论为什么会 OOM 之前，我们先来看一下这个区里面会存什么数据，Java7 之前字符串常量池被放到了 Perm 区，所有被 intern 的 String 都会被存在这里，由于 String.intern 是不受控的，所以 -XX:MaxPermSize 的值也不太好设置，经常会出现 java.lang.OutOfMemoryError: PermGen space 异常，所以在 Java7 之后常量池等字面量（Literal）、类静态变量（Class Static）、符号引用（SymbolsReference）等几项被移到 Heap 中。而 Java8 之后 PermGen 也被移除，取而代  
之的是 MetaSpace。

MetaSpace 的对象为什么无法释放，我们看最重要的一点：

类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在 Metaspace 中的类元数据也是存活的，不能被回收。每个加载器有单独的存储空间，通过 ClassLoaderMetaspace 来进行管理 SpaceManager* 的指针，相互隔离的。

所以关键原因就是 ClassLoader 不停地在内存中 load 了新的 Class ，一般这种问题都发生在动态类加载等情况上。

###### 解决办法

了解大概什么原因后，如何定位和解决就很简单了，可以 dump 快照之后通过 JProfiler 或 MAT 观察 Classes 的 Histogram（直方图） 即可，或者直接通过命令即可定位， jcmd 打几次 Histogram 的图，看一下具体是哪个包下的 Class 增加较多就可以定位了。不过有时候也要结合 InstBytes、KlassBytes、Bytecodes、MethodAll 等几  
项指标综合来看下。

如下图便是笔者使用 jcmd 排查到一个 Orika 的问题。

```shell
jcmd <PID> GC.class_stats|awk '{print$13}'|sed 's/\(.*\)\.\(.*\)/\1/
g'|sort |uniq -c|sort -nrk1
```

![image-20250613232754255](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232754255.png)

如果无法从整体的角度定位，可以添加 -XX:+TraceClassLoading 和 -XX-:+TraceClassUnLoading 参数观察详细的类加载和卸载信息。

原理理解比较复杂，但定位和解决问题会比较简单，经常会出问题的几个点有 Orika的 classMap、JSON 的 ASMSerializer、Groovy 动态加载类等，基本都集中在反射、Javasisit 字节码增强、CGLIB 动态代理、OSGi 自定义类加载器等的技术点上。另外就是及时给 MetaSpace 区的使用率加一个监控，如果指标有波动提前发现并解决问题。

##### 过早晋升

###### 现象

这种场景主要发生在分代的收集器上面，专业的术语称为“Premature Promotion”。90% 的对象朝生夕死，只有在 Young 区经历过几次 GC 的洗礼后才会晋升到 Old 区，每经历一次 GC 对象的 GC Age 就会增长 1，最大通过 -XX:MaxTenuring-  
Threshold 来控制。

过早晋升一般不会直接影响 GC，总会伴随着浮动垃圾、大对象担保失败等问题，但这些问题不是立刻发生的，我们可以观察以下几种现象来判断是否发生了过早晋升。

主要现象如下：

- GC 日 志 中 出 现“Desired survivor size 107347968 bytes, new threshold 1(max 6)”等信息，说明此时经历过一次 GC 就会放到 Old 区。

- Full GC 比较频繁，且经历过一次 GC 之后 Old 区的 。

比如说 Old 区触发的回收阈值是 80%，经历过一次 GC 之后下降到了 10%，这就说明 Old 区的 70% 的对象存活时间其实很短，如下图所示，Old 区大小每次 GC 后从 2.1G 回收到 300M，也就是说回收掉了 1.8G 的垃圾，只有 300M 的活跃对象。  
整个 Heap 目前是 4G，活跃对象只占了不到十分之一。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232807317.png" alt="image-20250613232807317" style="zoom:80%;" />

过早晋升的危害：

- Young GC 频繁，总的吞吐量下降。
- Full GC 频繁，可能会有较大停顿。

###### 原因

主要的原因有以下两点：

- **Young / Eden 区过小：** 过小的直接后果就是 Eden 被装满的时间变短，本应该回收的对象参与了 GC 并晋升，Young GC 采用的是复制算法，由基础篇我们知道 copying 耗时远大于 mark，也就是 Young GC 耗时本质上就是copy 的时间（CMS 扫描 Card Table 或 G1 扫描 Remember Set 出问题的情况另说），没来及回收的对象增大了回收的代价，所以 Young GC 时间增加，同时又无法快速释放空间，Young GC 次数也跟着增加。
- **分配速率过大：** 可以观察出问题前后 Mutator 的分配速率，如果有明显波动可以尝试观察网卡流量、存储类中间件慢查询日志等信息，看是否有大量数据被加载到内存中。

同时无法 GC 掉对象还会带来另外一个问题，引发动态年龄计算：JVM 通过 -XX:-MaxTenuringThreshold 参数来控制晋升年龄，每经过一次 GC，年龄就会加一，达到最大年龄就可以进入 Old 区，最大值为 15（因为 JVM 中使用 4 个比特来表示对象的年龄）。设定固定的 MaxTenuringThreshold 值作为晋升条件：

- MaxTenuringThreshold 如果设置得过大，原本应该晋升的对象一直停留在Survivor 区，直到 Survivor 区溢出，一旦溢出发生，Eden + Survivor 中对象将不再依据年龄全部提升到 Old 区，这样对象老化的机制就失效了。
- MaxTenuringThreshold 如果设置得过小，过早晋升即对象不能在 Young 区充分被回收，大量短期对象被晋升到 Old 区，Old 区空间迅速增长，引起频繁的 Major GC，分代回收失去了意义，严重影响 GC 性能。

###### 解决办法

知道问题原因后我们就有解决的方向，如果是 ，我们可以在总的 Heap 内存不变的情况下适当增大 Young 区，具体怎么增加？

一般情况下 Old 的大小应当为活跃对象的 2~3 倍左右，考虑到浮动垃圾问题最好在 3 倍左右，剩下的都可以分给 Young 区。

拿笔者的一次典型过早晋升优化来看，原配置为 Young 1.2G + Old 2.8G，通过观察 CMS GC 的情况找到存活对象大概为 300~400M，于是调整 Old 1.5G 左右，剩下 2.5G 分给 Young 区。仅仅调了一个 Young 区大小参数（ -Xmn），整个 JVM 一分钟 Young GC 从 26 次降低到了 11 次，单次时间也没有增加，总的 GC 时间从 1100ms 降低到了 500ms，CMS GC 次数也从 40 分钟左右一次降低到了 7 小时 30 分钟一次。

![image-20250613232824736](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232824736.png)

![image-20250613232833857](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232833857.png)

如果是分配速率过大：

- **偶发较大：** 通过内存分析工具找到问题代码，从业务逻辑上做一些优化。
- **一直较大：** 当前的 Collector 已经不满足 Mutator 的期望了，这种情况要么扩容 Mutator 的 VM，要么调整 GC 收集器类型或加大空间。

> 过早晋升问题一般不会特别明显，但日积月累之后可能会爆发一波收集器退化之类的问题，所以我们还是要提前避免掉的，可以看看自己系统里面是否有这些现象，如果比较匹配的话，可以尝试优化一下。一行代码优化的 ROI 还是很高的。
>
> 如果在观察 Old 区前后比例变化的过程中，发现可以回收的比例非常小，如从 80%只回收到了 60%，说明我们大部分对象都是存活的，Old 区的空间可以适当调大些。

## JVM调优

### JVM 调优效果

VM 调优目标是需要进行二选一的，即：`最短停顿时间`或`最大吞吐量`，具体要达成哪个，需要根据我们的系统情况来进行判断。

- **最短停顿时间**：JVM 的 GC 会 STW（Stop The World），这时将暂停所有应用线程，对于用户而言就有卡顿感了。因此，对于注重用户操作体验的系统来说，**缩短 STW 的停顿时间是系统调优目标**。
- **最大吞吐量**：对于一些执行任务计算类的后台系统来说，其关注点并不是停顿时间，而是在单位时间内进行更多的任务计算，那么**获取最大的吞吐量则是系统调优目标**。

我们都听说过分布式系统的 CAP 定理：在一个分布式系统中，最多只能在一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）中三者满足其二，不能同时满足这三项。

JVM 调优也与其类似，**`最低内存占用率`**、**`最短停顿时间`** 和 **`最大吞吐量`** **，这三者也只能满足其二**，不存在三者兼得的情况。如果选择了其中的任意两个，必然会以牺牲另一个为代价。

![image-20250613232844521](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232844521.png)

再换句话说，在内存占用率恒定的情况下，最短停顿时间和最大吞吐量，我们系统的优化目标只能两者取其一。

### JVM 调优步骤

#### 1. 明确调优目标

两个方向性目标，最短停顿时间和最大吞吐量。

#### 2. 分析运行情况

在这一步，我们可以借助于主流的监控工具 Prometheus + Grafana ，再结合 JDK 自带的命令行工具（jps、jstat、jinfo、jstack 等）进行分析。

主要的分析点包括：Young & Full & Mixed GC 频率、Young & Full & Mixed GC 耗时、系统负载、CPU 使用率、JVM 参数配置，以及是否存在内存泄露、OOM、线程死锁等。

#### 3. 参数配置调整

本着少即是多的原则，常见 JVM 调优参数如下：

```shell
//内存设置
//设置最大堆内存，该值设置过小会导致频繁Full GC或OOM，设置过大则会导致非堆内存消耗殆尽
//建议将该值设置为物理内存的60%——80%
-Xmx3072m

//初始堆内存，建议与-Xmx设置相同，避免每次垃圾回收完成后，JVM重新分配内存
-Xms3072m

//设置堆外内存，若不进行指定，则跟-Xmx值一致
-XX:MaxDirectMemorySize=512m


//设置垃圾回收器
//老年代使用Parallel Old收集器，新生代使用Parallel Scavenge收集器，以最大吞吐量为目标
-XX:+UseParallelOldGC

//使用G1收集器，会在吞吐量和停顿时间中进行平衡
-XX:+UseG1GC

//使用ZGC收集器，以最短停顿时间为目标
-XX:+UseZGC

//新生代使用Serial收集器，老年代使用Serial Old收集器。特点是占用内存小，启动速度快
-XX:+UseSerialGC

//其他类型参数
//对象从年轻代进入老年代的年龄值，JDK8默认值15，JDK9则将该值调整为7
-XX:InitialTenuringThreshold=7

//新生代可容纳的最大对象，超出该阈值则直接将对象分配到老年代，默认值为0，任何对象都先在新生代分配内存，
//不过，该参数只对Serial和ParNew收集器有效
-XX:PretenureSizeThreshold=1048576

//GC停顿时间，垃圾收集器会尝试用各种手段达到这个时间，但不能完全保证达成，该参数值不可设置过低，单位为毫秒
 -XX:MaxGCPauseMillis=200
 
 //设置GC的并行线程数量
 -XX:ParallelGCThreads=8

//Region中的存活对象低于这个值时，才会对该Region进行回收，否则存活对象占比较高，那回收的的意义
//就不大了，且复制的时间也会变长，默认85%
-XX:G1MixedGCLiveThresholdPercent=85

//Mixed GC是基于复制算法进行的，会把要回收的Region中的存活对象复制到其他Region中，然后再把这
//个Region清空，这样就会不断有新的Region空出来，一旦空出来的Region数量达到了堆内存的该参数比
//例值，就会立即停止混合回收，默认5%
-XX:G1HeapWastePercent=5 

//设置每个Region的大小，单位MB，需要为1，2，4，8，16，32其一，默认是堆内存的1/2000
-XX:G1HeapRegionSize=2
```

我们需要根据上述参数，以及系统的调优目标和当前实际情况，有针对性地进行参数调优。

#### 4. 灰度差异对比

在我们进行 JVM 参数调优之后，不会直接应用到集群中的所有应用服务器中。

我们会先选择集群中的一台服务器，进行 JVM 参数优化后的灰度测试，将此台服务器的运行情况和集群中的其他服务器进行运行指标对比，以此得知本次 JVM 参数优化的效果。

除此之外，我们还需要观察这台灰度的应用服务器，是否有其他异常情况发生，影响了应用程序的正常运行。

#### 5. 全量推进应用

如果经过观察对比，此台服务器的优化效果明显，且运行几天并无异常情况发生，我们将本次 JVM 参数优化的结果，全量应用在集群的所有应用服务器中。

至此，我们才算完成了 JVM 调优的整体闭环步骤。

### JVM 调优真实案例

#### 背景

`data-hub`服务是一些数据处理相关的服务，其中有一个高频核心接口 -- `onlineSegments`线上分词接口很慢，后面通过 `Prometheus + Grafana 监控系统` + `JDK 自带的命令行工具进行排查`，发现 JVM 的 Full GC 非常频繁，基本上十多分钟就会发生一次，每次的 GC 时间有十几秒。

通过 `jmap -histo` 命令进行排查，`onlineSegments`返回的大对象，包含了某个门店下，某个商品的同义词、关键词、描述等信息。

这里增加了`Caffeine 缓存`，接口虽然查询出来的结果数量不多，但是结果集中包含了同义词、关键词、描述等大字段，平均几十K，有的甚至100K以上。

key是shopId+skuCode，缓存的命中率不是很高，由于设置了 Caffeine 的 maximumSize 属性的原因，这些对象全部进入了老年代。

峰值 QPS 达到了 1500+，该服务的集群是 3 台 4c8g 的服务器，那么单台服务器的 QPS 是 500+，该对象每秒钟进入到老年代的大小达到了 10M+（部分查询命中缓存），这就是其频繁 Full GC 的原因。

#### 案例解决

定位到问题后，接下来就比较容易解决了。

（1）换一个以最短停顿时间为目标的垃圾收集器，来替代 Parallel Old 收集器，解决系统的长时间卡顿问题。

由于该系统用的是 JDK 1.8 版本，无法使用 ZGC 收集器，我们将垃圾收集器换成了 G1（XX:+UseG1GC）。

G1 收集器是一种基于 Region 的内存布局形式，进行局部收集的设计思路，其不仅仅停顿时间可控（默认 MaxGCPauseMillis 为 200ms），而且对系统吞吐量也很友好。

（2）将代码中 Caffeine 缓存的 maximumSize 参数设置为 10000（之前是 10 万），减少 JVM 中长时间驻留对象的数量，解决潜在的 Mixed GC 频繁的问题。

经此调整后，系统在 Mixed GC 期间的停顿时间，从十几秒减少到了 200 毫秒左右，且相比于之前 ParallelOld 十多分钟一次的 Full GC 频率，调整后的 G1 Mixed GC 频率降低到了三个小时一次。