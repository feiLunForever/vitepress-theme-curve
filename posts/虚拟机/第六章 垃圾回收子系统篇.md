# 垃圾回收子系统

## GC 基础篇

### 判断存活对象

GC机制只会回收运行过程中产生的“垃圾”对象，对于存活对象是不会进行回收的，那么在运行过程中又该如何判断一个对象是否为“垃圾”呢？“垃圾”是指运行过程中已经没有任何指针指向的对象，这类对象就是GC机制回收的目标。

在编程中主要存在两种垃圾判定算法，一种为**引用计数算法**，另一种为**可达性分析算法**。

#### 引用计数法

当 Object 的对象实例被创建出来后，计数器会被初始化为 `1`，因为局部变量 obj 的指针引用了该实例对象。而后续执行过程中，又有另外一个变量引用该实例时，该对象的引用计数器会 `+1`。而当方法执行结束，栈帧中局部变量表中引用该对象的指针随之销毁时，当前对象的引用计数器会 `-1`。当一个对象的计数器为 `0` 时，代表当前对象已经没有指针引用它了，那么在 GC 发生时，该对象会被判定为“`垃圾`”，然后会被回收。

##### 优缺点

- 方法实现简单，效率高
- 无法解决循环引用问题

> 比如两个**对象循环引用**，a 对象引用了 b 对象，b 对象也引用了 a 对象，a、b 对象却没有再被其他对象所引用了，其实正常来说这两个对象已经是垃圾了，因为没有其他对象在使用了，但是计数器内的数值却不是 0，所以引用计数算法就无法回收它们。

##### `Recycler` 试验删除算法

虽然循环引用的问题可通过 `Recycler` 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低，早期的编程语言会采用此算法。

当出现环状引用结构或者自引用结构的时候，导致垃圾回收器无法回收这部分内存，为了解决这个问题，业界出现的最普遍的最广泛认可的是**试验删除算法**。

试验删除算法的思想是：

- 在环状垃圾指针结构内部，所有对象的引用计数都由其内部对象之间的指针产生。
- 只有在删除某一对象的某个引用之后，该对象的引用计数扔大于零时，才有可能出现环状垃圾。
- 有了这两条，可以使用部分追踪(partial tracing)从一个可能是垃圾的对象开始进行子图追踪。对于每一个候选垃圾对象，算法将对其进行试验删除，从而移除由内部指针产生的引用计数。追踪完成后，如果某个对象的引用计数仍然不为0，那么肯定存在一个外部对象引用了该对象。

> 使用recycler算法可以实现这个思想，它主要分为以下三个阶段：
>
> - 回收器从某个可能是环状垃圾成员的对象出发进行子图追踪，同时减少由内部指针产生的引用计数。算法通过 `三色标记法` （后面会讲到） 将遍历到的对象设为灰色。
> - 对子图中所有对象进行检测，如果某一对象的引用计数不是零，则该对象必然被子图外的其他对象引用。此时需要对第一阶段的试验删除操作进行修正，算法将存活的灰色对象重新设为黑色，同时将其他灰色对象设为白色。
> - 子图中依然为白色的对象必然是垃圾，算法可以将其回收。

#### 可达性分析

会以这些 GCRoots 作为根节点，然后从上至下的方式进行搜索分析，当一个对象没有任何引用链相连时，则会被判定为该对象是不可达的，即代表着此对象不可用，最终该对象会被判定为“垃圾”对象等待回收。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231933464.png" alt="image-20250613231933464" style="zoom:50%;" />

##### GC root

- 虚拟机栈(栈帧中的本地变量表)中引用的对象

    - 譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等

```java
public class StackLocalParameter {
       public StackLocalParameter(String name){}
}
public static void testGC(){
       StackLocalParameter s = new StackLocalParameter("localParameter");
       s = null; 
}
```

> 此时的 s，即为 GC Root，当 s 置空时，localParameter 对象也断掉了与 GC Root 的引⽤链，将被回收。

- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象

    - 譬如 Java 类的引用静态变量
- 方法区中常量引用的对象

    - 譬如字符串常量池中的引用
- Java 虚拟机内部的引用

    - 如基本数据类型对应的 Class 对象
    - 一些常驻的异常对象(空指针异常、OOM 等)
    - 还有类加载器
- 所有被 Synchronized 持有的对象

##### 临时 GC Roots

- 目前的垃圾回收大部分都是分代收集和局部回收，如果只针对某一部分区域进行局部回收，那么就必须要考虑的当前区域的对象有可能正被其他区域的对象所引用，这时候就要将这部分关联的对象也添加到 GC Roots 中去来确保根可达算法的准确性。

### 垃圾回收算法

#### 标记清除

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231949368.png" alt="image-20250613231949368" style="zoom:50%;" />

- 从 `gcroot` 开始标记，记录在 `markword` 中
- 标记完，所有不可达对象，就需要被清除掉

> 注：关于 GC 标记到底在哪儿？
>
> 在对象头中存在一个 `markword` 字段，而 GC 标志位就存在其内部。
>
> 同时，清除阶段并不是简单的置空内存，而是把需要清除的对象地址保存在空闲的地址列表里，下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够就存放。

##### 缺点

- 额外维持一个内存的空闲列表
- 效率问题，随着对象越来越多，那么所需要消耗的时间就会越来越多
- 空间问题（标记清除后会产生大量不连续的碎片）

#### 标记复制

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232003347.png" alt="image-20250613232003347" style="zoom:50%;" />

在发生 GC 时，首先会将左侧这块内存区域中的存活对象移动到右侧这块空闲内存中，如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232026428.png" alt="image-20250613232026428" style="zoom:90%;" />

然后会对于左侧这块内存所有区域进行统一回收，如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232037307.png" alt="image-20250613232037307" style="zoom:90%;" />

##### 缺点

- 浪费过多的内存，使现有的可用空间变为原先的一半

#### 标记整理

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232046679.png" alt="image-20250613232046679" style="zoom:70%;" />

标记跟标-清一样，整理是将存活对象移动到一端

- 在标记阶段时也会基于 `GcRoots` 节点遍历整个内存中的所有对象，然后对所有存活对象做一次标记。
- 在整理阶段该算法并不会和标-清算法一样简单的清理内存，而是会将所有存活对象移动（压缩）到内存的一端，然后对于存活对象边界之外的内存进行统一回收。

##### 缺点

- 收集效率并不高

    - 因为标-整算法不仅仅要标记对象，同时还要移动存活对象，所以整个 GC 过程下来，它所需要耗费的时间资源开销必然是不小的。

#### 分代收集

- 新生代 - 复制算法
  - 因为在新生代中的对象几乎绝大部分都是朝生夕死的，每次 GC 发生后只会有少量对象存活，这种情况下采用复制算法无疑是个不错的选择，付出一定的内存空间开销以及少量存活对象的移动开销，换取内存的整齐度以及可观收集效率，这很明显是个“划得来的买卖”。

- 老年代 - 标-整 / 标 - 清
  - 但绝大多数年老代 GC 器都会选择采用标-整算法，因为毕竟标-清算法会导致大量的内存碎片产生，在年老代对象分配时，内存不完整可能会导致大对象分配不下而持续触发 GC。
  - 而标-整算法虽然效率较低，但胜在 GC 后内存足够整齐，再加上年老代的 GC 并没有新生代频繁，所以年老代空间采用标-整算法无疑也是个不错的选择。


#### 分区收集

在 JDK1.8 及之前的 JVM 中，堆中间一般会按照对象的生命周期长短划分为 `新生代`、`年老代` 两个空间，分别用于存储不同周期的对象。

而在新版本的GC器，如 `G1、ZGC` 中，则摒弃了之前物理内存上分代的思想，在运行时并不会直接将堆空间切分为两块区域，而是将整个堆划分为连续且不同的小区间，每一个小区间都独立使用，独立回收，这种回收策略带来的好处是：可以控制一次回收多少个小区间。

### STW

在发生 GC 时会停下所有的用户线程，从而导致 Java 程序出现全局停顿的无响应情况，而这种情况则被称为 `STW` （Stop The World）世界暂停。

- 避免产生浮动垃圾

    - 刚刚标记完成一块区域中的对象，但转眼用户线程又在该区域中产生了新的“垃圾”
- 确保内存一致

    - 可达性分析算法的工作必须要在一个能够确保一致性的内存快照中进行
    - 不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果的准确性无法得到保证

### gc 类型划分

#### young gc

在 JVM 中，发生次数最多的也就是新生代 GC，毕竟新生代中的对象都是朝生夕死的，也是分配最为频繁的，所以新生代 GC 也是触发最频繁的。

- `eden区` 满了触发，`survivor满` 不会触发

#### old gc

当老年代满时会触发 old gc，但一般而言，年老代 GC 触发时往往都会伴随新生代 GC 一起发生，只有 CMS 收集器会有单独收集年老代空间的行为，其他收集器均无此行为。

#### full gc

全面收集也被称为 FullGC，是所有 GC 类型中，耗时最长、停顿最久的 GC，FullGC 会对于所有可发生 GC 的区域进行全面回收，其中涵盖新生代、年老代以及元数据空间。

一般触发 FullGC 的原因有如下几种：

- 调用 `system.gc()`，JVM 在内存占用较多时会尝试发生 FullGC，但并非 100% 触发
- 老年代不足
- 元空间不足
- 对象晋升时年老代空间无法承载晋升对象
- 新生代空间分配担保机制触发 `担保机制` 失败

    - 老年代为新生代提供担保
    - 老年代最大可用的连续空间是否大于新生代所有对象总空间
    - 如果不成立，检查是否允许担保失败

        - 如果允许，检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小

            - 如果大于，尝试进行一次 young gc
            - 如果小于，或者不允许冒险，full gc

### 完整的 GC 流程

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232143825.png" alt="image-20250613232143825" style="zoom:80%;" />

- 如果对象在 `Eden` 出生，并经过第一次 Young GC 后仍然存活，并且被 Survivor 容纳的话，年龄设为 1
- 当 `Eden` 区的空间满了， Java 虚拟机会触发一次 Young GC，`Eden` 区和当前的 `from` 区中存活的对象会被复制到空闲的 `to` 区。复制完成后，`from区` 和 `Eden区` 的内容被清空，这两个区域的角色互换，即原来的 `to区` 变为新的 `from区`，原来的 `from` 区变为新的 `to区`。
- 每熬过一次 Young GC，年龄 +1，若年龄超过一定限制 (15)，则被晋升到老年态
- 老年代满了而无法容纳更多的对象，Young GC 之后通常就会进行 Full GC，Full GC 清理整个内存堆 – 包括年轻代和年老代
- 大对象(需要大量连续内存空间的 Java 对象，如那种很长的字符串)直接进入老年态

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232118606.png" alt="image-20250613232118606" style="zoom:80%;" />

### 什么对象会进入老年代

初次分配时，`大对象` 直接进入年老代。  
一般对象进入年老代的情况只有三种：`大对象`、`长期存活对象` 以及`动态年龄判断符合条件的对象`。

> 动态年龄符合条件的对象：sum(Survivor 区中相同年龄的所有对象大小) > Survivor 空间 / 2

### 担保机制

- 老年代为新生代提供担保
- 老年代最大可用的连续空间是否大于新生代所有对象总空间
- 如果不成立，检查是否允许担保失败

    - 如果允许，检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小

        - 如果大于，尝试进行一次 young gc
        - 如果小于，或者不允许冒险，full gc

## gc 收集器

### 分代收集器

分代堆空间中会分为 `新生代` 与 `年老代` 两个区域，而 `新生代` 又会分为 `Eden*1 、 Survivor*2` 三块。其中新生代采用复制算法，HotSpot中因为调整了 `Eden` 与 `Survivor` 区域的比例为 `8:1:1`，所以说新生代的内存最多浪费 `10%`，最大容量为 `80% + 10% = 90%`。而当 `Survivor` 空间不足以存放存活对象时，会依赖于年老代进行分配担保，承接符合标准的对象进入年老代空间。

#### 新生代

##### Serial 收集器（单线程）

![image-20250613232159221](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232159221.png)

- 串行 GC，单线程
- 采用算法：`复制算法`
- GC 时，停掉用户线程，同时，在 `STW` 的时候**只会有一条线程**去进行垃圾收集的工作
- `-XX:+UseSerialGC `

##### ParNew 收集器（多线程）

![image-20250613232208842](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232208842.png)

- 并行 GC，多线程
- 采用算法：`复制算法`
- GC 过程发生在 `STW` 中，采用多线程回收
- 可以被称为 `Serial` 收集器的 `多线程` 版本
- `-XX:+UseParNewGC`

##### Parallel Scavenge

![image-20250613232219041](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232219041.png)

- 并行 GC，多线程
- 采用算法：`复制算法`
- GC 过程发生在 `STW` 中，采用多线程回收
- `-XX:+UseParallelGC`

> - ParNew 通过控制 GC 线程数量来缩短程序暂停时间（一个CPU核，就创建一个线程），更关心程序的响应时间
> - ParallelScavenge 更关心的是程序运行的吞吐量（固定线程，允许用户设置目标吞吐量，并尽可能达到这个目标）

__**吞吐量和响应时间不可兼得**__

在追求响应时间的时候必然会牺牲吞吐量，而追求吞吐量的同时必然会牺牲响应时间。好比你通过参数将GC时间设置的很小，那么 `PS` 在运行时会将新生代空间调小，如从原本的 `1GB` 调整到 `800MB`，收集 `800MB` 的空间必然速度会比 `1GB` 的快很多。但与之相对应的收集频率会增高，可能原本原来 `60s` 收集一次，每次收集停顿 `100ms`，而现如今内存被调小后，`40s` 就要发生一次GC，每次GC停顿 `80ms`，你可以对比这两者之间的区别：

- 24min/1GB`空间-GC开销：`(24min/60s)*100ms=24000ms*
- *24min/800MB`空间-GC开销：`(24min/40s)*80ms=28800ms

因此，最终可以得到一个结果，虽然响应时间确实降低了，但吞吐量也降了下来了。

#### 老年代

##### Serial Old（MSC） （单线程）

![image-20250613232229711](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232229711.png)

- 串行 GC，单线程
- `标记-整理算法`
- GC 过程发生在 `STW` 中，采用单线程执行串行回收
- `-XX:+UseSerialGC`

##### Parallel Old （多线程）

![image-20250613232239539](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232239539.png)

并行 GC，多线程

- `标记-整理算法 `
- GC 过程发生在 `STW` 中，采用多线程回收
- `-XX:+UseParallelOldGC`

##### CMS

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232255724.png" alt="image-20250613232255724" style="zoom:80%;" />

- 并发 GC，多线程并行执行
- `标记-清除算法 `
- GC 过程会发生 `STW`，但并非整个 GC 过程都在 STW 中执行，采用多线程回收
- `-XX:+UseConcMarkSweepGC`

###### 缺点

- 无法回收浮动垃圾
- 对 CPU 资源非常依赖
- GC 完成后会造成大量内存碎片

###### 详细过程

- ①初始标记
  - 仅标记 `GcRoot` 节点直接关联的对象，该阶段速度会很快
  - 需在 `STW` 中进行
- ②并发标记
  - 该阶段主要是做 GC 溯源工作（`GcTracing`），从根节点出发，对整个堆空间进行可达性分析，找出所有存活对象
  - 该阶段的GC线程会与用户线程同时执行
- ③并发预清理（可选）
  - 在并发标记阶段，由于引用的变更，可能会产生一些 dirty page，这一阶段的主要工作就就是处理这些脏页，虽然在后面的重新标记阶段也拥有处理脏页的逻辑，但重新标记阶段会 Stop The World，所以这一阶段的核心仍然是让停顿时间尽量缩短
  - 该阶段的 GC 线程会与用户线程同时执行
> 一些引用发生了更改。当发生这种情况时，JVM 将包含变化对象的堆区域(称为“Card”)标记为“脏”(这称为卡片标记)，Card 是典型的采用空间换时间的逻辑，因为不需要扫描整个Heap 空间，从而可以有效的降低 GC 耗时。
>
> <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232330600.png" alt="image-20250613232330600" style="zoom:60%;" />
>
> 在预清理阶段，这些脏对象会被计算在内，并且还会标记从这些脏对象可以到达的对象。这一步完成后，卡片将被清洗。
>
> <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232347506.png" alt="image-20250613232347506" style="zoom:60%;" />

- ④并发可终止的预清理阶段
  - 这一阶段的主要工作是处理新生代指向老年代的新引用，从而让老年代的一些未被标记的对象成为活跃对象。
  - 同样，在重新标记阶段也会处理这样的情况，这一阶段仍然是为了缩短停顿时间而进行的。

> 显然，在这一阶段中要识别新生代对象对老年代对象的新引用，那么就必须扫描整个新生代，这显然是一项很耗时的操作，但由于新生代的对象大多是朝生夕死的，所以如果在一次 youngGC 之后紧接着进行一次预清理，新生代中需要扫描的对象就会所剩无几了。
>
> CMS 通过 CMSScavengeBeforeRemark 参数强制在可中断的并发预清理阶段执行一次 youngGC，虽然 youngGC 也会让用户线程短暂停顿，但这样可以缩短下一阶段的停顿时间，整体上还是利大于弊的。

- ⑤重新标记
  - 这个阶段主要是为了 `修正`“并发标记”阶段由于用户线程执行造成的 GC 标记变动的那部分对象
  - 该阶段需要在 `STW` 中执行，并且该阶段的停顿时间会比初始阶段要长不少

  > CMS 的第二个 STW 事件。这个 STW 阶段的目标是完成对年老代所有活动对象的标记。
  >
  > 由于以前的 preclean 阶段是并发的，它们可能无法跟上应用程序的变化速度。为了完成这个工作，所以必须再次进行 STW。

- ⑥并发清除
  - 在该阶段主要是对存活对象之外的垃圾对象进行清除
  - 不需要停止用户线程，是并发执行的

- ⑦并发重置
  - 并行执行阶段，重置 CMS 算法的内部数据结构，并为下一个周期做好准备

###### 日志解析

CMS收集器的整个事件如下所示:

```shell
2024-07-01T16:23:07.321-0200: 64.425: [GC (CMS Initial Mark) [CMS-initial-mark: 10812086K(11901376K)] 10887844K(12514816K), 0.0001997 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
2024-07-01T16:23:07.321-0200: 64.425: [CMS-concurrent-mark-start]
2024-07-01T16:23:07.357-0200: 64.460: [CMS-concurrent-mark: 0.035/0.035 secs] [Times: user=0.07 sys=0.00, real=0.03 secs]
2024-07-01T16:23:07.357-0200: 64.460: [CMS-concurrent-preclean-start]
2024-07-01T16:23:07.373-0200: 64.476: [CMS-concurrent-preclean: 0.016/0.016 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]
2024-07-01T16:23:07.373-0200: 64.476: [CMS-concurrent-abortable-preclean-start]
2024-07-01T16:23:08.446-0200: 65.550: [CMS-concurrent-abortable-preclean: 0.167/1.074 secs] [Times: user=0.20 sys=0.00, real=1.07 secs]
2024-07-01T16:23:08.447-0200: 65.550: [GC (CMS Final Remark) [YG occupancy: 387920K(613440K)]65.550: [Rescan (parallel), 0.0085125 secs]65.559: [weak refs processing, 0.0000243 secs]65.559: [class unloading, 0.0013120 secs]65.560: [scrub symbol table, 0.0008345 secs]65.561: [scrub string table, 0.0001759 secs][1 CMS-remark: 10812086K(11901376K)] 11200006K(12514816K), 0.0110730 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]
2024-07-01T16:23:08.458-0200: 65.561: [CMS-concurrent-sweep-start]
2024-07-01T16:23:08.485-0200: 65.588: [CMS-concurrent-sweep: 0.027/0.027 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]
2024-07-01T16:23:08.485-0200: 65.589: [CMS-concurrent-reset-start]
2024-07-01T16:23:08.497-0200: 65.601: [CMS-concurrent-reset: 0.012/0.012 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
```

![-XX:+PrintGC日志解读](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/ef0eb460cf514d35a4c9a6a0413e1314~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

`阶段 1：`**`Initial Mark 初始标记`**

```shell
2024-07-01T16:23:07.321-0200: 64.421: [GC (CMS Initial Mark [CMS-initial-mark: 10812086K(11901376K)] 10887844K(12514816K), 0.0001997 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
```

- `[GC (CMS Initial Mark`：表示CMS垃圾回收的初始标记阶段开始。
- `[CMS-initial-mark: 10812086K(11901376K)]`：初始标记的细节，其中 `10812086K` 是已使用内存，`11901376K` 是总内存。
- `10887844K(12514816K)`：整个堆的已使用内存和总内存。
- `0.0001997 secs`：该阶段耗时。
- `[Times: user=0.00 sys=0.00, real=0.00 secs]`：详细时间信息（用户态时间、内核态时间、实际时间）。



`阶段 2 ：`**`Concurrent Mark 并发标记`**

```shell
2024-07-01T16:23:07.321-0200: 64.425: [CMS-concurrent-mark-start]
2024-07-01T16:23:07.357-0200: 64.460: [CMS-concurrent-mark: 0.035/0.035 secs] [Times: user=0.07 sys=0.00, real=0.03 secs]
```

- `CMS-concurrent-mark` :表示收集阶段，此处为“并发标记”，遍历年老代并标记所有活动对象。
- `0.035 secs`：该阶段耗时。



`阶段 3：`**`Concurrent Preclean 并发预清理`**

```shell
2024-07-01T16:23:07.357-0200: 64.460: [CMS-concurrent-preclean-start]
2024-07-01T16:23:07.373-0200: 64.476: [CMS-concurrent-preclean: 0.016/0.016 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]
```

- `CMS-concurrent-preclean` ：表示收集阶段， “并发预清理”，主要考虑在前一个标记阶段更改的引用。
- `0.016 secs`：该阶段耗时。



`阶段 4：`**`Concurrent Abortable Preclean 并发可终止的预清理阶段`**

```shell
2024-07-01T16:23:07.373-0200: 64.476: [CMS-concurrent-abortable-preclean-start]
2024-07-01T16:23:08.446-0200: 65.550: [CMS-concurrent-abortable-preclean: 0.167/1.074 secs] [Times: user=0.20 sys=0.00, real=1.07 secs]
```

- `CMS-concurrent-abortable-preclean-` ：表示收集阶段， “发可终止的预清理”
- `0.167`：表示 GC 线程实际工作的 CPU 时间（单位为秒），即垃圾回收线程执行任务消耗的计算资源时间。
- `1.074`：表示 该阶段从开始到结束的总挂钟时间（Wall Clock Time）（单位为秒），即实际经过的时间。
- 比值意义：若 CPU 时间（0.167秒）远小于总时间（1.074秒），说明此阶段以并发方式运行，GC 线程与用户程序线程交替使用 CPU，未完全占用计算资源



`阶段 5：`**`Final Remark 重新标记`**

```shell
2024-07-01T16:23:08.447-0200: 65.550: [GC (CMS Final Remark) [YG occupancy: 387920K(613440K)]65.550: [Rescan (parallel), 0.0085125 secs]65.559: [weak refs processing, 0.0000243 secs]65.559: [class unloading, 0.0013120 secs]65.560: [scrub symbol table, 0.0008345 secs]65.561: [scrub string table, 0.0001759 secs][1 CMS-remark: 10812086K(11901376K)] 11200006K(12514816K), 0.0110730 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]
```

- `CMS Final Remark` ：表示收集阶段， "最终重新标记" ，标记了年老代中的所有活动对象，包括在先前的并发标记阶段中创建/修改的引用。
- `YG occupancy: 387920 K (613440 K) `：年轻代占用和容量
- `[Rescan (parallel) , 0.0085125 secs]` ：“重新扫描”在应用程序停止时完成活动对象的标记。在本例中，重新扫描是并行进行的，耗时 0.0085125 秒。
- `weak refs processing, 0.0000243 secs]65.559`：第一个子阶段，正在处理弱引用以及该阶段的持续时间和时间戳。
- `class unloading, 0.0013120 secs]65.560`：下一个子阶段，正在卸载未使用的类，并带有该阶段的持续时间和时间戳。
- `scrub string table, 0.0001759 secs`：最后一个子阶段，清理符号和字符串表，它们分别保存了类级别的元数据和字符串内部池，暂停的时钟时间也包括在内。
- `10812086K(11901376K)` ：年老代情况
- `11200006K(12514816K)` ：堆使用情况
- `0.0110730 secs` ：持续时间



`阶段 6：`**`Concurrent Sweep 并发清除`**

```shell
2024-07-01T16:23:08.458-0200: 65.561: [CMS-concurrent-sweep-start]
2024-07-01T16:23:08.485-0200: 65.588: [CMS-concurrent-sweep: 0.027/0.027 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]
```



`阶段 7：`**`Concurrent Reset 并发重置`**

```shell
2024-07-01T16:23:08.485-0200: 65.589: [CMS-concurrent-reset-start]
2024-07-01T16:23:08.497-0200: 65.601: [CMS-concurrent-reset: 0.012/0.012 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]
```



#### GC组合方案

![Java中的分代收集器](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/78fe7502d89e495792aaa4cc0c326b1e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

- 如果你的程序追求低延迟，用户交互度较为频繁，那你可以采用 `ParNew + CMS` 组合。
- 如若你的程序追求高吞吐，后台计算工作较多，那么 `Parallel Scavenge + Parallel Old` 这组 `PS + PO` 的收集器会更适合你。
- 但你的程序写出来后，更多的情况下部署在单核或双核的机器时，那么最经典的 `Serial + Serial Old` 组合绝对是你的最佳选择

### 分区收集器

#### G1

##### 特点

- ① 与 CMS 收集器一样，能够与用户线程同时执行，完成并发收集。
- ②GC 过程会有整理内存的过程，不会产生内存碎片，并且整理空闲内存速度更快。
- ③GC 发生时，停顿时间可控，可以让程序更大程度上追求低延迟。
- ④ 采用 `复制算法`，region -> region

    - 每个 Region 区角度看来是采用的 `复制算法`，但从堆空间整体看来，则是采用了 `标-整` 算法，这也是所谓的“`局部复制，全局标-整`”
- ⑤ 后台维护一个 CSet 优先列表，记录了 gc 要收集的 region 集合（可任意年代），gc 回收时，根据用户指的的期望停顿时间，优先从列表中回收价值最大的 region 区域，g1 的由来

##### 内存划分

![image-20250613232409391](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232409391.png)

G1 将 Java 堆划分为多个大小相等的独立的 `Region` 区域，一般 `Region` 区的大小等于堆空间的总大小除以 `2048`，比如目前的堆空间总大小为 8GB，就是 8192MB/2048=4MB，那么最终每个 `Region` 区的大小为 4MB。

新生代中的 `Eden` 区和 `Survivor` 区对应的 Region 区比例也跟之前一样，默认 `8:1:1`，假设新生代现在有 400 个 Region，那么整个新生代的占比则为 `Eden`=320,`S0/From`=40,`S1/To`=40。

G1 中的年老代晋升条件和之前的无差，达到 `年龄阈值` 的对象会被转入 `年老代` 的 `Region` 区中，不同的是对于大对象的分配，在 G1 中不会让大对象进入年老代，在 G1 中由专门存放大对象的 Region 区叫做 `Humongous` 区，如果在分配对象时，判定出一个对象属于大对象，那么则会直接将其放入 `Humongous` 区存储。

> 对象大小是否超过单个普通 `Region` 区的 `50%`，如果超过则代表当前对象为大对象，那么该对象会被直接放入 `Humongous` 区。
>
> 可以避免一些“短命”的巨型对象直接进入年老代，节约年老代的内存空间，可以有效避免年老代因空间不足时的 GC 开销

##### gc 类型

G1 中主要存在 `YoungGC`、`MixedGC` 以及 `FullGC` 三种 GC 类型，这三种 GC 类型分别会在不同情景下被触发。

- young gc

> - 在 G1 中，当新生代区域被用完时，G1 首先会大概计算一下回收当前的新生代空间需要花费多少时间，如果回收时间远远小于参数 `-XX:MaxGCPauseMills` 设定的值，那么不会触发 `YoungGC`，而是会继续为新生代增加新的 `Region` 区用于存放新分配的对象实例。
> - 直至某次 `Eden` 区空间再次被放满并经过计算后，此次回收的耗时接近 `-XX:MaxGCPauseMills` 参数设定的值，那么才会触发 `YoungGC`。
> - 当 `YoungGC` 被触发时，首先会将目标 `Region` 区中的存活对象移动至幸存区空间（被打着 `Survivor-from` 区标志的 `Region`）。同时达到晋升年龄标准的对象也会被移入至年老代 `Region` 中存储。

- mixed gc

> - 当整个堆中年老代的区域占有率达到参数设定的值
> - 回收所有 `新生代Region区`、部分 `年老代Region区`（会根据期望的 GC 停顿时间选择合适的年老代 Region 区 `优先` 回收）以及 `大对象Humongous区`

- full gc

> - MixedGC 时，如果发现没有足够空闲的 `region` 区去拷贝对象，触发 fullgc
> - 首先会 `停止` 系统所有用户线程
> - 然后采用 `单线程` 进行 `标记`、`清理` 和 `压缩整理` 内存，以便于清理出足够多的空闲 `Region` 来供下一次 `MixedGC` 使用

##### 过程

![image-20250613232423043](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232423043.png)

`阶段 1：`**`Initial Mark 初始标记`**

- `STW`，`单线程` GC 线程快速标记 `GCRoots` 直连的对象

```yaml
1.631: [GC pause (G1 Evacuation Pause) (young) **(initial-mark)** , 0.0062656 secs]
```

`阶段 2：`**`Root Region Scan 根区域扫描`**

- G1扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一个过程**必须在Young GC之前完成（因为Young GC会操作Survivor区中的对象）** 。

```yaml
1.362: [GC concurrent-root-region-scan-start]
1.364: [GC concurrent-root-region-scan-end, 0.0028513 secs]
```

`阶段 3：`**`Concurrent Mark 并发标记`**

- 与 CMS 的并发标记过程一致，采用多条 GC 线程与用户线程共同执行，根据 `Root` 根节点标记所有对象。

```yaml
1.364: [GC concurrent-mark-start]
1.645: [GC concurrent-mark-end, 0.2803470 secs]
```

`阶段 4：`**`Remark 最终标记`**

- `STW`，同 CMS 的重新标记阶段，主要是为了 `纠正` 并发标记阶段因用户操作导致的 `错标`、`误标`、`漏标` 对象

```yaml
1.645: [GC remark 1.645: [Finalize Marking, 0.0009461 secs] 1.646: [GC ref-proc, 
0.0000417 secs] 1.646: [Unloading, 0.0011301 secs], 0.0074056 secs]
[Times: user=0.01 sys=0.00, real=0.01 secs]
```

`阶段 5：`**`Cleanup 筛选回收`**

- 先对各个 `Region` 区的回收价值和成本进行 `排序`，找出「回收价值最大」的 `Region` 优先回收
- `STW`，多线程并行回收，停顿时间可控，回收效率高

```yaml
1.652: [GC cleanup 1213M->1213M(1885M), 0.0030492 secs]
[Times: user=0.01 sys=0.00, real=0.00 secs]
```

##### 适用场景

- 采用原本分代收集器 GC 时间会长达 1s+ 的应用
- 至少 8GB 以上堆内存的应用
- 追求停顿时间在 500ms 以内的应用

##### 性能问题

初始标记因为只标记 GC Roots，耗时较短。再标记因为对象数少，耗时也较短。清理阶段因为内存分区数量少，耗时也较短。转移阶段要处理所有存活的对象，耗时会较长。

因此，G1 停顿时间的瓶颈主要是标记 - 复制中的转移阶段 STW。为什么转移阶段不能和标记阶段一样并发执行呢？**主要是 G1 未能解决转移过程中准确定位对象地址的问题。**

G1 的 Young GC 和 CMS 的 Young GC，其标记 - 复制全过程 STW，这里不再详细阐述。

#### ZGC

##### 分区

在 ZGC 中，也会把堆空间划分为一个个的 `Region` 区域，但 ZGC 中的 `Region` 区不存在 `分代` 的概念，它仅仅只是简单的将所有 `Region` 区分为了 `大`、`中`、`小` 三个等级

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232437487.png" alt="image-20250613232437487" style="zoom:90%;" />

- 小型区/页(`Small`)：固定大小为 2MB，用于分配小于 256KB 的对象。
- 中型区/页(`Medium`)：固定大小为 32MB，用于分配 >=256KB ~ <=4MB 的对象。
- 大型区/页(`Large`)：没有固定大小，容量可以动态变化，但是大小必须为 2MB 的整数倍，专门用于存放 >4MB 的巨型对象。
- 过程

    - 标记：从根节点出发标记所有存活对象
    - 转移：将需要回收区域中的存活对象转移到新的分区中
    - 重定位：将所有指向转移前地址的指针更改为指向转移后的地址

与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用**标记 - 复制算法**，不过 ZGC 对该算法做了重大改进：ZGC 在 `标记`、`转移` 和 `重定位` 阶段几乎都是并发的，这是 ZGC 实现停顿时间小于 10ms 目标的最关键原因。

##### 三大重要特性

###### **1. 内存多重映射**

内存多重映射，就是使用 mmap 把不同的虚拟内存地址映射到同一个物理内存地址上。如下图：

![image-20250613232449555](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232449555.png)

ZGC 为了更灵活高效地管理内存，使用了内存多重映射，把同一块儿物理内存映射为 Marked0、Marked1 和 Remapped 三个虚拟内存。

当应用程序创建对象时，会在堆上申请一个虚拟地址，这时 ZGC 会为这个对象在 Marked0、Marked1 和 Remapped 这三个视图空间分别申请一个虚拟地址，这三个虚拟地址映射到同一个物理地址。

Marked0、Marked1 和 Remapped 这三个虚拟内存作为 ZGC 的三个视图空间，在同一个时间点内只能有一个有效。ZGC 就是通过这三个视图空间的切换，来完成并发的垃圾回收。

###### **2.染色指针**

我们知道 G1 垃圾收集器使用了三色标记，这里先做一个回顾。下面是一个三色标记过程中的对象引用示例图：

![image-20250613232500879](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232500879.png)

总共有三种颜色，说明如下：

- 白色：本对象还没有被标记线程访问过。
- 灰色：本对象已经被访问过，但是本对象引用的其他对象还没有被全部访问。
- 黑色：本对象已经被访问过，并且本对象引用的其他对象也都被访问过了。

三色标记的过程如下：

1. 初始阶段，所有对象都是白色。
2. 将 GC Roots 直接引用的对象标记为灰色。
3. 处理灰色对象，把当前灰色对象引用的所有对象都变成灰色，之后将当前灰色对象变成黑色。
4. 重复步骤 3，直到不存在灰色对象为止。

三色标记结束后，白色对象就是没有被引用的对象（比如上图中的 H  和 G），可以被回收了。

那什么是**染色指针**呢？

ZGC 出现之前， GC 信息保存在对象头的 Mark Word 中。比如 64 位的 JVM，对象头的 Mark Word 中保存的信息如下图：

![image-20250613232513294](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232513294.png)

前 62位保存了 GC 信息，最后两位保存了锁标志。

> 这种记录方式在**有对象访问的场景下**是很自然流畅的，不会有什么额外负担。但如果有一些对象根本就不会去访问它，但又希望得知该对象的某些信息的场景呢？
>
> 我们就有这样的场景——追踪式收集算法的标记阶段就可能存在**只跟指针打交道而不必涉及指针所引用的对象本身的场景**。
>
> - 例如 对象标记的过程中需要给对象打上三色标记，这些标记本质上就只和对象的引用有关，而与对象本身无关——某个对象只有它的引用关系能决定它存活与否，对象上其他所有的属性都不能够影响它的存活判定结果
> - ZGC的染色指针**直接把标记信息记在引用对象的指针上**

ZGC 的一大创举是将 GC 信息保存在了染色指针上。**染色指针是一种将少量信息直接存储在指针上的技术**。在 64 位 JVM  中，对象指针是 64 位，如下图：

![image-20250613232524854](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232524854.png)

‍

在这个 64 位的指针上，高 16 位都是 0，暂时不用来寻址。剩下的 48 位支持的内存可以达到 256 TB（2 ^48）,这可以满足多数大型服务器的需要了。不过 ZGC 并没有把 48 位都用来保存对象信息，而是用高 4 位保存了四个标志位，这样 ZGC 可以管理的最大内存可以达到 16 TB（2 ^ 44）。

通过这四个标志位，JVM 可以从指针上直接看到对象的三色标记状态（Marked0、Marked1）、是否进入了重分配集（Remapped）、是否需要通过 finalize 方法来访问到（Finalizable）。

无需进行对象访问就可以获得 GC 信息，这大大提高了 GC 效率。

###### **3.读屏障**

读屏障类似于 Spring AOP 的前置增强，是 JVM 向应用代码中插入一小段代码，当应用线程从堆中读取对象的引用时，会先执行这段代码。**注意：只有从堆内存中读取对象的引用时，才会执行这个代码**。下面代码只有第一行需要加入读屏障。

```java
Object o = obj.FieldA // 从堆中读取引用，需要加入屏障
<Load barrier>
Object p = o // 无需加入屏障，因为不是从堆中读取引用
o.dosomething() // 无需加入屏障，因为不是从堆中读取引用
int i = obj.FieldB //无需加入屏障，因为不是对象引用
```

**ZGC 中读屏障的代码作用**：在对象标记和转移过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。

> 读屏障会对应用程序的性能有一定影响，据测试，对性能的最高影响达到 4%，但提高了 GC 并发能力，降低了 STW。

> 着色指针和读屏障技术不仅应用在并发转移阶段，还应用在并发标记阶段：将对象设置为已标记，传统的垃圾回收器需要进行一次内存访问，并将对象存活信息放在对象头中；而在 ZGC 中，只需要设置指针地址的第 42~45 位即可，并且因为是寄存器访问，所以速度比访问内存更快。

> ZGC 通过着色指针和读屏障技术，解决了转移过程中准确访问对象的问题，实现了并发转移。大致原理描述如下：并发转移中“并发”意味着 GC 线程在转移对象的过程中，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。
>
> 而在 ZGC 中，应用线程访问对象将触发“读屏障”，如果发现对象被移动了，那么“读屏障”会把读出来的指针更新  
> 到对象的新地址上，这样应用线程始终访问的都是对象的新地址。那么，JVM 是如何判断对象被移动过呢？就是利用对象引用的地址，即着色指针。下面介绍着色指针和读屏障技术细节。

##### gc 过程

前面已经讲过，ZGC 使用内存多重映射技术，把物理内存映射为 Marked0、Marked1 和 Remapped 三个地址视图，利用地址视图的切换，ZGC 实现了高效的并发收集。

ZGC 的垃圾收集过程包括标记、转移和重定位三个阶段。如下图：

![image-20250613232538841](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232538841.png)

ZGC 初始化后，整个内存空间的地址视图被设置为 Remapped。

**1. 初始标记**

从 GC Roots 出发，找出 GC Roots 直接引用的对象，放入活跃对象集合，这个过程需要 STW，不过 **STW 的时间跟 GC Roots 数量成正比**，耗时比较短。

**2. 并发标记**

并发标记过程中，GC 线程和 Java 应用线程会并行运行。这个过程需要注意下面几点：

- GC 标记线程访问对象时，如果对象地址视图是 `Remapped`，就把对象地址视图切换到 `Marked0`，如果对象地址视图已经是 `Marked0`，说明已经被其他标记线程访问过了，跳过不处理。
- 标记过程中Java 应用线程新创建的对象会直接进入 `Marked0 视图`。
- 标记结束后，如果对象地址视图是 `Marked0`，那就是活跃的，如果对象地址视图是 `Remapped`，那就是不活跃的。

**标记阶段的活跃视图也可能是 Marked1，为什么会采用两个视图呢？**

这里采用两个视图是为了区分前一次标记和这一次标记。如果这次标记的视图是 Marked0，那下一次并发标记就会把视图切换到 Marked1。这样做可以配合 ZGC 按照页回收垃圾的做法。如下图：

![image-20250613232552070](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232552070.png)

第二次标记的时候，如果还是切换到 `Marked0`，那么 2 这个对象区分不出是活跃的还是上次标记过的。如果第二次标记切换到 `Marked1`，就可以区分出了。

这时 `Marked0` 这个视图的对象就是上次标记过程被标记过活跃，转移的时候没有被转移，但这次标记没有被标记为活跃的对象。`Marked1` 视图的对象是这次标记被标记为活跃的对象。

`Remapped` 视图的对象是上次垃圾回收发生转移或者是被 Java 应用线程访问过，本次垃圾回收中被标记为不活跃的对象。

![image-20250613232603596](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232603596.png)

**3. 再标记**

并发标记阶段 GC 线程和 Java 应用线程并发执行，标记过程中可能会有引用关系发生变化而导致的漏标记问题。再标记阶段重新标记**并发标记阶段**发生变化的对象，还会对非强引用（软应用，虚引用等）进行并行标记。

这个阶段需要 STW，但是需要标记的对象少，耗时很短。

**4. 初始转移**

**转移就是把活跃对象复制到新的内存，之前的内存空间可以被回收。**

初始转移需要扫描 GC Roots 直接引用的对象并进行转移，这个过程需要 STW，STW 时间跟 GC Roots 成正比。

**5. 并发转移**

并发转移过程 GC 线程和 Java 线程是并发进行的。上面已经讲过，转移过程中对象视图会被切回 Remapped 。转移过程需要注意以下几点：

- 如果 GC 线程访问对象的视图是 `Marked0`，则转移对象，并把对象视图设置成 `Remapped`。
- 如果 GC 线程访问对象的视图是 `Remapped`，说明被其他 GC 线程处理过，跳过不再处理。
- 并发转移过程中 Java 应用线程创建的新对象地址视图是 `Remapped`。
- 如果 Java 应用线程访问的对象被标记为活跃并且对象视图是 Marked0，则转移对象，并把对象视图设置成 Remapped。

**6.重定位**

转移过程对象的地址发生了变化，在这个阶段，把所有指向对象旧地址的指针调整到对象的新地址上。

### 三色标记法

三色标记算法是自 CMS 收集器后，应用比较广泛的一种并发标记算法，它可以让 `JVM` 在发生 `GC` 时，只发生短暂的 `STW` 即可实现存活对象标记的一种算法。

#### 定义

- 白：未曾标记过的对象，或不具备引用的对象（垃圾对象）
- 灰：当前对象已经被标记完成，但关联节点（属性成员）还未标记的对象
- 黑：已经被标记完成，且依旧存活的对象

#### 过程

![image-20250613232617973](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232617973.png)

- 最开始，所有对象都属于 `白色` 集合
- 在 GC 发生时，发生短暂的 `STW`，将所有与 `GcRoots` 直接相连的对象转入 `灰色` 集合中
- 之后并发执行，对灰色集合中的对象进行遍历，根据 `可达性分析` 算法进行对象存活 `标记`，当一个对象的 `所有成员` 全部被标记完成后，该对象则会被移入到 `黑色` 集合中。同时，也会将该对象中被标记的成员从 `白色` 集合移入 `灰色` 集合中
- 不断重复上一步操作，直至灰色集合彻底没了对象为止
- 标记完成所有对象后，再次触发 `STW`，通过 `write-barrier写屏障` 检测对象是否有变化，如果发生了改变则 `重新标记`，纠正并发标记期间的“误标”
- 并发执行清除工作，将 `白色` 集合中的所有对象全部回收（因为根据 GCRoots 节点进行可达性分析后，所有的存活对象都会从白色集合移入到黑色集合中，所以依旧留在白色集合中的对象必然为垃圾对象，这些对象就是需要被回收的对象）
- 最终等待清除工作完成后，代表着整个 GC 过程结束，再把 `标记复位`，将所有的对象再次放入白色集合中，等待迎接下次 GC 的到来

#### 问题

##### 并发标记导致的错标

- 被标记为黑色的对象，被引用的关系突然断开了，成为了垃圾

> 这种情况则被称为三色标记导致的“错标/误标/多标”，也被称为并发标记产生的**浮动垃圾**。
>
> 后面早晚被干掉，问题不大

##### 发执行导致漏标

- ① 白色对象断开灰色对象的引用，但又与黑色对象建立引用

![image-20250613232630026](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232630026.png)

- 白色对象断开灰色对象的引用，后面又重新建立了引用

> 一条用户线程在执行过程中，正好在 GC 线程标记时，将一个灰色对象与一个未标记的白色对象之间的引用连接断开了，然后当 GC 标记完成这个灰色对象，将其标记为黑色后，之前断开的白色对象又重新与之建立起了引用关系。

![image-20250613232640349](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232640349.png)

而当出现这两种情况时，因为重新建立引用的 `白色` 对象“`父节点`”已经被标记 `黑色` 了，所以 GC 线程不会再次标记该对象以及其成员对象，所以这些 `白色` 对象会被一直停留在白色集合中。最终导致的结果就是这些依旧存在引用的存活对象会被“`误判`”为垃圾对象 `清除掉`。

这种情况会直接影响到应用程序的正确性，是 `不可接受` 的。

##### 如何解决漏标问题

先来思考一下引起漏标问题的原因：

> - 条件一：`灰色` 对象 `断开` 了与 `白色` 对象的引用（直接引用或间接引用都可）。
> - 条件二：已经标为 `黑色` 的对象 `重新` 与 `白色` 对象建立了引用关系。

只有当一个对象同时满足了如上两个条件时才可发生漏标问题。

###### CMS解决漏标问题：增量更新 + 写屏障

- 写屏障

> 所谓的写屏障，则是指在赋值操作前后加入一些逻辑处理（类似于 SpringAOP 面向切面前后置处理的思想）
>
> 而 CMS 收集器则是通过在写屏障的后置处理中，实现了增量更新的逻辑，从而解决了漏标问题。

- 增量更新

> - 当一个未标记的白色对象，被其他对象重新引用时，白色对象会被记录下
> - 等并发标记阶段的 `GCRoots` 遍历标记完成后，在重新标记阶段会去找到集合里面的引用，再把 `源头` 标记为 `灰色`，然后重新去扫描标记这些对象。

> CMS 通过写屏障 + 增量更新这种手段，破坏了之前分析漏标问题时的第二个条件：已经标为黑色的对象重新与白色对象建立了引用关系。
>
> 通过增量更新的手段，会将这些重新建立了引用的“源头”再次恢复为灰色对象，然后在重新标记阶段会再次标记，同时为了避免重新标记阶段时再次发生漏标问题，所以重新标记阶段是必须要发生 STW 的。

###### G1解决漏标问题：STAB + 写屏障

> - GC 开始前，会生成一份原始快照，并发标记过程会以最初的对象关系进行访问，也就是说，不管怎么变，都以最初的引用关系进行标记
> - G1 是通过破坏「条件一：灰色对象断开了与白色对象的引用。」解决了漏标问题。

### 跨代引用

跨代引用是指年老代空间中的对象引用了新生代的对象，或者新生代中的对象引用了年老代中的对象。面对这种情况，在进行可达性分析扫描存活对象时，不可能从新生代一直扫描至年老代的，因为这样就会出现整堆扫描的情况，效率必然会很低。

在HotSpot虚拟机中，为了解决跨代引用的问题，会专门在内存中开辟一块小空间用于维护这些特殊的引用，从而达到让GC不必扫描整个堆空间的目的。而开辟的这块小空间则被称为**记忆集、卡表**。

#### G1 记忆集 Rset

- （HashTable），Key 为其他引用当前区内对象的 Region 起始地址，Value 则是一个集合，里面的元素为其他 Region 中每个引用当前区内对象的地址

#### CMS 卡表

- 一个字节数组，数组中每个元素对应着其标识的内存区域，称为卡页，hotSpot 使用的卡页大小为 2^9 即 512 字节，也就是说内存中每连续的 512 字节会被当作一个卡页作为卡表的一个元素。
- 如果有年老代的对象引用了新生代的对象，那么该新生代对象所在区域对应的卡页元素设置为 1，反之则为 0

## gc问题判断

在做 GC 问题排查和优化之前，我们需要先来明确下到底是不是 GC 直接导致的问题，或者应用代码导致的 GC 异常，最终出现问题。

### 判断 GC 有没有问题

#### 设定评价标准

评判 GC 的两个核心指标：

- 也可以理解为最大停顿时间，即垃圾收集过程中一次 STW 的最长时间，越短越好，一定程度上可以接受频次的增大。
- 应 用 系 统 的 生 命 周 期 内， 由 于 GC 线 程 会 占 用 Mutator 当前可用的 CPU 时钟周期，吞吐量即为 Mutator 有效花费的时间占系统总运行时间的百分比，例如系统运行了 100 min，GC 耗时 1 min，则系统吞吐量为 99%，吞吐量优先的收集器可以接受较长的停顿。

简而言之，即为 **一次停顿的时间不超过应用服务的 TP9999，GC的吞吐量不小于99.99%** 。

举个例子，假设某个服务 A 的 TP9999 为 80 ms，平均 GC 停顿为 30ms，那么该服务的最大停顿时间最好不要超过 80 ms，GC 频次控制在 5 min 以上一次。如果满足不了，那就需要调优或者通过更多资源来进行并联冗余。（大家可以先停下来，看看监控平台上面的 gc.meantime 分钟级别指标，如果超过了 6 ms 那单机 GC 吞吐量就达不到 4 个 9 了。）

#### 读懂 GC Cause

拿到 GC 日志，我们就可以简单分析 GC 情况了，通过一些工具，我们可以比较直观地看到 Cause 的分布情况，如下图就是使用 gceasy 绘制的图表：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232701539.png" alt="image-20250613232701539" style="zoom:90%;" />

如上图所示，我们很清晰的就能知道是什么原因引起的 GC，以及每次的时间花费情况，但是要分析 GC 的问题，先要读懂 GC Cause，即 JVM 什么样的条件下选择进行 GC 操作，具体 Cause 的分类可以看一下 Hotspot 源码：src/share/vm/gc/shared/gcCause.hpp 和 src/share/vm/gc/shared/gcCause.cpp 中。

重点需要关注的几个 GC Cause：

- **System.gc()** ：手动触发 GC 操作。
- **CMS**：CMS GC 在执行过程中的一些动作，重点关注 CMS Initial Mark 和 CMS Final Remark 两个 STW 阶段。
- **Promotion Failure**：Old 区没有足够的空间分配给 Young 区晋升的对象（即使总可用内存足够大）。
- **Concurrent Mode Failure**：CMS GC 运行期间，Old 区预留的空间不足以分配给新的对象，此时收集器会发生退化，严重影响 GC 性能，下面的一个案例即为这种场景。
- **GCLocker Initiated GC**：如果线程执行在 JNI 临界区时，刚好需要进行GC，此时 GC Locker 将会阻止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。

### 判断是不是GC引发的问题

到底是结果（现象）还是原因，在一次 GC 问题处理的过程中，如何判断是 GC 导致的故障，还是系统本身引发 GC 问题。这里继续拿在本文开头提到的一个 Case：“GC 耗时增大、线程 Block 增多、慢查询增多、CPU 负载高等四个表象，如何判断哪个是根因？”，笔者这里根据自己的经验大致整理了四种判断方法供参考：

- **时序分析：** 先发生的事件是根因的概率更大，通过监控手段分析各个指标的异常时间点，还原事件时间线，如先观察到 CPU 负载高（要有足够的时间Gap），那么整个问题影响链就可能是：CPU 负载高 -> 慢查询增多 -> GC 耗时增大 -> 线程 Block 增多 -> RT 上涨。

- **概率分析：** 使用统计概率学，结合历史问题的经验进行推断，由近到远按类型分析，如过往慢查的问题比较多，那么整个问题影响链就可能是：慢查询增多 -> GC 耗时增大 -> CPU 负载高 -> 线程 Block 增多 -> RT 上涨。
- **实验分析：** 通过故障演练等方式对问题现场进行模拟，触发其中部分条件（一个或多个），观察是否会发生问题，如只触发线程 Block 就会发生问题，那么整个问题影响链就可能是：线程 Block 增多 -> CPU 负载高 -> 慢查询增多  
  -> GC 耗时增大 -> RT 上涨。
- **反证分析：** 对其中某一表象进行反证分析，即判断表象的发不发生跟结果是否有相关性，例如我们从整个集群的角度观察到某些节点慢查和 CPU 都正常，但也出了问题，那么整个问题影响链就可能是：GC 耗时增大 -> 线程 Block  
  增多 -> RT 上涨。

不同的根因，后续的分析方法是完全不同的。如果是 CPU 负载高那可能需要用火焰图看下热点、如果是慢查询增多那可能需要看下 DB 情况、如果是线程 Block 引起那可能需要看下锁竞争的情况，最后如果各个表象证明都没有问题，那可能 GC 确实存在问题，可以继续分析 GC 问题了。

### 常见场景分析与解决

#### 动态扩容引起的空间动荡

##### 现象

服务 **刚刚启动时 GC 次数较多** ，最大空间剩余很多但是依然发生 GC，这种情况我们可以通过观察 GC 日志或者通过监控工具来观察堆的空间变化情况即可。GC Cause一般为 Allocation Failure，且在 GC 日志中会观察到经历一次 GC ，堆内各个空间的大小会被调整，如下图所示：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232715125.png" alt="image-20250613232715125" style="zoom:80%;" />

##### 原因

在 JVM 的参数中 -Xms 和 -Xmx 设置的不一致，在初始化时只会初始 -Xms 大小的空间存储信息，每当空间不够用时再向操作系统申请，这样的话必然要进行一次GC。

另外，如果空间剩余很多时也会进行缩容操作，JVM 通过 -XX:MinHeapFreeRatio 和 -XX:MaxHeapFreeRatio 来控制扩容和缩容的比例，调节这两个值也可以控制伸缩的时机。

整个伸缩的模型理解可以看这个图，当 committed 的空间大小超过了低水位 / 高水位的大小，capacity 也会随之调整：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232726031.png" alt="image-20250613232726031" style="zoom:70%;" />

##### 解决方案

尽量 将成对出现的空间大小配置参数设置成固定的值，如 -Xms 和 -Xmx，-XX:-MaxNewSize 和 -XX:NewSize，-XX:MetaSpaceSize 和 -XX:MaxMetaSpace-Size 等。

#### 显式 GC 的去与留

##### 现象

除了扩容缩容会触发 CMS GC 之外，还有 Old 区达到回收阈值、MetaSpace 空间不足、Young 区晋升失败、大对象担保失败等几种触发条件，如果这些情况都没有发生却触发了 GC ？

这种情况有可能是代码中手动调用了 `System.gc` 方法，此时可以找到 GC 日志中的 GC Cause 确认下。

那么这种 GC 到底有没有问题，翻看网上的一些资料，有人说可以添加 `-XX:+DisableExplicitGC` 参数来避免这种 GC，  
也有人说不能加这个参数，加了就会影响 `Native Memory` 的回收。

先说结论，笔者这里建议保留 `System.gc`，那为什么要保留？我们一起来分析下。

##### 原因

找到 `System.gc` 在 `Hotspot` 中 的 源 码， 可以发现增加 `-XX:+DisableExplicitGC`参数后，这个方法变成了一个空方法，如果没有加的话便会调用 `Universe::heap()::collect` 方法，继续跟进到这个方法中，发现 `System.gc`会引发一次 STW 的 `Full GC`，对整个堆做收集。

```c++
JVM_ENTRY_NO_ENV(void, JVM_GC(void))
    JVMWrapper("JVM_GC");
    if (!DisableExplicitGC) {
       Universe::heap()->collect(GCCause::_java_lang_system_gc);
    }
JVM_END
void GenCollectedHeap::collect(GCCause::Cause cause) {
    if (cause == GCCause::_wb_young_gc) {
       // Young collection for the WhiteBox API.
       collect(cause, YoungGen);
    } else {
    #ifdef ASSERT
       if (cause == GCCause::_scavenge_alot) {
          // Young collection only.
          collect(cause, YoungGen);
       } else {
          // Stop-the-world full collection.
          collect(cause, OldGen);
       }
    #else
       // Stop-the-world full collection.
       collect(cause, OldGen);
    #endif
    }
}
```

##### 保留 System.gc

此处补充一个知识点，**CMS GC** 共分为 **Background** 和 **Foreground** 两种模式，前者就是我们常规理解中的并发收集，可以不影响正常的业务线程运行，但**Foreground Collector** 却有很大的差异，他会进行一次压缩式 GC。

使用 Foreground Collector 时将会带来非常长的 STW。如果在应用程序中 System.gc 被频繁调用，那就非常危险了。

##### 去掉 System.gc

如果禁用掉的话就会带来另外一个内存泄漏问题，此时就需要说一下Direct-ByteBuffer，它有着零拷贝等特点，被 Netty 等各种 NIO 框架使用，会使用到堆外内存。堆内存由 JVM 自己管理，堆外内存必须要手动释放，DirectByteBuffer 没有  
Finalizer，它的 Native Memory 的清理工作是通过 sun.misc.Cleaner 自动完成的，是一种基于 PhantomReference（虚引用） 的清理工具，比普通的 Finalizer 轻量些。

为 DirectByteBuffer 分配空间过程中会显式调用 System.gc ，希望通过 Full GC 来强迫已经无用的 DirectByteBuffer 对象释放掉它们关联的 Native Memory。

HotSpot VM 只会在 Old GC 的时候才会对 Old 中的对象做 Reference Processing，而在 Young GC 时只会对 Young 里的对象做 Reference Processing。Young 中的 DirectByteBuffer 对象会在 Young GC 时被处理，也就是说，做 CMS  
GC 的 话 会 对 Old 做 Reference Processing， 进而能触发 Cleaner 对已死的DirectByteBuffer 对象做清理工作。但如果很长一段时间里没做过 GC 或者只做了Young GC 的话则不会在 Old 触发 Cleaner 的工作，那么就可能让本来已经死亡，  
但已经晋升到 Old 的 DirectByteBuffer 关联的 Native Memory 得不到及时释放。

这几个实现特征使得依赖于 System.gc 触发 GC 来保证 DirectByteMemory 的清理工作能及时完成。如果打开了 -XX:+DisableExplicitGC，清理工作就可能得不到及时完成，于是就有发生 Direct Memory 的 OOM。

##### 解决方案

通过上面的分析看到，无论是保留还是去掉都会有一定的风险点，不过目前互联网中的 RPC 通信会大量使用 NIO，所以笔者在这里建议保留。此外 JVM 还提供了-XX:+ExplicitGCInvokesConcurrent 和 -XX:+ExplicitGCInvokesCon-  
currentAndUnloadsClasses 参数来将 System.gc 的触发类型从 Foreground 改为 Background，同时 Background 也会做 Reference Processing，这样的话就能大幅降低了 STW 开销，同时也不会发生 NIO Direct Memory OOM。

#### MetaSpace 区 OOM

##### 现象

JVM 在启动后或者某个时间点开始，MetaSpace的已使用大小在持续增加，同时每次 GC 也无法完全释放，调大 MetaSpace 空间也无法彻底解决。

##### 原因

在讨论为什么会 OOM 之前，我们先来看一下这个区里面会存什么数据，Java7 之前字符串常量池被放到了 Perm 区，所有被 intern 的 String 都会被存在这里，由于 String.intern 是不受控的，所以 -XX:MaxPermSize 的值也不太好设置，经常会出现 java.lang.OutOfMemoryError: PermGen space 异常，所以在 Java7 之后常量池等字面量（Literal）、类静态变量（Class Static）、符号引用（SymbolsReference）等几项被移到 Heap 中。而 Java8 之后 PermGen 也被移除，取而代  
之的是 MetaSpace。

MetaSpace 的对象为什么无法释放，我们看最重要的一点：

类和其元数据的生命周期与其对应的类加载器相同，只要类的类加载器是存活的，在 Metaspace 中的类元数据也是存活的，不能被回收。每个加载器有单独的存储空间，通过 ClassLoaderMetaspace 来进行管理 SpaceManager* 的指针，相互隔离的。

所以关键原因就是 ClassLoader 不停地在内存中 load 了新的 Class ，一般这种问题都发生在动态类加载等情况上。

##### 解决办法

了解大概什么原因后，如何定位和解决就很简单了，可以 dump 快照之后通过 JProfiler 或 MAT 观察 Classes 的 Histogram（直方图） 即可，或者直接通过命令即可定位， jcmd 打几次 Histogram 的图，看一下具体是哪个包下的 Class 增加较多就可以定位了。不过有时候也要结合 InstBytes、KlassBytes、Bytecodes、MethodAll 等几  
项指标综合来看下。

如下图便是笔者使用 jcmd 排查到一个 Orika 的问题。

```shell
jcmd <PID> GC.class_stats|awk '{print$13}'|sed 's/\(.*\)\.\(.*\)/\1/
g'|sort |uniq -c|sort -nrk1
```

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232754255.png" alt="image-20250613232754255" style="zoom:80%;" />

如果无法从整体的角度定位，可以添加 -XX:+TraceClassLoading 和 -XX-:+TraceClassUnLoading 参数观察详细的类加载和卸载信息。

原理理解比较复杂，但定位和解决问题会比较简单，经常会出问题的几个点有 Orika的 classMap、JSON 的 ASMSerializer、Groovy 动态加载类等，基本都集中在反射、Javasisit 字节码增强、CGLIB 动态代理、OSGi 自定义类加载器等的技术点上。另外就是及时给 MetaSpace 区的使用率加一个监控，如果指标有波动提前发现并解决问题。

#### 过早晋升

##### 现象

这种场景主要发生在分代的收集器上面，专业的术语称为“Premature Promotion”。90% 的对象朝生夕死，只有在 Young 区经历过几次 GC 的洗礼后才会晋升到 Old 区，每经历一次 GC 对象的 GC Age 就会增长 1，最大通过 -XX:MaxTenuring-  
Threshold 来控制。

过早晋升一般不会直接影响 GC，总会伴随着浮动垃圾、大对象担保失败等问题，但这些问题不是立刻发生的，我们可以观察以下几种现象来判断是否发生了过早晋升。

主要现象如下：

- GC 日 志 中 出 现“Desired survivor size 107347968 bytes, new threshold 1(max 6)”等信息，说明此时经历过一次 GC 就会放到 Old 区。

- Full GC 比较频繁，且经历过一次 GC 之后 Old 区的 。

比如说 Old 区触发的回收阈值是 80%，经历过一次 GC 之后下降到了 10%，这就说明 Old 区的 70% 的对象存活时间其实很短，如下图所示，Old 区大小每次 GC 后从 2.1G 回收到 300M，也就是说回收掉了 1.8G 的垃圾，只有 300M 的活跃对象。  
整个 Heap 目前是 4G，活跃对象只占了不到十分之一。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232807317.png" alt="image-20250613232807317" style="zoom:80%;" />

过早晋升的危害：

- Young GC 频繁，总的吞吐量下降。
- Full GC 频繁，可能会有较大停顿。

##### 原因

主要的原因有以下两点：

- **Young / Eden 区过小：** 过小的直接后果就是 Eden 被装满的时间变短，本应该回收的对象参与了 GC 并晋升，Young GC 采用的是复制算法，由基础篇我们知道 copying 耗时远大于 mark，也就是 Young GC 耗时本质上就是copy 的时间（CMS 扫描 Card Table 或 G1 扫描 Remember Set 出问题的情况另说），没来及回收的对象增大了回收的代价，所以 Young GC 时间增加，同时又无法快速释放空间，Young GC 次数也跟着增加。
- **分配速率过大：** 可以观察出问题前后 Mutator 的分配速率，如果有明显波动可以尝试观察网卡流量、存储类中间件慢查询日志等信息，看是否有大量数据被加载到内存中。

同时无法 GC 掉对象还会带来另外一个问题，引发动态年龄计算：JVM 通过 -XX:-MaxTenuringThreshold 参数来控制晋升年龄，每经过一次 GC，年龄就会加一，达到最大年龄就可以进入 Old 区，最大值为 15（因为 JVM 中使用 4 个比特来表示对象的年龄）。设定固定的 MaxTenuringThreshold 值作为晋升条件：

- MaxTenuringThreshold 如果设置得过大，原本应该晋升的对象一直停留在Survivor 区，直到 Survivor 区溢出，一旦溢出发生，Eden + Survivor 中对象将不再依据年龄全部提升到 Old 区，这样对象老化的机制就失效了。
- MaxTenuringThreshold 如果设置得过小，过早晋升即对象不能在 Young 区充分被回收，大量短期对象被晋升到 Old 区，Old 区空间迅速增长，引起频繁的 Major GC，分代回收失去了意义，严重影响 GC 性能。

##### 解决办法

知道问题原因后我们就有解决的方向，如果是 ，我们可以在总的 Heap 内存不变的情况下适当增大 Young 区，具体怎么增加？

一般情况下 Old 的大小应当为活跃对象的 2~3 倍左右，考虑到浮动垃圾问题最好在 3 倍左右，剩下的都可以分给 Young 区。

拿笔者的一次典型过早晋升优化来看，原配置为 Young 1.2G + Old 2.8G，通过观察 CMS GC 的情况找到存活对象大概为 300~400M，于是调整 Old 1.5G 左右，剩下 2.5G 分给 Young 区。仅仅调了一个 Young 区大小参数（ -Xmn），整个 JVM 一分钟 Young GC 从 26 次降低到了 11 次，单次时间也没有增加，总的 GC 时间从 1100ms 降低到了 500ms，CMS GC 次数也从 40 分钟左右一次降低到了 7 小时 30 分钟一次。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232824736.png" alt="image-20250613232824736" style="zoom:70%;" />

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232833857.png" alt="image-20250613232833857" style="zoom:70%;" />

如果是分配速率过大：

- **偶发较大：** 通过内存分析工具找到问题代码，从业务逻辑上做一些优化。
- **一直较大：** 当前的 Collector 已经不满足 Mutator 的期望了，这种情况要么扩容 Mutator 的 VM，要么调整 GC 收集器类型或加大空间。

> 过早晋升问题一般不会特别明显，但日积月累之后可能会爆发一波收集器退化之类的问题，所以我们还是要提前避免掉的，可以看看自己系统里面是否有这些现象，如果比较匹配的话，可以尝试优化一下。一行代码优化的 ROI 还是很高的。
>
> 如果在观察 Old 区前后比例变化的过程中，发现可以回收的比例非常小，如从 80%只回收到了 60%，说明我们大部分对象都是存活的，Old 区的空间可以适当调大些。
