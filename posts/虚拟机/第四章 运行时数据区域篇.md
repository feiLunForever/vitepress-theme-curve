# 运行时的数据区域

JVM内存区域也被称为JVM运行时数据区，主要包含**程序计数器、虚拟机栈、本地方法栈、堆空间、元数据空间（方法区）、运行时常量池、字符串常量池、直接内存（本地内存）等**。站在程序执行的角度来看，总体可分为线程共享区和线程私有区两大块。如下图：

![image-20250613231659141](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231659141.png)

## 线程私有

对于每条线程而言，在创建它们时，JVM 都会为它们分配的区域，这些内存区域的生命周期会随着 `线程` 的启动、死亡而创建和销毁。这些区域创建后，其他线程是不可见的，只有当前线程自身可以访问。

运行时数据区中的线程私有区域主要包含：`程序计数器`、`虚拟机栈` 以及 `本地方法栈`。

### 程序计数器

> 生命周期随着 `线程` 创建而创建，结束而死亡

- 字节码解释器通过程序计数器依次读取指令(顺序执行、循环)
- 记录当前线程执行的位置，上下文切换

> 作为当前线程执行时的字节码行号指示器来使用的，当线程执行一个Java方法时，记录线程正在执行的字节码指令地址，当执行引擎处理完某个指令后，程序计数器需要进行对应更新，将指针改向下一条要执行的指令地址，执行引擎会根据PC计数器中记录的地址进行对应的指令执行。
>
> 当线程在执行一些由 `C/C++` 编写的 `Native` 方法时，PC计数器中则为空（`Undefined`）。除此作用之外，也可以保证线程发生CPU时间片切换后能恢复到正确的位置执行。

### 虚拟机栈

> 负责程序运行时具体如何执行、如何处理数据
>
> 生命周期与线程一致，每个线程创建时都会为之创建一个虚拟机栈

一个栈帧中主要包含 **局部变量表、操作数栈、动态链接、方法出口** 等信息。

#### 局部变量表

- 一个由  `槽（slot）`  组成的数组，用于存储 `方法参数` 和方法内部定义的 `局部变量`
- 表中存储的数据只对于当前方法中有效
- 局部变量表中的每个元素都可以存储一个数据值，数据类型可以是基本数据类型或者引用类型。
- 方法执行结束后，局部变量表会随着栈帧的的出栈/销毁而随之销毁

局部变量的存储位置：

- 对于基本数据类型的局部变量，它们的值直接存储在局部变量表中。
- 对于引用类型的局部变量，局部变量表中存储的是对象的引用，而对象的实际数据存储在堆内存中。

> 一般而言，如果当前方法属于构造方法或实例方法，那么这些方法的局部变量表中下标为 `0` 的槽位必然存储的是 `this` 引用，也就是局部变量表中的第一个位置会被用来放当前方法所属的对象引用，其他的局部变量会按照顺序在局部变量表中进行存储。如下图：
>
> <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/bb75309d0656409091b720a218c97ab8~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="局部变量表结构" style="zoom:80%;" />

#### 操作数栈

- 操作数栈是一个遵循 `FILO` 先进后出模式的栈结构
- 在执行一个方法时，首先会先创建一个与该方法对于的 `栈帧` ，该 `栈帧` 中的 `操作数栈` 最初是空的，在执行过程中，会根据 字节码指令 往 栈 中写入（入栈）和提取（出栈）数据。
- 操作数栈的主要目的是用于保存计算过程的 `中间结果`，同时作为计算过程中变量 `临时` 的存储空间。

> 同时因为 `操作数栈` 在运行时是位于 `内存` 中的，频繁的去对内存进行读写操作会影响执行速度，所以实际在执行过程中，虚拟机会将栈顶元素全部缓存到物理 CPU 的 `寄存器` 或高速缓存（L1/L2/L3）中，以此降低对内存的读写次数，从而提升执行引擎的执行效率。

以 `add` 方法的 `a+b` 例子进行讲解，源码与操作数栈计算过程如下图：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/767d86d0bcc14daf9bfbca0d06c1fb04~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="操作数栈计算案例" style="zoom:90%;" />

#### 动态链接

- 在 Java 源文件被编译成 `Class` 文件时，类中所有的变量、方法调用都会化为符号引用，然后保存在 `class` 文件的常量池中
- 常量池中，在 class 文件中描述一个方法调用另一个方法时，就使用常量池中指向方法的符号引用来表示的
- 动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用(方法在实际运行时的内存布局中的入口地址)

```java
public class Animal {
    public void makeSound() {
        System.out.println("Animal makes a sound");
    }
}

public class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Dog says: Woof!");
    }
  
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.makeSound();
    }
}
```

以下是当 `Dog` 类的 `main` 方法被执行时，动态链接是如何工作的：

1. **创建对象**：

    - `Animal myDog = new Dog();` 这行代码在堆上创建了一个 `Dog` 对象，并在栈上为 `myDog` 变量分配了一个引用。
2. **方法调用**：

    - 当执行到 `myDog.makeSound();` 这行代码时，JVM将 `makeSound` 方法的符号引用压入操作数栈。
3. **动态链接解析**：

    - JVM执行 `invokevirtual` 指令，这是用于调用实例方法的指令。
    - `invokevirtual` 指令会查找 `myDog` 引用的实际类型（即 `Dog` 类型），而不是声明类型（即 `Animal` 类型）。
    - JVM在 `Dog` 类的运行时常量池中查找 `makeSound` 方法的符号引用。
    - 如果是第一次调用，JVM会将符号引用解析为直接引用，即 `Dog` 类中 `makeSound` 方法在内存中的实际地址。
    - 解析后，JVM会调用 `Dog` 类的 `makeSound` 方法，而不是 `Animal` 类的 `makeSound` 方法。
4. **执行方法**：

    - 一旦解析完成，JVM跳转到 `Dog` 类的 `makeSound` 方法的代码，并执行它。
    - 结果是输出：“Dog says: Woof!”

##### 动态链接的重要性

在这个例子中，动态链接允许我们在运行时确定调用哪个方法。由于 `myDog` 变量的声明类型是 `Animal`，但实际类型是 `Dog`，动态链接确保了正确的 `makeSound` 方法被调用，这就是 `多态` 性的体现。

如果没有动态链接，Java的多态性将无法实现，因为方法调用将基于变量的声明类型而不是实际类型，这将导致 `Animal` 类的 `makeSound` 方法被调用，输出将是“Animal makes a sound”，而不是期望的“Dog says: Woof!”。

##### 虚方法表

在面向对象的编程中，动态分派使用频繁，每次动态分派的过程中，都要重新在类的元数据中搜索合适的目标的话就可能影响到执行效率，为此，虚拟机在类的方法区建立了一个虚方法表来实现使用索引表来代替查找。

每个类都有一个自己的虚方法表，存放的是方法的实际入口地址（就是方法的直接引用）。

虚方法表会在类加载的链接阶段创建并开始初始化，类的变量值初始完成之后，虚方法表也会初始完成。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231750425.png" alt="image-20250613231750425" style="zoom:90%;" />

**虚方法表中存放着各个方法的实际入口地址，如果某个方法在子类没有被重写，那么该方法在子类和父类的虚方法表中的实际入口地址是一样的，都指向父类的入口，如果重写了，子类虚方法表的地址就会被替换为重写的方法入口地址，** 如上图，Son 类重写了 Father 的全部方法，所以 Son 类的方法表没有指向 Father 的类型数据(方法的直接引用存于方法去类型数据下)，而 Son 和 Father 都没有重写 Object 的方法，所以虚方法表中没有重写的方法都指向了 Object 的类型数据。

#### 方法出口

- 正常时，返回调用者的程序计数器
- 异常时由异常处理器来确定

> 一个方法当开始被执行引擎执行时，只有两种情况会导致方法退出，一种是在执行过程中遇到了正常返回的字节码指令，如：ireturn、lreturn、dreturn、areturn、return，释义如下：
>
> - `ireturn`：返回值为 int、byte、char、short、boolean 类型时使用该指令返回
> - `lreturn`：返回值为 long 类型时使用该指令返回
> - `dreturn`：返回值为 double 类型时使用该指令返回
> - `areturn`：返回值为引用类型时使用该指令返回
> - `return`：无返回 void、类或接口初始化方法时使用该指令返回
>
> 方法正常执行完成后退出的情况被称为**正常完成出口**，一般执行返回的字节码指令时，调用者的程序计数器会被作为返回的地址。
> 
> 除开正常执行完成后退出的情况外，还有一种情况也会导致方法的退出，那就是方法执行过程中出现了异常，并且在方法体中没有处理该异常（没有 try/catch），此时也会导致方法退出，这种情况下被称为**异常完成出口**，返回地址则需要通过异常处理器表来确定。

当一个方法执行结束退出时，会执行如下步骤：

- ① 复原上层方法的局部变量表以及操作数栈。
- ② 如果当前方法有返回值的情况下，把返回值压入调用者方法栈帧的操作数栈中。
- ③ 将 PC 计数器的地址指向改为方法下一条指令的位置，从而使得调用者正常工作。
- PS：异常退出的情况下，是不会给上层调用者返回任何值的。

### 本地方法栈

本地方法栈和虚拟机栈差不多是类似的，区别在于虚拟机栈是用于执行 Java 方法的，而本地方法栈则是用于执行 C 所编写的 Native 本地方法。在程序运行之初，首先会在本地方法栈中登记 Native 本地方法，在执行引擎执行时，保存本地方法的相关数据（参数、局部变量等）。

### 程序计数器，操作数栈，局部变量表 协调工作

```java
public int calc() {
        int a = 100;
        int b = 200;
        int c = 300;
        return (a + b) * c;
    }
```

![image-20250613231804557](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231804557.png)

## 线程共享

在运行时，这些区域对于程序中的所有线程而言都是可见的，这些区域的状态不会因为某一条线程的死亡而发生改变，这些区域创建后是与 JVM 同级别的，伴随 JVM 的生命周期共生共死。

运行时数据区中的线程共享去主要包含：`堆空间`、`元数据空间（方法区）` 以及 `直接内存` 这三大块。

### 堆

Java 堆的作用与前面分析的 Java 栈不同，栈主要是作为运行时的单位，用于临时存储运行时需要以及产生的数据，而 Java 堆是存储的单位，主要解决的问题是数据存储问题，重点关注的领域是数据怎么存，放哪里，怎么放等。

#### 堆和栈的区别

1. 内存分别
    - 堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。
    - 栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。

2. 存放的内容
    - 堆存放的是对象的实例和数组。因此该区更关注的是数据的存储
    - 栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。

> - 静态变量放在方法区
> - 静态的对象还是放在堆
> - 如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上。
> - 如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。
> - 对象的成员变量与对象本身一起存储在堆上, 不管成员变量的类型是原生数值，还是对象引用。
> - 类的静态变量则和类定义一样都保存在方法区中。

3. 程序的可见度
    - 堆对于整个应用程序都是共享、可见的。
    - 栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。

#### 为什么把堆和栈区分出来

- 栈代表处理逻辑
  堆代表数据
- 比较符合面向对象的设计，栈和堆配合使用

> 1. 从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。分而治之的思想。这种隔离、模块化的思想在软件设计的方方面面都有体现。
> 2. 堆与栈的分离，使得堆中的内容可以被多个栈共享（也可以理解为多个线程访问同一个对象）。这种共享的收益是很多的。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。
> 3. 栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。
> 4. 面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美。

### 元数据空间(原方法区)

- 类的元数据、VM 内部表、类的层级信息/方法信息/字段信息、方法的编译信息和字节码数据、静态变量、常量池以及符号引用

### 直接内存

直接向操作系统申请内存空间，属于直接使用物理内存的一块区域，也被称为“堆外空间”。

对比堆空间而言，访问直接内存的速度会超出堆内存，也就是读写性能优于 Java 堆，来源于 Java 的 `NIO` 库，Java 的 `NIO` 可以允许 Java 程序直接使用本地的直接内存存储数据缓冲，因为如果把一些文件数据转为对象存储在堆中时，很容易导致堆空间负载过重而 OOM。所以出于 `性能` 和 `稳定性` 两方面的考虑，一般对于一些 `读写频繁` 的场景或 `读取/写出大文件` 时的场景都可以使用直接内存进行操作。

#### 直接内存（堆外内存）与堆内存比较

- 直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显
- 直接内存 IO 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显

## 内存泄漏与内存溢出

- 内存溢出：程序分配到了 `10MB` 内存，但运行过程中产生了 `11MB` 数据写入到该空间，这叫做内存溢出
- 内存泄漏：是没有完全回收掉之前申请的内存

## OOM

### 原因

- 内存中加载数据量过于庞大导致 OOM，如一次性从数据库中查询出几千万条数据导致创建出一个超大型的数据数组
- JVM 启动时，使用参数为其分配的堆空间过小，导致程序正常运行的内存都不足够
- 系统流量超出原有的预估值，导致大量请求进入系统，创建大量对象，内存过小 OOM
- 代码中存在逻辑不正确的循环导致在特定情况下产生了大量重复的对象实例，比如 for 循环创建大量对象

### 排查

- 利用 top 命令获取相应 pid，“-H”代表 thread 模式，你可以配合 grep 命令更精准定位。

```shell
top –H
```

- 然后转换成为 16 进制。

```shell
printf "%x" your_pid
```

- 最后利用 jstack 获取的线程栈，对比相应的 ID 即可。
