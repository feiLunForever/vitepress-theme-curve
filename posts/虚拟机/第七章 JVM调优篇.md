# JVM调优

## JVM 调优效果

VM 调优目标是需要进行二选一的，即：`最短停顿时间`或`最大吞吐量`，具体要达成哪个，需要根据我们的系统情况来进行判断。

- **最短停顿时间**：JVM 的 GC 会 STW（Stop The World），这时将暂停所有应用线程，对于用户而言就有卡顿感了。因此，对于注重用户操作体验的系统来说，**缩短 STW 的停顿时间是系统调优目标**。
- **最大吞吐量**：对于一些执行任务计算类的后台系统来说，其关注点并不是停顿时间，而是在单位时间内进行更多的任务计算，那么**获取最大的吞吐量则是系统调优目标**。

我们都听说过分布式系统的 CAP 定理：在一个分布式系统中，最多只能在一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）中三者满足其二，不能同时满足这三项。

JVM 调优也与其类似，**`最低内存占用率`**、**`最短停顿时间`** 和 **`最大吞吐量`** **，这三者也只能满足其二**，不存在三者兼得的情况。如果选择了其中的任意两个，必然会以牺牲另一个为代价。

![image-20250613232844521](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613232844521.png)

再换句话说，在内存占用率恒定的情况下，最短停顿时间和最大吞吐量，我们系统的优化目标只能两者取其一。

## JVM 调优步骤

### 1. 明确调优目标

两个方向性目标，最短停顿时间和最大吞吐量。

### 2. 分析运行情况

在这一步，我们可以借助于主流的监控工具 Prometheus + Grafana ，再结合 JDK 自带的命令行工具（jps、jstat、jinfo、jstack 等）进行分析。

主要的分析点包括：Young & Full & Mixed GC 频率、Young & Full & Mixed GC 耗时、系统负载、CPU 使用率、JVM 参数配置，以及是否存在内存泄露、OOM、线程死锁等。

### 3. 参数配置调整

本着少即是多的原则，常见 JVM 调优参数如下：

```shell
//内存设置
//设置最大堆内存，该值设置过小会导致频繁Full GC或OOM，设置过大则会导致非堆内存消耗殆尽
//建议将该值设置为物理内存的60%——80%
-Xmx3072m

//初始堆内存，建议与-Xmx设置相同，避免每次垃圾回收完成后，JVM重新分配内存
-Xms3072m

//设置堆外内存，若不进行指定，则跟-Xmx值一致
-XX:MaxDirectMemorySize=512m


//设置垃圾回收器
//老年代使用Parallel Old收集器，新生代使用Parallel Scavenge收集器，以最大吞吐量为目标
-XX:+UseParallelOldGC

//使用G1收集器，会在吞吐量和停顿时间中进行平衡
-XX:+UseG1GC

//使用ZGC收集器，以最短停顿时间为目标
-XX:+UseZGC

//新生代使用Serial收集器，老年代使用Serial Old收集器。特点是占用内存小，启动速度快
-XX:+UseSerialGC

//其他类型参数
//对象从年轻代进入老年代的年龄值，JDK8默认值15，JDK9则将该值调整为7
-XX:InitialTenuringThreshold=7

//新生代可容纳的最大对象，超出该阈值则直接将对象分配到老年代，默认值为0，任何对象都先在新生代分配内存，
//不过，该参数只对Serial和ParNew收集器有效
-XX:PretenureSizeThreshold=1048576

//GC停顿时间，垃圾收集器会尝试用各种手段达到这个时间，但不能完全保证达成，该参数值不可设置过低，单位为毫秒
 -XX:MaxGCPauseMillis=200
 
 //设置GC的并行线程数量
 -XX:ParallelGCThreads=8

//Region中的存活对象低于这个值时，才会对该Region进行回收，否则存活对象占比较高，那回收的的意义
//就不大了，且复制的时间也会变长，默认85%
-XX:G1MixedGCLiveThresholdPercent=85

//Mixed GC是基于复制算法进行的，会把要回收的Region中的存活对象复制到其他Region中，然后再把这
//个Region清空，这样就会不断有新的Region空出来，一旦空出来的Region数量达到了堆内存的该参数比
//例值，就会立即停止混合回收，默认5%
-XX:G1HeapWastePercent=5 

//设置每个Region的大小，单位MB，需要为1，2，4，8，16，32其一，默认是堆内存的1/2000
-XX:G1HeapRegionSize=2
```

我们需要根据上述参数，以及系统的调优目标和当前实际情况，有针对性地进行参数调优。

### 4. 灰度差异对比

在我们进行 JVM 参数调优之后，不会直接应用到集群中的所有应用服务器中。

我们会先选择集群中的一台服务器，进行 JVM 参数优化后的灰度测试，将此台服务器的运行情况和集群中的其他服务器进行运行指标对比，以此得知本次 JVM 参数优化的效果。

除此之外，我们还需要观察这台灰度的应用服务器，是否有其他异常情况发生，影响了应用程序的正常运行。

### 5. 全量推进应用

如果经过观察对比，此台服务器的优化效果明显，且运行几天并无异常情况发生，我们将本次 JVM 参数优化的结果，全量应用在集群的所有应用服务器中。

至此，我们才算完成了 JVM 调优的整体闭环步骤。

## JVM 调优真实案例

### 背景

`data-hub`服务是一些数据处理相关的服务，其中有一个高频核心接口 -- `onlineSegments`线上分词接口很慢，后面通过 `Prometheus + Grafana 监控系统` + `JDK 自带的命令行工具进行排查`，发现 JVM 的 Full GC 非常频繁，基本上十多分钟就会发生一次，每次的 GC 时间有十几秒。

通过 `jmap -histo` 命令进行排查，`onlineSegments`返回的大对象，包含了某个门店下，某个商品的同义词、关键词、描述等信息。

这里增加了`Caffeine 缓存`，接口虽然查询出来的结果数量不多，但是结果集中包含了同义词、关键词、描述等大字段，平均几十K，有的甚至100K以上。

key是shopId+skuCode，缓存的命中率不是很高，由于设置了 Caffeine 的 maximumSize 属性的原因，这些对象全部进入了老年代。

峰值 QPS 达到了 1500+，该服务的集群是 3 台 4c8g 的服务器，那么单台服务器的 QPS 是 500+，该对象每秒钟进入到老年代的大小达到了 10M+（部分查询命中缓存），这就是其频繁 Full GC 的原因。

### 案例解决

定位到问题后，接下来就比较容易解决了。

（1）换一个以最短停顿时间为目标的垃圾收集器，来替代 Parallel Old 收集器，解决系统的长时间卡顿问题。

由于该系统用的是 JDK 1.8 版本，无法使用 ZGC 收集器，我们将垃圾收集器换成了 G1（XX:+UseG1GC）。

G1 收集器是一种基于 Region 的内存布局形式，进行局部收集的设计思路，其不仅仅停顿时间可控（默认 MaxGCPauseMillis 为 200ms），而且对系统吞吐量也很友好。

（2）将代码中 Caffeine 缓存的 maximumSize 参数设置为 10000（之前是 10 万），减少 JVM 中长时间驻留对象的数量，解决潜在的 Mixed GC 频繁的问题。

经此调整后，系统在 Mixed GC 期间的停顿时间，从十几秒减少到了 200 毫秒左右，且相比于之前 ParallelOld 十多分钟一次的 Full GC 频率，调整后的 G1 Mixed GC 频率降低到了三个小时一次。
