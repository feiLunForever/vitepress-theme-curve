# 类加载子系统篇

## 类加载机制及加载过程（类的生命周期）

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231523933.png" alt="image-20250613231523933" style="zoom:50%;" />

### 加载

加载阶段是指通过完全限定名查找Class文件二进制数据并将其加载进内存的过程。

大体流程会分为三步：

- ① 通过完全限定名查找定位 `.class` 文件，并获取其二进制字节流数据
- ② 在方法区中生成运行时的数据结构
- ③ 在堆中间中为其创建一个 `Class` 对象，这样便可以通过该对象访问方法区中的这些数据

### 连接

连接步骤包含了 `验证`、`准备`、`解析` 三个阶段。这三个阶段中，前两个执行顺序是确定的，但 `解析` 阶段不一定，可能会发生在 `初始化` 之后。

#### 验证

验证阶段主要用于确保被加载的 `Class` 正确性，检测 `Class` 字节流中的数据是否符合虚拟机的要求，确保不会危害虚拟机自身安全。

`验证` 阶段主要包括四种验证：`文件格式验证` 、`元数据验证`、`字节码验证` 以及 `符号引用验证`。

- **文件格式验证**：验证字节流是否符合 `Class` 文件格式的规范
  - 例如：是否以 0xCAFEBABE 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- **元数据验证**：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求
  - 检查是否继承了不允许被继承的类 final
  - 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法
- **字节码验证**：通过数据流和控制流分析，确定程序语义是否符合逻辑的。
  - 比如任意时刻的操作数栈和指令代码是否都能配合使用
- **符号引用验证**：确保解析动作能正确执行
  - 通过字符串描述的全限定名是否能找到对应的类
  - 符号引用中的类、字段、方法的可访问性是否可被当前类访问

#### 准备

为类中声明的 `静态变量` 分配内存空间，并将其初始化成默认值（零值），这些内存都将在方法区中分配。

1. 这时候进行内存分配的仅包括 `类变量（static）`，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
2. 这里所设置的初始值"通常情况"下是数据类型默认的 `零值`（如 0、0L、null、false 等）

   - 比如 `public static int value=111` ，那么 value 变量在准备阶段的初始值就是 ` 0` 而不是 111（初始化阶段才会赋值）。
   - 特殊情况：`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

#### 解析

符号引用 转换为 直接引用。

> 符号引用比如 `import java.util.ArrayList ` 这就算符号引用，直接引用就是指针或者对象地址

- 在编译的时候一个每个 java 类都会被编译成一个 class 文件，但在编译的时候，被引用的类、方法或者变量还没有被加载到内存中，虚拟机并不知道所引用类的地址。
- 暂时用符号（比如 com.example.Test）引用来代替，而在这个解析阶段就是为了把这个符号引用转化成为真正的地址的阶段。

### 初始化

在 Java 中 `对类变量进行初始值设定` 有两种方式：

> 1. 声明类变量时指定初始值
> 2. 使用静态代码块为类变量指定初始值

#### JVM初始化步骤

1. 假如这个类还没有被加载和连接，则程序先加载并连接该类
2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类
3. 假如类中有初始化语句，则系统依次执行这些初始化语句

#### 类初始化时机

只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：

1. 创建类的实例，也就是 `new` 的方式
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（如 Class.forName(“com.shengsiyuan.Test”)）
5. 初始化某个类的子类，则其父类也会被初始化
6. Java 虚拟机启动时被标明为启动类的类（Java Test），直接使用 java.exe 命令来运行某个主类

> `注意以下几种情况不会执行类初始化`：
>
> 1. 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。
> 2. 定义对象数组，不会触发该类的初始化。
> 3. 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。
> 4. 通过类名获取 Class 对象，不会触发类的初始化。
> 5. 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。
> 6. 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。

### 卸载

而当一个 Class 对象不再被任何一处位置引用，即不可触及时，Class 就会结束生命周期，该类加载的数据也会被卸载。

卸载类需要满足 3 个要求:

- 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象
- 该类没有在其他任何地方被引用
- 该类的类加载器的实例已被 GC

所以，在 JVM 生命周期类，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

> 只要想通一点就好了，jdk 自带的 BootstrapClassLoader,ExtClassLoader,AppClassLoader 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

## 类加载器

### 类加载器类型

#### BootstrapClassLoader(启动类加载器)

- `<JAVA_HOME>\lib` 下的核心库

#### ExtensionClassLoader(扩展类加载器)

- `<JAVA_HOME>\lib\ext` 下

#### AppClassLoader(应用程序类加载器)

- `java -classpath` 下

> 一般情况下，该类加载器是程序的默认类加载器，我们可以通过ClassLoader.getSystemClassLoader()方法可以直接获取到它。

#### Custom ClassLoader

- 当 class 文件不在 classpath 路径下时，需要自定义类加载器加载特定路径下的 class
- 当一个 class 文件是通过网络传输过来的并经过了加密处理，需要首先对 class 文件做了对应的解密处理后再加载到内存中时，需要自定义类加载器
- 线上环境不能停机时，要动态更改某块代码，这种情况下需要自定义类加载器
- 继承 ClassLoader 需要自己重写 findClass()方法并编写加载逻辑

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231600088.png" alt="image-20250613231600088" style="zoom:70%;" />

### 双亲委派

#### 核心思想

- 自下向上检查类是否已经被加载
- 从上至下尝试加载类

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231624973.png" alt="image-20250613231624973" style="zoom:50%;" />

#### 为什么需要双亲委派

- 避免类的重复加载

    - 通过这种层级关可以避免类的重复加载，当⽗亲已经加载了该类时，就没有必要⼦ ClassLoader 再加载⼀次
- 防⽌核⼼ API 库被随意篡改

    - 假设通过⽹络传递⼀个名为 java.lang.Integer 的类，通过双亲委托模式传递到启动类加载器，⽽启动类加载器在核⼼ Java API 发现这个名字的类，发现该类已被加载，并不会重新加载⽹络传递的过来的 java.lang.Integer，⽽直接返回已加载过的 Integer.class，这样便可以防⽌核⼼ API 库被随意篡改。

#### 为什么要打破双亲委派

- 官方为我们提供了很多 `SPI` 接口，例如 JDBC，官方往往只会定义规范，具体的实现则是由第三方来完成的
- 这些 SPI 接口直接由 Java 核心库来提供，一般位于 `rt.jar` 包中，是由 `Bootstrap` 类加载器完成加载的
- 而第三方实现的具体代码库则一般被放在 `classpath` 的路径下，则是 `App类加载器` 进行加载的
- 在 SPI 接口中，会经常调用实现者的代码，所以一般会需要先去加载自己的实现类，但实现类并不在 `Bootstrap类加载器` 的加载范围内
- 双亲委派是指子类加载器可以将类加载请求委托给父类加载器进行加载，但这个过程是不可逆的
- 只能通过打破双亲委派机制来加载 SPI 接口的实现类

##### jdbc

> - 在 `DriverManager` 类的静态代码块中调用了 `loadInitialDrivers()` 方法
> - 该方法会通过 `ServiceLoader` 查找服务接口的实现类
> - 通过该 jar 包 `META-INF/services/` 里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入

我们先来看看 Java 中 SPI 定义的一个核心类：`DriverManager`，该类位于 `rt.jar` 包中，是 Java 中用于管理不同数据库厂商实现的驱动，同时这些各厂商实现的 Driver 驱动类，都继承自 Java 的核心类 `java.sql.Driver`，如 MySQL 的 `com.mysql.cj.jdbc.Driver` 的驱动类。先看看 `DriverManager` 的源码，如下：

```java
// rt.jar包 → DriverManager类
public class DriverManager {
    // .......
    
    // 静态代码块
    static {
        // 加载并初始化驱动
        loadInitialDrivers();
        println("JDBC DriverManager initialized");
    }

// DriverManager类 → loadInitialDrivers()方法
 private static void loadInitialDrivers() {
    // 先读取系统属性 jdbc.drivers
    String drivers;
    try {
        drivers = AccessController.doPrivileged(new PrivilegedAction<String>() {
            public String run() {
                return System.getProperty("jdbc.drivers");
            }
        });
    } catch (Exception ex) {
        drivers = null;
    }
    
    AccessController.doPrivileged(new PrivilegedAction<Void>() {
        public Void run() {
            //通过ServiceLoader类查找驱动类的文件位置并加载
            ServiceLoader<Driver> loadedDrivers =
            ServiceLoader.load(Driver.class);
            //省略......
        }
    });
    //省略......
}
```

在 `DriverManager` 类的静态代码块中调用了 `loadInitialDrivers()` 方法，该方法中，会通过 `ServiceLoader` 查找服务接口的实现类。前面分析 Java 的 SPI 机制时，曾提到过：Java 的 SPI 存在一种动态的服务发现机制，在程序启动时，会自动去 jar 包中的 `META-INF/services/` 目录查找以服务命名的文件，mysql-connector-java-6.0.6.jar 包文件目录如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250613231645530.png" alt="image-20250613231645530" style="zoom:80%;" />

观察如上工程结构，我们明确可以看到，在 MySQL 的 jar 包中存在一个 `META-INF/services/` 目录，而在该目录下，存在一个 `java.sql.Driver` 文件，该文件中指定了 MySQL 驱动 `Driver` 类的路径，该类源码如下：

```java
// com.mysql.cj.jdbc.Driver类
public class Driver extends NonRegisteringDriver 
                        implements java.sql.Driver {
    public Driver() throws SQLException {
    }
    // 省略.....
}
```

可以看到，该类是实现了 Java 定义的 SPI 接口 `java.sql.Driver` 的，所以在启动时，SPI 的动态服务发现机制可以发现指定的位置下的驱动类。

最终来看看 SPI 机制是如何加载对应实现类的，`ServiceLoader.load()` 源码如下：

```java
// ServiceLoader类 → load()方法
public static <S> ServiceLoader<S> load(Class<S> service) {
    // 获取线程上下文类加载器
    ClassLoader cl = Thread.currentThread().getContextClassLoader();
    // 使用线程上下文类加载器对驱动类进行加载
    return ServiceLoader.load(service, cl);
}
```

通过如上源码可以清晰的看见：最终是通过 `Thread.currentThread().getContextClassLoader()` 获取的当前执行线程的线程上下文类加载器对 SPI 接口的实现类进行了加载。

### 热部署

- 全限定名相同的一个类被加载过之后，第二次需要用到该类时，会直接在类加载器的命名空间（可以理解为缓存）中进行查找，而不会二次加载此类
- 销毁自定义 classloader(被该加载器加载的 class 也会自动卸载)
- 更新 class
- 使用新的 ClassLoader 去加载 class