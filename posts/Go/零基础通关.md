---
title: 零基础通关
tags:
  - Go
categories:
  - Go
date: '2025-01-03'
description: 欢迎使用 Curve 主题，这是你的第一篇文章
articleGPT: 这是一篇初始化文章，旨在告诉用户一些使用说明和须知。
#cover: "/images/logo/logo.webp"
---

# 零基础通关

## 知识大纲

![小册知识点结构.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/4a076b7d583e435c83acd7515d741928~tplv-k3u1fbpfcp-watermark.png)

## 环境搭建

> https://golang.google.cn/dl/ 中文镜像

### 第一个Go程序

使用 vi 或启动任何一个纯文本编辑器，输入如下内容：

```go
package main
import "fmt"
func main(){
    fmt.Println("Hello World!")
}
```

将其保存为 hello.go。 接下来，启动终端，导航至 hello.go 所在目录，然后执行以下命令，编译 hello.go 程序：

```bash
go build hello.go
```

稍等片刻，程序编译完成。编译完成后将生成名为 hello 的可执行文件。在终端执行这个文件，可以看到 “Hello World!” 字样的文本输出，如下图所示：

```shell
(base) jiangbolun@jiangbolundeMacBook-Pro-2 main % ./hello 
Hello Word!% 
```

> 注意：
> Go 语言要求包含 `main` 函数的文件必须声明为 `package main`。这是生成可执行文件的关键。

## 源码结构以及命令行工具

### Go程序源码结构

```go
package main
import "fmt"
func main(){
    fmt.Println("Hello World!")
}
```

接下来，我们简单解释代码。

1. 第一行内容为 “package main”，它表示这个源码文件属于 main 包。main 包是每个 Go 应用程序都包含的包，有且只有一个。
2. 从第三行开始到最后，是 main() 函数，这个函数比较特殊，它是 Go 程序的“入口”函数，是程序运行的起点。这个函数必须存在且只能存在一个，且必须声明在 main 包中。任何一个 Go 函数都要求使用成对的大括号将函数体包裹起来。

### Go SDK 命令行工具

#### go build

> go build 命令的作用是编译 Go 源码，并生成可执行的文件。

从原理上说，Go SDK 自 1.9 版本开始就支持并发编译了，能尽可能地发挥电脑的最大性能完成编译，所以 Go 源码的编译速度是非常快的。在编译过程中，除了我们自己写的代码外，如果使用了第三方的包，这些包会被一同编译。当我们执行 go build 命令后，会搜索当前目录下的 go 源码并完成编译。

go build 命令还允许附加参数，方便开发者对编译参数进行配置，具体如下表所示：

| 参数名   | 作用                               |
|-------|----------------------------------|
| -v    | 编译时显示包名                          |
| -p x  | 指定编译时并发的数量（使用x表示），该值默认为CPU的逻辑核心数 |
| -a    | 强制进行重新构建                         |
| -n    | 仅输出编译时执行的所有命令                    |
| -x    | 执行编译并输出编译时执行的所有命令                |
| -race | 开启竞态检测                           |

此外，如果我们希望只编译某个 go 源码文件或包，可在 go build 命令后添加文件或包名。例如，现有 file1.go、file2.go 和file3.go，我们只希望编译 file1.go，便可如下执行：

```bash
go build file1.go
```

#### go clean

go clean 命令可以清理当前目录内的所有编译生成的文件，具体包括：

-   当前目录下生成的与包名或者 Go 源码文件同名的可执行文件，以及当前目录中 _obj 和 _test 目录中名为 _testmain.go、test.out、build.out、a.out 以及后缀为 .5、.6、.8、.a、.o和 .so 的文件，这些文件通常是执行go build命令后生成的；
-   当前目录下生成的包名加 “.test” 后缀为名的文件，这些文件通常是执行 go test 命令后生成的；
-   工作区中 pkg 和 bin 目录的相应归档文件和可执行文件，这些文件通常是执行 go install 命令后生成的。

go clean 命令还允许附加参数，具体参数和作用如下表所示：

| 参数名        | 作用                                        |
|------------|-------------------------------------------|
| -i         | 清除关联的安装的包和可运行文件，这些文件通常是执行go install命令后生成的 |
| -n         | 仅输出清理时执行的所有命令                             |
| -r         | 递归清除在 import 中引入的包                        |
| -x         | 执行清理并输出清理时执行的所有命令                         |
| -cache     | 清理缓存，这些缓存文件通常是执行go build命令后生成的            |
| -testcache | 清理测试结果                                    |

在团队式开发中，通常在每次提交代码前执行 go clean 命令，防止提交编译时生成的文件。

#### go run

go run 命令的作用是直接运行 go 源码，不在当前目录下生成任何可执行的文件。

从原理上讲，go run 只是将编译后生成的可执行文件放到临时目录中执行，工作目录仍然为当前目录。同时，go run 命令允许添加参数，这些参数将作为 go 程序的可接受参数使用。

由此可见，go run 命令同样会执行编译操作。但要注意的是，go run 不适用于包的执行。

#### gofmt

gofmt 命令的作用是将代码按照Go语言官方提供的代码风格进行格式化操作。

请大家注意，**gofmt和go fmt是两个不同的命令**。go fmt 命令是 gofmt 的封装，go fmt 支持两个参数：-n 和 -x，分别表示仅输出格式化时执行的命令，以及执行格式化并输出格式化时执行的命令。

执行 gofmt 命令时，可指定文件或目录，也可不指定。当不指定时，gofmt 命令会搜索当前目录中的 go 源码文件，并执行相应的格式化操作。

gofmt 命令还允许附加参数，具体参数和作用如下表所示：

| 参数名                  | 作用                                                 |
|----------------------|----------------------------------------------------|
| -l                   | 仅输出需要进行代码格式化的源码文件的绝对路径                             |
| -w                   | 进行代码格式化，并用改写后的源码覆盖原有源码                             |
| -r rule              | 添加自定义的代码格式化规则（使用rule表示），格式为：pattern -> replacement |
| -s                   | 开启源码简化                                             |
| -d                   | 对比输出代码格式化前后的不同，依赖diff命令                            |
| -e                   | 输出所有的语法错误，默认只会打印每行第1个错误，且最多打印10个错误                 |
| -comments            | 是否保留代码注释，默认值为true                                  |
| -tabwidth x          | 用于指定代码缩进的空格数量（使用x表示），默认值为8，该参数仅在-tabs参数为false时生效   |
| -tabs                | 用于指定代码缩进是否使用tab（“\t”），默认值为true                     |
| -cpuprofile filename | 是否开启CPU用量分析，需要给定记录文件（使用filename表示），分析结果将保存在这个文件中   |

`💡 提示：使用-s参数进行源码简化的规则请参考：https://pkg.go.dev/cmd/gofmt#hdr-The_simplify_command`

#### go install

go install 命令的作用和 go build 类似，都是将源码编译为可执行的文件，附加参数也基本通用，这里就不再赘述了。区别在于：

-   go install 命令在编译源码后，会将可执行文件或库文件安装到约定的目录下；
-   go install 命令生成的可执行文件使用包名来命名；
-   默认情况下，go install 命令会将可执行文件安装到 GOPATH\bin 目录下，依赖的三方包会被安装到 GOPATH\bin 目录下。

#### go get

go get 命令的作用是获取源码包，这一操作包含两个步骤，分别是下载源码和执行 go install 命令进行安装。使用时，仅需将源码仓库地址追加到 go get 后即可（访问<https://pkg.go.dev/>，搜索包名，在包详情页可以找到仓库地址），例如：

```bash
go get github.com/ethereum/go-ethereum
```



go get 命令还允许附加参数，具体参数和作用如下表所示：

| 参数名       | 作用                        |
|-----------|---------------------------|
| -d        | 仅下载源码包，不安装                |
| -f        | 在执行-u参数操作时，不验证导入的每个包的获取状态 |
| -fix      | 在下载源码包后先执行fix操作           |
| -t        | 获取运行测试所需要的包               |
| -u        | 更新源码包到最新版本                |
| -u=patch  | 只小版本地更新源码包，如从1.1.0到1.1.16 |
| -v        | 执行获取并显示实时日志               |
| -insecure | 允许通过未加密的HTTP方式获取          |

若要指定所获取源码包的版本，可以通过添加 “@版本号” 的方式执行。如：

```bash
go get github.com/ethereum/go-ethereum@v1.10.1
```

在使用 Go SDK 1.17 版本时，有一点需要额外注意：执行 go get 命令可能会收到警告，大意是 go get 命令是不建议使用的。此时，使用go install替换 go get 即可，原因是在未来的 Go SDK 版本中 go get 的作用等同于 go get -d。

如果你对 “go get” 命令感兴趣，可以阅读官方对它的说明，写的非常详细：<https://docs.studygolang.com/doc/go-get-install-deprecation>

### debug

goland	debug 时会失效：

> undefined behavior - version of Delve is too old for Go version 1.23.5 (maximum supported version 1.20) 15

因依赖问题要求GO版本需要从1.18.x版本升级到1.23.x，升级后，Test 启动 debug时，发现打断点的红点一闪而过，出现一个失效的标志（一个灰色圆圈+斜杠），在经过百度大法后，原来高版本（1.20及以上版本）会出现debug断点无效的现象。

经过资料查阅，发现是因为go高版本问题，导致dlv插件失效，[github](https://so.csdn.net/so/search?q=github&spm=1001.2101.3001.7020)上提供了源代码，可以clone下来打包，并把dlv文件放到指定的目录。

1. Git clone

   ```shell
   git clone https://github.com/go-delve/delve.git
   ```

2. #### 编译并打包成dlv可执行文件

   ```
   cd cmd/dlv
   
   go build
   ```

   执行完毕后，当前目录下多出一个dlv可执行文件 

3. #### 复制dlv文件到goland插件目录

   - goland 新版本（大于等于23年版本）

     ```
     cp dlv /Applications/GoLand.app/Contents/plugins/go-plugin/lib/dlv/mac
     ```

     

   - goland老版本（小于23年版本）

     ```
     cp dlv /Applications/GoLand.app/Contents/plugins/go/lib/dlv/mac
     ```

## 基础语法

### 命名规范

- 对于变量，除了首个单词外，每个单词的首字母用大写表示，这种命名法通常被称为小驼峰式命名法；若所有单词的首字母均大写，则成为大驼峰式命名法（又被称为帕斯卡命名法）。由于变量有可见性（有关可见性的更多内容，将在结构体/包中介绍。）之分，对于对外可见的变量，使用大驼峰法；对于对外不可见的变量，使用小驼峰法。特别地，若变量/常量是布尔类型，最好以is、allow、has、can之类来开头；
- 对于常量，单词均用大写字母来表示，每个字母之间使用下划线来分割。

```go
// 变量声明
var exampleNumberA int = 10
var isDarkMode bool = false
// 常量声明
const WIDTH_OF_RECT int = 12
const ALLOW_DOWNLOAD_WHEN_WIFI bool = true
```

### 声明与赋值

**在Go语言中，变量或常量的数据类型必须先声明，才能使用**，且无法将不相关的数据赋值给它们。

这是因为Go语言和Java、C、C++等语言一样，属于静态语言，静态语言具有更严谨的结构要求、调试便捷（可通过代码直观地看到数据类型）与确保类型安全（无法使用不同类型的数据赋值）的特点，必须要先做声明。而像PHP、Python、JavaScript等动态语言则没有这个限制。

#### 变量的声明与赋值

在Go语言中，声明变量的一般格式为：

```Go
var name type
```

- 其中，var是声明变量的关键字，固定不变，表明意图——要声明一个变量
- type表示该变量所属的数据类型。

```Go
// 声明一个名为number的变量，类型为int（整数类型）
var number int
// 为number赋值
number = 100

// 变量声明
var number int = 100
```

#### 常量的声明与赋值

常量声明和赋值的一般格式为：

```Go
const name type = value
```

其中，const是声明常量的关键字，固定不变，表明意图，要声明一个常量；name和type的意义与声明变量时一样；value是常量的值。如：

```Go
// 声明一个名为PI的常量，类型为float64（浮点数类型）
const PI float64 = 3.14
```

`❗️ 注意： 声明常量时，必须为其赋值，且后续无法修改。`

#### Go语言的类型推断

使用Go语言可简化代码，类型推断体现了这一点。当声明与赋值一并进行时，如果数据为Go内置的基础类型，则可无需指定类型。如：

```Go
// 变量声明
var number = 100
// 常量声明
const PI = 3.14
```

无需担心，由于number的值为100，Go语言会推断出它的类型为整数型。同理，PI也会被推断为浮点数型。

对于变量，还有一种超级精简的声明和赋值方式，示例如下：

```Go
//变量声明
number := 100
```

`❗️ 注意： 冒号等于号“:=”的作用是声明和赋值，若number是已经声明过的变量，则无法使用 := 的方式赋值。`

#### 批量声明/赋值

为了方便多个变量/常量的声明和赋值，我们还可以批量处理它们，示例如下：

```Go
//变量
var (
        // 声明 + 赋值
        number int = 100
        // 声明 + 赋值（类型推断）
        text = "Hello"
        // 只声明
        name string
)
//常量
const (
        // PI 声明 + 赋值
        PI float64 = 3.14
        // WIDTH 声明 + 赋值（类型推断）
        WIDTH  = 5
        // HEIGHT 声明 + 赋值（类型推断）
        HEIGHT = 10
)
```

### 指针类型

> 在上一讲中，我们介绍了Go语言的基本数据类型，学会了如何对变量进行声明和赋值，也知道了在这个过程中会在内存开辟空间方便它们“安家”。那如何才能找到这个“家”呢？这就涉及到了指针。
>
> 通过使用指针，开发者可以直接访问内存中的数据，从而可以实现对数据的精准管理以及运算。
>
> 如果说变量名是数据的“代号”，那么指针存放的则是数据的“**实际地址**”，我们可以通过这个地址获取或修改存放于这个地址的变量的值。
>
> 存放整数值的变量称为整型变量，存放布尔值的变量称为布尔变量……类似地，存放指针值的变量称为指针变量。
>
> 那么问题来了，想要获取或改变某个变量的值，直接通过变量名就可以实现了。而且像Java之类的编程语言几乎不会用到指针，**那Go为何还要用指针呢？**
>
> `❗️ 注意： 实际上，Java中的指针操作封装在JDK中，普通开发者一般不会接触到，所以会误认为Java没有指针。`

我们不妨先了解一下Go语言中的指针，它主要由两大核心概念构成：**类型指针**和**切片指针**。

- 类型指针：在**传递数据**时直接使用指针，可以避免创建数据的副本，节约内存开销。类型指针不能进行偏移和运算，可以**避免非法修改**为其它数据的风险，也更**有利于垃圾回收**机制及时找到并回收它们；

- 切片指针：切片由**指向起始元素的指针**、元素数量和总容量构成。当访问切片发生越界时，会发生宕机并输出堆栈信息。宕机是**可以恢复**的，而崩溃只能导致程序停止运行。

可见，**使用指针更有利于程序运行的性能和稳定性**。另外，在某些操作中，如使用反射修改变量的值，必须使用可寻址的变量（通过指针）。

在实际应用中，最为常用的便是获取变量的内存地址，以及获取某个地址对应的值。在Go语言中，前者使用“&”运算符，后者使用“*”运算符。它们互为反向操作，操作的对象也不同。具体请看下面的示例：

```Go
// exampleNumberA变量（整数型变量）声明和赋值
var exampleNumberA int = 10
// 获取exampleNumberA的地址，并赋值给exampleNumberAPtr变量（exampleNumberAPtr的类型是指针类型）
exampleNumberAPtr := &exampleNumberA
//输 出exampleNumberAPtr变量的值（将输出内存地址）
fmt.Println(exampleNumberAPtr)
// 获取exampleNumberAPtr（指针变量）表示的实际数据值，并赋值给exampleNumberAPtrValue变量（整数型变量）
exampleNumberAPtrValue := *exampleNumberAPtr
// 输出exampleNumberAPtrValue变量（整数型变量）的值
fmt.Println(exampleNumberAPtrValue)
```

运行后，控制台输出：

> 0xc00001a088 
> 10

上面的代码示例演示了如何使用已有的变量创建指针类型变量。我们还可以使用new()函数直接创建指针变量，相当于在内存中创建了**没有变量名**的**某种类型**的**变量**。

这样做无需产生新的数据“代号”，取值和赋值转而通过指针变量完成。常用在无需变量名或必须要传递指针变量值的场景中。

new()函数的使用格式如下：

```Go
new(type)
```

其中，type是所在地址存放的数据类型。一旦完成创建，便会在内存中“安家”，完成内存分配，即使没有赋值。

具体代码示例如下：

```Go
// 使用new()函数创建名为exampleNumberAPtr指针类型变量，表示int64型值
exampleNumberAPtr := new(int64)
// 修改exampleNumberAPtr表示的实际数据值
*exampleNumberAPtr = 100
// 获取exampleNumberAPtr表示的实际数据值
fmt.Println(*exampleNumberAPtr)
```

程序运行后，控制台将输出：

> 100

## 流程控制

### 循环结构

循环结构的格式如下：

```go
for init; condition; post {
    //循环体代码块
}
```

其中，for表明接下来的代码是for循环结构；init是初始化语句；condition是关系或逻辑表达式，值为true时则会停止循环；post是每次循环结束后执行的语句；循环体代码块就是要重复执行的代码了。

比如我们要输出：
![image-20250124134602852](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250124134602852.png)

我们用这个循环结构实现：

```go
package main

import "fmt"

func main() {
	n := 7
	for i := 1; i <= n; i++ {
		for j := 0; j < n-i; j++ {
			fmt.Print(" ")
		}
		for k := 0; k < 2*i-1; k++ {
			fmt.Print("*")
		}
		fmt.Println()
	}
	for i := 1; i < n; i++ {
		for j := 0; j < i; j++ {
			fmt.Print(" ")
		}
		for k := 0; k < 2*n-1-2*i; k++ {
			fmt.Print("*")
		}
		fmt.Println()
	}
}
```

### 流程控制语句

流程控制语句多用于管理循环结构的运行。考虑这样一个需求：编程实现查找1-10以内的素数。

```go
func main() {
	for i := 2; i > 0; i++ {
		//当i大于10s
		if i > 10 {
			break
		}
		if i == 2 {
			fmt.Println(i)
			continue
		}
		//假定i为素数
		flag := true
		for j := 2; j < i; j++ {
			if i%j == 0 {
				//当i能被某个整数整除时，不是素数
				flag = false
				break
			}
		}
		//如果依旧为true，则i为素数
		if flag {
			fmt.Println(i)
		}
	}
}
```





## 数组、切片和集合

### 数组

Go语言中声明数组的一般格式为：

```go
var array_name [quantity]Type
```

其中，var关键字用于声明变量；array_name表示数组名；quantity表示数组元素个数；Type表示元素类型。例如：

```go
var resultArray [4]int
```

声明后即可为单个元素赋值了。和其它的编程语言类似，要为数组中的某个元素赋值，格式为：

```go
array_name[index] = Value
```

例如：

```go
resultArray[2] = 5
```

### 切片

使用数组来存放一些结果，很容易引发下标越界错误。和数组相对，Go语言还提供了一种专门存放**不定元素个数**的数据结构——切片。

在Go语言中，切片的声明一般格式为：

```go
var slice_name []Type
```

其中，var关键字用于声明变量；slice_name表示切片名；Type表示元素类型。

> `💡 提示： 注意到了吗？声明切片和数组的区别仅仅是去掉了中括号中的元素个数！`

例如：

```go
var resultSlice []int
```

> `❗️ 注意： 和数组类似，切片中的元素也不限制值的类型，但要求所有元素均为相同的类型。`

完成切片的声明后，就来到赋值环节。

与数组不同，为切片赋值可以理解为“**扩充**”。在一开始，切片里面的元素个数为0。“扩充”一个值，就相当于为切片中的第一个元素赋值。赋值后，切片的元素个数就变成了1。若再次“扩充”，则相当于为切片中的第二个元素赋值。赋值后，切片的元素个数就变成了2，以此类推……

在Go语言中，为切片“扩充”需要使用append()函数，使用格式如下：

```go
slice_name = append(slice_name, value)
```

其中，slice_name表示已声明的切片变量名，value表示具体的数据值。

值得一提的是，**append()函数本身并不会改变原有切片**，只是将切片“扩容”后的结果作为函数返回值。因此，需要将“扩容”后的结果再次（即函数返回值）赋值给slice_name，才能真正使slice_name发生改变。

例如：

```go
resultSlice = append(resultSlice, value)
```

在实际项目中，切片的使用其实更为广泛。例如：当用户发起搜索，搜索的结果个数往往会根据搜索关键字的不同而发生变化。在不确定总数的前提下，使用数组显然是不合适的。

### 集合

使用数组不合适，那使用什么呢？答案是：集合。我们考虑另一个场景——管理学生信息。

如何保存和查找一所学校所有学生的信息呢？通过姓名显然是不合适的，因为会有重名的情况。通过年级+姓名呢？显然也是不合适的，因为这可能会执行两次筛选，而且也无法从根本上排除重名的情况。所以，我们应使用一个能标识一个学生**唯一性**的数据作为保存和查找的依据。比如：学号。

一个学号对应一个学生，保存时如此，查找时亦如此。

> `💡 提示： 与此类似的管理方式还有身份证号、驾驶证号、商品ID、图书ISBN等等。这些能标识唯一性的值可以统称为“唯一ID”。在实际项目中，为了保证单条数据的唯一性，为其构建唯一ID号是非常有必要的。`

像上述这种唯一ID对应单条数据，可以使用集合来管理。集合可以看作是一类特殊的切片，只不过集合的元素都是由若干“**键-值对**”数据构成的。所谓“键”，相当于“唯一ID”；“值”，相当于单条数据，**键不允许重复**。

Go语言中声明集合的一般格式为：

```go
var map_name = make(map[key_type]value_type)
```

`❗️ 注意： 和数组、切片类似，集合中的键和值均不限制数据类型，且键和值可分别使用不同的类型。但要求所有键均为相同的类型，所有值均为相同类型。`

其中，var用于声明变量；map_name表示集合的变量名；key_type表示键的类型；value_type表示值的类型。

对于本例而言，学号和学生信息都使用string类型来表示，集合的变量名为studentInfos。对应的代码为：

```go
var studentInfos = make(map[string]string)
```

集合中元素的赋值和数组类似，只不过中括号中不再是索引，而是键的值。例如，保存学号为“0001”的学生，名为“王小红”，代码实现为：

```go
studentInfos["0001"] = "王小红"
```

以此类推，继续增加4条信息，完整的代码如下：

```go
func main() {
   var studentInfos = make(map[string]string)
   studentInfos["0001"] = "王小红"
   studentInfos["0002"] = "李小明"
   studentInfos["0003"] = "张三丰"
   studentInfos["0004"] = "孙小贝"
   studentInfos["0005"] = "何明明"
   // 输出语句
   fmt.Println(studentInfos)
}
```

程序运行结果为：

> map[0001:王小红 0002:李小明 0003:张三丰 0004:孙小贝 0005:何明明]

值得一提的是，若对一个已经存在数据的“键”再次赋值，原有的数据将被**覆盖**。比如，在本例输出语句前添加：

```go
studentInfos["0003"] = "周丹"
```

再次运行本例，结果则变为：

> map[0001:王小红 0002:李小明 0003:周丹 0004:孙小贝 0005:何明明]

在实际项目中，充分利用集合键唯一的性质，还可以确保**排除重复**的数据。

### 循环遍历

除了for循环外，Go语言还提供了range关键字。与for结合，也可以实现循环遍历，其使用格式如下：

```go
for index, value := range variable {
    // 循环体
}
```

其中，index表示索引或键的值；value表示元素的值；variable表示数组、切片或集合变量；由大括号包裹的部分是循环体，可以使用index和value变量。

for 循环对比 for-range：

- 使用`for`循环：

```
slice := []int{1, 2, 3, 4, 5}
for i := 0; i < len(slice); i++ {
    fmt.Println(slice[i])
}
```

- 使用`range`：

```
slice := []int{1, 2, 3, 4, 5}
for i, v := range slice {
    fmt.Println(i, v)
}
```

`range`自动处理了索引`i`和值`v`的赋值，并且代码更加简洁。

这种for与range结合实现循环遍历的结构，也被称为**for-range结构**。这种结构同样适用于数组和切片。

## 函数

### 普通函数的定义和调用

在Go语言中，定义一个普通函数的格式如下：

```go
func function_name([params_list])([return_values_list]){
    // 函数体
}
```

其中，func关键字表示定义一个函数；function_name是函数名；params_list表示参数列表；return_values_list表示函数的返回值列表；使用大括号包裹起来的部分称为函数体，是函数内部要执行的代码。其中，参数列表和返回值列表是可选的。有些函数无需参数，有些参数运行后并不会有任何返回值，有些函数则无需参数也无需返回值。

先举个简单的例子，下面的函数实现了将参数（即传入的string类型字符串）作为返回值（类型也为string）输出。

```go
func stringLoop(content string) string {
   return content
}
```

这段代码一共有三行，我们逐行拆解：

 - 第一行定义了名为stringLoop的函数，参数列表中，content是参数名，string是参数的类型。当需要多个参数是，使用英文的逗号（,）隔开。再往后表示该函数运行后将返回string类型的结果；
 - 第二行是函数体，return表示返回函数运行的结果。本例是直接将传入的参数——content变量的值返回；
 - 第三行是函数的结尾。

下面，尝试调用这个函数，整个函数定义与调用的示例如下：

```go
func main() {
   result := stringLoop("字符串回环测试")
   fmt.Println(result)
}

// 用于测试的自定义函数
func stringLoop(content string) string {
   return content
}
```

### **值传递**和**引用传递**

先猜猜它的运行结果：

```go
func main() {
   var resultSlice []int
   findPrimeNumber(resultSlice, 10)
   fmt.Println(resultSlice)
}

func findPrimeNumber(result []int, max int) {
   for i := 2; i < max; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到result数组中
         result = append(result, i)
      }
   }
}
```

答案揭晓：这段程序的运行结果为：

> []

相信不少人看到这里会一脸懵。为什么我把main()函数中的resultSlice传入findPrimeNumber()了，并且在findPrimeNumber()中对其做了修改，却并没有使resultSlice发生变化呢？

要解开这个谜团，我们不妨输出 main()函数中resultSlice和findPrimeNumber()中，result的内存地址。因为只有这二者的地址相同，才能证明这两个变量是“一回事”。

输出内存地址的代码示例如下：

```go
ptr := &variable
fmt.Println(&ptr)
```

其中，variable表示变量名，对应本例为main()中的resultSlice和findPrimeNumber()中的result。

这一对比的结果是显而易见的，main()中的resultSlice和findPrimeNumber()中的result，二者内存地址是不同的！这也就意味着，无论result变量在findPrimeNumber()中作出如何改变，都无法作用到main()中的resultSlice变量上。问题也就跟着来了：在函数间传值的过程中，到底发生了什么呢？

实际上，这里涉及到两个容易混淆的传递概念——**值传递**和**引用传递**。

像上述示例当中的做法，即直接传递一个变量名到另一个函数中，属于**值传递**。按照Go代码的执行策略，发生值传递时，将在另一个函数中自动生成一个值的副本。所以我们才会看到main()中的resultSlice和findPrimeNumber()中的result的内存地址是不同的，因为后者完全是前者的“替身”，我们在findPrimeNumber()函数中只是对替身做了改变，“真身”根本就没有收到影响！

与值传递相对的便是**引用传递**，这种方式在函数间传递的是指针，而指针恰恰是内存地址。这样的传值，无论发生在多少个函数之间，改变将始终作用于相同地址的数据上。

了解过值传递和引用传递后，便很清楚如何修改我们的代码了——只需将原有的值传递改为引用传递，即向findPrimeNumber()函数传递resultSlice的内存地址就行了。当然，还要适当修改findPrimeNumber()函数的定义和逻辑。修改后的完整代码如下：

```go
func main() {
   var resultSlice []int
   findPrimeNumber(&resultSlice, 10)
   fmt.Println(resultSlice)
}

func findPrimeNumber(result *[]int, max int) {
   for i := 2; i < max; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到result数组中
         *result = append(*result, i)
      }
   }
}
```

再次运行程序，将输出：

> [2 3 5 7]

除了将值传递改为引用传递外，还有一种“**偷懒式**”修改方法也可使程序正常输出——直接把resultSlice变量声明在函数外，改为**全局变量**，即可在所有函数中访问和修改这个变量了。

之所以称这种方法是“偷懒式”，是因为所有函数都能修改这个全局变量，数据存在一定的安全风险。若不慎错误地修改了变量的值，修复起来也会相对更困难一些了。

### 函数的延迟调用

接下来，我们保持findPrimeNumber()函数不变，在main()函数伊始添加两行神奇的代码：

```go
func main() {
   defer fmt.Print("素数")
   defer fmt.Print("查找")
   var resultSlice []int
   findPrimeNumber(&resultSlice, 10)
   fmt.Println(resultSlice)
}
```

很明显，main()函数开头的两行代码和普通的代码不同，前面有个“defer”。**“defer”的作用是让整句代码延迟执行，且多个defer存在时，它们的顺序是反向的。**

根据这一规律，我们便可推测上述代码运行的结果将是：

>[2 3 5 7]   
>查找素数

defer的典型应用场景是执行一些**收尾工作**，通常是在常规逻辑执行结束后释放系统资源。如文件读写、网络IO等等。也用于程序在**发生宕机时的恢复**。

### 匿名函数的定义和调用

> 回调保证了程序运行的正确性和及时性。**匿名函数则是实现回调的核心技能**。

在Go语言中，匿名函数的定义格式如下：

```go
func ([params_list])([return_values_list]){
    // 函数体
}
```

其中，params_list表示参数列表；return_values_list表示函数的返回值列表；使用大括号包裹起来的部分称为函数体，是匿名函数内部要执行的代码。其中，参数列表和返回值列表是可选的。有些函数无需参数，有些参数运行后并不会有任何返回值，有些函数则无需参数也无需返回值。

> `❗️ 注意： 请大家注意普通函数与匿名函数在定义时的区别，普通函数在定义时仅比匿名函数多了函数名。`

定义了函数后，接下来便是如何调用它。根据使用时机的不同，Go语言提供了两种调用匿名函数的方式：一是在定义时调用；二是将匿名函数赋值给变量，通过变量调用。

举例来说，下面的代码定义了一个匿名函数，实际作用便是在控制台输出传入的参数，类型是string：

```go
func main() {
   // 定义匿名函数
   func(text string) {
      fmt.Println(text)
   }
}
```

> `💡 提示：注意到了吗？和普通函数不同，匿名函数可以在某个普通函数内定义和使用。`

如果要在该函数定义时便调用它，只需在大括号结束后，使用小括号将要传入的参数值包裹起来即可，比如：

```go
func main() {
   // 定义匿名函数
   func(text string) {
      fmt.Println(text)
   }("定义时就调用")
}
```

这段代码中，“定义时就调用”便是要传入的参数了。运行这段代码，控制台将输出这些文字。

另一种调用匿名函数的方法是将匿名函数赋值给某个变量，然后通过变量调用。这听起来很神奇，写起来其实非常简单：

```go
func main() {
   // 定义匿名函数
   exampleVal := func(text string) {
      fmt.Println(text)
   }
   exampleVal("通过变量调用匿名函数")
}
```

如上代码所示，声明了变量exampleVal，并将匿名函数赋值给了它。在后续的代码中，即可随时使用exampleVal变量调用匿名函数了。

#### 实战回调

模拟网络文件下载，定期查询进度、及时汇报状态。

##### 主动定期查询进度

```go
package main

import (
	"fmt"
	"time"
)

var percent = 0

func main() {
	var keepChecking = true
	// 开启下载
	fmt.Println("开始下载任务！")
	go download("")
	//开启检查下载进度
	for {
		if keepChecking {
			time.Sleep(500 * time.Millisecond)
			fmt.Println("当前进度：", getPercent())
		} else {
			break
		}
	}
}

// 下载
func download(url string) {
	for {
		time.Sleep(1 * time.Second)
		percent++
		if percent >= 100 {
			break
		}
	}
}

// 获取进度
func getPercent() int {
	return percent
} 
```

##### 下载并执行回调

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	var keepChecking = true
	// 开启下载
	fmt.Println("开始下载任务！")
	go downloadFunc("", func() {
		keepChecking = false
		fmt.Println("下载完成！")
	}, func(currentPercent int) {
		keepChecking = false
		fmt.Println("下载取消！", currentPercent)
	}, func(currentPercent int) {
		keepChecking = false
		fmt.Println("下载失败！", currentPercent)
	})

	//开启检查下载进度
	for {
		if keepChecking {
			time.Sleep(500 * time.Millisecond)
			fmt.Println("当前进度：", getPercent())
		} else {
			break
		}
	}
}

// 下载
func downloadFunc(url string, downloadSuccess func(), downloadCancelled func(int), downloadFailed func(int)) {
	for {
		time.Sleep(1 * time.Second)
		percent++
		if percent == 100 {
			downloadSuccess()
			break
		}
	}
}
```

## 结构体

### 定义

在Go语言中，定义结构体的标准格式为：

```go
type StructName struct {
   // 属性字段
}
```

其中，开头的type表示要定义自定义的类型；StructName代表结构体的名称；struct表示结构体类型；由大括号包裹的部分是属性列表，由一个或若干个字段构成。字段的名称不允许重复。

举例，若要定义用于描述游戏角色的结构体，名称为Player，则可如下实现：

```go
type Player struct {
   // 角色名
   name string
   // 职业
   career string
   // 性别
   gender string
}
```

具体来说，本例定义了名为“Player”类型的数据，该数据的类型为结构体。这个结构体中由3个属性构成，分别使用3个字段来描述。包括角色名（name）、职业（career）和性别（gender），它们都是string类型。

实际上，Player作为**自定义类型，和基本数据类型相似，同样遵循Go语言官方建议的命名方法（驼峰式），作用域的规则限制也同样适用**。

### 使用

#### 声明与初始化

下面的代码声明了Player类型的变量，并完成初始化。最终创建了狂斩天下角色：

```go
playerA := Player{
   name:   "狂斩天下",
   career: "战士",
   gender: "男",
}
```

如上代码所示，playerA就是狂斩天下了。

> `❗️ 注意：在初始化结构体时，每个字段需要使用逗号分割开。在定义结构体时则不用。`

在初始化结构体时，可以一次性地赋值所有字段，也可以只赋值部分字段，甚至不赋值。下面几种写法都是允许的：

```go
playerA := Player{
   name:   "狂斩天下",
   gender: "男",
}
```

```go
playerA := Player{}
```

对于本例这种一口气赋值所有字段的行为，Go语言提供了更简洁的方式，如下所示：

```go
playerA := Player{
   "狂斩天下",
   "战士",
   "男",
}
```

注意到区别了吗？这种简洁方式省略了所有字段名。但为了确保字段的正确匹配，需要按照结构体内部定义的顺序进行赋值，且必须一次完成所有属性赋值。即定义时是角色名、职业、性别；初始化时也应是角色名、职业、性别，顺序不能颠倒，且值缺一不可。

#### 访问和修改属性值

在Go语言中，改变或完善（针对初始化时未赋值的情况）结构体内属性值的方法是非常简单的，其格式为：

```go
变量名.属性名=值
```

举例来说，狂斩天下对应的是playerA变量，职业对应的是career字段。因此，若要完成转职，应如下实现：

```go
playerA.career = "战神"
```

再次向控制台输出playerA的值，可以看到如下输出：

> {狂斩天下 战神 男}

可以看到，只有职业发生了变化，其它属性仍保持不变。

另一方面，如果我们想单独获取playerA变量的某个属性值，也可以使用类似的方式。举例来说，获取playerA的角色名，实现方式为：

```go
fmt.Println(playerA.name)
```

运行结果为：

> 狂斩天下

### 匿名结构体

在实际开发中，还有一类情况，就是某个结构体的作用域很小，甚至只存在于某个函数内部，或是无需创建太多的该结构体变量等等。对于上述情况，Go语言允许我们使用匿名结构体简化编码，即使用匿名结构体。

> `💡 提示：这是本讲第二次介绍简化编码的方式了，这便是Go语言中结构体使用简便特性的体现。大家还记得上一个简化编码是用来做什么吗？答案是——初始化结构体变量`

举例来说，还是游戏中的场景。某天，温玉琳琅来到许愿树下进行许愿，这一天是她的生日，许愿树这个植物仅在生日场景中出现。因此为了简化编码，考虑使用匿名结构体来定义和使用它。

使用匿名结构体的方法并不难，实际上就是省略了单独的结构体定义。而是将定义和相关变量的声明、属性赋值合三为一处理。如果我们要声明一个变量来表示许愿树，示例代码如下所示：

```go
wishingTree := struct {
   height   float64
   width    float64
   treeType string
}{
   height:   22.5 * 100,
   width:    50,
   treeType: "banyan"}
fmt.Println(wishingTree)
```

仔细阅读上述代码，wishingTree便是表示许愿树变量了，它是结构体（struct）类型。结构体内包含3个属性，分别是浮点型的高度（height）、浮点型的胸径（width）以及字符串型的树品种。这3个属性由一个大括号包裹起来。紧随其后的大括号是为属性赋值的过程，其规则依然是允许全部赋值，也允许部分赋值。简化的赋值方式同样适用，这里不再赘述。

`❗️ 注意：即使不为任何属性赋值，第二个大括号也是必不可少的，否则将引发编译时错误，程序无法被编译和运行。`

运行上述代码，可见控制台如下输出：

> 2250 50 banyan

### 构建独一无二的对象——构造函数

本例使用品种（string）、年龄(int)、体重(float)、性别(int)这四个特征来创建“狗”对象，根据我们现有的知识，若要使用结构体来描述，其代码实现类似如下：

```go
type Dog struct {
   Breed  string
   Age    int
   Weight float64
   Gender string
}
```

既然说，构造函数是通过使用结构体初始化的过程来模拟实现的，我们不妨编写一个函数，将狗的四个特征作为参数传入其中，并最终返回Dog类型的变量。如此一来，一旦这个函数被调用后，便会生成一个独一无二的Dog类型变量。代码示例如下：

```go
func NewDog(breed string, age int, weight float64, gender string) *Dog {
   return &Dog{
      Breed:  breed,
      Age:    age,
      Weight: weight,
      Gender: gender,
   }
}
```

类似NewDog()这样的函数，其作用与面向对象语言中的构造函数类似。如此，我们便使用结构体实现了Go语言中并未原生支持的构造函数。

构造函数在使用时非常简单，我们只需声明一个变量，并通过调用NewDog()函数为其赋值即可。比如下面这段完整的代码，就创建了两只胖瘦不同柴犬：

```go
type Dog struct {
   Breed  string
   Age    int
   Weight float64
   Gender string
}

func NewDog(breed string, age int, weight float64, gender string) *Dog {
   return &Dog{
      Breed:  breed,
      Age:    age,
      Weight: weight,
      Gender: gender,
   }
}

func main() {
   fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")
   weakShibaInu := NewDog("Shiba Inu", 2, 7.0, "公")
   fmt.Println(fatShibaInu)
   fmt.Println(weakShibaInu)
}
```

相信不少朋友可能会有疑问：使用构造函数，和直接创建结构体，似乎没有什么区别。就拿fatShibaInu变量来说吧，下面两种写法都能达到目的。


 - 使用构造函数：

```go
fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")
```

 - 不使用用构造函数：

```go
fatShibaInu2 := &Dog{
   Breed:  "Shiba Inu",
   Age:    2,
   Weight: 12.0,
   Gender: "公",
}
```

乍看上去还真是一样，但我们考虑一种情况——使用多国语言。

像年龄和体重倒没关系，关键是品种和性别。就拿性别来说吧，当使用“公”来赋值时，只有懂汉语的人能看懂。所以更多时候我们使用0和1分别代表公和母，这样就屏蔽了语言不同造成的理解上的困难。

所以，我们就非常迫切地需要在赋值和取值过程中进行一个“转换”处理。在赋值时将不同语言中表达性别的文字转换成0或1，并在取值时反向转换。

因此，我们修改Dog的结构体和构造函数如下：

```go
type Dog struct {
   Breed  string
   Age    int
   Weight float64
   Gender int
}

func NewDog(breed string, age int, weight float64, gender string) *Dog {
   genderValue := 0
   if gender == "公" {
      genderValue = 0
   } else if gender == "母" {
      genderValue = 1
   }
   return &Dog{
      Breed:  breed,
      Age:    age,
      Weight: weight,
      Gender: genderValue,
   }
}
```

如此修改后，NewDog()函数内部完成了对gender参数的转换，尽管传入的是汉字，但最终创建Dog变量时用的却是数字。main()函数中创建fatShibaInu变量无需做任何修改，依然使用汉字来表示性别即可。

反观直接创建结构体的方式，就只能传入0和1了：

```go
fatShibaInu := &Dog{
   Breed:  "Shiba Inu",
   Age:    2,
   Weight: 12.0,
   Gender: 0,
}
```

### 对象定义方法是否使用指针

为对象定义方法时，需要注意接收器的类型。使用指针与否，将决定了是否对原始变量产生影响。本例使用了\*Dog，即指针类型，在方法中对该类型变量（d变量）的任何影响都将影响原始变量（fatShibaInu）；反之，若使用Dog类型，则不会影响。

其原因是当不使用指针类型变量时，方法中的接收器变量实际上是对原始数据的“拷贝”，所做出的改变也仅仅会作用于这份“拷贝”的数据上，并不会影响到原始数据。

对比来说，我们分别定义两个不同的方法——GrowUp()和GrowUp2()，前者使用指针类型接收器，后者不使用。方法体均是对相应变量中的年龄属性自增1，然后在控制台输出运行结果。测试代码关键部分如下：

```go
func (d *Dog) GrowUp() {
   d.Age++
}

func (d Dog) GrowUp2() {
   d.Age++
}

func main() {
   fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")

   fatShibaInu.GrowUp()
   fmt.Println(fatShibaInu)

   fatShibaInu.GrowUp2()
   fmt.Println(fatShibaInu)
}
```

运行结果为：

> Shiba Inu 3 12 0
>
> Shiba Inu 3 12 0

显然，虽然GrowUp2()方法也对d变量中的Age属性做了自增1计算，但并未影响原始数据。

### 结构体的嵌套

> 在Go语言中，没有直接等同于Java中`extends`的关键字，因为Go不支持传统的类继承。Go使用组合（composition）来复用代码，而不是继承。

我们先来实现作为父结构体的动物（Animal），这个结构体具有名字（Name）、年龄（Age）和性别（Gender）属性。

> `💡 提示：请留意这三个属性也是本例中所有子结构体所具有的。`

示例代码如下：

```go
type Animal struct {
   Name   int
   Age    int
   Gender string
}
```

接下来，以子结构体鸟（Bird）为例，它还具有翅膀颜色的属性。因此，Bird的结构体定义示例如下：

```go
type Bird struct {
   WingColor    string
   CommonAnimal Animal
}
```

很明显地，Bird结构体中包含了一个名为CommonAnimal的Animal类型成员，而Animal类型就是我们刚刚定义好的结构体。如此，便完成了结构体的嵌套，即把Animal嵌入Bird中。从此，Bird也具有了Animal中的Name、Age和Gender属性了。

```go
func NewBird(name string, age int, gender string, wingColor string) *Bird {
   return &Bird{
      WingColor: wingColor,
      CommonAnimal: Animal{
         Name:   name,
         Age:    age,
         Gender: gender,
      },
   }
}
```

接着，鸟还有“飞行”的动作。使用上一讲中“方法”的知识，创建Bird类型的“飞行”方法：

```go
func (b *Bird) Fly() {
   fmt.Println("我起飞啦！")
}
```

关于“鸟”的结构体定义、构造函数和方法的实现到此先告一段落。我们回到main()函数中使用它们。

在main()函数中，首先声明一个变量，名为bird，使用NewBird()构造函数为其赋值，然后再调用Fly()方法，让小鸟执行飞行动作。完整的代码如下：

```go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

type Bird struct {
   WingColor    string
   CommonAnimal Animal
}

func NewBird(name string, age int, gender string, wingColor string) *Bird {
   return &Bird{
      WingColor: wingColor,
      CommonAnimal: Animal{
         Name:   name,
         Age:    age,
         Gender: gender,
      },
   }
}

func (b *Bird) Fly() {
   fmt.Println("我起飞啦！")
}

func main() {
   bird := *NewBird("小鸟", 1, "公", "绿色")
   fmt.Println(bird)
   bird.Fly()
}
```

从输出的格式上，我们也可看出，Animal类型确实被Bird类型嵌入其中。那么，问题也随之而来：若想访问Bird中的Animal中的Name属性值，该怎么做呢？

思路其实非常简单，也是层层嵌套地访问就可以了。就拿本例来说，bird.CommonAnimal访问到的是CommonAnimal属性，它是Animal类型；bird.CommonAnimal.Name，访问到的就是CommonAnimal中的Name属性了。

类似地，我们继续定义子结构体狗（Dog），它拥有毛色（Color）属性。还有犬吠（Bark）动作。请读者参考上面小鸟（Bird）部分的代码，独立完成狗（Dog）部分的代码，要求依然使用构造函数（NewDog()）和方法（Bark()）。

完整的代码如下：

```go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

type Dog struct {
   Color        string
   CommonAnimal Animal
}

func NewDog(name string, age int, gender string, color string) *Dog {
   return &Dog{
      Color: color,
      CommonAnimal: Animal{
         Name:   name,
         Age:    age,
         Gender: gender,
      },
   }
}

func (d *Dog) Bark() {
   fmt.Println("汪汪汪！")
}

func main() {
   dog := *NewDog("小狗", 2, "公", "黄色")
   fmt.Println(dog)
   dog.Bark()
}
```

有了Bird，Dog的实现应该不会有问题吧？

在继续之前，我有个问题要考考大家：dog变量是Dog类型，bird变量是Bird类型。那么，dog可以执行Fly()方法吗？反过来，bird可以执行Bark()方法吗？为什么？

答案是：统统**不能**。

因为Fly()方法的接收者是\*Bird，Bark()方法的接收者是\*Dog。**动作的接收者不同，意味着发生或执行动作的对象不同，因此不能混用。**（想想现实世界中，有谁见过小鸟犬吠，小狗起飞吗？）

但是，有一些动作确实是小狗和小鸟同时具备的，比如：吃饭（Eat）。几乎没有哪种动物（Animal）能够不吃饭而存活吧？

那么，若要实现吃饭这个动作，继续为Bird和Dog分别创建方法当然是可行的。但又没有更好的实现方式呢？

当然有！Bird和Dog都是由Animal派生而来，而吃饭（Eat）又是Animal所具有的公共动作。因此，我们便可为Animal创建一个方法，接收者是\*Animal类型即可。这样一来，**因为Bird和Dog都嵌入了Animal类型数据，自然也就可以执行Animal的动作了**。

下面，创建一个接收者是\*Animal类型的方法，名为Eat()。为了体现动作的作用对象，我们在Eat()方法中，将Name属性值一并输出到控制台中。具体代码如下：

```go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

func (a *Animal) Eat() {
   fmt.Println(a.Name, "我要吃到饱！")
}
```

下面，回到main()函数中，使用bird和dog变量逐层调用Eat()方法。具体代码如下：

```go
func main() {
   bird := *NewBird("小鸟", 1, "公", "绿色")
   bird.CommonAnimal.Eat()
   dog := *NewDog("小狗", 2, "公", "黄色")
   dog.CommonAnimal.Eat()
}
```

运行程序，控制台将输出：

> 小鸟 我要吃到饱！
>
> 小狗 我要吃到饱！

通过上面的输出结果可以看出：虽然它们调用的是公共方法，但由于执行该动作的变量不同，最终的输出结果也会随之变化。这便是我们想要的效果。

### 匿名结构体嵌套

Go语言语法还允许开发者以一种更为简单的方式嵌套结构体使用，这种更简单的方式便是嵌套匿名结构体。在后期使用时，也会被简化。以Bird类型结构体为例，下面的写法是完全合法的：

```go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

func (a *Animal) Eat() {
   fmt.Println(a.Name, "我要吃到饱！")
}

type Bird struct {
   string
   Animal
}

func NewBird(name string, age int, gender string, wingColor string) *Bird {
   return &Bird{
      wingColor,
      Animal{
         name,
         age,
         gender,
      },
   }
}

func (b *Bird) Fly() {
   fmt.Println("我起飞啦！")
}

func main() {
   bird := *NewBird("小鸟", 1, "公", "绿色")
   //访问string类型成员
   fmt.Println(bird.string)
   //访问Name成员
   fmt.Println(bird.Name)
   bird.Eat()
```

上述代码运行后，控制台将输出：

> 绿色
>
> 小鸟             
>
> 小鸟 我要吃到饱！

请大家将这种简化写法与普通的写法对比，重点关注Bird结构体的定义方式、NewBird()构造函数的实现方式以及main()函数中，bird变量的字段取值和方法调用方式。
