---
title: 零基础通关
tags:
  - Go
categories:
  - Go
date: '2025-01-03'
description: 欢迎使用 Curve 主题，这是你的第一篇文章
articleGPT: 这是一篇初始化文章，旨在告诉用户一些使用说明和须知。
#cover: "/images/logo/logo.webp"
---

# 零基础通关

## 知识大纲

![小册知识点结构.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/4a076b7d583e435c83acd7515d741928~tplv-k3u1fbpfcp-watermark.png)

## 环境搭建

> https://golang.google.cn/dl/ 中文镜像

### 第一个Go程序

使用 vi 或启动任何一个纯文本编辑器，输入如下内容：

```go
package main
import "fmt"
func main(){
    fmt.Println("Hello World!")
}
```

将其保存为 hello.go。 接下来，启动终端，导航至 hello.go 所在目录，然后执行以下命令，编译 hello.go 程序：

```bash
go build hello.go
```

稍等片刻，程序编译完成。编译完成后将生成名为 hello 的可执行文件。在终端执行这个文件，可以看到 “Hello World!” 字样的文本输出，如下图所示：

```shell
(base) jiangbolun@jiangbolundeMacBook-Pro-2 main % ./hello 
Hello Word!% 
```

> 注意：
> Go 语言要求包含 `main` 函数的文件必须声明为 `package main`。这是生成可执行文件的关键。

### GOPATH 环境变量

1. `GOPATH`环境变量，是Go语言用来查找项目和第三方库的路径。
2. 刚安装完Go后，`GOPATH`环境变量默认未设置，需手动配置；如果不设置，Go默认在本地的特定目录下查找，如Unix/Linux下的用户主目录下的`go`，Windows下的`documents and settings`下的用户名下的`go`。
3. 建议即便在默认路径下工作，也应设置`GOPATH`环境变量，以便更好地管理项目和第三方库。
4.  `GOPATH`目录下可以存放个人的多个项目和所有拉取的第三方库，尽管也可以为每个项目设置不同的`GOPATH`。
5.  `GOPATH`作为一个环境变量，可以指示多个路径，Go在编译时会遍历这些路径来查找所需的依赖包。

## 源码结构以及命令行工具

### Go程序源码结构

```go
package main
import "fmt"
func main(){
    fmt.Println("Hello World!")
}
```

接下来，我们简单解释代码。

1. 第一行内容为 “package main”，它表示这个源码文件属于 main 包。main 包是每个 Go 应用程序都包含的包，有且只有一个。
2. 从第三行开始到最后，是 main() 函数，这个函数比较特殊，它是 Go 程序的“入口”函数，是程序运行的起点。这个函数必须存在且只能存在一个，且必须声明在 main 包中。任何一个 Go 函数都要求使用成对的大括号将函数体包裹起来。

### Go SDK 命令行工具

#### go build

> go build 命令的作用是编译 Go 源码，并生成可执行的文件。

从原理上说，Go SDK 自 1.9 版本开始就支持并发编译了，能尽可能地发挥电脑的最大性能完成编译，所以 Go 源码的编译速度是非常快的。在编译过程中，除了我们自己写的代码外，如果使用了第三方的包，这些包会被一同编译。当我们执行 go build 命令后，会搜索当前目录下的 go 源码并完成编译。

go build 命令还允许附加参数，方便开发者对编译参数进行配置，具体如下表所示：

| 参数名   | 作用                               |
|-------|----------------------------------|
| -v    | 编译时显示包名                          |
| -p x  | 指定编译时并发的数量（使用x表示），该值默认为CPU的逻辑核心数 |
| -a    | 强制进行重新构建                         |
| -n    | 仅输出编译时执行的所有命令                    |
| -x    | 执行编译并输出编译时执行的所有命令                |
| -race | 开启竞态检测                           |

此外，如果我们希望只编译某个 go 源码文件或包，可在 go build 命令后添加文件或包名。例如，现有 file1.go、file2.go 和file3.go，我们只希望编译 file1.go，便可如下执行：

```bash
go build file1.go
```

#### go clean

go clean 命令可以清理当前目录内的所有编译生成的文件，具体包括：

-   当前目录下生成的与包名或者 Go 源码文件同名的可执行文件，以及当前目录中 _obj 和 _test 目录中名为 _testmain.go、test.out、build.out、a.out 以及后缀为 .5、.6、.8、.a、.o和 .so 的文件，这些文件通常是执行go build命令后生成的；
-   当前目录下生成的包名加 “.test” 后缀为名的文件，这些文件通常是执行 go test 命令后生成的；
-   工作区中 pkg 和 bin 目录的相应归档文件和可执行文件，这些文件通常是执行 go install 命令后生成的。

go clean 命令还允许附加参数，具体参数和作用如下表所示：

| 参数名        | 作用                                        |
|------------|-------------------------------------------|
| -i         | 清除关联的安装的包和可运行文件，这些文件通常是执行go install命令后生成的 |
| -n         | 仅输出清理时执行的所有命令                             |
| -r         | 递归清除在 import 中引入的包                        |
| -x         | 执行清理并输出清理时执行的所有命令                         |
| -cache     | 清理缓存，这些缓存文件通常是执行go build命令后生成的            |
| -testcache | 清理测试结果                                    |

在团队式开发中，通常在每次提交代码前执行 go clean 命令，防止提交编译时生成的文件。

#### go run

go run 命令的作用是直接运行 go 源码，不在当前目录下生成任何可执行的文件。

从原理上讲，go run 只是将编译后生成的可执行文件放到临时目录中执行，工作目录仍然为当前目录。同时，go run 命令允许添加参数，这些参数将作为 go 程序的可接受参数使用。

由此可见，go run 命令同样会执行编译操作。但要注意的是，go run 不适用于包的执行。

#### gofmt

gofmt 命令的作用是将代码按照Go语言官方提供的代码风格进行格式化操作。

请大家注意，**gofmt和go fmt是两个不同的命令**。go fmt 命令是 gofmt 的封装，go fmt 支持两个参数：-n 和 -x，分别表示仅输出格式化时执行的命令，以及执行格式化并输出格式化时执行的命令。

执行 gofmt 命令时，可指定文件或目录，也可不指定。当不指定时，gofmt 命令会搜索当前目录中的 go 源码文件，并执行相应的格式化操作。

gofmt 命令还允许附加参数，具体参数和作用如下表所示：

| 参数名                  | 作用                                                 |
|----------------------|----------------------------------------------------|
| -l                   | 仅输出需要进行代码格式化的源码文件的绝对路径                             |
| -w                   | 进行代码格式化，并用改写后的源码覆盖原有源码                             |
| -r rule              | 添加自定义的代码格式化规则（使用rule表示），格式为：pattern -> replacement |
| -s                   | 开启源码简化                                             |
| -d                   | 对比输出代码格式化前后的不同，依赖diff命令                            |
| -e                   | 输出所有的语法错误，默认只会打印每行第1个错误，且最多打印10个错误                 |
| -comments            | 是否保留代码注释，默认值为true                                  |
| -tabwidth x          | 用于指定代码缩进的空格数量（使用x表示），默认值为8，该参数仅在-tabs参数为false时生效   |
| -tabs                | 用于指定代码缩进是否使用tab（“\t”），默认值为true                     |
| -cpuprofile filename | 是否开启CPU用量分析，需要给定记录文件（使用filename表示），分析结果将保存在这个文件中   |

`💡 提示：使用-s参数进行源码简化的规则请参考：https://pkg.go.dev/cmd/gofmt#hdr-The_simplify_command`

#### go install

go install 命令的作用和 go build 类似，都是将源码编译为可执行的文件，附加参数也基本通用，这里就不再赘述了。区别在于：

-   go install 命令在编译源码后，会将可执行文件或库文件安装到约定的目录下；
-   go install 命令生成的可执行文件使用包名来命名；
-   默认情况下，go install 命令会将可执行文件安装到 GOPATH\bin 目录下，依赖的三方包会被安装到 GOPATH\bin 目录下。

#### go get

go get 命令的作用是获取源码包，这一操作包含两个步骤，分别是下载源码和执行 go install 命令进行安装。使用时，仅需将源码仓库地址追加到 go get 后即可（访问<https://pkg.go.dev/>，搜索包名，在包详情页可以找到仓库地址），例如：

```bash
go get github.com/ethereum/go-ethereum
```



go get 命令还允许附加参数，具体参数和作用如下表所示：

| 参数名       | 作用                        |
|-----------|---------------------------|
| -d        | 仅下载源码包，不安装                |
| -f        | 在执行-u参数操作时，不验证导入的每个包的获取状态 |
| -fix      | 在下载源码包后先执行fix操作           |
| -t        | 获取运行测试所需要的包               |
| -u        | 更新源码包到最新版本                |
| -u=patch  | 只小版本地更新源码包，如从1.1.0到1.1.16 |
| -v        | 执行获取并显示实时日志               |
| -insecure | 允许通过未加密的HTTP方式获取          |

若要指定所获取源码包的版本，可以通过添加 “@版本号” 的方式执行。如：

```bash
go get github.com/ethereum/go-ethereum@v1.10.1
```

在使用 Go SDK 1.17 版本时，有一点需要额外注意：执行 go get 命令可能会收到警告，大意是 go get 命令是不建议使用的。此时，使用go install替换 go get 即可，原因是在未来的 Go SDK 版本中 go get 的作用等同于 go get -d。

如果你对 “go get” 命令感兴趣，可以阅读官方对它的说明，写的非常详细：<https://docs.studygolang.com/doc/go-get-install-deprecation>

### debug

goland	debug 时会失效：

> undefined behavior - version of Delve is too old for Go version 1.23.5 (maximum supported version 1.20) 15

因依赖问题要求GO版本需要从1.18.x版本升级到1.23.x，升级后，Test 启动 debug时，发现打断点的红点一闪而过，出现一个失效的标志（一个灰色圆圈+斜杠），在经过百度大法后，原来高版本（1.20及以上版本）会出现debug断点无效的现象。

经过资料查阅，发现是因为go高版本问题，导致dlv插件失效，[github](https://so.csdn.net/so/search?q=github&spm=1001.2101.3001.7020)上提供了源代码，可以clone下来打包，并把dlv文件放到指定的目录。

1. Git clone

   ```shell
   git clone https://github.com/go-delve/delve.git
   ```

2. #### 编译并打包成dlv可执行文件

   ```
   cd cmd/dlv
   
   go build
   ```

   执行完毕后，当前目录下多出一个dlv可执行文件 

3. #### 复制dlv文件到goland插件目录

   - goland 新版本（大于等于23年版本）

     ```
     cp dlv /Applications/GoLand.app/Contents/plugins/go-plugin/lib/dlv/mac
     ```

     

   - goland老版本（小于23年版本）

     ```
     cp dlv /Applications/GoLand.app/Contents/plugins/go/lib/dlv/mac
     ```

## 基础语法

### 命名规范

- 对于变量，除了首个单词外，每个单词的首字母用大写表示，这种命名法通常被称为小驼峰式命名法；若所有单词的首字母均大写，则成为大驼峰式命名法（又被称为帕斯卡命名法）。由于变量有可见性（有关可见性的更多内容，将在结构体/包中介绍。）之分，对于对外可见的变量，使用大驼峰法；对于对外不可见的变量，使用小驼峰法。特别地，若变量/常量是布尔类型，最好以is、allow、has、can之类来开头；
- 对于常量，单词均用大写字母来表示，每个字母之间使用下划线来分割。

```go
// 变量声明
var exampleNumberA int = 10
var isDarkMode bool = false
// 常量声明
const WIDTH_OF_RECT int = 12
const ALLOW_DOWNLOAD_WHEN_WIFI bool = true
```

### 声明与赋值

**在Go语言中，变量或常量的数据类型必须先声明，才能使用**，且无法将不相关的数据赋值给它们。

这是因为Go语言和Java、C、C++等语言一样，属于静态语言，静态语言具有更严谨的结构要求、调试便捷（可通过代码直观地看到数据类型）与确保类型安全（无法使用不同类型的数据赋值）的特点，必须要先做声明。而像PHP、Python、JavaScript等动态语言则没有这个限制。

#### 变量的声明与赋值

在Go语言中，声明变量的一般格式为：

```Go
var name type
```

- 其中，var是声明变量的关键字，固定不变，表明意图——要声明一个变量
- type表示该变量所属的数据类型。

```Go
// 声明一个名为number的变量，类型为int（整数类型）
var number int
// 为number赋值
number = 100

// 变量声明
var number int = 100
```

#### 常量的声明与赋值

常量声明和赋值的一般格式为：

```Go
const name type = value
```

其中，const是声明常量的关键字，固定不变，表明意图，要声明一个常量；name和type的意义与声明变量时一样；value是常量的值。如：

```Go
// 声明一个名为PI的常量，类型为float64（浮点数类型）
const PI float64 = 3.14
```

> `❗️ 注意： 声明常量时，必须为其赋值，且后续无法修改。`

#### Go语言的类型推断

使用Go语言可简化代码，类型推断体现了这一点。当声明与赋值一并进行时，如果数据为Go内置的基础类型，则可无需指定类型。如：

```Go
// 变量声明
var number = 100
// 常量声明
const PI = 3.14
```

无需担心，由于number的值为100，Go语言会推断出它的类型为整数型。同理，PI也会被推断为浮点数型。

对于变量，还有一种超级精简的声明和赋值方式，示例如下：

```Go
//变量声明
number := 100
```

`❗️ 注意： 冒号等于号“:=”的作用是声明和赋值，若number是已经声明过的变量，则无法使用 := 的方式赋值。`

#### 批量声明/赋值

为了方便多个变量/常量的声明和赋值，我们还可以批量处理它们，示例如下：

```Go
//变量
var (
        // 声明 + 赋值
        number int = 100
        // 声明 + 赋值（类型推断）
        text = "Hello"
        // 只声明
        name string
)
//常量
const (
        // PI 声明 + 赋值
        PI float64 = 3.14
        // WIDTH 声明 + 赋值（类型推断）
        WIDTH  = 5
        // HEIGHT 声明 + 赋值（类型推断）
        HEIGHT = 10
)
```

### 指针类型

> 在上一讲中，我们介绍了Go语言的基本数据类型，学会了如何对变量进行声明和赋值，也知道了在这个过程中会在内存开辟空间方便它们“安家”。那如何才能找到这个“家”呢？这就涉及到了指针。
>
> 通过使用指针，开发者可以直接访问内存中的数据，从而可以实现对数据的精准管理以及运算。
>
> 如果说变量名是数据的“代号”，那么指针存放的则是数据的“**实际地址**”，我们可以通过这个地址获取或修改存放于这个地址的变量的值。
>
> 存放整数值的变量称为整型变量，存放布尔值的变量称为布尔变量……类似地，存放指针值的变量称为指针变量。
>
> 那么问题来了，想要获取或改变某个变量的值，直接通过变量名就可以实现了。而且像Java之类的编程语言几乎不会用到指针，**那Go为何还要用指针呢？**
>
> `❗️ 注意： 实际上，Java中的指针操作封装在JDK中，普通开发者一般不会接触到，所以会误认为Java没有指针。`

我们不妨先了解一下Go语言中的指针，它主要由两大核心概念构成：**类型指针**和**切片指针**。

- 类型指针：在**传递数据**时直接使用指针，可以避免创建数据的副本，节约内存开销。类型指针不能进行偏移和运算，可以**避免非法修改**为其它数据的风险，也更**有利于垃圾回收**机制及时找到并回收它们；

- 切片指针：切片由**指向起始元素的指针**、元素数量和总容量构成。当访问切片发生越界时，会发生宕机并输出堆栈信息。宕机是**可以恢复**的，而崩溃只能导致程序停止运行。

可见，**使用指针更有利于程序运行的性能和稳定性**。另外，在某些操作中，如使用反射修改变量的值，必须使用可寻址的变量（通过指针）。

在实际应用中，最为常用的便是获取变量的内存地址，以及获取某个地址对应的值。在Go语言中，前者使用“&”运算符，后者使用“*”运算符。它们互为反向操作，操作的对象也不同。具体请看下面的示例：

```Go
// exampleNumberA变量（整数型变量）声明和赋值
var exampleNumberA int = 10
// 获取exampleNumberA的地址，并赋值给exampleNumberAPtr变量（exampleNumberAPtr的类型是指针类型）
exampleNumberAPtr := &exampleNumberA
//输 出exampleNumberAPtr变量的值（将输出内存地址）
fmt.Println(exampleNumberAPtr)
// 获取exampleNumberAPtr（指针变量）表示的实际数据值，并赋值给exampleNumberAPtrValue变量（整数型变量）
exampleNumberAPtrValue := *exampleNumberAPtr
// 输出exampleNumberAPtrValue变量（整数型变量）的值
fmt.Println(exampleNumberAPtrValue)
```

运行后，控制台输出：

> 0xc00001a088 
> 10

上面的代码示例演示了如何使用已有的变量创建指针类型变量。我们还可以使用new()函数直接创建指针变量，相当于在内存中创建了**没有变量名**的**某种类型**的**变量**。

这样做无需产生新的数据“代号”，取值和赋值转而通过指针变量完成。常用在无需变量名或必须要传递指针变量值的场景中。

new()函数的使用格式如下：

```Go
new(type)
```

其中，type是所在地址存放的数据类型。一旦完成创建，便会在内存中“安家”，完成内存分配，即使没有赋值。

具体代码示例如下：

```Go
// 使用new()函数创建名为exampleNumberAPtr指针类型变量，表示int64型值
exampleNumberAPtr := new(int64)
// 修改exampleNumberAPtr表示的实际数据值
*exampleNumberAPtr = 100
// 获取exampleNumberAPtr表示的实际数据值
fmt.Println(*exampleNumberAPtr)
```

程序运行后，控制台将输出：

> 100

## 流程控制

### if 语句

条件语句的格式如下：

```go
if condition {
    
}
```

另外：if 语句后面可以跟多个语句条件，允许先赋值再判断，其作用域仅限于当前F语句块内，一旦离开该块，所定义的变量将不再有效。

```go
if contents, err := ioutil.ReadFile(`test.txt`); err == nil {
		fmt.Println(string(contents))
	} else {
		fmt.Println("cannot print file contents:", err)
	}
```

### switch 语句

>  switch语句默认在每个case之后包含break，无需显式添加，这与C语言或Java等语言不同，减少了编程负担，更显人性化。
>
>  如果在switch语句中不希望执行break，反而需要使用特定结构如for through来实现，这与常规的编程习惯相反，提供了一种灵活的控制流程方式。

```go
func un_grade(grade string) string {
	switch grade {
	case "F":
		return "< 60"
	case "C":
		return "< 80"
	case "B":
		return "< 90"
	default:
		return "<= 100"
	}
}
```

另外switch也可以不写任何参数：
```go
func grade(score int) string {
	switch {
	case score < 60:
		return "F"
	case score < 80:
		return "C"
	case score < 90:
		return "B"
	default:
		return "A"
	}
}
```

### for 循环语句

循环结构的格式如下：

```go
for init; condition; post {
    //循环体代码块
}
```

其中，for表明接下来的代码是for循环结构；init是初始化语句；condition是关系或逻辑表达式，值为true时则会停止循环；post是每次循环结束后执行的语句。

```go
sum := 0
for i:= 1; i <= 100; i++ {
  sum += i
}
```

>  注意：go 语言没有while关键字，其功能被 for 循环所涵盖，因此去掉了while。

```go
for {
  fmt.Println("abc")
}
```

## 数组、切片和集合

### 数组

Go语言中声明数组的一般格式为：

```go
var array_name [quantity]Type
```

其中，var关键字用于声明变量；array_name表示数组名；quantity表示数组元素个数；Type表示元素类型。例如：

```go
var resultArray [4]int
```

声明后即可为单个元素赋值了。和其它的编程语言类似，要为数组中的某个元素赋值，格式为：

```go
array_name[index] = Value
```

例如：

```go
resultArray[2] = 5
```

### 切片

使用数组来存放一些结果，很容易引发下标越界错误。和数组相对，Go语言还提供了一种专门存放**不定元素个数**的数据结构——切片。

在Go语言中，切片的声明一般格式为：

```go
var slice_name []Type
```

其中，var关键字用于声明变量；slice_name表示切片名；Type表示元素类型。

> `💡 提示： 注意到了吗？声明切片和数组的区别仅仅是去掉了中括号中的元素个数！`

例如：

```go
var resultSlice []int
```

> `❗️ 注意： 和数组类似，切片中的元素也不限制值的类型，但要求所有元素均为相同的类型。`

完成切片的声明后，就来到赋值环节。

与数组不同，为切片赋值可以理解为“**扩充**”。在一开始，切片里面的元素个数为0。“扩充”一个值，就相当于为切片中的第一个元素赋值。赋值后，切片的元素个数就变成了1。若再次“扩充”，则相当于为切片中的第二个元素赋值。赋值后，切片的元素个数就变成了2，以此类推……

在Go语言中，为切片“扩充”需要使用append()函数，使用格式如下：

```go
slice_name = append(slice_name, value)
```

其中，slice_name表示已声明的切片变量名，value表示具体的数据值。

值得一提的是，**append()函数本身并不会改变原有切片**，只是将切片“扩容”后的结果作为函数返回值。因此，需要将“扩容”后的结果再次（即函数返回值）赋值给slice_name，才能真正使slice_name发生改变。

例如：

```go
resultSlice = append(resultSlice, value)
```

在实际项目中，切片的使用其实更为广泛。例如：当用户发起搜索，搜索的结果个数往往会根据搜索关键字的不同而发生变化。在不确定总数的前提下，使用数组显然是不合适的。

### Map

使用数组不合适，那使用什么呢？答案是：集合。我们考虑另一个场景——管理学生信息。

如何保存和查找一所学校所有学生的信息呢？通过姓名显然是不合适的，因为会有重名的情况。通过年级+姓名呢？显然也是不合适的，因为这可能会执行两次筛选，而且也无法从根本上排除重名的情况。所以，我们应使用一个能标识一个学生**唯一性**的数据作为保存和查找的依据。比如：学号。

一个学号对应一个学生，保存时如此，查找时亦如此。

> `💡 提示： 与此类似的管理方式还有身份证号、驾驶证号、商品ID、图书ISBN等等。这些能标识唯一性的值可以统称为“唯一ID”。在实际项目中，为了保证单条数据的唯一性，为其构建唯一ID号是非常有必要的。`

像上述这种唯一ID对应单条数据，可以使用集合来管理。集合可以看作是一类特殊的切片，只不过集合的元素都是由若干“**键-值对**”数据构成的。所谓“键”，相当于“唯一ID”；“值”，相当于单条数据，**键不允许重复**。

Go语言中声明集合的一般格式为：

```go
var map_name = make(map[key_type]value_type)
```

`❗️ 注意： 和数组、切片类似，集合中的键和值均不限制数据类型，且键和值可分别使用不同的类型。但要求所有键均为相同的类型，所有值均为相同类型。`

其中，var用于声明变量；map_name表示集合的变量名；key_type表示键的类型；value_type表示值的类型。

对于本例而言，学号和学生信息都使用string类型来表示，集合的变量名为studentInfos。对应的代码为：

```go
var studentInfos = make(map[string]string)
```

集合中元素的赋值和数组类似，只不过中括号中不再是索引，而是键的值。例如，保存学号为“0001”的学生，名为“王小红”，代码实现为：

```go
studentInfos["0001"] = "王小红"
```

以此类推，继续增加4条信息，完整的代码如下：

```go
func main() {
   var studentInfos = make(map[string]string)
   studentInfos["0001"] = "王小红"
   studentInfos["0002"] = "李小明"
   studentInfos["0003"] = "张三丰"
   studentInfos["0004"] = "孙小贝"
   studentInfos["0005"] = "何明明"
   // 输出语句
   fmt.Println(studentInfos)
}
```

程序运行结果为：

> map[0001:王小红 0002:李小明 0003:张三丰 0004:孙小贝 0005:何明明]

值得一提的是，若对一个已经存在数据的“键”再次赋值，原有的数据将被**覆盖**。比如，在本例输出语句前添加：

```go
studentInfos["0003"] = "周丹"
```

再次运行本例，结果则变为：

> map[0001:王小红 0002:李小明 0003:周丹 0004:孙小贝 0005:何明明]

在实际项目中，充分利用集合键唯一的性质，还可以确保**排除重复**的数据。

### 循环遍历

除了for循环外，Go语言还提供了range关键字。与for结合，也可以实现循环遍历，其使用格式如下：

```go
for index, value := range variable {
    // 循环体
}
```

其中，index表示索引或键的值；value表示元素的值；variable表示数组、切片或集合变量；由大括号包裹的部分是循环体，可以使用index和value变量。

for 循环对比 for-range：

- 使用`for`循环：

```
slice := []int{1, 2, 3, 4, 5}
for i := 0; i < len(slice); i++ {
    fmt.Println(slice[i])
}
```

- 使用`range`：

```
slice := []int{1, 2, 3, 4, 5}
for i, v := range slice {
    fmt.Println(i, v)
}
```

`range`自动处理了索引`i`和值`v`的赋值，并且代码更加简洁。

这种for与range结合实现循环遍历的结构，也被称为**for-range结构**。这种结构同样适用于数组和切片。

## 函数

### 普通函数的定义和调用

在Go语言中，定义一个普通函数的格式如下：

```go
func function_name([params_list])([return_values_list]){
    // 函数体
}
```

其中，func关键字表示定义一个函数；function_name是函数名；params_list表示参数列表；return_values_list表示函数的返回值列表；使用大括号包裹起来的部分称为函数体，是函数内部要执行的代码。其中，参数列表和返回值列表是可选的。有些函数无需参数，有些参数运行后并不会有任何返回值，有些函数则无需参数也无需返回值。

先举个简单的例子，下面的函数实现了将参数（即传入的string类型字符串）作为返回值（类型也为string）输出。

```go
func stringLoop(content string) string {
   return content
}
```

下面，尝试调用这个函数，整个函数定义与调用的示例如下：

```go
func main() {
   result := stringLoop("字符串回环测试")
   fmt.Println(result)
}

// 用于测试的自定义函数
func stringLoop(content string) string {
   return content
}
```

### **值传递**和**引用传递**

先猜猜它的运行结果：

```go
func main() {
   var resultSlice []int
   findPrimeNumber(resultSlice, 10)
   fmt.Println(resultSlice)
}

func findPrimeNumber(result []int, max int) {
   for i := 2; i < max; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到result数组中
         result = append(result, i)
      }
   }
}
```

答案揭晓：这段程序的运行结果为：

> []

相信不少人看到这里会一脸懵。为什么我把main()函数中的resultSlice传入findPrimeNumber()了，并且在findPrimeNumber()中对其做了修改，却并没有使resultSlice发生变化呢？

要解开这个谜团，我们不妨输出 main()函数中resultSlice和findPrimeNumber()中，result的内存地址。因为只有这二者的地址相同，才能证明这两个变量是“一回事”。

输出内存地址的代码示例如下：

```go
ptr := &variable
fmt.Println(&ptr)
```

其中，variable表示变量名，对应本例为main()中的resultSlice和findPrimeNumber()中的result。

这一对比的结果是显而易见的，main()中的resultSlice和findPrimeNumber()中的result，二者内存地址是不同的！这也就意味着，无论result变量在findPrimeNumber()中作出如何改变，都无法作用到main()中的resultSlice变量上。问题也就跟着来了：在函数间传值的过程中，到底发生了什么呢？

实际上，这里涉及到两个容易混淆的传递概念——**值传递**和**引用传递**。

像上述示例当中的做法，即直接传递一个变量名到另一个函数中，属于**值传递**。按照Go代码的执行策略，发生值传递时，将在另一个函数中自动生成一个值的副本。所以我们才会看到main()中的resultSlice和findPrimeNumber()中的result的内存地址是不同的，因为后者完全是前者的“替身”，我们在findPrimeNumber()函数中只是对替身做了改变，“真身”根本就没有收到影响！

与值传递相对的便是**引用传递**，这种方式在函数间传递的是指针，而指针恰恰是内存地址。这样的传值，无论发生在多少个函数之间，改变将始终作用于相同地址的数据上。

了解过值传递和引用传递后，便很清楚如何修改我们的代码了——只需将原有的值传递改为引用传递，即向findPrimeNumber()函数传递resultSlice的内存地址就行了。当然，还要适当修改findPrimeNumber()函数的定义和逻辑。修改后的完整代码如下：

```go
func main() {
   var resultSlice []int
   findPrimeNumber(&resultSlice, 10)
   fmt.Println(resultSlice)
}

func findPrimeNumber(result *[]int, max int) {
   for i := 2; i < max; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到result数组中
         *result = append(*result, i)
      }
   }
}
```

再次运行程序，将输出：

> [2 3 5 7]

除了将值传递改为引用传递外，还有一种“**偷懒式**”修改方法也可使程序正常输出——直接把resultSlice变量声明在函数外，改为**全局变量**，即可在所有函数中访问和修改这个变量了。

之所以称这种方法是“偷懒式”，是因为所有函数都能修改这个全局变量，数据存在一定的安全风险。若不慎错误地修改了变量的值，修复起来也会相对更困难一些了。

### 函数的延迟调用

接下来，我们保持findPrimeNumber()函数不变，在main()函数伊始添加两行神奇的代码：

```go
func main() {
   defer fmt.Print("素数")
   defer fmt.Print("查找")
   var resultSlice []int
   findPrimeNumber(&resultSlice, 10)
   fmt.Println(resultSlice)
}
```

很明显，main()函数开头的两行代码和普通的代码不同，前面有个“defer”。**“defer”的作用是让整句代码延迟执行，且多个defer存在时，它们的顺序是反向的。**

根据这一规律，我们便可推测上述代码运行的结果将是：

>[2 3 5 7]   
>查找素数

defer的典型应用场景是执行一些**收尾工作**，通常是在常规逻辑执行结束后释放系统资源。如文件读写、网络IO等等。也用于程序在**发生宕机时的恢复**。

### 匿名函数的定义和调用

> 回调保证了程序运行的正确性和及时性。**匿名函数则是实现回调的核心技能**。

在Go语言中，匿名函数的定义格式如下：

```go
func ([params_list])([return_values_list]){
    // 函数体
}
```

其中，params_list表示参数列表；return_values_list表示函数的返回值列表；使用大括号包裹起来的部分称为函数体，是匿名函数内部要执行的代码。其中，参数列表和返回值列表是可选的。有些函数无需参数，有些参数运行后并不会有任何返回值，有些函数则无需参数也无需返回值。

> `❗️ 注意： 请大家注意普通函数与匿名函数在定义时的区别，普通函数在定义时仅比匿名函数多了函数名。`

定义了函数后，接下来便是如何调用它。根据使用时机的不同，Go语言提供了两种调用匿名函数的方式：一是在定义时调用；二是将匿名函数赋值给变量，通过变量调用。

举例来说，下面的代码定义了一个匿名函数，实际作用便是在控制台输出传入的参数，类型是string：

```go
func main() {
   // 定义匿名函数
   func(text string) {
      fmt.Println(text)
   }
}
```

> `💡 提示：注意到了吗？和普通函数不同，匿名函数可以在某个普通函数内定义和使用。`

如果要在该函数定义时便调用它，只需在大括号结束后，使用小括号将要传入的参数值包裹起来即可，比如：

```go
func main() {
   // 定义匿名函数
   func(text string) {
      fmt.Println(text)
   }("定义时就调用")
}
```

这段代码中，“定义时就调用”便是要传入的参数了。运行这段代码，控制台将输出这些文字。

另一种调用匿名函数的方法是将匿名函数赋值给某个变量，然后通过变量调用。这听起来很神奇，写起来其实非常简单：

```go
func main() {
   // 定义匿名函数
   exampleVal := func(text string) {
      fmt.Println(text)
   }
   exampleVal("通过变量调用匿名函数")
}
```

如上代码所示，声明了变量exampleVal，并将匿名函数赋值给了它。在后续的代码中，即可随时使用exampleVal变量调用匿名函数了。

## 结构体

### 定义

在Go语言中，定义结构体的标准格式为：

```go
type StructName struct {
   // 属性字段
}
```

其中，开头的type表示要定义自定义的类型；StructName代表结构体的名称；struct表示结构体类型；由大括号包裹的部分是属性列表，由一个或若干个字段构成。字段的名称不允许重复。

举例：

```go
type treeNode struct {
	value       int
	left, right *treeNode
}
```

### 使用

#### 声明与初始化

```go
type treeNode struct {
	value       int
	left, right *treeNode
}

func main() {
	var root treeNode

	root = treeNode{value: 3} // 直接指定 value

	root.left = &treeNode{} // 因为left是指针，所以要用 `&` 取地址

	root.right = &treeNode{5, nil, nil} // 也可以按照顺序指定值

	root.right.left = new(treeNode) // 套用 内建函数 new
	
	// 也可以直接用 slides 方式 创建
	nodes := []treeNode{
		{value: 3},
		{},
		{6, nil, &root},
	}
	fmt.Println(nodes)
}
```

> 不论地址还是结构体本身，一律使用. 来访问成员

#### 访问和修改属性值

在Go语言中，改变或完善（针对初始化时未赋值的情况）结构体内属性值的方法是非常简单的，其格式为：

```go
变量名.属性名=值
```

举例来说：

```go
root.value = 4
```

### 匿名结构体

在实际开发中，还有一类情况，就是某个结构体的作用域很小，甚至只存在于某个函数内部，或是无需创建太多的该结构体变量等等。对于上述情况，Go语言允许我们使用匿名结构体简化编码，即使用匿名结构体。

> `💡 提示：这是本讲第二次介绍简化编码的方式了，这便是Go语言中结构体使用简便特性的体现。大家还记得上一个简化编码是用来做什么吗？答案是——初始化结构体变量`

举例来说，还是游戏中的场景。某天，温玉琳琅来到许愿树下进行许愿，这一天是她的生日，许愿树这个植物仅在生日场景中出现。因此为了简化编码，考虑使用匿名结构体来定义和使用它。

使用匿名结构体的方法并不难，实际上就是省略了单独的结构体定义。而是将定义和相关变量的声明、属性赋值合三为一处理。如果我们要声明一个变量来表示许愿树，示例代码如下所示：

```go
wishingTree := struct {
   height   float64
   width    float64
   treeType string
}{
   height:   22.5 * 100,
   width:    50,
   treeType: "banyan"}
fmt.Println(wishingTree)
```

仔细阅读上述代码，wishingTree便是表示许愿树变量了，它是结构体（struct）类型。结构体内包含3个属性，分别是浮点型的高度（height）、浮点型的胸径（width）以及字符串型的树品种。这3个属性由一个大括号包裹起来。紧随其后的大括号是为属性赋值的过程，其规则依然是允许全部赋值，也允许部分赋值。简化的赋值方式同样适用，这里不再赘述。

`❗️ 注意：即使不为任何属性赋值，第二个大括号也是必不可少的，否则将引发编译时错误，程序无法被编译和运行。`

运行上述代码，可见控制台如下输出：

> 2250 50 banyan

### 构造函数

其实就是用工厂函数新建结构体

```go
type treeNode struct {
	value       int
	left, right *treeNode
}

func createTreeNode(value int) *treeNode {
	return &treeNode{value: value} // 返回的是局部变量的地址，但跟C不一样，不会导致程序崩溃
}

func main() {
  root1 := treeNode{value: 3}

	root2 := createTreeNode(4)
}
```

> 1. 在工厂函数中，我们通常返回一个结构的地址，无需特别考虑其在何处分配，只需返回局部变量的地址即可。
> 2. 局部变量的存储位置（栈或堆）由编译器和运行环境决定，这在Go语言中尤其如此，因为Go具有自动垃圾回收机制。
> 3. 如果局部变量被取地址并返回，编译器会认为它需要在堆上分配，以便外部使用，从而参与垃圾回收过程。
> 4. 这种机制简化了程序设计，开发者无需关心对象的具体分配位置，只要确保不再使用时，指针会被正确处理，对象将被自动回收。
> 5. 与C++等需要手动管理内存的语言不同，Go语言的这一特性使得返回局部变量的地址成为可能，同时也简化了内存管理的复杂性。

### 为对象定义方法

在Go语言中，方法和函数的定义格式非常像，大家可不要搞混了。由于方法和对象存在紧密的关系，因此在定义的格式上需要**接收器**，具体格式如下：

```go
func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) {
    函数体
}
```

其中，**接收器变量和接收器类型共同构成了接收器**；参数列表是可选的；返回参数也是可选的；方法名无需多做解释。

```go
type treeNode struct {
	value       int
	left, right *treeNode
}

func (node treeNode) print() {
	fmt.Println(node)
}

func main() {

	root2 := createTreeNode(4)

	root2.print() // root2 对象 就可以 直接使用了
}
```

其实跟正常函数一样：

```go
type treeNode struct {
	value       int
	left, right *treeNode
}

func (node treeNode) print() {
	fmt.Println(node)
}

func print(node treeNode) {
	fmt.Println(node)
}
```

#### 对象定义方法是否使用指针

为对象定义方法时，需要注意接收器的类型。使用指针与否，将决定了是否对原始变量产生影响。本例使用了\*Dog，即指针类型，在方法中对该类型变量（d变量）的任何影响都将影响原始变量（fatShibaInu）；反之，若使用Dog类型，则不会影响。

其原因是当不使用指针类型变量时，方法中的接收器变量实际上是对原始数据的“拷贝”，所做出的改变也仅仅会作用于这份“拷贝”的数据上，并不会影响到原始数据。

对比来说，我们分别定义两个不同的方法——GrowUp()和GrowUp2()，前者使用指针类型接收器，后者不使用。方法体均是对相应变量中的年龄属性自增1，然后在控制台输出运行结果。测试代码关键部分如下：

```go
func (d *Dog) GrowUp() {
   d.Age++
}

func (d Dog) GrowUp2() {
   d.Age++
}

func main() {
   fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")

   fatShibaInu.GrowUp()
   fmt.Println(fatShibaInu)

   fatShibaInu.GrowUp2()
   fmt.Println(fatShibaInu)
}
```

运行结果为：

> Shiba Inu 3 12 0
>
> Shiba Inu 3 12 0

显然，虽然GrowUp2()方法也对d变量中的Age属性做了自增1计算，但并未影响原始数据。

### 结构体的嵌套

> 在Go语言中，没有直接等同于Java中`extends`的关键字，因为Go不支持传统的类继承。Go使用组合（composition）来复用代码，而不是继承。

我们先来实现作为父结构体的动物（Animal），这个结构体具有名字（Name）、年龄（Age）和性别（Gender）属性。

> `💡 提示：请留意这三个属性也是本例中所有子结构体所具有的。`

示例代码如下：

```go
type Animal struct {
   Name   int
   Age    int
   Gender string
}
```

接下来，以子结构体鸟（Bird）为例，它还具有翅膀颜色的属性。因此，Bird的结构体定义示例如下：

```go
type Bird struct {
   WingColor    string
   CommonAnimal Animal
}
```

很明显地，Bird结构体中包含了一个名为CommonAnimal的Animal类型成员，而Animal类型就是我们刚刚定义好的结构体。如此，便完成了结构体的嵌套，即把Animal嵌入Bird中。从此，Bird也具有了Animal中的Name、Age和Gender属性了。

```go
func NewBird(name string, age int, gender string, wingColor string) *Bird {
   return &Bird{
      WingColor: wingColor,
      CommonAnimal: Animal{
         Name:   name,
         Age:    age,
         Gender: gender,
      },
   }
}
```

接着，鸟还有“飞行”的动作。使用上一讲中“方法”的知识，创建Bird类型的“飞行”方法：

```go
func (b *Bird) Fly() {
   fmt.Println("我起飞啦！")
}
```

关于“鸟”的结构体定义、构造函数和方法的实现到此先告一段落。我们回到main()函数中使用它们。

在main()函数中，首先声明一个变量，名为bird，使用NewBird()构造函数为其赋值，然后再调用Fly()方法，让小鸟执行飞行动作。完整的代码如下：

```go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

type Bird struct {
   WingColor    string
   CommonAnimal Animal
}

func NewBird(name string, age int, gender string, wingColor string) *Bird {
   return &Bird{
      WingColor: wingColor,
      CommonAnimal: Animal{
         Name:   name,
         Age:    age,
         Gender: gender,
      },
   }
}

func (b *Bird) Fly() {
   fmt.Println("我起飞啦！")
}

func main() {
   bird := *NewBird("小鸟", 1, "公", "绿色")
   fmt.Println(bird)
   bird.Fly()
}
```

从输出的格式上，我们也可看出，Animal类型确实被Bird类型嵌入其中。那么，问题也随之而来：若想访问Bird中的Animal中的Name属性值，该怎么做呢？

思路其实非常简单，也是层层嵌套地访问就可以了。就拿本例来说，bird.CommonAnimal访问到的是CommonAnimal属性，它是Animal类型；bird.CommonAnimal.Name，访问到的就是CommonAnimal中的Name属性了。

类似地，我们继续定义子结构体狗（Dog），它拥有毛色（Color）属性。还有犬吠（Bark）动作。请读者参考上面小鸟（Bird）部分的代码，独立完成狗（Dog）部分的代码，要求依然使用构造函数（NewDog()）和方法（Bark()）。

完整的代码如下：

```go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

type Dog struct {
   Color        string
   CommonAnimal Animal
}

func NewDog(name string, age int, gender string, color string) *Dog {
   return &Dog{
      Color: color,
      CommonAnimal: Animal{
         Name:   name,
         Age:    age,
         Gender: gender,
      },
   }
}

func (d *Dog) Bark() {
   fmt.Println("汪汪汪！")
}

func main() {
   dog := *NewDog("小狗", 2, "公", "黄色")
   fmt.Println(dog)
   dog.Bark()
}
```

有了Bird，Dog的实现应该不会有问题吧？

在继续之前，我有个问题要考考大家：dog变量是Dog类型，bird变量是Bird类型。那么，dog可以执行Fly()方法吗？反过来，bird可以执行Bark()方法吗？为什么？

答案是：统统**不能**。

因为Fly()方法的接收者是\*Bird，Bark()方法的接收者是\*Dog。**动作的接收者不同，意味着发生或执行动作的对象不同，因此不能混用。**（想想现实世界中，有谁见过小鸟犬吠，小狗起飞吗？）

但是，有一些动作确实是小狗和小鸟同时具备的，比如：吃饭（Eat）。几乎没有哪种动物（Animal）能够不吃饭而存活吧？

那么，若要实现吃饭这个动作，继续为Bird和Dog分别创建方法当然是可行的。但又没有更好的实现方式呢？

当然有！Bird和Dog都是由Animal派生而来，而吃饭（Eat）又是Animal所具有的公共动作。因此，我们便可为Animal创建一个方法，接收者是\*Animal类型即可。这样一来，**因为Bird和Dog都嵌入了Animal类型数据，自然也就可以执行Animal的动作了**。

下面，创建一个接收者是\*Animal类型的方法，名为Eat()。为了体现动作的作用对象，我们在Eat()方法中，将Name属性值一并输出到控制台中。具体代码如下：

```go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

func (a *Animal) Eat() {
   fmt.Println(a.Name, "我要吃到饱！")
}
```

下面，回到main()函数中，使用bird和dog变量逐层调用Eat()方法。具体代码如下：

```go
func main() {
   bird := *NewBird("小鸟", 1, "公", "绿色")
   bird.CommonAnimal.Eat()
   dog := *NewDog("小狗", 2, "公", "黄色")
   dog.CommonAnimal.Eat()
}
```

运行程序，控制台将输出：

> 小鸟 我要吃到饱！
>
> 小狗 我要吃到饱！

通过上面的输出结果可以看出：虽然它们调用的是公共方法，但由于执行该动作的变量不同，最终的输出结果也会随之变化。这便是我们想要的效果。

### 匿名结构体嵌套

Go语言语法还允许开发者以一种更为简单的方式嵌套结构体使用，这种更简单的方式便是嵌套匿名结构体。在后期使用时，也会被简化。以Bird类型结构体为例，下面的写法是完全合法的：

```go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

func (a *Animal) Eat() {
   fmt.Println(a.Name, "我要吃到饱！")
}

type Bird struct {
   string
   Animal
}

func NewBird(name string, age int, gender string, wingColor string) *Bird {
   return &Bird{
      wingColor,
      Animal{
         name,
         age,
         gender,
      },
   }
}

func (b *Bird) Fly() {
   fmt.Println("我起飞啦！")
}

func main() {
   bird := *NewBird("小鸟", 1, "公", "绿色")
   //访问string类型成员
   fmt.Println(bird.string)
   //访问Name成员
   fmt.Println(bird.Name)
   bird.Eat()
```

上述代码运行后，控制台将输出：

> 绿色
>
> 小鸟             
>
> 小鸟 我要吃到饱！

请大家将这种简化写法与普通的写法对比，重点关注Bird结构体的定义方式、NewBird()构造函数的实现方式以及main()函数中，bird变量的字段取值和方法调用方式。

## 接口

### 定义

在Go语言中，定义接口的格式如下：

```go
type interface_name interface {
    function_name( [params] ) [return_values]
    ...
}
```

其中，type关键字表示要自定义类型；interface_name是自定义的接口名；interface表示接口类型；由大括号包裹的部分定义了要被实现方法，一个接口中可以同时存在一个或多个方法。function_name是方法名；params是方法所需的参数；return_values是方法的返回值。params和return_values可以省略，也可以存在一个或多个。

对于本例而言，接口的目的在于规范图片加载的流程。为了讲解方便，我在此将图片加载的过程简化为查找并下载图片一个步骤。

在查找并下载图片时，需要图片下载地址作为依据，并将返回图片的实际数据。因此，我们定义一个名为imageLoader的接口，接口中包含FetchImage()方法，该方法需要string类型的变量作为参数，表示下载地址，返回string类型（在实际开发中通常是byte[]），表示图片数据。

> `💡 提示： 注意到接口的命名（imageLoader）特点了吗？在为接口命名时，一般会在单词后面加上er后缀。接口中的方法名（FetchImage()）首字母大小写决定了该方法的可访问范围。`

具体代码如下：

```go
// ImageDownloader 图片加载接口
type ImageDownloader interface {
	// FetchImage 获取图片，需要传入图片地址，方法返回图片数据
	FetchImage(url string) string
}
```

如此，接口的定义便完成了。

### 接口的实现

在Go语言中，实现接口的格式如下：

```go
func (struct_variable struct_name) function_name([params]) [return_values] {
   // 方法实现 
}
```

其中，struct_name_variable和struct_name一起，表示作用的对象。对于本例而言，则是*fileCache类型的变量。紧接着的function_name是方法名，params指的是方法所需的参数，return_values指的是方法的返回值。其中，params和return_values是可选的，也允许有多个值。

我们先来实现从本地缓存中获取图片数据的部分，代码如下：

```go
type fileCache struct {
}
// FetchImage接口实现
func (f *fileCache) FetchImage(url string) string {
	return "从本地缓存中获取图片：" + url
}
```

对比FetchImage()方法的接口声明：

```go
// FetchImage 获取图片，需要传入图片地址，方法返回图片数据
FetchImage(url string) string
```

发现了吗？在实现方法时，需要满足两个条件：

- 第一是**接口中定义的的方法与实现接口的类型方法格式一致**。这要求不仅方法名称相同，参数和返回值也要相同；

- 第二就是**接口中定义的所有方法全部都要实现**。

如法炮制，继续定义负责从网络下载图片的结构体以及作用于该结构体的接口实现：

```go
// 定义从网络下载图片的结构体
type netFetch struct {
}
// FetchImage接口实现
func (n *netFetch) FetchImage(url string) string {
	return "从网络下载图片：" + url
}
```

到此，接口的定义和实现就都已完成。下一步就是回到main()函数中使用它们了。

### 接口的调用

来到main()函数，定义一个ImageDownloader类型的变量，然后通过new(fileCache)函数为其赋值，随后便可通过这个变量调用从缓存中加载图片的方法。类似地，通过new(netFetch)为其赋值，便可通过这个变量调用从网络上下载图片的方法。

> `💡 提示： 为何ImageDownloader类型的变量可以通过new(fileCache)或new(netFetch)进行赋值呢，你知道原因吗？`

从具体的业务需求分析，我们应首先检查本地缓存是否存在相应的图片数据，当找不到时再从网络中获取。因此，整个接口调用部分的示例代码如下：

```go
func main() {
	// 从本地缓存中获取数据
	var imageLoader ImageDownloader
	imageLoader = new(fileCache)
	data := imageLoader.FetchImage("https://www.example.com/a.png")
	fmt.Println(data)
	if data == "" {
		// 当本地缓存中没有数据时，从网络下载
		var imageLoader2 ImageDownloader
		imageLoader2 = new(netFetch)
		data2 := imageLoader2.FetchImage("https://www.example.com/a.png")
		fmt.Println(data2)
	}
}
```

如上所示，代码的逻辑将首先检查本地缓存，当返回值为空字符串（""）时，即表示本地无缓存。此时，应考虑去网络上下载图片。

将本讲示例代码汇总并运行，控制台可得如下输出：

> 从本地缓存中获取图片：https://www.example.com/a.png

修改针对*fileCache的FetchImage()方法，使其返回值为空字符串（""），再次运行程序，控制台上的输出将变为：

> 从网络下载图片：https://www.example.com/a.png

### 空接口与泛型

#### 泛型初体验

什么时候该使用泛型呢？举个例子，如果我们想要封装一个函数，该函数的作用便是实现传入参数数据的原样输出，该如何做呢？

利用我们已经掌握的知识，写出的代码可能会是这样：

```go
func main() {
   dataOutput("Hello")
}

func dataOutput(data string) {
   fmt.Println(data)
}
```

直接运行这段程序，控制台会输出：

> Hello

看似没有问题，但如果传入的参数不是string类型，而是数字型、布尔型呢？显然，程序是无法编译通过的，因为类型不匹配。

当然，我们也可以编写多个函数，来匹配不同的参数类型，比如：

```go
func main() {
   stringDataOutput("Hello")
   intDataOutput(123)
}

func stringDataOutput(data string) {
   fmt.Println(data)
}

func intDataOutput(data int) {
   fmt.Println(data)
}
```

如此确实可以实现，但代码整体不够优雅。况且这还只是两种类型，要是更多，日后的代码维护成本就会直线飙升了。

细心的朋友会发现，尽管类型不同，但函数体内实际执行的逻辑都是相通的。那么，有没有一种办法使函数的参数不再受限呢？当然有，那就是使用泛型。

**泛型是类型中的“万能牌”**，使用泛型作为函数参数，实际上就相当于告诉调用者：“我能兼容任何类型的参数，尽管将数据传给我就是了。”泛型以超级宽广的胸怀接纳所有类型的数据。**在Go语言中的泛型，则使用空接口来实现。** 而所谓的“空接口”，使用代码表示非常简单，就是：

```go
interface{}
```

和普通接口的定义格式不同，空接口内部无需填写任何方法。

**空接口能接纳所有类型的数据，因此可以将任何类型的数据赋值给它的变量**，请大家阅读下面这段代码：

```go
var anyTypeValue interface{}

func main() {
   anyTypeValue = 123
   anyTypeValue = true
   anyTypeValue = "Hello"
}
```

这段代码完全合法，可以编译、运行。

另一方面，**在函数参数中使用空接口，可以使其能接受所有类型的数据传入。** 以本讲一开始的示例举例，若要编写一个函数，实现传入参数数据的原样输出，只需按如下编写代码即可：

```go
func main() {
   dataOutput("Hello")
   dataOutput(123)
   dataOutput(true)
}

func dataOutput(data interface{}) {
   fmt.Println(data)
}
```

程序运行结果为：

> Hello
>
> 123
>
> true

如此编码，是不是比写一堆类似的函数要方便、简洁很多呢？还能节省开发和维护的时间。

> `💡 提示： 猜一猜，如果在dataOutput()函数中输出data变量的类型，将会如何输出呢？各位朋友不妨亲自动手一试，获取数据类型的函数是reflect.TypeOf(i interface{})。注意到了吗？这个函数所需的参数类型也是空接口类型，即泛型。`

#### 货车容量计算器

现在，我们计划进行一次搬家，正在预估需要多大容量的货车来存放全部家当。

为了讲解方便，本例将简化各种家具家电的体积计算方式。把它们简单粗暴地分为正方体、长方体和圆柱体三种体积形式，这三种形状的物品分别对应代码中的三种结构体类型。

此外，还需实现为这三种形状的物品编写体积计算的方法。如此一来，我们便可通过调用这个体积计算的方法，将其计算结果累加在一起，便可得知需要至少多大容量的货车了。

还记得如何定义一个结构体吧？以正方体为例，计算体积仅需要知道边长就可以了。所以我们定义一个名为cube的结构体，其中包含float64类型的length变量，表示边长，具体代码如下：

```go
// 正方体
type cube struct {
   // 边长
   length float64
}
```

接着，定义一个方法，名为cubeVolume，表示计算正方体的体积。作用于\*cube类型，返回float64类型值，具体代码为：

```go
// 正方体的体积计算
func (c *cube) cubeVolume() float64 {
   return c.length * c.length * c.length
}
```

如上，关于正方体的结构体和体积计算方法已经全部实现完成。依葫芦画瓢，继续实现长方体和圆柱体对应的结构体和体积计算方法。以下是具体的代码片段：

```go
// 长方体
type cuboid struct {
   // 长
   length float64
   // 宽
   width float64
   // 高
   height float64
}

// 长方体的体积计算
func (c *cuboid) cuboidVolume() float64 {
   return c.length * c.width * c.height
}

// 圆柱体
type cylinder struct {
   // 直径
   diameter float64
   // 高度
   height float64
}

// 圆柱体的体积计算
func (c *cylinder) cylinderVolume() float64 {
   return math.Pi * (c.diameter / 2) * (c.diameter / 2) * c.height
}
```

接下来是本讲的另一个重点知识。如果我们想用同样一个函数来计算所有类型物体的体积，那么“认清”家具的种类就是非常必要的一环。换言之，当传入这个函数的参数是正方体，则需要调用cubeVolume()函数进行计算；当传入这个函数的参数是长方体，则需要调用cuboidVolume()函数进行计算；当传入这个函数的参数是正方体，则需要调用cylinderVolume()函数进行计算。

**在Go语言中，用来判断某个数据是否属于某种类型的方法被称为“类型断言”。**

类型断言的使用格式为：

```
value, ok := x.(T)
```

其中，x是指某个变量，T表示类型，value是将x变量转换为T类型之后的值，ok是布尔类型，表示x是否属于T类型。

看上去有些绕口，我们用实际的例子来做演示。

前面说过，我们要实现一个函数，传入空接口类型的参数以便接收不同类型形状的家具，然后在这个函数中计算体积并返回最终的计算值。我们先以正方体为例，具体代码如下：

```go
// 计算某个物体的体积
func calcSize(material interface{}) float64 {
   cubeMaterial, cubeOk := material.(cube)
   if cubeOk {
      return cubeMaterial.cubeVolume()
   } else {
      return 0
   }
}
```

请大家仔细阅读这段代码，函数体内首行便进行了类型断言。material是传入该函数的参数，material.(cube)表示要判断material变量是否属于cube（正方体）类型。这种判断最终将返回两个结果，一个是cubeOk，它时布尔类型的值，当该值为true时，表示material是cube类型，反之则不是。另一个是cubeMaterial，它是将material变量转换为cube类型之后的变量，以便后续用它参与运算。

理解了函数中的首行代码，后面的代码便很好理解了。当cubeOK为true，即material属于cube时，使用转换后的cubeMaterial变量执行cubeVolume()方法，最终返回正方体的体积。

接下来，请大家自行编码实现长方体和圆柱体的类型断言和体积计算。

最后，整个程序完整的代码如下：

```go
package main

import (
   "fmt"
   "math"
)

func main() {
   truckSize := 0.0
   // 声明空接口类型变量materials，存放各种不同体积的家具
   var materials []interface{}
   materials = append(materials, cube{12.5})
   materials = append(materials, cuboid{25, 13, 60})
   materials = append(materials, cylinder{5, 25.3})
   // 遍历materials切片，依次计算每个家具的体积，并相加求和
   for _, singleMaterial := range materials {
      truckSize += calcSize(singleMaterial)
   }
   fmt.Println(truckSize)
}

// 计算某个物体的体积
func calcSize(material interface{}) float64 {
   cubeMaterial, cubeOk := material.(cube)
   cuboidMaterial, cuboidOk := material.(cuboid)
   cylinderMaterial, cylinderOk := material.(cylinder)
   if cubeOk {
      return cubeMaterial.cubeVolume()
   } else if cuboidOk {
      return cuboidMaterial.cuboidVolume()
   } else if cylinderOk {
      return cylinderMaterial.cylinderVolume()
   } else {
      return 0
   }
}

// 正方体
type cube struct {
   // 边长
   length float64
}

// 正方体的体积计算
func (c *cube) cubeVolume() float64 {
   return c.length * c.length * c.length
}

// 长方体
type cuboid struct {
   // 长
   length float64
   // 宽
   width float64
   // 高
   height float64
}

// 长方体的体积计算
func (c *cuboid) cuboidVolume() float64 {
   return c.length * c.width * c.height
}

// 圆柱体
type cylinder struct {
   // 直径
   diameter float64
   // 高度
   height float64
}

// 圆柱体的体积计算
func (c *cylinder) cylinderVolume() float64 {
   return math.Pi * (c.diameter / 2) * (c.diameter / 2) * c.height
}
```

程序运行的结果为：

> 21949.889338348887

如此，我们便可有依据地选择货车了。

你注意到了吗？在main()函数中，我**将空接口类型作为切片中的元素**放在了名为materials的切片中。这在实际开发中是非常巧妙的使用空接口的方式，它可以规避数据类型的不同，将不同类型的数据存放于同一个切片/数组中，对于组织大量具有不同类型的数据是非常有效的做法。

### 灵活运用接口

#### 接口的嵌套组合

我们都知道，结构体是允许嵌套使用的。实际上，接口也可以。

举例来说，我们使用浏览器进行下载文件的时候，通常会在保存、另存为和取消之间做出选择。抛开取消不谈，选择保存时，浏览器会自动执行下载和保存两个步骤；选择另存为时，浏览器会先询问文件保存的路径，再开始下载和保存。

如果我们把选择路径、下载、保存看作是待下载文件的3个接口，并用代码来表示，它很可能会是这样的：

```go
// ChooseDest 选择保存路径
type ChooseDest interface {
	chooseDest(localFile string)
}

// Download 执行下载
type Download interface {
	download()
}

// Save 保存文件
type Save interface {
	save()
}
```

细心的朋友会发现，无论何种方式下载文件，其中的下载和保存都是必需且顺序不变的。所以，我们不妨再创建一个接口，使其包含下载和保存两个接口，代码如下：

```go
// DownloadAndSave 下载和保存
type DownloadAndSave interface {
   Download
   Save
}
```

在使用时，我们便可直接声明DownloadAndSave类型的变量去执行下载和保存了，示例代码如下：

```go
func main() {
   // 声明一个file类型的变量，命名为downloadFileExample
   downloadFileExample := new(file)
   // 使用ChooseDest接口
   var chooseDest ChooseDest
   chooseDest = downloadFileExample
   chooseDest.chooseDest("")
   // 使用DownloadAndSave接口
   var downloadAndSave DownloadAndSave
   downloadAndSave = downloadFileExample
   downloadAndSave.download()
   downloadAndSave.save()
}
```

如上代码所示，无需单独声明Download和Save接口变量，仅使用DownloadAndSave接口变量便可调用download()和save()两个方法。

#### 从空接口取值

在上一讲中，曾经使用过类似下面这样的案例：

```go
func main() {
   dataOutput("Hello")
}

func dataOutput(data interface{}) {
   fmt.Println(data)
}
```

为了实现“将传入的参数按原样输出”的需求，我们编写了dataOutput()函数。该函数所需的参数是空接口，能接纳所有类型的数据，然后通过调用fmt.Println()将数据输出，满足了需求。

现在，如果想从data中获取数据，并赋值给某个变量，该如何做呢？显然，可以如下实现：

```go
func dataOutput(data interface{}) {
   fmt.Println(data)
   var stringValue string = data
   fmt.Println(stringValue)
}
```

暂且将上述方法当作方法A。

再看如下实现：

```go
func dataOutput(data interface{}) {
   fmt.Println(data)
   stringValue := data.(string)
   fmt.Println(stringValue)
}
```

暂且将该方法当作方法B。

猜一猜，哪种方法可以呢？

答案是：**方法B**。

是不是很奇怪，为什么方法A不行呢？实际上，当我们按照方法A去写时，GoLand会自动识别出问题，提示：Cannot use 'data' (type interface{}) as the type string，意思是无法将类型为interface{}的data变量作为string类型使用。

这是因为在进行类型断言前，谁也不知道data里放的是何类型。举个形象一点的例子，虽然箱子里装了某样货物，但箱子依然还是箱子，是不能将箱子当货使用的。

所以，在从空接口中取值时，切记要使用类型断言。

#### 空接口的值比较

撸起袖子，我们一起来挑战几道题。

不要用电脑编译和运行下面的代码，先猜猜它们的运行结果。

```go
func main() {
   var a interface{} = 10
   var b interface{} = "10"
   fmt.Println(a == b)
}
```

相信各位都能回答正确，上面这段代码运行结果为：

> false

挑战继续，再来试试这个：

```go
func main() {
   var a interface{} = []int{1, 2, 3, 4, 5}
   var b interface{} = []int{1, 2, 3, 4, 5}
   fmt.Println(a == b)
}
```

上面这段代码运行后，程序会发生宕机。报错信息如下：

> panic: runtime error: comparing uncomparable type []int

从字面上看，错误原因是程序比较了不可比较的类型——[]int。

在Go语言中，**有两种数据是无法比较的，它们是：Map和Slice**，强行比较会引发如上宕机错误。

数组是可以比较的，而且会比较数组中每个元素的值。因此，只需将上述代码改为：

```go
func main() {
   var a interface{} = [5]int{1, 2, 3, 4, 5}
   var b interface{} = [5]int{1, 2, 3, 4, 5}
   fmt.Println(a == b)
}
```

程序便会正常运行，输出结果：

> true

#### 接口与nil

在Go语言中，nil是一个特殊的值，它只能赋值给指针类型和接口类型。

让我们来挑战下面这段代码，还是不要用电脑编译运行，猜一猜它的输出结果：

```go
func main() {
   var a interface{} = nil
   fmt.Println(a == nil)
}
```

这段代码运行后，控制台将输出：

> true

应该没什么疑问吧？继续看下面的代码：

```go
type Person struct {
   name   string
   age    int
   gender int
}

type SayHello interface {
   sayHello()
}

func (p *Person) sayHello() {
   fmt.Println("Hello!")
}

func getSayHello() SayHello {
   var p *Person = nil
   return p
}

func main() {
   var person = new(Person)
   person.name = "David"
   person.age = 18
   person.gender = 0
   var sayHello SayHello
   sayHello = person
   fmt.Println(reflect.TypeOf(sayHello))
   fmt.Println(sayHello == nil)
   fmt.Println(getSayHello())
   fmt.Println(getSayHello() == nil)
}
```

猜一猜最终控制台将输出什么呢？

答案是：

> *main.Person
>
> false
> nil
>
> false

是不是也很奇怪？

输出第一个false无可厚非，可输出的第二个false就很耐人寻味了。第二个false来自于main()函数中调用的getSayHello()函数，该函数返回SayHello类型的接口，函数体内返回了nil值的*Person。直接输出getSayHello()函数的结果，是nil，但与nil比较时却不是true。

这是因为：**将一个带有类型的nil赋值给接口时，只有值为nil，而类型不为nil。此时，接口与nil判断将不相等。**

那么，为了规避这类问题，我们不妨在getSayHello()函数值做些特殊处理。当函数体中的p变量为nil时，直接返回nil即可。发生修改部分的代码如下：

```go
func getSayHello() SayHello {
   var p *Person = nil
   if p == nil {
      return nil
   } else {
      return p
   }
}
```

再次运行程序，控制台输出如下：

> *main.Person
>
> false
> nil
>
> true


## 包

在一开始配置好开发环境后，我们一起编写了一个能输出“Hello World”的程序：

```go
package main
import "fmt"
func main(){
    fmt.Println("Hello World!")
}
```

尽管那个程序非常简单，只有5行，但有些细节还是值得深入挖掘的。比如，第一行的package时什么意思，第二行的import到底做了什么……

这些问题看似互相独立，但都和一个话题有关，它就是——**Go程序源码的组织结构**。本讲就来带大家彻底搞清楚一个Go程序的源码是如何组织起来的。

### 包的声明

在Go源码中，**package的意思就是包，后面跟着的就是包名。Go语言通过包来组织源码，拥有相同包名的Go源码属于同一个包。反过来，一个包内通常会包含一个或多个Go源码文件。**“封装”和“复用”等就可以用包来实现。

在Hello World的源码中，第一行的内容是：

```go
package main
```

这句话就表示这个源码属于main包。Go语言有一个强制性要求，就是**源码文件的第一行有效代码必须声明自己所在的包**。

需要特别指出的是：**main包是一个比较特殊的包。一个Go程序必须有main包，且只能有一个main包**。

### 包的导入

和声明相对的，是导入。用通俗的话讲，**包的声明就是要告诉大家：“我属于哪个包”；包的导入就是要提出要求：“我想要使用哪个包”**。

在Hello World示例中，第2行代码就是在做包的导入，具体如下：

```go
import "fmt"
```

这句代码的意思就是说要导入名为“fmt”的包。细心的朋友可能会问：“这个fmt的包在哪儿呢？”fmt是Go SDK的众多内置包之一，当我们在装Go SDK的时候，fmt包就一并安装进来了。如果使用GoLand，可以在Project视图中找到fmt包的源码。这些源码文件位于Go SDK的安装路径下。

![image.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/3a74224bb6fa4b0e8661ae07542a8779~tplv-k3u1fbpfcp-watermark.png)

我们使用过无数次的fmt.Println()函数就位于fmt包里的print.go源码文件中。

![image.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/0e26975180534877b133c469b471d02c~tplv-k3u1fbpfcp-watermark.png)

正因为是内置包，在导入时只需指定包名就可以了。如果要导入自定义的包，则需要按照一定的规则来进行。

> `❗️ 注意：Go语言在导入包方面要求较为严格，在使用GoLand时，如果某个包被导入却没有使用，将会出现错误提示。`

### Go 程序是怎么跑的

#### main()函数

从示例的第3行开始到最后，都是main()函数了：

```go
func main(){
    fmt.Println("Hello World!")
}
```

在Go语言中，**main()函数是程序的入口函数，它位于main包中。如果想要编译生成可执行文件，main()函数则是必须的**。如果将示例代码中的main()函数去掉直接编译，可以看到控制台会输出如下错误：

> runtime.main_main·f: function main is undeclared in the main package

大意就是说main()函数没有在main包中声明。

我们还可以看到在main()函数中可以调用fmt包中的函数，这正是由于我们导入了fmt包才能做到的。

####  Go源码的启动流程

我们都知道，main()函数是Go程序的入口函数。实际上，Go程序还有一个init()函数，被称为“初始化”函数。我们来看下面这段代码：

```go
package main
import "fmt"
func init() {
   fmt.Println("Hello")
}
func main() {
   fmt.Println("World")
}
```

上述代码运行后，控制台将输出：

> Hello
>
> World

发现规律了吗？没错，init()函数在main()函数之前执行，经常做一些程序初始化的工作，因此它被称为初始化函数。

对于一个较为复杂的软件代码而言，通常会按照前面介绍过的“分而治之”的编码方式进行开发。特别是在多人协同开发场景中，由于每个人负责的功能模块不同，通常会将一个完整的软件产品代码分为多个包。一旦Go程序开始运行，main包中的代码便会首先得到执行，所有导入的包会执行其中的init()初始化函数。

下图较为清晰地描述了Go源码的启动过程：

![image.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/6c91ccc186824ea8b8ad06dc2b28faf8~tplv-k3u1fbpfcp-watermark.png)

我们从左上角的开始处分析这张图，可以发现Go源码的启动流程是这样的：

1. 程序开始运行后，首先来到main包，检索所有导入的包。发现代码中导入了A包，于是来到A包；
2. 发现A包代码中导入了B包，于是又来到B包；
3. B包代码没有导入任何其它的包，于是开始声明B包内的常量和变量，并执行B包中的init()函数；
4. 回到A包，进行A包内的常量和变量的声明，并执行A包中的init()函数；
5. 回到main包，执行main包内的常量和变量的声明，并执行main包中的init()函数；
6. 执行main包中的main()函数。

> `💡 提示：了解Go源码的启动加载过程，有助于编写更高效率的代码，排查程序启动缓慢等性能问题。`

### 封装包

Go语言借助文件系统树形结构来组织包。具体来说，

- 虽然**Go语法没有强制要求包名与其所在的目录名相同，但习惯上我们还是会保持这二者相同** ；
- 包**可以定义在多层级的目录中**；
- **单个包的所有源码应存在相同的目录下**，不同目录通常包含不同的包源码；
- 包名一般开头是小写的，**采用小驼峰式命名法**；
- 多个类似业务的公司可能会封装相同名称的包，为了确保唯一性，建议大家**使用域名作为目录结构的一部分** 。
- 特殊的包包含可执行的入口，即main函数，如果目录包含main函数，则该目录下只能有一个main包。
- 通过函数命名如camel case来区分方法的可见性，**首字母大写**表示public，**小写**表示private。
- 所有结构、常量和定义的可见性也是通过首字母的大小写来确定，public和private的界定是针对**包**而言。

对应到本例，首先新建一个工程，工程名称为go-juejin-weather，创建好后，依次创建juejin.cn（此为域名）目录，再进入该目录，创建weather（此为包名）目录。既然我们要封装获取实时天气的包，便可将包的源码命名为weather.go，放置在该目录下。如此一通操作后，整个工程的结构如下图所示：

![image-20220328092833793.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/5cceaec11390407baacc5913fa0b8cf1~tplv-k3u1fbpfcp-watermark.png)

打开weather.go源码，分别使用Go SDK中的net包和io包中的函数进行网络数据请求和请求结果的解析，完整的代码如下：

```go
package weather
import (
   "fmt"
   "io/ioutil"
   "net/http"
)
func CurrentWeather(cityCode string) string {
   //使用net包发起Get请求
   resp, err := http.Get("https://devapi.qweather.com/v7/weather/now?location=" + cityCode + "&key=[您自己申请的AppKey]")
   if err != nil {
      fmt.Println("HTTP请求失败：", err)
      panic(err)
   }
   //使用断言关闭网络请求
   defer resp.Body.Close()
   //使用ioutil工具包获取服务端响应数据
   body, err := ioutil.ReadAll(resp.Body)
   if err != nil {
      fmt.Println("读取网络响应失败：", err)
      panic(err)
   }
   return string(body)
}
```

上述代码中，一上来便声明了这个源码文件属于weather包，接着导入了fmt、io和net包。最后的部分是名为CurrentWeather()函数，该函数需要一个表示城市代码的string类型值作为参数，并返回了最终的网络响应数据。这个函数是大写字母开头的，只有这样才能被其它的go源码调用。

>`💡 提示：有关net包和io包的更多内容将在下一讲中详述。`

> `❗️ 注意：本示例使用了和风天气提供的天气数据API。通常来说，若要使用某个公共数据平台的服务，都要先申请AppKey。AppKey简称API接口验证序号，相当于一个ID，用于验证API接入合法性的。它代表一个应用程序，便于区分和管理。只有通过申请的合法AppKey才能合法地获取数据，像百度/高德地图等API，若要正常使用都需要申请AppKey，且过程都是类似的。强烈建议大家自行登录和风天气开发者网站，注册开发者账户，体验一次完整的AppKey申请和使用的过程。`

到此，一个简单的weather包的封装就结束了。

### 使用包

回到main.go中，尝试调用weather包中的函数——CurrentWeather()。

如果各位使用的是GoLand，在main函数中只需输入Cur三个字母，便可在代码提示中看到CurrentWeather()函数了。选中它并敲回车键，函数的调用会被自动补全，同时，weather包也会自动导入。

由于CurrentWeather()函数最终将返回string类型的数据，因此我们声明一个名为result的变量，并将函数的返回值赋给这个变量。整个main.go的代码如下所示：

```go
package main
import (
   "fmt"
   "go_juejin_weather/juejin.cn/weather"
)
func main() {
   result := weather.CurrentWeather("101010100")
   fmt.Println(result)
}
```

运行后，控制台将输出：

>{"code":"200","updateTime":"2022-03-28T09:02+08:00","fxLink":"http://hfx.link/2ax1","now":{"obsTime":"2022-03-28T08:47+08:00","temp":"10","feelsLike":"6","icon":"100","text":"晴","wind360":"225","windDir":"西南风","windScale":"2","windSpeed":"11","humidity":"31","precip":"0.0","pressure":"1018","vis":"30","cloud":"0","dew":"-5"},"refer":{"sources":["QWeather","NMC","ECMWF"],"license":["no commercial use"]}}
>
>Process finished with the exit code 0

我是怎么知道请求地址的呢？城市代码又是什么意思呢？上述数据结果又该如何解读呢？

实际上，这些内容都可以在和风天气开发者网站找到。我们使用任何一个公共数据服务平台时，都可以阅读它的开发者文档找到该平台所能提供的一切能力，以及请求返回结果的解读方法。

本例中的实时天气的获取和解读方法就是从：[https://dev.qweather.com/docs/api/weather/weather-now/](https://dev.qweather.com/docs/api/weather/weather-now/) 找到的。

本例中的城市代码使用了“101010100”，这个代码表示中国北京市。这个代码在开发者网站并没有直接提供，但可以通过“城市信息查询API（[https://dev.qweather.com/docs/api/geo/city-lookup/](https://dev.qweather.com/docs/api/geo/city-lookup/) ）”获取答案。

### 实现一个服务器软件

#### 准备工作

在正式开始之前，请大家了解下列概念：

1.  **http协议**，重点关注请求和响应，包括Get/Post的区别、各自适用的场景等等；
1.  **json格式**，重点理解语法、json对象和数组的数据结构。

以上内容可阅读下面的参考资料：

1.  [HTTP 教程 | 菜鸟教程 (runoob.com)](https://link.juejin.cn/?target=https%3A%2F%2Fwww.runoob.com%2Fhttp%2Fhttp-tutorial.html "https://www.runoob.com/http/http-tutorial.html")
1.  [JSON 教程 | 菜鸟教程 (runoob.com)](https://link.juejin.cn/?target=https%3A%2F%2Fwww.runoob.com%2Fjson%2Fjson-tutorial.html "https://www.runoob.com/json/json-tutorial.html")

为了测试服务器软件运行的正确性，我们将使用**Postman接口测试工具**进行验证。Postman是一款免费的软件，下载地址：[Download Postman | Get Started for Free](https://link.juejin.cn/?target=https%3A%2F%2Fwww.postman.com%2Fdownloads%2F "https://www.postman.com/downloads/")。相关教程请参考：[postman使用教程 - 掘金 (juejin.cn)](https://juejin.cn/post/7001116261446844429 "https://juejin.cn/post/7001116261446844429")

本讲案例源码位于：[gitee.com/wh1990xiao2…](https://link.juejin.cn/?target=https%3A%2F%2Fgitee.com%2Fwh1990xiao2005%2Fgo-juejin-human-resource-server "https://gitee.com/wh1990xiao2005/go-juejin-human-resource-server")，没有版权限制，感兴趣的朋友可以克隆到本地进行实验。

#### 启动和停止网络服务器

Go SDK内置了启动服务器并监听自定义端口号的工具包，位于net\http包中。若要启动一个本地服务器，只需调用：

```go
http.ListenAndServe()
```

函数即可，该函数的声明格式如下：

```go
func ListenAndServe(addr string, handler Handler) error
```

显而易见地，该函数需要两个参数。string类型的addr表示要监听的端口号；Handler类型的handler用来自定义路由的处理逻辑，在大多数时候只需传入nil即可。函数的返回值是error类型，当服务器启动成功后，将为nil，反之则会包含具体的错误信息。

大家都知道，http通常使用的端口号是80，我们不妨就监听80端口，然后根据error类型的返回值来判断服务器是否已经启动成功。具体代码如下：

```go
//启动本地服务器（localhost）
err := http.ListenAndServe(":80", nil)
if err != nil {
   fmt.Println("启动服务失败，错误信息：", err)
}
```

完成编码后，运行程序，控制台没有任何输出，表示服务器启动应该是成功的。同时，也没有程序停止运行的输出，这表示80端口一直处于被监听的状态。

此时，打开浏览器，访问localhost（或127.0.0.1），会发现网页显示404错误信息。这是正常的现象，因为我们只是启动了服务器，并没有明确定义路径和返回的数据。这个404表示找不到路径，它其实就是http包在找不到匹配的路径时默认返回的数据。

和终止一般程序运行一样，停止服务器软件依然可以点击GoLand上方的Stop按钮实现。当以可执行文件运行时，可以**按键盘上的Control+C组合键**进行停止。

#### 响应“/”路径（站点首页）

乍一看标题，可能会发蒙，什么是“/”路径呢？其实就是网站的**根路径**，也就是很多网站都在使用的首页路径。

比如知乎，当我们输入juejin.cn时，就会来到掘金首页的综合推荐栏目。这就是掘金网站的根路径。接着再来到沸点，网址会变为juejin.cn/pin，我们就来到了/pin路径下。

所以，一旦服务器成功响应根路径的访问请求，并返回一些数据，那么当我们使用浏览器进行访问网站时，就能成功地看到返回的数据了！

在Go语言中响应访问请求非常简单，下面的代码就实现了返回一句网站欢迎语的响应：

```go
//响应
http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
   fmt.Fprintf(w, "欢迎使用人力资源管理系统")
})
```

**将这段代码放在启动服务器代码之前**，然后运行程序。并打开浏览器访问localhost或127.0.0.1，可以看到浏览器中将显示“欢迎使用人力资源管理系统”字样。若使用Postman工具访问，也会得到相同的结果。

> `❗️ 注意：请务必将接口响应的代码放在启动服务器代码之前，相应的接口请求才能得到响应。`

上述代码中有两个地方值得注意，一个是**HandleFunc()函数**，另一个是**Fprintf()函数**。

我们先来看HandleFunc()，该函数是http包提供的。从源码的角度看，该函数的声明格式为：

```go
func HandleFunc(pattern string, handler func(ResponseWriter, *Request))
```

该函数需要string类型的pattern作为参数之一，它表示路径。请注意，这里的pattern还可以是正则表达式，而非一个绝对固定的路径值。传入非正则表达式即表示固定的路径值。第二个参数则表示接收到的所有请求参数（包含Header、请求方式、参数值等等）和响应输出管道。整个函数没有任何返回值。

我们再来看Fprintf()函数，该函数来自fmt包。这个包我们已经不陌生了，已经使用过无数次Println()函数。Fprintf()函数的功能与之类似，都是输出一些内容。不同的是，该函数需要两个参数，来看它的声明格式：

```go
func Fprintln(w io.Writer, a ...interface{}) (n int, err error)
```

该函数需要的两个参数中，我们重点看第一个。它是io.Writer类型的。**该参数指定了输出的“目标”** 。在示例代码中，我们**将网络响应的输出管道传给它，目的就是将要输出的内容作为网络响应返回给发起请求的一方**，即浏览器或Postman工具。

#### 增加人员

所谓“人力资源管理系统”，对人员数据的增、删、改、查是最最基本的操作了。本讲介绍人员的增加和查询，删除和修改留作思考题给大家。

先来说说增加，我们把增加人员的请求路径命名为“insert”，并只允许通过POST请求来进行。一个人员的信息包括名字（Name）、年龄（Age）和性别（Gender）。名字是string型，年龄和性别均为int，性别中0表示男，1表示女。

先来定义“人员”结构体吧，按照上述规则，我们将人员定义名为hr的结构体，同时为了使用标准化的json结构，在结构体字段后面添加json字段名，具体格式如下：

```go
type hr struct {
   Name   string `json:"name"`
   Age    int    `json:"age"`
   Gender int    `json:"gender"`
}
```

请注意，结构体的**字段名必须要大写，允许外部可见**。否则将影响json解析和赋值。另外，用于指定**json字段的部分应该由英文的反单引号包括，json字段名用英文的双引号包括**。

接下来，照猫画虎实现响应/insert路径的函数：

```go
var db []hr
//响应/insert，从传入的参数新增人员信息
http.HandleFunc("/insert", func(w http.ResponseWriter, r *http.Request) {
   if r.Method == "POST" {
      err := r.ParseForm()
      if err != nil {
         fmt.Fprintln(w, "错误的请求")
      } else {
         name := r.FormValue("name")
         // 将string转为int
         age, _ := strconv.Atoi(r.FormValue("age"))
         gender, _ := strconv.Atoi(r.FormValue("gender"))
         db = append(db, hr{Name: name, Age: age, Gender: gender})
         fmt.Fprintln(w, "添加了"+name)
      }
   }
})
```

上述代码中，有一些没见过的函数调用。

函数体一开始通过

```go
r.Method
```

的值**过滤掉非POST请求**，达到只允许POST提交数据的目的。接着，又调用了

```go
r.ParseForm()
```

这一步的作用是**将POST请求的表单解析**出来，此处的作用就是初步验证表单信息的正确性，便于后面的赋值。

当解析无误后，进入else分支，通过

```go
r.FormValue()
```

函数**将特定键的值从表单中取出来**。然而，该函数的返回值却是string类型的。对于“名字（Name）”字段还好说，但是年龄和性别就难办了。此时，就需要派strconv包来救场了。

**strconv包的作用是将字符串转至其它基本数据类型**。示例中调用了

```go
strconv.Atoi()
```

函数，作用就是**将string类型的值转换为int类型的值**。

当然，**前提是原值确实是可以被正常转换的。** 比如：1、125、367、……通常不会出错，但像“56只”、“128兆字节”这些包含文字的值将转换失败，**当发生转换失败时，我们可以从函数返回值中获取到具体的出错信息，转换的结果将会是int的默认值——0**。

当传入的数据被成功解析和取值后，创建hr类型的变量，并追加到db切片中。最后，输出“添加了xxx”（xxx是Name值）的文字。

完成编码后，将/insert响应的代码添加至开启服务器代码前，然后运行。接着，打开Postman，使用POST方式访问这个接口，并给定请求表单数据，具体如下图所示：

![image-20250205160048535](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250205160048535.png)

显然，小王的人员信息已经被成功地添加到系统中。

接着，我们不妨将请求方式改为GET，大家猜一猜，可以得到什么样的响应呢？

答案是：没有任何输出。

#### 查询人员

好了，写过两次网络响应，想必大家已经熟知实现的“套路”了吧？我们继续实现查询人员的网络响应，该接口的请求路径为/query。

稍微来点“超纲”的要求，作为服务器软件，我们在此处提供了两种格式的输出，一种是普通的文本输出，另一种是json格式的输出，通过请求参数中的format字段来控制。只有当format值为json的时候，输出json格式。具体如下图所示：

文本输出：

![image-20250205160131277](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250205160131277.png)

json格式输出：

![image-20250205160149972](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250205160149972.png)

**将某种类型转换为json格式及反向转换需借助encoding/json包来实现，转换为json格式的函数声明为：**

```go
func Marshal(v interface{}) ([]byte, error)
```

**反向转换的函数声明为：**

```go
func Unmarshal(data []byte, v interface{}) error
```

在增加人员部分，我们将新增的人员信息都保存在了db切片中。因此，查询人员时只需将db切片中的数据按要求的格式进行输出就可以了。请大家先尝试自己动手实操，然后再参考下面的答案。

> `💡 提示：db变量会随着每次程序停止运行而清空。在测试运行时，请先访问/insert接口新增一些数据，这是能成功查询到已有数据的前提。我将在下一讲介绍数据持久化的方法。`

具体代码如下：

```go
//响应/query，获取所有已存在的人员信息。
//给定format，可按json格式输出，默认格式为字符串
http.HandleFunc("/query", func(w http.ResponseWriter, r *http.Request) {
   err := r.ParseForm()
   if err != nil {
      fmt.Fprintln(w, "错误的请求")
   } else {
      format := r.FormValue("format")
      if format == "json" {
         data, err := json.Marshal(db)
         if err != nil {
            fmt.Println(err)
         } else {
            fmt.Fprintln(w, string(data))
         }
      } else {
         for i := 0; i < len(db); i++ {
            fmt.Fprintln(w, db[i].Name, db[i].Age, db[i].Gender)
         }
      }
   }
})
```

## 数据库

### 集成包

现在开始动手！

前文已经说到，Go SDK中并未附带连接数据库的包，因此需要我们自己去找合适的包来使用。幸运的是，我们很快就能找到相应的包：[go-sql-driver/mysql](https://pkg.go.dev/github.com/go-sql-driver/mysql)。

> `💡 提示：还记得去哪里搜索源码包吗？当然是Go语言官方提供的package库首页：https://pkg.go.dev/ ，只需在搜索框中输入 mysql，就会看到很多搜索结果。通过查看包详情，可以得知包的作用、发布时间、使用人数、使用方法等等，由此便可做出选择。`

找到合适的包后，使用命令行将该包集成到项目中。创建一个工程，名为 go-juejin-note-book-server。启动 GoLand 中的 Terminal 视图，使用 go get 命令集成库：

```shell
go get -u github.com/go-sql-driver/mysql
```

在执行这条命令的时候，很有可能会受到网络错误的提示。解决办法很简单，只需将获取包的 GOPROXY 环境变量指向国内镜像源即可，具体如下：

```shell
$ go env -w GO111MODULE=on
$ go env -w GOPROXY=https://goproxy.cn,direct
```

其实，国内的镜像源网站不止一个，阿里云同样也支持（[阿里云 Go Module代理服务 ](http://mirrors.aliyun.com/goproxy/)）。在学习本讲内容时，若刚好上述镜像源均已失效，您还可以自行查找，完全不用担心。

集成成功后，再次回到 GoLand，打开 Project 视图，然后打开 External Libraries，可以在其中找到github.com/go-sql-driver/mysql，如下图所示：

![image-20220412144953560.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/ec79ffc24e154a29b114e015bb0f8080~tplv-k3u1fbpfcp-watermark.png)

### 实现网络请求的响应

本例将响应用户的5类请求，对应5个接口地址，具体如下：

- 根路径（/）：接受 POST/GET 请求，均返回欢迎信息和接口调用地址的含义；
- 添加一条记事本数据（/add）：仅接受 POST 请求，传入标题、正文和日期时间，添加成功后返回添加的标题；
- 根据 id 删除一条记事本数据（/delete）：接受 POST/GET 请求，传入 id，删除该 id 所属的数据，删除成功后返回成功结果；
- 根据id更新一条记事本数据（/update）：接受 POST/GET 请求，传入 id 和新的标题、正文和日期时间，用新传入的数据覆盖已有的数据，更新成功后返回成功结果；
- 查询记事本数据，可传入 id 进行精准查找（/query）：接受 POST/GET 请求，支持根据 id 进行单条数据的查找或查找全部数据，执行成功后返回查询结果集。

以下是完整的代码：

```go
package main
import (
   "fmt"
   "net/http"
   "time"
)
type notebook struct {
   Id       int
   Title    string `json:"title"`
   Content  string `json:"content"`
   DateTime string `json:"dateTime"`
}
func main() {
   launchServer()
}
// 添加数据到数据库
func add(data notebook) {
}
// 删除一条数据
func del(id string) {
}
// 更新数据到数据库
func update(id string, data notebook) {
}
// 从数据库获取数据
func query(id string) []notebook {
   var notebooks []notebook
   return notebooks
}
// 启动服务器
func launchServer() {
   //响应/
   http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
      fmt.Fprintf(w, "欢迎使用在线记事本\n")
      fmt.Fprintf(w, "▶▶ /add 添加新的数据\n")
      fmt.Fprintf(w, "▶▶ /delete 根据ID删除数据\n")
      fmt.Fprintf(w, "▶▶ /update 根据ID更新数据\n")
      fmt.Fprintf(w, "▶▶ /query 获取全部数据或根据ID获取单条数据\n")
   })
   //响应/add，从传入的参数新增一条记事本
   http.HandleFunc("/add", func(w http.ResponseWriter, r *http.Request) {
      if r.Method == "POST" {
         err := r.ParseForm()
         if err != nil {
            fmt.Fprintln(w, "错误的请求")
         } else {
            title := r.FormValue("title")
            content := r.FormValue("content")
            dateTime := r.FormValue("dateTime")
            add(notebook{Title: title, Content: content, DateTime: dateTime})
            fmt.Fprintln(w, "添加了："+title)
         }
      }
   })
   //响应/delete，从传入的参数删除一条记事本
   http.HandleFunc("/delete", func(w http.ResponseWriter, r *http.Request) {
      err := r.ParseForm()
      if err != nil {
         fmt.Fprintln(w, "错误的请求")
      } else {
         id := r.FormValue("id")
         del(id)
         fmt.Fprintln(w, "删除成功")
      }
   })
   //响应/update，更新一条数据
   http.HandleFunc("/update", func(w http.ResponseWriter, r *http.Request) {
      err := r.ParseForm()
      if err != nil {
         fmt.Fprintln(w, "错误的请求")
      } else {
         id := r.FormValue("id")
         title := r.FormValue("title")
         content := r.FormValue("content")
         dateTime := r.FormValue("dateTime")
         update(id, notebook{Title: title, Content: content, DateTime: dateTime})
         fmt.Fprintln(w, "更新成功")
      }
   })
   //响应/query，从传入的参数删除一条记事本
   http.HandleFunc("/query", func(w http.ResponseWriter, r *http.Request) {
      err := r.ParseForm()
      if err != nil {
         fmt.Fprintln(w, "错误的请求")
      } else {
         id := r.FormValue("id")
         fmt.Fprintln(w, query(id))
      }
   })
   //启动本地服务器（localhost）
   err := http.ListenAndServe(":80", nil)
   if err != nil {
      fmt.Println("启动服务失败，错误信息：", err)
   }
}
```

显然，这段代码中的 add()、del()、update() 和 query() 函数就是真正操作数据库的函数了！不过别急，如果要进行数据库的CRUD操作，首先要做的是要成功地连接到数据库，检查并创建相应的数据表，最后才是针对表的数据操作。当然，这一切的操作均要使用 mysql 包中的函数。

### 建立连接

根据 mysql 包的[说明](https://github.com/go-sql-driver/mysql)，首先需要import。具体如下：

```go
import (
   "database/sql"

   _ "github.com/go-sql-driver/mysql"
)
```

请大家留意，这里在 import 时，使用了下划线（“\_”）开头。**“\_”是一个特殊标识符，它表示仅执行包内的init()函数，不做其它之用。**

接着，创建一个名为 connectToDb() 的函数，用来与 MySQL 数据库建立连接，并返回 \*sql.DB 类型值。在后续的建表以及 CRUD 操作时会频繁用到这个值。

看到这，有些朋友或许会感到好奇：“才刚到连接的步骤，你怎么知道后续的步骤该用什么呢？”实际上，**在编码之前，如果我们使用了其它的包（在实际开发中，这是非常常见的场景），务必要先了解这个包的用法。而要了解某个包的用法，最靠谱的办法就是看官方文档。**

mysql 包的官方文档就给出了有关建表和 CRUD 操作的具体示例：[Examples · go-sql-driver/mysql Wiki (github.com)](https://github.com/go-sql-driver/mysql/wiki/Examples)。从中我们便可得知，建立连接后返回的 \*sql.DB 类型值将频繁用于后续步骤。

根据官方指导文档中所述的内容，建立连接的函数是 sql.Open()，其中需要传入数据库连接凭据。此外，我们还可以根据实际情况设置最大连接数等参数。具体代码如下：

```go
var db *sql.DB
// 连接到数据库
func connectToDb() *sql.DB {
   db, _ := sql.Open("mysql", "root:123456@/go_learn")
   // 设置可重用链接的最长时间（0为不限制）
   db.SetConnMaxLifetime(time.Hour * 1)
   // 设置连接到数据库的最大数量（默认值为0，即不限制）
   db.SetMaxOpenConns(5)
   // 设置空闲连接的最大数量（默认值为2）
   db.SetMaxIdleConns(5)
   fmt.Println("连接成功！！")
   return db
}
```

执行 sql.Open() 函数后，它将返回两个参数：一个是 \*sql.DB 类型值，我还声明了一个全局变量，以便后续使用；另一个则是包含错误信息的 error 类型值，上述代码忽略了针对连接错误的处理。

### 创建数据表

一旦数据库连接成功，就可以检查所需的数据表是否存在了，如果不存在则创建。

对于本例中的记事本应用，需要创建的数据表头为自增长的 id、标题（title）、内容（content）和时间（dateTime）。除了 id 是数值型外，其它均为字符串类型。

mysql 包提供了 db.Exec() 方法，用来执行 SQL 语句，它的方法定义格式如下：

```go
func (db *DB) Exec(query string, args ...interface{}) (Result, error)
```

在创建数据表时，需要传入的参数则是建表的 SQL 语句。因此，整个创建数据表的函数实现如下：

```go
// 创建数据表
func createTable() {
   db.Exec("CREATE TABLE IF NOT EXISTS `notebook` (" +
      "`id` bigint(20) NOT NULL AUTO_INCREMENT," +
      "`title` varchar(45) DEFAULT ''," +
      "`content` varchar(45) DEFAULT ''," +
      "`dateTime` varchar(45) DEFAULT ''," +
      "PRIMARY KEY (`id`)" +
      ") ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;")
   fmt.Println("表存在或成功创建")
}
```

这段 SQL 语句将检查名为 notebook 的数据表是否存在，如果不存在则执行建表操作。表头信息和值类型均描述得非常清晰。

> `❗️ 注意：考虑到数据量的增长，id 列的数据类型设置为 bigint 是较为妥善的处理方式。int 的取值范围受限于 4 个字节，bigint 则是 8 个字节。更大的范围意味着该数据表能容纳更多的数据，除非十分确定数据量的大小，否则建议大家将id列的类型设置为 bigint。`

数据库的连接和表的创建可以看作是完成本例的“准备工作”，完成了准备工作后，用户的请求才有可能得到正确的响应，main() 函数也可以随之得到完善了：

```go
func main() {
   db = connectToDb()
   createTable()
   launchServer()
}
```

main() 函数的函数体首先执行了数据库的连接，然后进行了数据表的检查，准备工作完成。最后执行 launchServer() 函数，启动 Http 服务。

### 数据的增、删、改操作

对于 mysql 包而言，实现数据的增、删、改都遵循相同的模式：都是**先执行 db.Prepare() 方法，将完整的 SQL 语句作为参数传入。再通过该函数的返回值调用 Exec() 方法，将对应的值依次传入** ，即可完成整个过程。

db.Prepare() 和 Stmt.Exet() 的定义格式如下：

```go
func (db *DB) Prepare(query string) (*Stmt, error)
func (s *Stmt) Exec(args ...interface{}) (Result, error)
```

以增加一条数据（add()函数）为例，具体代码片段如下：

```go
// 添加数据到数据库
func add(data notebook) {
   stmtInsert, _ := db.Prepare("INSERT INTO notebook SET title=?,content=?,dateTime=?")
   res, _ := stmtInsert.Exec(data.Title, data.Content, data.DateTime)
   idValue, _ := res.LastInsertId()
   fmt.Printf("添加了id值为%d的数据\n", idValue)
}
```

请大家观察 db.Prepare() 方法和 stmtInsert.Exec() 方法中的对应关系，前者中每个问号（“?”）对应后者中的一个参数值。至于具体是如何匹配的，我们便无需关心了。

res 变量是执行 SQL 语句后的结果，它同样是 Result 类型的。该类型提供了两个方法：**LastInsertId() 和 RowsAffected()，前者表示最新一条数据新增的 id 值，后者表示执行完 SQL 语句后受影响的行数。** 在 add() 函数中，调用了 LastInsertId() 方法，返回被添加数据的 id 值。

接下来，依葫芦画瓢，实现删除一条数据（del()）和更新一条数据（update()）函数。具体代码如下：

```go
// 删除一条数据
func del(id string) {
   stmtDelete, _ := db.Prepare("DELETE FROM notebook WHERE id=?")
   res, _ := stmtDelete.Exec(id)
   rawsCount, _ := res.RowsAffected()
   fmt.Printf("删除了%d条数据\n", rawsCount)
}

// 更新数据到数据库
func update(id string, data notebook) {
   stmtInsert, _ := db.Prepare("UPDATE notebook SET title=?, content=?, dateTime=? WHERE id=?")
   res, _ := stmtInsert.Exec(data.Title, data.Content, data.DateTime, id)
   rawsCount, _ := res.RowsAffected()
   fmt.Printf("更新了%d条数据\n", rawsCount)
}
```

如上代码所示，del() 和 update() 函数均向控制台输出了受影响的行数。由于删除和更新是通过 id 来检索的，因此受影响的行数应为 1。

### 数据的查询操作

在 mysql 包中有一个专门用于数据查询的方法，它就是db.Query()。该方法的定义格式如下：

```go
func (db *DB) Query(query string, args ...interface{}) (*Rows, error) 
```

在执行查询时，需要将 SQL 语句传入其中，通过遍历 \*Rows 类型值来获取查询结果。

本例中，要求服务端根据请求参数响应两种结果。当存在id参数时，进行 id 列条件查找；反之则返回全部数据。具体实现如下：

```go
// 从数据库获取数据
func query(id string) []notebook {
   var notebooks []notebook
   var rows *sql.Rows
   if id == "" {
      rows, _ = db.Query("SELECT * FROM notebook")
   } else {
      rows, _ = db.Query("SELECT * FROM notebook WHERE id=" + id)
   }
   for rows.Next() {
      var singleNote notebook
      rows.Scan(&singleNote.Id, &singleNote.Title, &singleNote.Content, &singleNote.DateTime)
      notebooks = append(notebooks, singleNote)
   }
   return notebooks
}
```

此外，当仅需要检索第一条与查找条件相匹配的数据时，还可调用 db.QueryRow()，该函数返回 \*Row 类型，表示单条数据。

## 并发

###  协程与线程

在 Java 中，若要创建一个线程需要斟酌再三。这是因为**线程是操作系统的资源，它的创建、切换、停止等等都属于操作系统操作，比较“重”** 。

协程看上去和线程类似，但**协程是在用户层面的，它的创建、切换、停止等等由用户操作，更“轻”** 。

线程能充分发挥多核 CPU 的优势，可以做到并行执行多任务。协程则不然，协程是为并发而生的，一个线程上可以跑多个协程。

**Go 语言中的并发是靠协程来实现的。在后端服务器软件开发中，有大量的 IO 密集操作，这正是协程最适合的场景。这也正是 Go 语言更适合高并发场景的原因。**

> `💡 提示： Go 语言的任务调度模型被称为 GPM，我将在下一讲详述GPM模型架构及原理。`

### 并发任务的启动

在 Go 语言中启动并发任务非常简单，只需要在相应的语句前面加上 go 即可。来看下面这段代码：

```go
func main() {
   // 并发调用testFunc()
   go testFunc()
   time.Sleep(time.Second * 5)
   fmt.Println("程序运行结束")
}
// 并发测试函数
func testFunc() {
   for i := 1; i <= 3; i++ {
      fmt.Printf("第%d次运行\n", i)
      time.Sleep(time.Second)
   }
}
```

在 testFunc() 函数中调用了 time.Sleep() 函数，**time.Sleep() 的作用是让当前协程暂停特定的时间**。所以整个testFunc() 函数的目的就是每隔1秒执行1次循环体中的代码，总共执行 3 次，共计耗时 3 秒。main() 函数中在调用 testFunc() 函数时前面加了 “go ”，表示创建一个 Goroutine，在另一个协程中执行 testFunc()。程序运行结果为：

> 第 1 次运行
>
> 第 2 次运行w
>
> 第 3 次运行
>
> 程序运行结束

为什么 main() 函数中要等待 5 秒呢？这是因为 testFunc() 函数需要至少 3 秒才能完成，由于 testFunc() 在另一个协程中，并不会影响 main() 函数体中后续代码的执行。因此main() 函数将迅速完成，整个程序便宣告终止了。

**一旦程序终止，所有在 main() 函数中启动的 Goroutine 也会随之终止**，我们便看不到其它协程中的输出了。所以要给 testFunc() 预留足够多的时长，等待它完成执行。这是使用并发时特别需要注意的一点。

然而，在实际开发中，我们通常无法确切地得知一个协程的准确执行时长。况且像上述代码中，过长的等待时间将会导致程序运行效率的降低。Go 语言提供了一种特别方便的方式确保执行协程任务的完整性，它来自 sync 包。下面的代码演示了它的使用方法：

```go
var goRoutineWait sync.WaitGroup
func main() {
   goRoutineWait.Add(1)
   // 并发调用testFunc()
   go testFunc()
   goRoutineWait.Wait()
   fmt.Println("程序运行结束")
}
// 并发测试函数
func testFunc() {
   defer goRoutineWait.Done()
   for i := 1; i <= 3; i++ {
      fmt.Printf("第%d次运行\n", i)
      time.Sleep(time.Second)
   }
}
```

这段代码中，声明了 sync.WaitGroup 类型的变量goRoutineWait。main() 函数体一上来调用了goRoutineWait.Add() 方法，并向其中传入 1。表示即将开启 1 个 Goroutine。紧接着便是启动 Goroutine 了。最后执行了 goRoutineWait.Wait() 方法，该方法将告知程序在此处等待协程任务的完成。在 testFunc() 函数体中，末尾调用了goRoutineWait.Done() 方法，表示协程任务执行完成。

运行这段代码，控制台将得到同样的输出，但不会傻傻地等待 5 秒了。

`💡 提示：从源码中，有一个 Goroutine 计数器。每次调用 goRoutineWait.Add() 方法时，传入的参数便作为累加值使用；调用 goRoutineWait.Done() 方法时相当于让计数器自减 1。当计数器归 0 时，goRoutineWait.Wait() 方法才会结束。`

接下来上升一点难度，如果要连续并发两次 testFunc() 任务，该如何修改上述代码呢？

答案是：

```go
var goRoutineWait sync.WaitGroup
func main() {
   // Goroutine计数器增2
   goRoutineWait.Add(2)
   // 第一次并发调用testFunc()
   go testFunc()
   // 第二次并发调用testFunc()
   go testFunc()
   goRoutineWait.Wait()
   fmt.Println("程序运行结束")
}
// 并发测试函数
func testFunc() {
   defer goRoutineWait.Done()
   for i := 1; i <= 3; i++ {
      fmt.Printf("第%d次运行\n", i)
      time.Sleep(time.Second)
   }
}
```

由于并发两次，所以要向 goRoutineWait.Add() 方法传入 2。程序运行结果为：

> 第 1 次运行
>
> 第 1 次运行
>
> 第 2 次运行
>
> 第 2 次运行
>
> 第 3 次运行
>
> 第 3 次运行
>
> 程序运行结束

在 Go 语言中开启 Goroutine，还可以**通过匿名函数的方式，当代码中只发生一次调用时特别方便**。比如：

```go
func main() {
   goRoutineWait.Add(1)
   go func() {
      defer goRoutineWait.Done()
      for i := 1; i <= 3; i++ {
         fmt.Printf("第%d次运行\n", i)
         time.Sleep(time.Second)
      }
   }()
   goRoutineWait.Wait()
   fmt.Println("程序运行结束")
}
```

这段代码依然会输出：

> 第 1 次运行
>
> 第 2 次运行
>
> 第 3 次运行
>
> 程序运行结束

细心的朋友会发现，在 testFunc() 函数体中，**使用 defer 执行 goRoutineWait.Done()。如此是为了保证即使在执行函数体时发生错误，goRoutineWait.Done() 方法也依然会被调用，从而保证main() 函数的正常运行。** 

> Go 中的 `defer` 语句与 Java 中的 `finally` 块在功能上是相似的。它们都用于确保在函数返回之前执行某些清理代码，无论函数是正常结束还是由于发生错误而提前结束。

### Go 并发原理

#### 任务调度进化史

##### 串行工作机制

1. **单核心处理器时代**：早期的CPU都是单核心，操作系统按顺序执行单个程序，导致CPU资源利用率低。
2. **性能浪费**：单进程执行时，若进程阻塞，CPU将处于闲置状态，造成资源浪费。
3. **易用性问题**：串行执行方式在现代多任务环境中显得效率低下，无法同时进行多项操作。

##### 多进程并发模式

1. **并发概念**：通过时间片切换实现单个CPU核心上的多任务执行。
2. **操作系统调度**：并发机制由操作系统负责进程的创建、切换和销毁。
3. **资源消耗**：频繁的进程切换会导致资源消耗，虽然CPU占用率高，但实际利用率并不理想。

##### 多线程并行模式

1. **超线程技术**：奔腾4处理器引入超线程技术，使得不同线程可以运行在不同CPU核心上，实现真正意义上的并行。
2. **线程分类**：线程分为内核态线程和用户态线程（协程）。内核态线程由CPU调度，协程由协程调度器调度。
3. **调度结构**：内核空间由内核态线程组成，协程在用户空间中，切换更快、更轻量。

下面这张图展示了上述调度结构：

![image-20220419093331601.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/b91b6f165ec644e4a95a29e8a5521418~tplv-k3u1fbpfcp-watermark.png)

图中的橙色线条表示绑定关系，其中隐含了协程调度器和协程队列处理器。

然而，单纯的并行模式也并非万金油。如果一个线程承载了全部协程任务，则仍然无法从分利用多核 CPU。在极端情形下，协程任务的阻塞还会引发整个线程的阻塞，后续的任务得不到执行，整个系统便会卡住。另外，当一个线程中只存在一个协程任务时，也并不会带来性能的提升。

看到这，一种更优的解决方案便浮现了出来，这种方案也是 Go 语言能实现高并发的原理。即**将多个协程绑定在多个线程中，同时将多个线程分配给不同的 CPU 核心运行。如此将并发与并行模式相结合，便打造出了较为理想的任务调度机制。**

#### GPM 任务调度模型

Go 语言中的 GPM 任务调度模型充分利用了多核 CPU 的资源。需要时，将创建与之匹配的线程，并将用户态的协程任务“智能”地分配给多个线程执行。整体上运用的是并行+并发的模式，具体如下图所示：

![图片1.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/70219d596d1e4ef6bdd291469680df8f~tplv-k3u1fbpfcp-watermark.png)

从图中可以看到，整个 GPM 结构分为上下两大部分，我们一起从下往上看，正好对应的是内核空间和用户空间。

首先来看内核空间，这是一颗 4 核心的 CPU（暂时不考虑超线程的情况）。由并行的概念不难得出，4 核心的 CPU 可以由操作系统调度，执行 4 个线程。

**在 Go 程序启动时，会自动根据 CPU 的核心数设置线程的最大数量**。当然，我们也可以通过编码手动设置，稍后会讲到。当一个线程发生阻塞时，新的线程便会创建。图中黄色的线程是一个空闲的线程，它没有绑定任何协程。

再来看用户空间，最上方的全局队列存放所有等待运行的协程任务（即 Goroutine）。下方若干个协程队列，**当发起一个协程任务时，该任务会首先尝试加入到协程队列中。每个协程队列的最大任务数被限制在256个以内**。

当协程队列满了之后，协程调度器会将一半数量的任务移动至全局队列中。至于一共能有多少个协程队列，在 Go 1.5 版本之后**队列数默认为CPU核心数量，也可以通过编码来指定**。

从另一个角度讲，设置了队列数就意味着设置了程序能同时跑多少个 Goroutine 的数量。一般地，在该参数确定后，所有的队列便会一口气创建完成。

在 Go 程序运行时，一个内核空间的线程若想获取某个协程任务来执行，就需要通过协程队列处理来获取特定的协程任务。当队列为空时，全局队列中的若干协程任务，或其它队列中的一半任务会被放到空队列中。如此循环往复，周而复始。

另一方面，**协程队列处理器的数量和线程在数量上并没有绝对关系**。如果一个线程发生阻塞，协程队列处理器便会创建或切换至其它线程。因此，即使只有一个协程队列，也有可能会有多个线程。

#### 动态调整系统资源

在 Go 程序运行时，可以根据需要设置程序要使用的 CPU 资源，也可以动态调整协程任务的执行方式，实现更灵活地运行。这些操作都是通过 runtime 包来实现的。

##### 获取和设置 CPU 核心数量

在 Go 语言中，可以随时获取操作系统类型、CPU 架构类型和 CPU 核心数量，下面的示例代码输出了它们：

```go
// 获取运行当前程序的操作系统
fmt.Println(runtime.GOOS)
// 获取运行当前程序的CPU架构
fmt.Println(runtime.GOARCH)
// 获取运行当前程序的CPU核心数量
fmt.Println(runtime.NumCPU())
```

在 macOS 中，操作系统名称为darwin；在Windows中，操作系统名称即windows；在Linux中，操作系统名称为linux。

**对于 32 位的 CPU，运行结果为 386；对于 64 位的 CPU，运行结果为 amd64；对于 arm 架构 32 位的 CPU，运行结果为 arm；对于 arm 架构 64 位的 CPU，运行结果为 arm64。**

`💡 提示：若要获取Go语言支持的所有操作系统和CPU架构，可执行命令行：go tool dist list。`

若要设置可用的 CPU 核心数，可以通过 runtime.GOMAXPROCS() 函数实现。需要注意的是：该函数将返回设置之前的核心数。

比如，对于一颗多核心的 CPU，若设置程序只能使用一半数量的核心，代码为：

```go
if runtime.NumCPU() > 2 {
   runtime.GOMAXPROCS(runtime.NumCPU() / 2)
}
// 获取当前程序可用的CPU核心数
fmt.Println(runtime.GOMAXPROCS(0))
```

请留意代码最后，当向 runtime.GOMAXPROCS() 函数传入 0 时，即可实现获取可用核心数。

##### 给其它任务“让行”

在程序运行中，某些特定的情况下需要暂停当前协程，让其它协程任务先执行。首先来看下面这段代码：

```go
func main() {
    go fmt.Println("Hello World")
    fmt.Println("程序运行结束")
}
```

显然，由于输出文本被放在了另一个协程中执行。程序将很快结束，甚至在大多数情况下都不会看到 “Hello World” 输出。

若要想正常看到控制台的输出，一种方法便是使用 sync.Wait() 方法，这一招在上一讲中已经介绍过了。另一种方法还可以使主线程中的任务让出资源，优先执行输出文本。方法如下：

```go
func main() {
   go fmt.Println("Hello World")
   runtime.Gosched()
   fmt.Println("程序运行结束")
}
```

如此，便会看到控制台输出：

> Hello World
>
> 程序运行结束

##### 终止自身协程

在某些条件下，我们还希望立即停止协程任务的执行。方法便是使用调用 runtime.Goexit() 函数。下面这段示例代码演示了在满足特定条件时终止协程的方法：

```
func main() {
    syncWait.Add(1)
    go testFunc()
    syncWait.Wait()
    fmt.Println("程序运行结束")
}
func testFunc() {
    defer syncWait.Done()
    for i := 1; i < 100; i++ {
        fmt.Println(i)
        if i >= 5 {
            runtime.Goexit()
        }
    }
}
```

### 并发中的Channel

在前面的示例中，对待协程任务的态度是“放任自流”的。也就是说，一个协程被开启后，我们便不再管它，让它自生自灭，最多是为其它任务让行或终止运行。但在实际开发中，协程任务之间常常会发生通信。

举例来说，现有协程 A 和协程 B，二者都处于运行状态。协程 B 中的某些逻辑需要协程 A 的执行结果作为输入条件，此时就急需将这些结果数据从协程 A 传递给协程 B 了。由此便引出一个问题：如何在并发任务之间进行**数据共享**。

#### CSP并发模型

纵观编程领域，在多任务之间共享数据的方式主要分为两种。

一种是**多线程任务之间的内存共享**，这种方式的代表是 Java、C++、Python 等语言中的多线程开发，这种方式普遍要通过“锁”来确保数据安全。

另一种便是 Go 语言提倡的 **CSP 模型**方式，这种方式的核心思想在于**以通信的方式共享内存数据**。

这两种数据共享的区别主要在于前者是共享内存实现通信，后者是通过通信共享内存。在 Effective Go 中，谈及并发时有这样一句原文：

> Do not communicate by sharing memory; instead, share memory by communicating.

说的就是这个意思。

> `💡 提示：Go语言并非只允许CSP方式并发，它同样支持传统的多线程任务调度方式。` 

随着对 Go 并发领会的逐渐深入，使用得越来越频繁，便会遇到使用 Goroutine 的三个“陷阱”：

1. **Goroutine Leaks（协程任务泄露）**
2. **Data Race（数据竞争）**
3. **Incomplete Work（未完成的任务）**

针对上述 1 和 3，规避的方式就是**确保每一个协程任务可以正常结束**。如果一个协程运行失控，便会长期驻留在内存中，导致系统资源的浪费，出现陷阱 1。或者该执行的任务没有完全完成，导致陷阱 3。

> `💡 提示：想想如何终止协程任务，想想协程中的 defer 的使用。` 

针对上述 2，规避的方式便是**通过传递数据的方式共享数据，而非直接操作某个公共变量**，从而规避数据竞争。

协程任务之间传递数据需要借助通道（Channel）来完成。

#### 通道（Channel）类型

从本质上说，**Go 语言中的通道（Channel）也是一种类型**，只不过在使用时有些特殊，稍后会详述。从分类上看，可将其分为两种。**一种是同步通道，另一种是缓冲通道**。

同步通道有点类似于送外卖的过程。若外卖小哥和点餐顾客分别为协程 A 和协程 B，只有当协程 A 把数据（即外卖）送给协程 B（即顾客），协程 B 才能开始执行后续的操作（即吃外卖）。否则，协程 B 只能一直等待数据（即外卖）的到来。

缓冲通道则有点类似于送快递的过程。若快递员和收件人分别为协程 A 和协程 B，协程 A 可以把数据（即快递）放到缓冲区（即菜鸟驿站）。当协程 B 需要时，只要去缓冲区（即菜鸟驿站）中取数据（即快递）即可。

值得一提的是，缓冲区和菜鸟驿站真的很像，它们都有最大容量限制。一旦协程 A 发现缓冲区（即菜鸟驿站）满了，就不得不等待数据（即快递）被取走，才能将数据（即快递）放到空余的位置中。

同步和缓冲，这两种方式孰优孰劣呢？其实并没有特别明确的定论，我们只要根据实际情况，选择合适的方式就是最优的。

##### 同步通道

理论部分到此为止，接下来实际演练。我们一起实现如下编程需求：

假设我们正在饲养一只母鸡，等待其下蛋。每下一个蛋，我们就拿来做荷包蛋吃。

为了使用同步通道，我们使用两个协程来实现上述需求。协程 A 代表母鸡，它的作用是产蛋，并将产蛋的数量传给协程 B，我们将协程 A 的代码逻辑封装成名为 layEggs() 函数。协程 B 表示吃荷包蛋，等待传入可用的鸡蛋数量，然后输出文字：“吃 x 个荷包蛋”（x 表示鸡蛋数量）。我们将协程B的代码逻辑封装成名为 eatEggs() 函数。

如前文所述，通道（Channel）也是一种数据类型。因此，为了让 layEggs() 和 eatEggs() 都能使用通道类型变量，将通道声明为全局公共变量。该通道将传送鸡蛋的数量，其传送的数据类型是 int，所以我们把它命名为 intChan。具体代码实现如下：

```go
var intChan = make(chan int)
```

这句代码中，**chan 即表明通道类型，紧接着的 int 表示通道上传送的数据的类型。make() 的目的则是创建通道**。最终的 intChan 变量就是通道类型的变量了。如果使用下面的代码输出 intChan 及其类型：

```go
func main() {
   fmt.Println(intChan)
   fmt.Println(reflect.TypeOf(intChan))
}
```

可以得到如下结果：

> 0xc00001a0c0
>
> chan int

接下来实现 layEggs()函数，该函数需要向通道中传出数据，方法是**使用箭头操作符**。在传送结束后，**别忘了调用 close()函数关闭通道，关闭通道时需要指定通道**。具体实现代码如下：

```go
func layEggs() {
   intChan <- 1
   close(intChan)
}
```

如此，便可将 1 通过 intChan 传出。

接着，再来实现 eatEggs() 函数。该函数需要从通道中取数据，方法依然是**使用箭头操作符**，只不过方向上刚好和传出数据相反。具体实现代码如下：

```go
func eatEggs(intChan chan int) {
   eggCounts := <-intChan
   fmt.Printf("吃%d个荷包蛋", eggCounts)
}
```

这里的 eggCounts 便是 int 型数据了。请注意这里的箭头操作符，虽然看上去和传出数据的方向相同，但由于主体角色发生了转变，实际上是相反的。但不能将 “<-” 改为 “->” 。

最后，整合这两个函数，完善 main() 函数，并使用 sync.WaitGroup 类型变量确保协程任务能够完全执行。整体代码如下：

```go
var syncWait sync.WaitGroup
// 创建通道类型变量，该通道将传送int类型数据
var intChan = make(chan int)
func main() {
   // 执行2个协程任务
   syncWait.Add(2)
   // 开启下蛋任务
   go layEggs()
   // 开启吃荷包蛋任务
   go eatEggs(intChan)
   // 等待协程任务完成
   syncWait.Wait()
}
func layEggs() {
   // 使用断言确保协程任务正常结束
   defer syncWait.Done()
   // 向通道传送int类型值
   intChan <- 1
   // 关闭通道
   close(intChan)
}
func eatEggs(intChan chan int) {
   // 使用断言确保协程任务正常结束
   defer syncWait.Done()
   // 从通道获取int类型值
   eggCounts := <-intChan
   // 输出结果
   fmt.Printf("吃%d个荷包蛋", eggCounts)
}
```

运行这段代码，程序输出：

> 吃1个荷包蛋

>  `❗️ 注意：使用同步通道时，要确保传出数据和获取数据必须成对出现。另外，一旦通道被关闭，便不能再向其中传出数据了。`

##### 缓冲通道

和同步通道不同，带缓冲的通道有点类似于快递员（协程 A）和收件人（协程 B）的关系，在他们之间存在一个快递驿站（缓冲区）。寄送快递时，快递员会默认将快递放到驿站中，收件人可以找个合适的时间去驿站中取快递。当驿站放满快递时，新的快递便无法存入其中，必须等待旧的快递被取走。这个过程描述的便是带缓冲的通道的工作流程。

在上述同步通道的代码中，intChan 就是构建的同步通道，通道内允许传送的数据类型是 int 型。main() 函数中开启了两个协程任务，分别是 layEggs() （产蛋）和 eatEggs() （吃蛋）。前者将会向同步通道中传出 1，表示产出 1 个蛋；后者从同步通道中读取值， 结果为 1，表示拿出 1 个蛋来吃。

在现实生活中，如果要统计一只鸡一周能产多少个鸡蛋，用上述同步方法就不是特别合适了。我们通常会用一个容器来存放这只鸡每天产下的鸡蛋，然后在 7 天后数容器内的鸡蛋的数量，便可得知这只鸡在这周产下的鸡蛋总数了。这里的“容器”其实就是缓冲通道中的缓冲区了。

若要实现这种统计并非难事，只需将上述代码稍加修改即可。

首要任务就是修改通道的创建模式，根据示例要求，需要统计 7 天的产蛋总量，我们便可将缓冲区的容量定为7。具体代码修改如下：

```go
const DaysOfWeek = 7
var intChan = make(chan int, DaysOfWeek)
```

这里声明了一个常量，表示一周的天数，同时也规定了 intChan 通道的缓冲区大小就是 7。考虑到稍后在发送和接收时都需要用到缓冲区大小值，所以将该常量声明为全局可访问的。

请大家留意**同步通道和缓冲通道在声明时的区别，只在于是否定义缓冲区的大小。当缓冲区大小的值为 0 时，通道的类型将为同步通道。**

接下来只考虑产蛋的部分，即数据的发送端。假设这只鸡 7 天中每一天都会产下 1 个鸡蛋，且每天都将产下的鸡蛋拿到盛蛋的容器中。我们使用一个 for 循环结构来描述这个过程，将 layEggs() 函数修改如下：

```go
func layEggs() {
	defer syncWait.Done()
	for i := 0; i < DaysOfWeek; i++ {
		time.Sleep(time.Millisecond * 500)
		intChan <- 1
         fmt.Println("产鸡蛋了")
	}
	close(intChan)
}
```

在每次 for 循环一开始，都延迟了 0.5 秒执行，表示 1 天。

接着再来考虑收集鸡蛋的过程，和产蛋类似，该过程每天都进行一次，因此也可使用 for 循环来描述，具体代码如下：

```go
func collectEggs(intChan chan int) {
   defer syncWait.Done()
   var eggCounts int
   for i := 0; i < DaysOfWeek; i++ {
      eggCounts += <-intChan
      fmt.Println("鸡蛋被收集了")
   }
   fmt.Printf("本周共产%d个鸡蛋\n", eggCounts)
}
```

最后，保持 main() 函数不做修改，运行整个代码，可以观察到控制台如下输出：

> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 本周共产7个鸡蛋

显然，“产鸡蛋了”和“鸡蛋被收集了”成对出现 7 次。表示这只鸡每天会产 1 个鸡蛋，这颗鸡蛋也会被按天收取。最终程序输出了一周产蛋总数为 7 颗，程序运行结束。

在使用同步通道时，一个强制性的要求便是每次发送和接收都必须成对存在。反之，在使用缓冲通道时则没有如此强制性的要求。就拿上例来说，虽然这只鸡在 7 天内每天都会产鸡蛋，但如果将收集鸡蛋的工作安排在周一至周五，即 5 天，就需要将 connectEggs() 函数体中循环的终止条件改为 i<5 。如此修改后，程序依然会正常运行，产鸡蛋的工作同样会执行 7 次，但收鸡蛋的工作只会执行 5 次。具体控制台输出将如下所示：

> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 本周共产5个鸡蛋
>
> 产鸡蛋了
>
> 产鸡蛋了

可以看到，“产鸡蛋了”和“鸡蛋被收集了”成对出现 5 次。

如果更激进一些，从 main() 中去掉 collectEggs() 函数的调用，程序还能正常运行吗？

答案是：**肯定的**。试想一下，现实生活中的快递驿站并不会因某个人没取快递而关门，快递员也不会关心收件人是否取快递，只需将快递放到驿站就大功告成了。本例中的鸡产鸡蛋也是类似的道理，无论鸡蛋被怎样处理，它该下蛋还是会下蛋。

#### 构建安全的通道

在接下来的内容中，我将为大家介绍两个重要的有助于增强通道健壮性的方法，即通道的关闭和单向通道的构建。

##### 通道的关闭

不知道大家注意到没有，小册中有关通道的示例在发送数据后都会调用内置的 close() 函数关闭通道。实际上，在关闭通道方面也是有一些讲究的。

正如前面的示例那样，我们应该**只让某个通道的唯一发送者关闭该通道**，这是关闭通道的原则之一。试想，如果多个发送者共用相同的通道，且都会在某种条件下关闭。那么一旦关闭了该通道，其它发送者就再也没有机会使用通道发送数据了。

从另一个角度讲，**发送者最好使用各自的通道**。当然，如果非要多个发送者共用一个通道，**可以通过恢复机制来规避程序宕机**。但这样做是不推荐的，因为它违反了关闭通道的原则。

> `❗️ 注意：通道关闭后，无法再通过它发送数据，但不会影响数据的接收。`

除此之外，关闭通道还有一个原则是**不允许关闭一个已经关闭了的通道**。否则也会引发程序宕机，错误信息为：panic: close of closed channel。由此便引出一个问题：如何判断通道已经关闭了呢？

我们可以通过**尝试从通道中接收值来判断通道是否关闭**。我们将本讲示例代码中的 collectEggs() 函数稍加修改如下：

```go
func collectEggs(intChan chan int) {
   defer syncWait.Done()
   var eggCounts int
   for i := 0; i < DaysOfWeek; i++ {
      eggCounts += <-intChan
      fmt.Println("鸡蛋被收集了")
   }
   _, isOpen := <-intChan
   if !isOpen {
      fmt.Printf("本周共产%d个鸡蛋\n", eggCounts)
   }
}
```

请各位留意最后 5 行代码。尝试从通道接收值时，除了可以得到值本身外，还可得到一个布尔类型的值。当这个布尔类型的值为 true 时，通道打开；反之，则表示通道已经被关闭了。

如上修改后，控制台输出结果不变。

另外，使用 for-range 循环结构可简化上述代码。当通道关闭后，for-range 循环会自动跳出。下面的代码与上面的代码具有同样的运行结果。

```go
func collectEggs(intChan chan int) {
   defer syncWait.Done()
   var eggCounts int
   for intValue := range intChan {
      eggCounts += intValue
      fmt.Println("鸡蛋被收集了")
   }
   fmt.Printf("本周共产%d个鸡蛋\n", eggCounts)
}
```

##### 单向通道的使用

在实际项目中，有时候需要**特别规定数据的流向，以确保其正确性**。这有点类似于单行道和双向车道，前者只能按照规定的方向行驶，后者来去都是自由的。

本讲案例中， layEggs() 和 collectEggs() 都使用了 intChan 通道。但很明显，前者只负责数据的发送，后者只负责数据的接收。像这种情况，我们就可以基于 intChan ，构建只能发送的通道，用于 layEggs() 函数；构建只能接收的通道，用于 collectEggs() 函数。

`💡 提示：单向通道不是凭空声明的，它需要基于已有的通道。` 

结合本例，下面的代码基于已有的 intChan 创建了名为 readOnlyIntChan 的只接收通道：

```go
var readOnlyIntChan <-chan int = intChan
```

这句代码中， <-chan 表示只接收通道。与其相反， chan<- 则表示只发送通道。下面的代码基于已有的 intChan 创建了名为 sendOnlyIntChan 的只发送通道：

```go
var sendOnlyIntChan chan<- int = intChan
```

