---
title: 零基础通关
tags:
  - Go
categories:
  - Go
date: '2025-01-03'
description: 欢迎使用 Curve 主题，这是你的第一篇文章
articleGPT: 这是一篇初始化文章，旨在告诉用户一些使用说明和须知。
#cover: "/images/logo/logo.webp"
---

# 零基础通关

## 知识大纲

![小册知识点结构.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/4a076b7d583e435c83acd7515d741928~tplv-k3u1fbpfcp-watermark.png)

## 环境搭建

> https://golang.google.cn/dl/ 中文镜像

### 第一个Go程序

使用 vi 或启动任何一个纯文本编辑器，输入如下内容：

```go
package main
import "fmt"
func main(){
    fmt.Println("Hello World!")
}
```

将其保存为 hello.go。 接下来，启动终端，导航至 hello.go 所在目录，然后执行以下命令，编译 hello.go 程序：

```bash
go build hello.go
```

稍等片刻，程序编译完成。编译完成后将生成名为 hello 的可执行文件。在终端执行这个文件，可以看到 “Hello World!” 字样的文本输出，如下图所示：

```shell
(base) jiangbolun@jiangbolundeMacBook-Pro-2 main % ./hello 
Hello Word!% 
```

> 注意：
> Go 语言要求包含 `main` 函数的文件必须声明为 `package main`。这是生成可执行文件的关键。

## 源码结构以及命令行工具

### Go程序源码结构

```go
package main
import "fmt"
func main(){
    fmt.Println("Hello World!")
}
```

接下来，我们简单解释代码。

1. 第一行内容为 “package main”，它表示这个源码文件属于 main 包。main 包是每个 Go 应用程序都包含的包，有且只有一个。
2. 从第三行开始到最后，是 main() 函数，这个函数比较特殊，它是 Go 程序的“入口”函数，是程序运行的起点。这个函数必须存在且只能存在一个，且必须声明在 main 包中。任何一个 Go 函数都要求使用成对的大括号将函数体包裹起来。

### Go SDK 命令行工具

#### go build

> go build 命令的作用是编译 Go 源码，并生成可执行的文件。

从原理上说，Go SDK 自 1.9 版本开始就支持并发编译了，能尽可能地发挥电脑的最大性能完成编译，所以 Go 源码的编译速度是非常快的。在编译过程中，除了我们自己写的代码外，如果使用了第三方的包，这些包会被一同编译。当我们执行 go build 命令后，会搜索当前目录下的 go 源码并完成编译。

go build 命令还允许附加参数，方便开发者对编译参数进行配置，具体如下表所示：

| 参数名 | 作用                                                         |
| ------ | ------------------------------------------------------------ |
| -v     | 编译时显示包名                                               |
| -p x   | 指定编译时并发的数量（使用x表示），该值默认为CPU的逻辑核心数 |
| -a     | 强制进行重新构建                                             |
| -n     | 仅输出编译时执行的所有命令                                   |
| -x     | 执行编译并输出编译时执行的所有命令                           |
| -race  | 开启竞态检测                                                 |

此外，如果我们希望只编译某个 go 源码文件或包，可在 go build 命令后添加文件或包名。例如，现有 file1.go、file2.go 和file3.go，我们只希望编译 file1.go，便可如下执行：

```bash
go build file1.go
```

#### go clean

go clean 命令可以清理当前目录内的所有编译生成的文件，具体包括：

-   当前目录下生成的与包名或者 Go 源码文件同名的可执行文件，以及当前目录中 _obj 和 _test 目录中名为 _testmain.go、test.out、build.out、a.out 以及后缀为 .5、.6、.8、.a、.o和 .so 的文件，这些文件通常是执行go build命令后生成的；
-   当前目录下生成的包名加 “.test” 后缀为名的文件，这些文件通常是执行 go test 命令后生成的；
-   工作区中 pkg 和 bin 目录的相应归档文件和可执行文件，这些文件通常是执行 go install 命令后生成的。

go clean 命令还允许附加参数，具体参数和作用如下表所示：

| 参数名     | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| -i         | 清除关联的安装的包和可运行文件，这些文件通常是执行go install命令后生成的 |
| -n         | 仅输出清理时执行的所有命令                                   |
| -r         | 递归清除在 import 中引入的包                                 |
| -x         | 执行清理并输出清理时执行的所有命令                           |
| -cache     | 清理缓存，这些缓存文件通常是执行go build命令后生成的         |
| -testcache | 清理测试结果                                                 |

在团队式开发中，通常在每次提交代码前执行 go clean 命令，防止提交编译时生成的文件。

#### go run

go run 命令的作用是直接运行 go 源码，不在当前目录下生成任何可执行的文件。

从原理上讲，go run 只是将编译后生成的可执行文件放到临时目录中执行，工作目录仍然为当前目录。同时，go run 命令允许添加参数，这些参数将作为 go 程序的可接受参数使用。

由此可见，go run 命令同样会执行编译操作。但要注意的是，go run 不适用于包的执行。

#### gofmt

gofmt 命令的作用是将代码按照Go语言官方提供的代码风格进行格式化操作。

请大家注意，**gofmt和go fmt是两个不同的命令**。go fmt 命令是 gofmt 的封装，go fmt 支持两个参数：-n 和 -x，分别表示仅输出格式化时执行的命令，以及执行格式化并输出格式化时执行的命令。

执行 gofmt 命令时，可指定文件或目录，也可不指定。当不指定时，gofmt 命令会搜索当前目录中的 go 源码文件，并执行相应的格式化操作。

gofmt 命令还允许附加参数，具体参数和作用如下表所示：

| 参数名               | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| -l                   | 仅输出需要进行代码格式化的源码文件的绝对路径                 |
| -w                   | 进行代码格式化，并用改写后的源码覆盖原有源码                 |
| -r rule              | 添加自定义的代码格式化规则（使用rule表示），格式为：pattern -> replacement |
| -s                   | 开启源码简化                                                 |
| -d                   | 对比输出代码格式化前后的不同，依赖diff命令                   |
| -e                   | 输出所有的语法错误，默认只会打印每行第1个错误，且最多打印10个错误 |
| -comments            | 是否保留代码注释，默认值为true                               |
| -tabwidth x          | 用于指定代码缩进的空格数量（使用x表示），默认值为8，该参数仅在-tabs参数为false时生效 |
| -tabs                | 用于指定代码缩进是否使用tab（“\t”），默认值为true            |
| -cpuprofile filename | 是否开启CPU用量分析，需要给定记录文件（使用filename表示），分析结果将保存在这个文件中 |

`💡 提示：使用-s参数进行源码简化的规则请参考：https://pkg.go.dev/cmd/gofmt#hdr-The_simplify_command`

#### go install

go install 命令的作用和 go build 类似，都是将源码编译为可执行的文件，附加参数也基本通用，这里就不再赘述了。区别在于：

-   go install 命令在编译源码后，会将可执行文件或库文件安装到约定的目录下；
-   go install 命令生成的可执行文件使用包名来命名；
-   默认情况下，go install 命令会将可执行文件安装到 GOPATH\bin 目录下，依赖的三方包会被安装到 GOPATH\bin 目录下。

#### go get

go get 命令的作用是获取源码包，这一操作包含两个步骤，分别是下载源码和执行 go install 命令进行安装。使用时，仅需将源码仓库地址追加到 go get 后即可（访问<https://pkg.go.dev/>，搜索包名，在包详情页可以找到仓库地址），例如：

```bash
go get github.com/ethereum/go-ethereum
```



go get 命令还允许附加参数，具体参数和作用如下表所示：

| 参数名    | 作用                                             |
| --------- | ------------------------------------------------ |
| -d        | 仅下载源码包，不安装                             |
| -f        | 在执行-u参数操作时，不验证导入的每个包的获取状态 |
| -fix      | 在下载源码包后先执行fix操作                      |
| -t        | 获取运行测试所需要的包                           |
| -u        | 更新源码包到最新版本                             |
| -u=patch  | 只小版本地更新源码包，如从1.1.0到1.1.16          |
| -v        | 执行获取并显示实时日志                           |
| -insecure | 允许通过未加密的HTTP方式获取                     |

若要指定所获取源码包的版本，可以通过添加 “@版本号” 的方式执行。如：

```bash
go get github.com/ethereum/go-ethereum@v1.10.1
```

在使用 Go SDK 1.17 版本时，有一点需要额外注意：执行 go get 命令可能会收到警告，大意是 go get 命令是不建议使用的。此时，使用go install替换 go get 即可，原因是在未来的 Go SDK 版本中 go get 的作用等同于 go get -d。

如果你对 “go get” 命令感兴趣，可以阅读官方对它的说明，写的非常详细：<https://docs.studygolang.com/doc/go-get-install-deprecation>

### debug

goland	debug 时会失效：

> undefined behavior - version of Delve is too old for Go version 1.23.5 (maximum supported version 1.20) 15

因依赖问题要求GO版本需要从1.18.x版本升级到1.23.x，升级后，Test 启动 debug时，发现打断点的红点一闪而过，出现一个失效的标志（一个灰色圆圈+斜杠），在经过百度大法后，原来高版本（1.20及以上版本）会出现debug断点无效的现象。

经过资料查阅，发现是因为go高版本问题，导致dlv插件失效，[github](https://so.csdn.net/so/search?q=github&spm=1001.2101.3001.7020)上提供了源代码，可以clone下来打包，并把dlv文件放到指定的目录。

1. Git clone

   ```shell
   git clone https://github.com/go-delve/delve.git
   ```

2. #### 编译并打包成dlv可执行文件

   ```
   cd cmd/dlv
   
   go build
   ```

   执行完毕后，当前目录下多出一个dlv可执行文件 

3. #### 复制dlv文件到goland插件目录

   - goland 新版本（大于等于23年版本）

     ```
     cp dlv /Applications/GoLand.app/Contents/plugins/go-plugin/lib/dlv/mac
     ```

     

   - goland老版本（小于23年版本）

     ```
     cp dlv /Applications/GoLand.app/Contents/plugins/go/lib/dlv/mac
     ```

## 基础语法

### 命名规范

- 对于变量，除了首个单词外，每个单词的首字母用大写表示，这种命名法通常被称为小驼峰式命名法；若所有单词的首字母均大写，则成为大驼峰式命名法（又被称为帕斯卡命名法）。由于变量有可见性（有关可见性的更多内容，将在结构体/包中介绍。）之分，对于对外可见的变量，使用大驼峰法；对于对外不可见的变量，使用小驼峰法。特别地，若变量/常量是布尔类型，最好以is、allow、has、can之类来开头；
- 对于常量，单词均用大写字母来表示，每个字母之间使用下划线来分割。

```go
// 变量声明
var exampleNumberA int = 10
var isDarkMode bool = false
// 常量声明
const WIDTH_OF_RECT int = 12
const ALLOW_DOWNLOAD_WHEN_WIFI bool = true
```

### 声明与赋值

**在Go语言中，变量或常量的数据类型必须先声明，才能使用**，且无法将不相关的数据赋值给它们。

这是因为Go语言和Java、C、C++等语言一样，属于静态语言，静态语言具有更严谨的结构要求、调试便捷（可通过代码直观地看到数据类型）与确保类型安全（无法使用不同类型的数据赋值）的特点，必须要先做声明。而像PHP、Python、JavaScript等动态语言则没有这个限制。

#### 变量的声明与赋值

在Go语言中，声明变量的一般格式为：

```Go
var name type
```

- 其中，var是声明变量的关键字，固定不变，表明意图——要声明一个变量
- type表示该变量所属的数据类型。

```Go
// 声明一个名为number的变量，类型为int（整数类型）
var number int
// 为number赋值
number = 100

// 变量声明
var number int = 100
```

#### 常量的声明与赋值

常量声明和赋值的一般格式为：

```Go
const name type = value
```

其中，const是声明常量的关键字，固定不变，表明意图，要声明一个常量；name和type的意义与声明变量时一样；value是常量的值。如：

```Go
// 声明一个名为PI的常量，类型为float64（浮点数类型）
const PI float64 = 3.14
```

`❗️ 注意： 声明常量时，必须为其赋值，且后续无法修改。`

#### Go语言的类型推断

使用Go语言可简化代码，类型推断体现了这一点。当声明与赋值一并进行时，如果数据为Go内置的基础类型，则可无需指定类型。如：

```Go
// 变量声明
var number = 100
// 常量声明
const PI = 3.14
```

无需担心，由于number的值为100，Go语言会推断出它的类型为整数型。同理，PI也会被推断为浮点数型。

对于变量，还有一种超级精简的声明和赋值方式，示例如下：

```Go
//变量声明
number := 100
```

`❗️ 注意： 冒号等于号“:=”的作用是声明和赋值，若number是已经声明过的变量，则无法使用 := 的方式赋值。`

#### 批量声明/赋值

为了方便多个变量/常量的声明和赋值，我们还可以批量处理它们，示例如下：

```Go
//变量
var (
        // 声明 + 赋值
        number int = 100
        // 声明 + 赋值（类型推断）
        text = "Hello"
        // 只声明
        name string
)
//常量
const (
        // PI 声明 + 赋值
        PI float64 = 3.14
        // WIDTH 声明 + 赋值（类型推断）
        WIDTH  = 5
        // HEIGHT 声明 + 赋值（类型推断）
        HEIGHT = 10
)
```

### 指针类型

> 在上一讲中，我们介绍了Go语言的基本数据类型，学会了如何对变量进行声明和赋值，也知道了在这个过程中会在内存开辟空间方便它们“安家”。那如何才能找到这个“家”呢？这就涉及到了指针。
>
> 通过使用指针，开发者可以直接访问内存中的数据，从而可以实现对数据的精准管理以及运算。
>
> 如果说变量名是数据的“代号”，那么指针存放的则是数据的“**实际地址**”，我们可以通过这个地址获取或修改存放于这个地址的变量的值。
>
> 存放整数值的变量称为整型变量，存放布尔值的变量称为布尔变量……类似地，存放指针值的变量称为指针变量。
>
> 那么问题来了，想要获取或改变某个变量的值，直接通过变量名就可以实现了。而且像Java之类的编程语言几乎不会用到指针，**那Go为何还要用指针呢？**
>
> `❗️ 注意： 实际上，Java中的指针操作封装在JDK中，普通开发者一般不会接触到，所以会误认为Java没有指针。`

我们不妨先了解一下Go语言中的指针，它主要由两大核心概念构成：**类型指针**和**切片指针**。

- 类型指针：在**传递数据**时直接使用指针，可以避免创建数据的副本，节约内存开销。类型指针不能进行偏移和运算，可以**避免非法修改**为其它数据的风险，也更**有利于垃圾回收**机制及时找到并回收它们；

- 切片指针：切片由**指向起始元素的指针**、元素数量和总容量构成。当访问切片发生越界时，会发生宕机并输出堆栈信息。宕机是**可以恢复**的，而崩溃只能导致程序停止运行。

可见，**使用指针更有利于程序运行的性能和稳定性**。另外，在某些操作中，如使用反射修改变量的值，必须使用可寻址的变量（通过指针）。

在实际应用中，最为常用的便是获取变量的内存地址，以及获取某个地址对应的值。在Go语言中，前者使用“&”运算符，后者使用“*”运算符。它们互为反向操作，操作的对象也不同。具体请看下面的示例：

```Go
// exampleNumberA变量（整数型变量）声明和赋值
var exampleNumberA int = 10
// 获取exampleNumberA的地址，并赋值给exampleNumberAPtr变量（exampleNumberAPtr的类型是指针类型）
exampleNumberAPtr := &exampleNumberA
//输 出exampleNumberAPtr变量的值（将输出内存地址）
fmt.Println(exampleNumberAPtr)
// 获取exampleNumberAPtr（指针变量）表示的实际数据值，并赋值给exampleNumberAPtrValue变量（整数型变量）
exampleNumberAPtrValue := *exampleNumberAPtr
// 输出exampleNumberAPtrValue变量（整数型变量）的值
fmt.Println(exampleNumberAPtrValue)
```

运行后，控制台输出：

> 0xc00001a088 
> 10

上面的代码示例演示了如何使用已有的变量创建指针类型变量。我们还可以使用new()函数直接创建指针变量，相当于在内存中创建了**没有变量名**的**某种类型**的**变量**。

这样做无需产生新的数据“代号”，取值和赋值转而通过指针变量完成。常用在无需变量名或必须要传递指针变量值的场景中。

new()函数的使用格式如下：

```Go
new(type)
```

其中，type是所在地址存放的数据类型。一旦完成创建，便会在内存中“安家”，完成内存分配，即使没有赋值。

具体代码示例如下：

```Go
// 使用new()函数创建名为exampleNumberAPtr指针类型变量，表示int64型值
exampleNumberAPtr := new(int64)
// 修改exampleNumberAPtr表示的实际数据值
*exampleNumberAPtr = 100
// 获取exampleNumberAPtr表示的实际数据值
fmt.Println(*exampleNumberAPtr)
```

程序运行后，控制台将输出：

> 100

## 流程控制

### 循环结构

循环结构的格式如下：

```go
for init; condition; post {
    //循环体代码块
}
```

其中，for表明接下来的代码是for循环结构；init是初始化语句；condition是关系或逻辑表达式，值为true时则会停止循环；post是每次循环结束后执行的语句；循环体代码块就是要重复执行的代码了。

比如我们要输出：
![image-20250124134602852](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250124134602852.png)

我们用这个循环结构实现：

```go
package main

import "fmt"

func main() {
	n := 7
	for i := 1; i <= n; i++ {
		for j := 0; j < n-i; j++ {
			fmt.Print(" ")
		}
		for k := 0; k < 2*i-1; k++ {
			fmt.Print("*")
		}
		fmt.Println()
	}
	for i := 1; i < n; i++ {
		for j := 0; j < i; j++ {
			fmt.Print(" ")
		}
		for k := 0; k < 2*n-1-2*i; k++ {
			fmt.Print("*")
		}
		fmt.Println()
	}
}
```

### 流程控制语句

流程控制语句多用于管理循环结构的运行。考虑这样一个需求：编程实现查找1-10以内的素数。

```go
func main() {
	for i := 2; i > 0; i++ {
		//当i大于10s
		if i > 10 {
			break
		}
		if i == 2 {
			fmt.Println(i)
			continue
		}
		//假定i为素数
		flag := true
		for j := 2; j < i; j++ {
			if i%j == 0 {
				//当i能被某个整数整除时，不是素数
				flag = false
				break
			}
		}
		//如果依旧为true，则i为素数
		if flag {
			fmt.Println(i)
		}
	}
}
```





## 数组、切片和集合

### 数组

Go语言中声明数组的一般格式为：

```go
var array_name [quantity]Type
```

其中，var关键字用于声明变量；array_name表示数组名；quantity表示数组元素个数；Type表示元素类型。例如：

```go
var resultArray [4]int
```

声明后即可为单个元素赋值了。和其它的编程语言类似，要为数组中的某个元素赋值，格式为：

```go
array_name[index] = Value
```

例如：

```go
resultArray[2] = 5
```

### 切片

使用数组来存放一些结果，很容易引发下标越界错误。和数组相对，Go语言还提供了一种专门存放**不定元素个数**的数据结构——切片。

在Go语言中，切片的声明一般格式为：

```go
var slice_name []Type
```

其中，var关键字用于声明变量；slice_name表示切片名；Type表示元素类型。

> `💡 提示： 注意到了吗？声明切片和数组的区别仅仅是去掉了中括号中的元素个数！`

例如：

```go
var resultSlice []int
```

> `❗️ 注意： 和数组类似，切片中的元素也不限制值的类型，但要求所有元素均为相同的类型。`

完成切片的声明后，就来到赋值环节。

与数组不同，为切片赋值可以理解为“**扩充**”。在一开始，切片里面的元素个数为0。“扩充”一个值，就相当于为切片中的第一个元素赋值。赋值后，切片的元素个数就变成了1。若再次“扩充”，则相当于为切片中的第二个元素赋值。赋值后，切片的元素个数就变成了2，以此类推……

在Go语言中，为切片“扩充”需要使用append()函数，使用格式如下：

```go
slice_name = append(slice_name, value)
```

其中，slice_name表示已声明的切片变量名，value表示具体的数据值。

值得一提的是，**append()函数本身并不会改变原有切片**，只是将切片“扩容”后的结果作为函数返回值。因此，需要将“扩容”后的结果再次（即函数返回值）赋值给slice_name，才能真正使slice_name发生改变。

例如：

```go
resultSlice = append(resultSlice, value)
```

在实际项目中，切片的使用其实更为广泛。例如：当用户发起搜索，搜索的结果个数往往会根据搜索关键字的不同而发生变化。在不确定总数的前提下，使用数组显然是不合适的。

### 集合

使用数组不合适，那使用什么呢？答案是：集合。我们考虑另一个场景——管理学生信息。

如何保存和查找一所学校所有学生的信息呢？通过姓名显然是不合适的，因为会有重名的情况。通过年级+姓名呢？显然也是不合适的，因为这可能会执行两次筛选，而且也无法从根本上排除重名的情况。所以，我们应使用一个能标识一个学生**唯一性**的数据作为保存和查找的依据。比如：学号。

一个学号对应一个学生，保存时如此，查找时亦如此。

> `💡 提示： 与此类似的管理方式还有身份证号、驾驶证号、商品ID、图书ISBN等等。这些能标识唯一性的值可以统称为“唯一ID”。在实际项目中，为了保证单条数据的唯一性，为其构建唯一ID号是非常有必要的。`

像上述这种唯一ID对应单条数据，可以使用集合来管理。集合可以看作是一类特殊的切片，只不过集合的元素都是由若干“**键-值对**”数据构成的。所谓“键”，相当于“唯一ID”；“值”，相当于单条数据，**键不允许重复**。

Go语言中声明集合的一般格式为：

```go
var map_name = make(map[key_type]value_type)
```

`❗️ 注意： 和数组、切片类似，集合中的键和值均不限制数据类型，且键和值可分别使用不同的类型。但要求所有键均为相同的类型，所有值均为相同类型。`

其中，var用于声明变量；map_name表示集合的变量名；key_type表示键的类型；value_type表示值的类型。

对于本例而言，学号和学生信息都使用string类型来表示，集合的变量名为studentInfos。对应的代码为：

```go
var studentInfos = make(map[string]string)
```

集合中元素的赋值和数组类似，只不过中括号中不再是索引，而是键的值。例如，保存学号为“0001”的学生，名为“王小红”，代码实现为：

```go
studentInfos["0001"] = "王小红"
```

以此类推，继续增加4条信息，完整的代码如下：

```go
func main() {
   var studentInfos = make(map[string]string)
   studentInfos["0001"] = "王小红"
   studentInfos["0002"] = "李小明"
   studentInfos["0003"] = "张三丰"
   studentInfos["0004"] = "孙小贝"
   studentInfos["0005"] = "何明明"
   // 输出语句
   fmt.Println(studentInfos)
}
```

程序运行结果为：

> map[0001:王小红 0002:李小明 0003:张三丰 0004:孙小贝 0005:何明明]

值得一提的是，若对一个已经存在数据的“键”再次赋值，原有的数据将被**覆盖**。比如，在本例输出语句前添加：

```go
studentInfos["0003"] = "周丹"
```

再次运行本例，结果则变为：

> map[0001:王小红 0002:李小明 0003:周丹 0004:孙小贝 0005:何明明]

在实际项目中，充分利用集合键唯一的性质，还可以确保**排除重复**的数据。

### 循环遍历

除了for循环外，Go语言还提供了range关键字。与for结合，也可以实现循环遍历，其使用格式如下：

```go
for index, value := range variable {
    // 循环体
}
```

其中，index表示索引或键的值；value表示元素的值；variable表示数组、切片或集合变量；由大括号包裹的部分是循环体，可以使用index和value变量。

for 循环对比 for-range：

- 使用`for`循环：

```
slice := []int{1, 2, 3, 4, 5}
for i := 0; i < len(slice); i++ {
    fmt.Println(slice[i])
}
```

- 使用`range`：

```
slice := []int{1, 2, 3, 4, 5}
for i, v := range slice {
    fmt.Println(i, v)
}
```

`range`自动处理了索引`i`和值`v`的赋值，并且代码更加简洁。

这种for与range结合实现循环遍历的结构，也被称为**for-range结构**。这种结构同样适用于数组和切片。

## 函数

### 普通函数的定义和调用

在Go语言中，定义一个普通函数的格式如下：

```go
func function_name([params_list])([return_values_list]){
    // 函数体
}
```

其中，func关键字表示定义一个函数；function_name是函数名；params_list表示参数列表；return_values_list表示函数的返回值列表；使用大括号包裹起来的部分称为函数体，是函数内部要执行的代码。其中，参数列表和返回值列表是可选的。有些函数无需参数，有些参数运行后并不会有任何返回值，有些函数则无需参数也无需返回值。

先举个简单的例子，下面的函数实现了将参数（即传入的string类型字符串）作为返回值（类型也为string）输出。

```go
func stringLoop(content string) string {
   return content
}
```

这段代码一共有三行，我们逐行拆解：

 - 第一行定义了名为stringLoop的函数，参数列表中，content是参数名，string是参数的类型。当需要多个参数是，使用英文的逗号（,）隔开。再往后表示该函数运行后将返回string类型的结果；
 - 第二行是函数体，return表示返回函数运行的结果。本例是直接将传入的参数——content变量的值返回；
 - 第三行是函数的结尾。

下面，尝试调用这个函数，整个函数定义与调用的示例如下：

```go
func main() {
   result := stringLoop("字符串回环测试")
   fmt.Println(result)
}

// 用于测试的自定义函数
func stringLoop(content string) string {
   return content
}
```

### **值传递**和**引用传递**

先猜猜它的运行结果：

```go
func main() {
   var resultSlice []int
   findPrimeNumber(resultSlice, 10)
   fmt.Println(resultSlice)
}

func findPrimeNumber(result []int, max int) {
   for i := 2; i < max; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到result数组中
         result = append(result, i)
      }
   }
}
```

答案揭晓：这段程序的运行结果为：

> []

相信不少人看到这里会一脸懵。为什么我把main()函数中的resultSlice传入findPrimeNumber()了，并且在findPrimeNumber()中对其做了修改，却并没有使resultSlice发生变化呢？

要解开这个谜团，我们不妨输出 main()函数中resultSlice和findPrimeNumber()中，result的内存地址。因为只有这二者的地址相同，才能证明这两个变量是“一回事”。

输出内存地址的代码示例如下：

```go
ptr := &variable
fmt.Println(&ptr)
```

其中，variable表示变量名，对应本例为main()中的resultSlice和findPrimeNumber()中的result。

这一对比的结果是显而易见的，main()中的resultSlice和findPrimeNumber()中的result，二者内存地址是不同的！这也就意味着，无论result变量在findPrimeNumber()中作出如何改变，都无法作用到main()中的resultSlice变量上。问题也就跟着来了：在函数间传值的过程中，到底发生了什么呢？

实际上，这里涉及到两个容易混淆的传递概念——**值传递**和**引用传递**。

像上述示例当中的做法，即直接传递一个变量名到另一个函数中，属于**值传递**。按照Go代码的执行策略，发生值传递时，将在另一个函数中自动生成一个值的副本。所以我们才会看到main()中的resultSlice和findPrimeNumber()中的result的内存地址是不同的，因为后者完全是前者的“替身”，我们在findPrimeNumber()函数中只是对替身做了改变，“真身”根本就没有收到影响！

与值传递相对的便是**引用传递**，这种方式在函数间传递的是指针，而指针恰恰是内存地址。这样的传值，无论发生在多少个函数之间，改变将始终作用于相同地址的数据上。

了解过值传递和引用传递后，便很清楚如何修改我们的代码了——只需将原有的值传递改为引用传递，即向findPrimeNumber()函数传递resultSlice的内存地址就行了。当然，还要适当修改findPrimeNumber()函数的定义和逻辑。修改后的完整代码如下：

```go
func main() {
   var resultSlice []int
   findPrimeNumber(&resultSlice, 10)
   fmt.Println(resultSlice)
}

func findPrimeNumber(result *[]int, max int) {
   for i := 2; i < max; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到result数组中
         *result = append(*result, i)
      }
   }
}
```

再次运行程序，将输出：

> [2 3 5 7]

除了将值传递改为引用传递外，还有一种“**偷懒式**”修改方法也可使程序正常输出——直接把resultSlice变量声明在函数外，改为**全局变量**，即可在所有函数中访问和修改这个变量了。

之所以称这种方法是“偷懒式”，是因为所有函数都能修改这个全局变量，数据存在一定的安全风险。若不慎错误地修改了变量的值，修复起来也会相对更困难一些了。

### 函数的延迟调用

接下来，我们保持findPrimeNumber()函数不变，在main()函数伊始添加两行神奇的代码：

```go
func main() {
   defer fmt.Print("素数")
   defer fmt.Print("查找")
   var resultSlice []int
   findPrimeNumber(&resultSlice, 10)
   fmt.Println(resultSlice)
}
```

很明显，main()函数开头的两行代码和普通的代码不同，前面有个“defer”。**“defer”的作用是让整句代码延迟执行，且多个defer存在时，它们的顺序是反向的。**

根据这一规律，我们便可推测上述代码运行的结果将是：

>[2 3 5 7]   
>查找素数

defer的典型应用场景是执行一些**收尾工作**，通常是在常规逻辑执行结束后释放系统资源。如文件读写、网络IO等等。也用于程序在**发生宕机时的恢复**。

### 匿名函数的定义和调用

> 回调保证了程序运行的正确性和及时性。**匿名函数则是实现回调的核心技能**。

在Go语言中，匿名函数的定义格式如下：

```go
func ([params_list])([return_values_list]){
    // 函数体
}
```

其中，params_list表示参数列表；return_values_list表示函数的返回值列表；使用大括号包裹起来的部分称为函数体，是匿名函数内部要执行的代码。其中，参数列表和返回值列表是可选的。有些函数无需参数，有些参数运行后并不会有任何返回值，有些函数则无需参数也无需返回值。

> `❗️ 注意： 请大家注意普通函数与匿名函数在定义时的区别，普通函数在定义时仅比匿名函数多了函数名。`

定义了函数后，接下来便是如何调用它。根据使用时机的不同，Go语言提供了两种调用匿名函数的方式：一是在定义时调用；二是将匿名函数赋值给变量，通过变量调用。

举例来说，下面的代码定义了一个匿名函数，实际作用便是在控制台输出传入的参数，类型是string：

```go
func main() {
   // 定义匿名函数
   func(text string) {
      fmt.Println(text)
   }
}
```

> `💡 提示：注意到了吗？和普通函数不同，匿名函数可以在某个普通函数内定义和使用。`

如果要在该函数定义时便调用它，只需在大括号结束后，使用小括号将要传入的参数值包裹起来即可，比如：

```go
func main() {
   // 定义匿名函数
   func(text string) {
      fmt.Println(text)
   }("定义时就调用")
}
```

这段代码中，“定义时就调用”便是要传入的参数了。运行这段代码，控制台将输出这些文字。

另一种调用匿名函数的方法是将匿名函数赋值给某个变量，然后通过变量调用。这听起来很神奇，写起来其实非常简单：

```go
func main() {
   // 定义匿名函数
   exampleVal := func(text string) {
      fmt.Println(text)
   }
   exampleVal("通过变量调用匿名函数")
}
```

如上代码所示，声明了变量exampleVal，并将匿名函数赋值给了它。在后续的代码中，即可随时使用exampleVal变量调用匿名函数了。

#### 实战回调

模拟网络文件下载，定期查询进度、及时汇报状态。

##### 主动定期查询进度

```go
package main

import (
	"fmt"
	"time"
)

var percent = 0

func main() {
	var keepChecking = true
	// 开启下载
	fmt.Println("开始下载任务！")
	go download("")
	//开启检查下载进度
	for {
		if keepChecking {
			time.Sleep(500 * time.Millisecond)
			fmt.Println("当前进度：", getPercent())
		} else {
			break
		}
	}
}

// 下载
func download(url string) {
	for {
		time.Sleep(1 * time.Second)
		percent++
		if percent >= 100 {
			break
		}
	}
}

// 获取进度
func getPercent() int {
	return percent
} 
```

##### 下载并执行回调

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	var keepChecking = true
	// 开启下载
	fmt.Println("开始下载任务！")
	go downloadFunc("", func() {
		keepChecking = false
		fmt.Println("下载完成！")
	}, func(currentPercent int) {
		keepChecking = false
		fmt.Println("下载取消！", currentPercent)
	}, func(currentPercent int) {
		keepChecking = false
		fmt.Println("下载失败！", currentPercent)
	})

	//开启检查下载进度
	for {
		if keepChecking {
			time.Sleep(500 * time.Millisecond)
			fmt.Println("当前进度：", getPercent())
		} else {
			break
		}
	}
}

// 下载
func downloadFunc(url string, downloadSuccess func(), downloadCancelled func(int), downloadFailed func(int)) {
	for {
		time.Sleep(1 * time.Second)
		percent++
		if percent == 100 {
			downloadSuccess()
			break
		}
	}
}
```

