---
title: 零基础通关
tags:
  - Go
categories:
  - Go
date: '2025-01-03'
description: 欢迎使用 Curve 主题，这是你的第一篇文章
articleGPT: 这是一篇初始化文章，旨在告诉用户一些使用说明和须知。
#cover: "/images/logo/logo.webp"
---

# 零基础通关

## 知识大纲

![小册知识点结构.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/4a076b7d583e435c83acd7515d741928~tplv-k3u1fbpfcp-watermark.png)

## 环境搭建

> https://golang.google.cn/dl/ 中文镜像

### 第一个Go程序

使用 vi 或启动任何一个纯文本编辑器，输入如下内容：

```go
package main
import "fmt"
func main(){
    fmt.Println("Hello World!")
}
```

将其保存为 hello.go。 接下来，启动终端，导航至 hello.go 所在目录，然后执行以下命令，编译 hello.go 程序：

```bash
go build hello.go
```

稍等片刻，程序编译完成。编译完成后将生成名为 hello 的可执行文件。在终端执行这个文件，可以看到 “Hello World!” 字样的文本输出，如下图所示：

```shell
(base) jiangbolun@jiangbolundeMacBook-Pro-2 main % ./hello 
Hello Word!% 
```

> 注意：
> Go 语言要求包含 `main` 函数的文件必须声明为 `package main`。这是生成可执行文件的关键。

### GOPATH 环境变量

1. `GOPATH`环境变量，是Go语言用来查找项目和第三方库的路径。
2. 刚安装完Go后，`GOPATH`环境变量默认未设置，需手动配置；如果不设置，Go默认在本地的特定目录下查找，如Unix/Linux下的用户主目录下的`go`，Windows下的`documents and settings`下的用户名下的`go`。
3. 建议即便在默认路径下工作，也应设置`GOPATH`环境变量，以便更好地管理项目和第三方库。
4.  `GOPATH`目录下可以存放个人的多个项目和所有拉取的第三方库，尽管也可以为每个项目设置不同的`GOPATH`。
5.  `GOPATH`作为一个环境变量，可以指示多个路径，Go在编译时会遍历这些路径来查找所需的依赖包。


## 源码结构以及命令行工具

### Go程序源码结构

```go
package main
import "fmt"
func main(){
    fmt.Println("Hello World!")
}
```

接下来，我们简单解释代码。

1. 第一行内容为 “package main”，它表示这个源码文件属于 main 包。main 包是每个 Go 应用程序都包含的包，有且只有一个。
2. 从第三行开始到最后，是 main() 函数，这个函数比较特殊，它是 Go 程序的“入口”函数，是程序运行的起点。这个函数必须存在且只能存在一个，且必须声明在 main 包中。任何一个 Go 函数都要求使用成对的大括号将函数体包裹起来。

### Go SDK 命令行工具

#### go build

> go build 命令的作用是编译 Go 源码，并生成可执行的文件。

从原理上说，Go SDK 自 1.9 版本开始就支持并发编译了，能尽可能地发挥电脑的最大性能完成编译，所以 Go 源码的编译速度是非常快的。在编译过程中，除了我们自己写的代码外，如果使用了第三方的包，这些包会被一同编译。当我们执行 go build 命令后，会搜索当前目录下的 go 源码并完成编译。

go build 命令还允许附加参数，方便开发者对编译参数进行配置，具体如下表所示：

| 参数名   | 作用                               |
|-------|----------------------------------|
| -v    | 编译时显示包名                          |
| -p x  | 指定编译时并发的数量（使用x表示），该值默认为CPU的逻辑核心数 |
| -a    | 强制进行重新构建                         |
| -n    | 仅输出编译时执行的所有命令                    |
| -x    | 执行编译并输出编译时执行的所有命令                |
| -race | 开启竞态检测                           |

此外，如果我们希望只编译某个 go 源码文件或包，可在 go build 命令后添加文件或包名。例如，现有 file1.go、file2.go 和file3.go，我们只希望编译 file1.go，便可如下执行：

```bash
go build file1.go
```

#### go clean

go clean 命令可以清理当前目录内的所有编译生成的文件，具体包括：

-   当前目录下生成的与包名或者 Go 源码文件同名的可执行文件，以及当前目录中 _obj 和 _test 目录中名为 _testmain.go、test.out、build.out、a.out 以及后缀为 .5、.6、.8、.a、.o和 .so 的文件，这些文件通常是执行go build命令后生成的；
-   当前目录下生成的包名加 “.test” 后缀为名的文件，这些文件通常是执行 go test 命令后生成的；
-   工作区中 pkg 和 bin 目录的相应归档文件和可执行文件，这些文件通常是执行 go install 命令后生成的。

go clean 命令还允许附加参数，具体参数和作用如下表所示：

| 参数名        | 作用                                        |
|------------|-------------------------------------------|
| -i         | 清除关联的安装的包和可运行文件，这些文件通常是执行go install命令后生成的 |
| -n         | 仅输出清理时执行的所有命令                             |
| -r         | 递归清除在 import 中引入的包                        |
| -x         | 执行清理并输出清理时执行的所有命令                         |
| -cache     | 清理缓存，这些缓存文件通常是执行go build命令后生成的            |
| -testcache | 清理测试结果                                    |

在团队式开发中，通常在每次提交代码前执行 go clean 命令，防止提交编译时生成的文件。

#### go run

go run 命令的作用是直接运行 go 源码，不在当前目录下生成任何可执行的文件。

从原理上讲，go run 只是将编译后生成的可执行文件放到临时目录中执行，工作目录仍然为当前目录。同时，go run 命令允许添加参数，这些参数将作为 go 程序的可接受参数使用。

由此可见，go run 命令同样会执行编译操作。但要注意的是，go run 不适用于包的执行。

#### gofmt

gofmt 命令的作用是将代码按照Go语言官方提供的代码风格进行格式化操作。

请大家注意，**gofmt和go fmt是两个不同的命令**。go fmt 命令是 gofmt 的封装，go fmt 支持两个参数：-n 和 -x，分别表示仅输出格式化时执行的命令，以及执行格式化并输出格式化时执行的命令。

执行 gofmt 命令时，可指定文件或目录，也可不指定。当不指定时，gofmt 命令会搜索当前目录中的 go 源码文件，并执行相应的格式化操作。

gofmt 命令还允许附加参数，具体参数和作用如下表所示：

| 参数名                  | 作用                                                 |
|----------------------|----------------------------------------------------|
| -l                   | 仅输出需要进行代码格式化的源码文件的绝对路径                             |
| -w                   | 进行代码格式化，并用改写后的源码覆盖原有源码                             |
| -r rule              | 添加自定义的代码格式化规则（使用rule表示），格式为：pattern -> replacement |
| -s                   | 开启源码简化                                             |
| -d                   | 对比输出代码格式化前后的不同，依赖diff命令                            |
| -e                   | 输出所有的语法错误，默认只会打印每行第1个错误，且最多打印10个错误                 |
| -comments            | 是否保留代码注释，默认值为true                                  |
| -tabwidth x          | 用于指定代码缩进的空格数量（使用x表示），默认值为8，该参数仅在-tabs参数为false时生效   |
| -tabs                | 用于指定代码缩进是否使用tab（“\t”），默认值为true                     |
| -cpuprofile filename | 是否开启CPU用量分析，需要给定记录文件（使用filename表示），分析结果将保存在这个文件中   |

`💡 提示：使用-s参数进行源码简化的规则请参考：https://pkg.go.dev/cmd/gofmt#hdr-The_simplify_command`

#### go install

go install 命令的作用和 go build 类似，都是将源码编译为可执行的文件，附加参数也基本通用，这里就不再赘述了。区别在于：

-   go install 命令在编译源码后，会将可执行文件或库文件安装到约定的目录下；
-   go install 命令生成的可执行文件使用包名来命名；
-   默认情况下，go install 命令会将可执行文件安装到 GOPATH\bin 目录下，依赖的三方包会被安装到 GOPATH\bin 目录下。

#### go get

go get 命令的作用是获取源码包，这一操作包含两个步骤，分别是下载源码和执行 go install 命令进行安装。使用时，仅需将源码仓库地址追加到 go get 后即可（访问<https://pkg.go.dev/>，搜索包名，在包详情页可以找到仓库地址），例如：

```bash
go get github.com/ethereum/go-ethereum
```



go get 命令还允许附加参数，具体参数和作用如下表所示：

| 参数名       | 作用                        |
|-----------|---------------------------|
| -d        | 仅下载源码包，不安装                |
| -f        | 在执行-u参数操作时，不验证导入的每个包的获取状态 |
| -fix      | 在下载源码包后先执行fix操作           |
| -t        | 获取运行测试所需要的包               |
| -u        | 更新源码包到最新版本                |
| -u=patch  | 只小版本地更新源码包，如从1.1.0到1.1.16 |
| -v        | 执行获取并显示实时日志               |
| -insecure | 允许通过未加密的HTTP方式获取          |

若要指定所获取源码包的版本，可以通过添加 “@版本号” 的方式执行。如：

```bash
go get github.com/ethereum/go-ethereum@v1.10.1
```

在使用 Go SDK 1.17 版本时，有一点需要额外注意：执行 go get 命令可能会收到警告，大意是 go get 命令是不建议使用的。此时，使用go install替换 go get 即可，原因是在未来的 Go SDK 版本中 go get 的作用等同于 go get -d。

如果你对 “go get” 命令感兴趣，可以阅读官方对它的说明，写的非常详细：<https://docs.studygolang.com/doc/go-get-install-deprecation>

### debug

goland	debug 时会失效：

> undefined behavior - version of Delve is too old for Go version 1.23.5 (maximum supported version 1.20) 15

因依赖问题要求GO版本需要从1.18.x版本升级到1.23.x，升级后，Test 启动 debug时，发现打断点的红点一闪而过，出现一个失效的标志（一个灰色圆圈+斜杠），在经过百度大法后，原来高版本（1.20及以上版本）会出现debug断点无效的现象。

经过资料查阅，发现是因为go高版本问题，导致dlv插件失效，[github](https://so.csdn.net/so/search?q=github&spm=1001.2101.3001.7020)上提供了源代码，可以clone下来打包，并把dlv文件放到指定的目录。

1. Git clone

   ```shell
   git clone https://github.com/go-delve/delve.git
   ```

2. #### 编译并打包成dlv可执行文件

   ```
   cd cmd/dlv
   
   go build
   ```

   执行完毕后，当前目录下多出一个dlv可执行文件 

3. #### 复制dlv文件到goland插件目录

   - goland 新版本（大于等于23年版本）

     ```
     cp dlv /Applications/GoLand.app/Contents/plugins/go-plugin/lib/dlv/mac
     ```

     

   - goland老版本（小于23年版本）

     ```
     cp dlv /Applications/GoLand.app/Contents/plugins/go/lib/dlv/mac
     ```

## 基础语法

### 命名规范

- 对于变量，除了首个单词外，每个单词的首字母用大写表示，这种命名法通常被称为小驼峰式命名法；若所有单词的首字母均大写，则成为大驼峰式命名法（又被称为帕斯卡命名法）。由于变量有可见性（有关可见性的更多内容，将在结构体/包中介绍。）之分，对于对外可见的变量，使用大驼峰法；对于对外不可见的变量，使用小驼峰法。特别地，若变量/常量是布尔类型，最好以is、allow、has、can之类来开头；
- 对于常量，单词均用大写字母来表示，每个字母之间使用下划线来分割。

```go
// 变量声明
var exampleNumberA int = 10
var isDarkMode bool = false
// 常量声明
const WIDTH_OF_RECT int = 12
const ALLOW_DOWNLOAD_WHEN_WIFI bool = true
```

### 声明与赋值

**在Go语言中，变量或常量的数据类型必须先声明，才能使用**，且无法将不相关的数据赋值给它们。

这是因为Go语言和Java、C、C++等语言一样，属于静态语言，静态语言具有更严谨的结构要求、调试便捷（可通过代码直观地看到数据类型）与确保类型安全（无法使用不同类型的数据赋值）的特点，必须要先做声明。而像PHP、Python、JavaScript等动态语言则没有这个限制。

#### 变量的声明与赋值

在Go语言中，声明变量的一般格式为：

```Go
var name type
```

- 其中，var是声明变量的关键字，固定不变，表明意图——要声明一个变量
- type表示该变量所属的数据类型。

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250212145811800.png" alt="image-20250212145811800" style="zoom:33%;" />

```Go
// 声明一个名为number的变量，类型为int（整数类型）
var number int
// 为number赋值
number = 100

// 变量声明
var number int = 100
```

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250212145836158.png" alt="image-20250212145836158" style="zoom:33%;" />

##### 匿名变量

匿名变量也就是没有名字的变量, 开发过程中可能会遇到有些变量不是必须的。匿名变量使用下划线" \_ " 表示。 "\_" 也称为空白标识符，任何类型都可以使用它进行赋值,而且任何类型赋值后都将直接被抛弃，所以在使用匿名变量时，表示后续代码不需要再用此变量。

```go
package main

import (
    "fmt"
)

func main() {
    a, _ := 100, 200
    //这里第二个值200赋给了匿名变量_ 也就忽略了不需要再次打印出来
    fmt.Println(a)
}
```

##### 变量的作用域

变量在程序中有一定的作用范围，如果一个变量声明在函数体的外部，这样的变量被认为是全局变量，全局变量在整个包内，也就是当前的package内都可以被调用得到。如果变量定义在函数体内部，则被称之为局部变量。例如下面代码:

```go
package main

import (
    "fmt"
    "os"
)

//全局变量
var name = "zhangsan"

//主函数 程序的入口
func main() {
    fmt.Println(name) //可以访问到全局变量name

    myfunc()
}

//自定义函数 
func myfunc() {
    fmt.Println(name) //这里也可以访问到全局变量name

    age := 30
    fmt.Println(age) //age为myfunc的局部变量 只能够在函数内部使用

    if t, err := os.Open("file.txt"); err != nil {
        fmt.Print(t) //t作为局部变量 只能在if内部使用
    }
    fmt.Println(t) //在if外部使用变量则会报错 undefined: t  未声明的变量t
}
```

#### 常量的声明与赋值

常量声明和赋值的一般格式为：

```Go
const name type = value
```

其中，const是声明常量的关键字，固定不变，表明意图，要声明一个常量；name和type的意义与声明变量时一样；value是常量的值。如：

```Go
// 声明一个名为PI的常量，类型为float64（浮点数类型）
const PI float64 = 3.14
```

> `❗️ 注意： 声明常量时，必须为其赋值，且后续无法修改。`

#### Go语言的类型推断

使用Go语言可简化代码，类型推断体现了这一点。当声明与赋值一并进行时，如果数据为Go内置的基础类型，则可无需指定类型。如：

```Go
// 变量声明
var number = 100
// 常量声明
const PI = 3.14
```

无需担心，由于number的值为100，Go语言会推断出它的类型为整数型。同理，PI也会被推断为浮点数型。

对于变量，还有一种超级精简的声明和赋值方式，示例如下：

```Go
//变量声明
number := 100
```

`❗️ 注意： 冒号等于号“:=”的作用是声明和赋值，若number是已经声明过的变量，则无法使用 := 的方式赋值。`

#### 批量声明/赋值

为了方便多个变量/常量的声明和赋值，我们还可以批量处理它们，示例如下：

```Go
// 变量
var a1,a2,a3 int = 10,20,30
// 也可以省略类型 根据数据进行类型推导
var a1,a2,a3 = 10,20,"ago"
var (
        // 声明 + 赋值
        number int = 100
        // 声明 + 赋值（类型推断）
        text = "Hello"
        // 只声明
        name string
)
// 常量
const (
        // PI 声明 + 赋值
        PI float64 = 3.14
        // WIDTH 声明 + 赋值（类型推断）
        WIDTH  = 5
        // HEIGHT 声明 + 赋值（类型推断）
        HEIGHT = 10
)
```

### 占位符类型

占位符表示在程序中输出一行字符串时候，或者格式化输出字符串的时候使用。go内置包fmt中Printf方法可以在控制台格式化打印出用户输入的内容。fmt.Printf("%T",x)

| 占位符 | 说明           | 举例                           | 输出         |
| ------ | -------------- | ------------------------------ | ------------ |
| %d     | 十进制的数字   | fmt.Printf("%d",10)            | 10           |
| %T     | 取类型         | b :=true fmt.Printf("%T",b)    | bool         |
| %s     | 取字符串       | s :="123" fmt.Printf("%s",s)   | 123          |
| %t     | 取bool类型的值 | b:=true fmt.Printf("%t",b)     | true         |
| %p     | 取内存地址     | p :="123" fmt.Printf("%p", &p) | 0xc0000461f0 |

### 指针类型

> 在上一讲中，我们介绍了Go语言的基本数据类型，学会了如何对变量进行声明和赋值，也知道了在这个过程中会在内存开辟空间方便它们“安家”。那如何才能找到这个“家”呢？这就涉及到了指针。
>
> 通过使用指针，开发者可以直接访问内存中的数据，从而可以实现对数据的精准管理以及运算。
>
> 如果说变量名是数据的“代号”，那么指针存放的则是数据的“**实际地址**”，我们可以通过这个地址获取或修改存放于这个地址的变量的值。
>
> 存放整数值的变量称为整型变量，存放布尔值的变量称为布尔变量……类似地，存放指针值的变量称为指针变量。
>
> 那么问题来了，想要获取或改变某个变量的值，直接通过变量名就可以实现了。而且像Java之类的编程语言几乎不会用到指针，**那Go为何还要用指针呢？**
>
> `❗️ 注意： 实际上，Java中的指针操作封装在JDK中，普通开发者一般不会接触到，所以会误认为Java没有指针。`

我们不妨先了解一下Go语言中的指针，它主要由两大核心概念构成：**类型指针**和**切片指针**。

- 类型指针：在**传递数据**时直接使用指针，可以避免创建数据的副本，节约内存开销。类型指针不能进行偏移和运算，可以**避免非法修改**为其它数据的风险，也更**有利于垃圾回收**机制及时找到并回收它们；

- 切片指针：切片由**指向起始元素的指针**、元素数量和总容量构成。当访问切片发生越界时，会发生宕机并输出堆栈信息。宕机是**可以恢复**的，而崩溃只能导致程序停止运行。

可见，**使用指针更有利于程序运行的性能和稳定性**。另外，在某些操作中，如使用反射修改变量的值，必须使用可寻址的变量（通过指针）。

在实际应用中，最为常用的便是获取变量的内存地址，以及获取某个地址对应的值。在Go语言中，前者使用“&”运算符，后者使用“*”运算符。它们互为反向操作，操作的对象也不同。具体请看下面的示例：

```Go
// exampleNumberA变量（整数型变量）声明和赋值
var exampleNumberA int = 10
// 获取exampleNumberA的地址，并赋值给exampleNumberAPtr变量（exampleNumberAPtr的类型是指针类型）
exampleNumberAPtr := &exampleNumberA
//输 出exampleNumberAPtr变量的值（将输出内存地址）
fmt.Println(exampleNumberAPtr)
// 获取exampleNumberAPtr（指针变量）表示的实际数据值，并赋值给exampleNumberAPtrValue变量（整数型变量）
exampleNumberAPtrValue := *exampleNumberAPtr
// 输出exampleNumberAPtrValue变量（整数型变量）的值
fmt.Println(exampleNumberAPtrValue)
```

运行后，控制台输出：

> 0xc00001a088 
> 10

上面的代码示例演示了如何使用已有的变量创建指针类型变量。我们还可以使用new()函数直接创建指针变量，相当于在内存中创建了**没有变量名**的**某种类型**的**变量**。

这样做无需产生新的数据“代号”，取值和赋值转而通过指针变量完成。常用在无需变量名或必须要传递指针变量值的场景中。

new()函数的使用格式如下：

```Go
new(type)
```

其中，type是所在地址存放的数据类型。一旦完成创建，便会在内存中“安家”，完成内存分配，即使没有赋值。

具体代码示例如下：

```Go
// 使用new()函数创建名为exampleNumberAPtr指针类型变量，表示int64型值
exampleNumberAPtr := new(int64)
// 修改exampleNumberAPtr表示的实际数据值
*exampleNumberAPtr = 100
// 获取exampleNumberAPtr表示的实际数据值
fmt.Println(*exampleNumberAPtr)
```

程序运行后，控制台将输出：

> 100

## 流程控制

### if 语句

条件语句的格式如下：

```go
if condition {
    
}
```

另外：if 语句后面可以跟多个语句条件，允许先赋值再判断，其作用域仅限于当前F语句块内，一旦离开该块，所定义的变量将不再有效。

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250213164052833.png" alt="image-20250213164052833" style="zoom:33%;" />

```go
if contents, err := ioutil.ReadFile(`test.txt`); err == nil {
		fmt.Println(string(contents))
	} else {
		fmt.Println("cannot print file contents:", err)
	}
```

### switch 语句

>  switch语句默认在每个case之后包含break，无需显式添加，这与C语言或Java等语言不同，减少了编程负担，更显人性化。
>
>  如果在switch语句中不希望执行break，反而需要使用特定结构如for through来实现，这与常规的编程习惯相反，提供了一种灵活的控制流程方式。

```go
// switch语法一
switch 变量名 {
    case 数值1: 分支1
    case 数值2: 分支2
    case 数值3: 分支3
    ...
    default:
        最后一个分支
}


// 语法二 省略变量 相当于作用在了bool 类型上
func grade(score int) string {
	switch {
	case score < 60:
		return "F"
	case score < 80:
		return "C"
	case score < 90:
		return "B"
	default:
		return "A"
	}
}

// 语法三 case 后可以跟随多个数值， 满足其中一个就执行
switch num  {
    case 1,2,3:
        fmt.Println("num符合其中某一个 执行代码")
    case 4,5,6:
        fmt.Println("执行此代码")
}

// 语法四 可以添加初始化变量 作用于switch内部
switch name:="huangrong"; name{
    case "guojing":
        fmt.Println("shideguojing")
    case "huangrong":
        fmt.Println("shidehuangrong")
} 
```

### for 循环语句

循环结构的格式如下：

```go
for init; condition; post {
    //循环体代码块
}
```

其中，for表明接下来的代码是for循环结构；init是初始化语句；condition是关系或逻辑表达式，值为true时则会停止循环；post是每次循环结束后执行的语句。

```go
sum := 0
for i:= 1; i <= 100; i++ {
  sum += i
}
```

>  注意：go 语言没有while关键字，其功能被 for 循环所涵盖，因此去掉了while。

```go
for {
  fmt.Println("abc")
}
```

#### 多层嵌套中的break和continue

默认都只结束当前一层循环，如果想要结束到指定循环，需要给循环体前贴上标签。

```go
flag:
    for i := 1; i < 10; i++ {
        for j := 1; j < i; j++ {
            fmt.Println(i, j)
            if j == 5 {
                break flag
            }
        }
        fmt.Println(i)
    }
```

#### goto语句

可以跳转到程序中指定的行和嵌套循环里的break标签是一样的，不管后面还有多少代码都不再执行。

```go
//语法
lable:func1
    ...
goto label
```

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250213174210204.png" alt="image-20250213174210204" style="zoom:60%;" />

```go
TestLabel: //标签
	for a := 20; a < 35; a++ {
		if a == 25 {
			a += 1
			goto TestLabel
		}
		fmt.Println(a)
		a++
	}
}
```

## 数组、切片和集合

### 数组

#### 声明

Go语言中声明数组的一般格式为：

```go
var array_name [quantity]Type
```

其中，var关键字用于声明变量；array_name表示数组名；quantity表示数组元素个数；Type表示元素类型。例如：

```go
var resultArray [4]int
```

声明后即可为单个元素赋值了。和其它的编程语言类似，要为数组中的某个元素赋值，格式为：

```go
array_name[index] = Value
```

例如：

```go
resultArray[2] = 5
```

* 数组有长度限制，访问和复制不能超过数组定义的长度，否则就会下标越界。
* 数组的长度，用内置函数 len()来获取。
* 数组的容量，用内置函数 cap()来获取。

```go
fmt.Println("数组的长度为：",len(arr))//  数组中实际存储的数据量
fmt.Println("数组的容量为：",cap(arr))//容器中能够存储的最大数据量  因为数组是定长的 所以长度和容量是相同的
```

#### 创建

```go
//  默认情况下 数组中每个元素初始化时候 根据元素的类型 对应该数据类型的零值，
arr1 := [3]int{1,2}
fmt.Println(arr1[2])// 下标为2的元素没有默认取int类型的零值

// 数组创建方式1 创建时 直接将值赋到数组里
arr2 := [5]int{1,2,3,4}    // 值可以少 默认是0  但是不能超过定长

// 在指定位置上存储值
arr3 := [5]int{1:2,3:5}// 在下标为1的位置存储2，在下标为3的位置存储5
```

在创建数组时候长度可以省略，用 ... 代替，表示数组的长度可以由初始化时候数组中的元素的个数来决定。

```go
// 长度可以用...代替  根据数值长度程序自动填充数值的大小
arr4 :=  [...]int{1,2,3,4}

// 简短声明方式
arr5 := [...]int{2:3,6:3}//在固定位置存储固定的值
```

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/17250f28f2679443~tplv-t2oaga2asx-jj-mark:1600:0:0:0:q75.png" style="zoom:33%;" />

#### 遍历

使用for range 进行循环数组中的元素，依次打印数组中的元素。

1. range 不需要操作下标，每次循环自动获取元素中的下标和对应的值。如果到达数组的末尾，自动结束循环。

```go
arr := [5]int{1,2,3,4,5}
// range方式循环数组
for index,value:=range arr{
    fmt.Println(index,value)
}
```

2. 可以通过 for循环 配合下标来访问数组中的元素。

```go
arr := [5]int{1,2,3,4,5}
// for循环
for i:=0; i<len(arr);i++{
    fmt.Println(arr[i])
}
```

### 切片

使用数组来存放一些结果，很容易引发下标越界错误。和数组相对，Go语言还提供了一种专门存放**不定元素个数**的数据结构——切片。

#### 声明

在Go语言中，切片的声明一般格式为：

```go
var slice_name []Type
```

其中，var关键字用于声明变量；slice_name表示切片名；Type表示元素类型。

> `💡 提示： 注意到了吗？声明切片和数组的区别仅仅是去掉了中括号中的元素个数！`

例如：

```go
var resultSlice []int
```

> `❗️ 注意： 和数组类似，切片中的元素也不限制值的类型，但要求所有元素均为相同的类型。`

通常情况下，使用make函数来创建一个切片，切片有长度和容量，默认情况下它的容量与长度相等。所以可以不用指定容量。

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/1720ea7de8a23f0f~tplv-t2oaga2asx-jj-mark:1600:0:0:0:q75.jpeg" style="zoom:33%;" />

```go
// 使用make函数来创建切片
slice :=make([]int,3,5)// 长度为3 容量为5  容量如果省略 则默认与长度相等也为3
fmt.Println(slice)// [0,0,0] 
fmt.Println(len(slice),cap(slice))// 长度3,容量5
```

#### 切片追加元素append()

完成切片的声明后，就来到赋值环节。

与数组不同，为切片赋值可以理解为“**扩充**”。在一开始，切片里面的元素个数为0。“扩充”一个值，就相当于为切片中的第一个元素赋值。赋值后，切片的元素个数就变成了1。若再次“扩充”，则相当于为切片中的第二个元素赋值。赋值后，切片的元素个数就变成了2，以此类推……

在Go语言中，为切片“扩充”需要使用append()函数，使用格式如下：

```go
slice_name = append(slice_name, value...)
```

其中，slice_name表示已声明的切片变量名，value表示具体的数据值。

例如：

```go
// 使用append() 给切片末尾追加元素
var slice []int
slice = append(slice, 1, 2, 3)
fmt.Println( slice) // [1, 2, 3]

// 使用make函数创建切片
s1:=make([]int,0,5)
fmt.Println(s1)// [] 打印空的切片
s1=append(s1,1,2)
fmt.Println(s1)// [1,2]
// 因为切片可以扩容  所以定义容量为5 但是可以加无数个数值
s1=append(s1,3,4,5,6,7)
fmt.Println(s1)// [1,2,3,4,5,6,7] 

// 添加一组切片到另一切片中
s2:=make([]int,0,3)
s2=append(s2,s1...) //...表示将另一个切片数组完整加入到当前切片中
```

#### make()与new() 的区别

make()是Go语言中的内置函数，主要用于创建并初始化slice切片类型，或者map字典类型，或者channel通道类型数据。他与new方法的区别是。new用于各种数据类型的内存分配，在Go语言中认为他返回的是一个指针。指向的是一个某种类型的零值。make 返回的是一个有着初始值的非零值。

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/17396426c5e6af5d~tplv-t2oaga2asx-jj-mark:1600:0:0:0:q75.png" style="zoom:33%;" />

```go
// 测试使用new方法新建切片
slice1 := new([]int)
fmt.Println(slice1) // 输出的是一个地址  &[]

// 使用make创建切片
slice2 := make([]int, 5)
fmt.Println(slice2)// 输出初始值都为0的数组， [0 0 0 0 0]

fmt.Println(slice1[0])// 结果出错 slice1是一个空指针 invalid operation: slice1[0] (type *[]int does not support indexing)
fmt.Println(slice2[0])// 结果为 0 因为已经初始化了
```

#### 切片是如何扩容的

```go
package main

import (
    "fmt"
)

func main() {
    s1 := make([]int, 0, 3)
    fmt.Printf("地址%p,长度%d,容量%d", s1, len(s1), cap(s1))
    s1 = append(s1, 1, 2)
    fmt.Printf("地址%p,长度%d,容量%d", s1, len(s1), cap(s1))
    s1 = append(s1, 3, 4, 5)
    fmt.Printf("地址%p,长度%d,容量%d", s1, len(s1), cap(s1))
    
    
    //地址0xc000010540,长度0,容量3
    //地址0xc000010540,长度2,容量3
    //地址0xc00000e4b0,长度5,容量6
}
```

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/1721e2a76f3cc011~tplv-t2oaga2asx-jj-mark:1600:0:0:0:q75.jpeg" style="zoom:50%;" />

容量成倍数扩充 3--->6--->12--->24......

如果添加的数据容量够用, 地址则不变。如果实现了扩容， 地址就会发生改变成新的地址，旧的则自动销毁。

### Map

#### 声明

Go语言中声明集合的一般格式为：

```go
var map_name = make(map[key_type]value_type)
```

例如：

```go
//  1, 声明map 默认值是nil
var m1 map[key_data_type]value_data_type
//  2，使用make声明
m2:=make(map[key_data_type]value_data_type)
// 3,直接声明并初始化赋值map方法
m3:=map[string]int{"语文":89,"数学":23,"英语":90}
```

#### 使用

map 是引用类型的，如果声明没有初始化值，默认是nil。空的切片是可以直接使用的，因为他有对应的底层数组,空的map不能直接使用。需要先make之后才能使用。

```go
var m1 map[int]string         //  只是声明 nil
var m2 = make(map[int]string) // 创建
m3 := map[string]int{"语文": 89, "数学": 23, "英语": 90}

fmt.Println(m1 == nil) //true
fmt.Println(m2 == nil) //false
fmt.Println(m3 == nil) //false

// map 为nil的时候不能使用 所以使用之前先判断是否为nil
if m1 == nil {
    m1 = make(map[int]string)
}

// 1存储键值对到map中  语法:map[key]=value
m1[1]="小猪"
m1[2]="小猫"

//2获取map中的键值对  语法:map[key]
val := m1[2]
fmt.Println(val)

//  3判断key是否存在   语法：value,ok:=map[key]
val, ok := m1[1]
fmt.Println(val, ok) // 结果返回两个值，一个是当前获取的key对应的val值。二是当前值否存在，会返回一个true或false。

//4修改map  如果不存在则添加， 如果存在直接修改原有数据。
m1[1] = "小狗"

// 5删除map中key对应的键值对数据 语法: delete(map, key)
delete(m1, 1)

// 6 获取map中的总长度 len(map)
fmt.Println(len(m1))
```

### 循环遍历

除了for循环外，Go语言还提供了range关键字。与for结合，也可以实现循环遍历，其使用格式如下：

```go
for index, value := range variable {
    // 循环体
}
```

其中，index表示索引或键的值；value表示元素的值；variable表示数组、切片或集合变量；由大括号包裹的部分是循环体，可以使用index和value变量。

for 循环对比 for-range：

- 使用`for`循环：

```
slice := []int{1, 2, 3, 4, 5}
for i := 0; i < len(slice); i++ {
    fmt.Println(slice[i])
}
```

- 使用`range`：

```
slice := []int{1, 2, 3, 4, 5}
for i, v := range slice {
    fmt.Println(i, v)
}
```

`range`自动处理了索引`i`和值`v`的赋值，并且代码更加简洁。

这种for与range结合实现循环遍历的结构，也被称为**for-range结构**。这种结构同样适用于数组和切片。

### 值传递与引用传递

数据如果按照数据类型划分

* 基本类型:`int、float、string、bool`
* 复合类型:`array、slice、map、struct、pointer、function、chan`

按照数据特点划分分为

* 值类型：`int、float、string、bool、array、struct` 值传递是传递的数值本身，不是内存地，将数据备份一份传给其他地址，本身不影响，如果修改不会影响原有数据。
* 引用类型: `slice、pointer、map、chan` 等都是引用类型。 引用传递因为存储的是内存地址，所以传递的时候则传递是内存地址，所以会出现多个变量引用同一个内存。

```go
// 数组为值传递类型
// 定义一个数组 arr1
arr1 := [4]int{1, 2, 3, 4}
arr2 := arr1            // 将arr1的值赋给arr2
fmt.Println(arr1, arr2) // [1 2 3 4] [1 2 3 4]  输出结果 arr1与arr2相同，
arr1[2] = 200           // 修改arr1中下标为2的值
fmt.Println(arr1, arr2) // [1 2 200 4] [1 2 3 4] 结果arr1中结果改变,arr2中不影响
// 说明只是将arr1中的值给了arr2 修改arr1中的值后并不影响arr2的值

// 切片是引用类型
// 定义一个切片 slice1
slice1 := []int{1, 2, 3, 4}
slice2 := slice1            // 将slice1的地址引用到slice2
fmt.Println(slice2, slice2) // [1 2 3 4] [1 2 3 4]   slice1输出结果 slice2输出指向slice1的结果，
slice1[2] = 200             // 修改slice1中下标为2的值
fmt.Println(slice1, slice2) // [1 2 200 4] [1 2 200 4] 结果slice1中结果改变,因为修改的是同一份数据
// 说明只是将slice1中的值给了slice2 修改slice1中的值后引用地址用的是同一份 slice1 和slice2 同时修改

fmt.Printf("%p,%p", slice1, slice2)// 0xc000012520,0xc000012520
// 切片引用的底层数组是同一个 所以值为一个地址 是引用的底层数组的地址
fmt.Printf("%p,%p", &slice1, &slice2)// 0xc0000044a0,0xc0000044c0
// 切片本身的地址
```

## 函数

### 普通函数的定义和调用

在Go语言中，定义一个普通函数的格式如下：

```go
func function_name([params_list])([return_values_list]){
    // 函数体
}
```

其中，func关键字表示定义一个函数；function_name是函数名；params_list表示参数列表；return_values_list表示函数的返回值列表；使用大括号包裹起来的部分称为函数体，是函数内部要执行的代码。其中，参数列表和返回值列表是可选的。有些函数无需参数，有些参数运行后并不会有任何返回值，有些函数则无需参数也无需返回值。

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250214174428193.png" alt="image-20250214174428193" style="zoom:33%;" />

- 函数的首字母区分大小写，如果是大写的表示公共的函数，其他包内可以调用到，相当于其他语言中的public 前提是在别的包中引入了当前包。
- 如果是小写的，表示私有的函数，仅能够在本包中调用，相当于其他语言中的private。

先举个简单的例子，下面的函数实现了将参数（即传入的string类型字符串）作为返回值（类型也为string）输出。

```go
func stringLoop(content string) string {
   return content
}
```

下面，尝试调用这个函数，整个函数定义与调用的示例如下：

```go
func main() {
   result := stringLoop("字符串回环测试")
   fmt.Println(result)
}

// 用于测试的自定义函数
func stringLoop(content string) string {
   return content
}
```

### **值传递**和**引用传递**

先猜猜它的运行结果：

```go
func main() {
   var resultSlice []int
   findPrimeNumber(resultSlice, 10)
   fmt.Println(resultSlice)
}

func findPrimeNumber(result []int, max int) {
   for i := 2; i < max; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到result数组中
         result = append(result, i)
      }
   }
}
```

答案揭晓：这段程序的运行结果为：

> []

相信不少人看到这里会一脸懵。为什么我把main()函数中的resultSlice传入findPrimeNumber()了，并且在findPrimeNumber()中对其做了修改，却并没有使resultSlice发生变化呢？

要解开这个谜团，我们不妨输出 main()函数中resultSlice和findPrimeNumber()中，result的内存地址。因为只有这二者的地址相同，才能证明这两个变量是“一回事”。

输出内存地址的代码示例如下：

```go
ptr := &variable
fmt.Println(&ptr)
```

其中，variable表示变量名，对应本例为main()中的resultSlice和findPrimeNumber()中的result。

这一对比的结果是显而易见的，main()中的resultSlice和findPrimeNumber()中的result，二者内存地址是不同的！这也就意味着，无论result变量在findPrimeNumber()中作出如何改变，都无法作用到main()中的resultSlice变量上。问题也就跟着来了：在函数间传值的过程中，到底发生了什么呢？

实际上，这里涉及到两个容易混淆的传递概念——**值传递**和**引用传递**。

像上述示例当中的做法，即直接传递一个变量名到另一个函数中，属于**值传递**。按照Go代码的执行策略，发生值传递时，将在另一个函数中自动生成一个值的副本。所以我们才会看到main()中的resultSlice和findPrimeNumber()中的result的内存地址是不同的，因为后者完全是前者的“替身”，我们在findPrimeNumber()函数中只是对替身做了改变，“真身”根本就没有收到影响！

与值传递相对的便是**引用传递**，这种方式在函数间传递的是指针，而指针恰恰是内存地址。这样的传值，无论发生在多少个函数之间，改变将始终作用于相同地址的数据上。

了解过值传递和引用传递后，便很清楚如何修改我们的代码了——只需将原有的值传递改为引用传递，即向findPrimeNumber()函数传递resultSlice的内存地址就行了。当然，还要适当修改findPrimeNumber()函数的定义和逻辑。修改后的完整代码如下：

```go
func main() {
   var resultSlice []int
   findPrimeNumber(&resultSlice, 10)
   fmt.Println(resultSlice)
}

func findPrimeNumber(result *[]int, max int) {
   for i := 2; i < max; i++ {
      //假定i为素数
      flag := true
      for j := 2; j < i; j++ {
         if i%j == 0 {
            //当i能被某个整数整除时，不是素数
            flag = false
         }
      }
      //如果依旧为true，则i为素数
      if flag {
         //将素数存放到result数组中
         *result = append(*result, i)
      }
   }
}
```

再次运行程序，将输出：

> [2 3 5 7]

除了将值传递改为引用传递外，还有一种“**偷懒式**”修改方法也可使程序正常输出——直接把resultSlice变量声明在函数外，改为**全局变量**，即可在所有函数中访问和修改这个变量了。

之所以称这种方法是“偷懒式”，是因为所有函数都能修改这个全局变量，数据存在一定的安全风险。若不慎错误地修改了变量的值，修复起来也会相对更困难一些了。

### 函数的延迟调用（defer）

接下来，我们保持findPrimeNumber()函数不变，在main()函数伊始添加两行神奇的代码：

```go
func main() {
   defer fmt.Print("素数")
   defer fmt.Print("查找")
   var resultSlice []int
   findPrimeNumber(&resultSlice, 10)
   fmt.Println(resultSlice)
}
```

很明显，main()函数开头的两行代码和普通的代码不同，前面有个“defer”。**“defer”的作用是让整句代码延迟执行，且多个defer存在时，它们的顺序是反向的。**

根据这一规律，我们便可推测上述代码运行的结果将是：

>[2 3 5 7]   
>查找素数

defer的典型应用场景是执行一些**收尾工作**，通常是在常规逻辑执行结束后释放系统资源。如文件读写、网络IO等等。也用于程序在**发生宕机时的恢复**。

### 匿名函数的定义和调用

> 回调保证了程序运行的正确性和及时性。**匿名函数则是实现回调的核心技能**。

在Go语言中，匿名函数的定义格式如下：

```go
func ([params_list])([return_values_list]){
    // 函数体
}
```

其中，params_list表示参数列表；return_values_list表示函数的返回值列表；使用大括号包裹起来的部分称为函数体，是匿名函数内部要执行的代码。其中，参数列表和返回值列表是可选的。有些函数无需参数，有些参数运行后并不会有任何返回值，有些函数则无需参数也无需返回值。

> `❗️ 注意： 请大家注意普通函数与匿名函数在定义时的区别，普通函数在定义时仅比匿名函数多了函数名。`

定义了函数后，接下来便是如何调用它。根据使用时机的不同，Go语言提供了两种调用匿名函数的方式：一是在定义时调用；二是将匿名函数赋值给变量，通过变量调用。

举例来说，下面的代码定义了一个匿名函数，实际作用便是在控制台输出传入的参数，类型是string：

```go
func main() {
   // 定义匿名函数
   func(text string) {
      fmt.Println(text)
   }
}
```

> `💡 提示：注意到了吗？和普通函数不同，匿名函数可以在某个普通函数内定义和使用。`

如果要在该函数定义时便调用它，只需在大括号结束后，使用小括号将要传入的参数值包裹起来即可，比如：

```go
func main() {
   // 定义匿名函数
   func(text string) {
      fmt.Println(text)
   }("定义时就调用")
}
```

这段代码中，“定义时就调用”便是要传入的参数了。运行这段代码，控制台将输出这些文字。

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250214174710013.png" alt="image-20250214174710013" style="zoom:30%;" />

另一种调用匿名函数的方法是将匿名函数赋值给某个变量，然后通过变量调用。这听起来很神奇，写起来其实非常简单：

```go
func main() {
   // 定义匿名函数
   exampleVal := func(text string) {
      fmt.Println(text)
   }
   exampleVal("通过变量调用匿名函数")
}
```

如上代码所示，声明了变量exampleVal，并将匿名函数赋值给了它。在后续的代码中，即可随时使用exampleVal变量调用匿名函数了。

* 匿名函数可以作为另一个函数的参数
* 匿名函数可以作为另一个函数的返回值

下面讲解一下匿名函数实现回调的例子（很像java中的函数式编程）

```go
package main
import (
    "fmt"
)
func main() {
    res2 := oper(20, 12, add)
    fmt.Println(res2)
    
    // 匿名函数作为回调函数直接写入参数中
    res3 := oper(2, 4, func(a, b int) int {
        return a + b
    })
    fmt.Println(res3) 
}
func add(a, b int) int {
    return a + b
}
func reduce(a, b int) int {
    return a - b
}
// oper就叫做高阶函数
// fun 函数作为参数传递则fun在这里叫做回调函数
func oper(a, b int, fun func(int, int) int) int {
    fmt.Println(a, b, fun) // 20 12 0x49a810A   第三个打印的是传入的函数体内存地址
    res := fun(a, b)// fun 在这里作为回调函数 程序执行到此之后才完成调用
    return res
}
```

是不是很像 java中的function函数？

### 闭包

go语言支持将一个函数作为参数传递，也支持将一个函数作为返回值。一个外层函数当中有内层函数，这个内层函数会操作外层函数的局部变量。并且，外层函数把内层函数作为返回值，则这里内层函数和外层函数的局部变量，统称为 **闭包结构** 。 这个外层函数的局部变量的生命周期会随着发生改变，原本当一个函数执行结束后，函数内部的局部变量也会随之销毁。但是闭包结构内的局部变量不会随着外层函数的结束而销毁。

```go
package main

import "fmt"

func main() {
	fmt.Println("--------")
	res := closure()
	fmt.Println(res) // 0xf8375c0  返回内层函数函数体地址
	r1 := res()      // 执行closure函数返回的匿名函数
	fmt.Println(r1)  // 1
	r2 := res()
	fmt.Println(r2) // 2
	// 普通的函数应该返回1，而这里存在闭包结构所以返回2 。
	// 一个外层函数当中有内层函数，这个内层函数会操作外层函数的局部变量,并且外层函数把内层函数作为返回值,则这里内层函数和外层函数的局部变量,统称为闭包结构。这个外层函数的局部变量的生命周期会发生改变，不会随着外层函数的结束而销毁。
	// 所以上面打印的r2 是累计到2 。
	fmt.Println("--------")
	res2 := closure() // 再次调用则产生新的闭包结构 局部变量则新定义的
	fmt.Println(res2) // 0xf8375c0
	r3 := res2()
	fmt.Println(r3) // 1
}

// 定义一个闭包结构的函数 返回一个匿名函数
func closure() func() int { // 外层函数
	// 定义局部变量a
	a := 0 // 外层函数的局部变量
	// 定义内层匿名函数 并直接返回
	return func() int { //内层函数
		a++ // 在匿名函数中将变量自增。内层函数用到了外层函数的局部变量，此变量不会随着外层函数的结束销毁
		return a
	}
}
```

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250214181412228.png" alt="image-20250214181412228" style="zoom:40%;" />

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250214181417710.png" alt="image-20250214181417710" style="zoom:40%;" />

## 结构体

### 定义

在Go语言中，定义结构体的标准格式为：

```go
type StructName struct {
   // 属性字段
}
```

其中，开头的type表示要定义自定义的类型；StructName代表结构体的名称；struct表示结构体类型；由大括号包裹的部分是属性列表，由一个或若干个字段构成。字段的名称不允许重复。

举例：

```go
type treeNode struct {
	value       int
	left, right *treeNode
}
```

### 使用

#### 声明与初始化

```go
type treeNode struct {
	value       int
	left, right *treeNode
}

func main() {
	var root treeNode

	root = treeNode{value: 3} // 直接指定 value

	root.left = &treeNode{} // 因为left是指针，所以要用 `&` 取地址

	root.right = &treeNode{5, nil, nil} // 也可以按照顺序指定值

	root.right.left = new(treeNode) // 套用 内建函数 new
	
	// 也可以直接用 slides 方式 创建
	nodes := []treeNode{
		{value: 3},
		{},
		{6, nil, &root},
	}
	fmt.Println(nodes)
}
```

> 不论地址还是结构体本身，一律使用. 来访问成员

#### 访问和修改属性值

在Go语言中，改变或完善（针对初始化时未赋值的情况）结构体内属性值的方法是非常简单的，其格式为：

```go
变量名.属性名=值
```

举例来说：

```go
root.value = 4
```

### 匿名结构体

在实际开发中，还有一类情况，就是某个结构体的作用域很小，甚至只存在于某个函数内部，或是无需创建太多的该结构体变量等等。对于上述情况，Go语言允许我们使用匿名结构体简化编码，即使用匿名结构体。

> `💡 提示：这是本讲第二次介绍简化编码的方式了，这便是Go语言中结构体使用简便特性的体现。大家还记得上一个简化编码是用来做什么吗？答案是——初始化结构体变量`

举例来说，还是游戏中的场景。某天，温玉琳琅来到许愿树下进行许愿，这一天是她的生日，许愿树这个植物仅在生日场景中出现。因此为了简化编码，考虑使用匿名结构体来定义和使用它。

使用匿名结构体的方法并不难，实际上就是省略了单独的结构体定义。而是将定义和相关变量的声明、属性赋值合三为一处理。如果我们要声明一个变量来表示许愿树，示例代码如下所示：

```go
wishingTree := struct {
   height   float64
   width    float64
   treeType string
}{
   height:   22.5 * 100,
   width:    50,
   treeType: "banyan"}
fmt.Println(wishingTree)
```

仔细阅读上述代码，wishingTree便是表示许愿树变量了，它是结构体（struct）类型。结构体内包含3个属性，分别是浮点型的高度（height）、浮点型的胸径（width）以及字符串型的树品种。这3个属性由一个大括号包裹起来。紧随其后的大括号是为属性赋值的过程，其规则依然是允许全部赋值，也允许部分赋值。简化的赋值方式同样适用，这里不再赘述。

`❗️ 注意：即使不为任何属性赋值，第二个大括号也是必不可少的，否则将引发编译时错误，程序无法被编译和运行。`

运行上述代码，可见控制台如下输出：

> 2250 50 banyan

### 构造函数

其实就是用工厂函数新建结构体

```go
type treeNode struct {
	value       int
	left, right *treeNode
}

func createTreeNode(value int) *treeNode {
	return &treeNode{value: value} // 返回的是局部变量的地址，但跟C不一样，不会导致程序崩溃
}

func main() {
  root1 := treeNode{value: 3}

	root2 := createTreeNode(4)
}
```

> 1. 在工厂函数中，我们通常返回一个结构的地址，无需特别考虑其在何处分配，只需返回局部变量的地址即可。
> 2. 局部变量的存储位置（栈或堆）由编译器和运行环境决定，这在Go语言中尤其如此，因为Go具有自动垃圾回收机制。
> 3. 如果局部变量被取地址并返回，编译器会认为它需要在堆上分配，以便外部使用，从而参与垃圾回收过程。
> 4. 这种机制简化了程序设计，开发者无需关心对象的具体分配位置，只要确保不再使用时，指针会被正确处理，对象将被自动回收。
> 5. 与C++等需要手动管理内存的语言不同，Go语言的这一特性使得返回局部变量的地址成为可能，同时也简化了内存管理的复杂性。

### 为对象定义方法

在Go语言中，方法和函数的定义格式非常像，大家可不要搞混了。由于方法和对象存在紧密的关系，因此在定义的格式上需要**接收器**，具体格式如下：

```go
func (接收器变量 接收器类型) 方法名(参数列表) (返回参数) {
    函数体
}
```

其中，**接收器变量和接收器类型共同构成了接收器**；参数列表是可选的；返回参数也是可选的；方法名无需多做解释。

```go
type treeNode struct {
	value       int
	left, right *treeNode
}

func (node treeNode) print() {
	fmt.Println(node)
}

func main() {

	root2 := createTreeNode(4)

	root2.print() // root2 对象 就可以 直接使用了
}
```

其实跟正常函数一样：

```go
type treeNode struct {
	value       int
	left, right *treeNode
}

func (node treeNode) print() {
	fmt.Println(node)
}

func print(node treeNode) {
	fmt.Println(node)
}
```

#### 对象定义方法是否使用指针

为对象定义方法时，需要注意接收器的类型。使用指针与否，将决定了是否对原始变量产生影响。本例使用了\*Dog，即指针类型，在方法中对该类型变量（d变量）的任何影响都将影响原始变量（fatShibaInu）；反之，若使用Dog类型，则不会影响。

其原因是当不使用指针类型变量时，方法中的接收器变量实际上是对原始数据的“拷贝”，所做出的改变也仅仅会作用于这份“拷贝”的数据上，并不会影响到原始数据。

对比来说，我们分别定义两个不同的方法——GrowUp()和GrowUp2()，前者使用指针类型接收器，后者不使用。方法体均是对相应变量中的年龄属性自增1，然后在控制台输出运行结果。测试代码关键部分如下：

```go
func (d *Dog) GrowUp() {
   d.Age++
}

func (d Dog) GrowUp2() {
   d.Age++
}

func main() {
   fatShibaInu := NewDog("Shiba Inu", 2, 12.0, "公")

   fatShibaInu.GrowUp()
   fmt.Println(fatShibaInu)

   fatShibaInu.GrowUp2()
   fmt.Println(fatShibaInu)
}
```

运行结果为：

> Shiba Inu 3 12 0
>
> Shiba Inu 3 12 0

显然，虽然GrowUp2()方法也对d变量中的Age属性做了自增1计算，但并未影响原始数据。

### 结构体的嵌套

> 在Go语言中，没有直接等同于Java中`extends`的关键字，因为Go不支持传统的类继承。Go使用组合（composition）来复用代码，而不是继承。

我们先来实现作为父结构体的动物（Animal），这个结构体具有名字（Name）、年龄（Age）和性别（Gender）属性。

> `💡 提示：请留意这三个属性也是本例中所有子结构体所具有的。`

示例代码如下：

```go
type Animal struct {
   Name   int
   Age    int
   Gender string
}
```

接下来，以子结构体鸟（Bird）为例，它还具有翅膀颜色的属性。因此，Bird的结构体定义示例如下：

```go
type Bird struct {
   WingColor    string
   CommonAnimal Animal
}
```

很明显地，Bird结构体中包含了一个名为CommonAnimal的Animal类型成员，而Animal类型就是我们刚刚定义好的结构体。如此，便完成了结构体的嵌套，即把Animal嵌入Bird中。从此，Bird也具有了Animal中的Name、Age和Gender属性了。

```go
func NewBird(name string, age int, gender string, wingColor string) *Bird {
   return &Bird{
      WingColor: wingColor,
      CommonAnimal: Animal{
         Name:   name,
         Age:    age,
         Gender: gender,
      },
   }
}
```

接着，鸟还有“飞行”的动作。使用上一讲中“方法”的知识，创建Bird类型的“飞行”方法：

```go
func (b *Bird) Fly() {
   fmt.Println("我起飞啦！")
}
```

关于“鸟”的结构体定义、构造函数和方法的实现到此先告一段落。我们回到main()函数中使用它们。

在main()函数中，首先声明一个变量，名为bird，使用NewBird()构造函数为其赋值，然后再调用Fly()方法，让小鸟执行飞行动作。完整的代码如下：

```go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

type Bird struct {
   WingColor    string
   CommonAnimal Animal
}

func NewBird(name string, age int, gender string, wingColor string) *Bird {
   return &Bird{
      WingColor: wingColor,
      CommonAnimal: Animal{
         Name:   name,
         Age:    age,
         Gender: gender,
      },
   }
}

func (b *Bird) Fly() {
   fmt.Println("我起飞啦！")
}

func main() {
   bird := *NewBird("小鸟", 1, "公", "绿色")
   fmt.Println(bird)
   bird.Fly()
}
```

从输出的格式上，我们也可看出，Animal类型确实被Bird类型嵌入其中。那么，问题也随之而来：若想访问Bird中的Animal中的Name属性值，该怎么做呢？

思路其实非常简单，也是层层嵌套地访问就可以了。就拿本例来说，bird.CommonAnimal访问到的是CommonAnimal属性，它是Animal类型；bird.CommonAnimal.Name，访问到的就是CommonAnimal中的Name属性了。

类似地，我们继续定义子结构体狗（Dog），它拥有毛色（Color）属性。还有犬吠（Bark）动作。请读者参考上面小鸟（Bird）部分的代码，独立完成狗（Dog）部分的代码，要求依然使用构造函数（NewDog()）和方法（Bark()）。

完整的代码如下：

```go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

type Dog struct {
   Color        string
   CommonAnimal Animal
}

func NewDog(name string, age int, gender string, color string) *Dog {
   return &Dog{
      Color: color,
      CommonAnimal: Animal{
         Name:   name,
         Age:    age,
         Gender: gender,
      },
   }
}

func (d *Dog) Bark() {
   fmt.Println("汪汪汪！")
}

func main() {
   dog := *NewDog("小狗", 2, "公", "黄色")
   fmt.Println(dog)
   dog.Bark()
}
```

有了Bird，Dog的实现应该不会有问题吧？

在继续之前，我有个问题要考考大家：dog变量是Dog类型，bird变量是Bird类型。那么，dog可以执行Fly()方法吗？反过来，bird可以执行Bark()方法吗？为什么？

答案是：统统**不能**。

因为Fly()方法的接收者是\*Bird，Bark()方法的接收者是\*Dog。**动作的接收者不同，意味着发生或执行动作的对象不同，因此不能混用。**（想想现实世界中，有谁见过小鸟犬吠，小狗起飞吗？）

但是，有一些动作确实是小狗和小鸟同时具备的，比如：吃饭（Eat）。几乎没有哪种动物（Animal）能够不吃饭而存活吧？

那么，若要实现吃饭这个动作，继续为Bird和Dog分别创建方法当然是可行的。但又没有更好的实现方式呢？

当然有！Bird和Dog都是由Animal派生而来，而吃饭（Eat）又是Animal所具有的公共动作。因此，我们便可为Animal创建一个方法，接收者是\*Animal类型即可。这样一来，**因为Bird和Dog都嵌入了Animal类型数据，自然也就可以执行Animal的动作了**。

下面，创建一个接收者是\*Animal类型的方法，名为Eat()。为了体现动作的作用对象，我们在Eat()方法中，将Name属性值一并输出到控制台中。具体代码如下：

```go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

func (a *Animal) Eat() {
   fmt.Println(a.Name, "我要吃到饱！")
}
```

下面，回到main()函数中，使用bird和dog变量逐层调用Eat()方法。具体代码如下：

```go
func main() {
   bird := *NewBird("小鸟", 1, "公", "绿色")
   bird.CommonAnimal.Eat()
   dog := *NewDog("小狗", 2, "公", "黄色")
   dog.CommonAnimal.Eat()
}
```

运行程序，控制台将输出：

> 小鸟 我要吃到饱！
>
> 小狗 我要吃到饱！

通过上面的输出结果可以看出：虽然它们调用的是公共方法，但由于执行该动作的变量不同，最终的输出结果也会随之变化。这便是我们想要的效果。

### 匿名结构体嵌套

Go语言语法还允许开发者以一种更为简单的方式嵌套结构体使用，这种更简单的方式便是嵌套匿名结构体。在后期使用时，也会被简化。以Bird类型结构体为例，下面的写法是完全合法的：

```go
type Animal struct {
   Name   string
   Age    int
   Gender string
}

func (a *Animal) Eat() {
   fmt.Println(a.Name, "我要吃到饱！")
}

type Bird struct {
   string
   Animal
}

func NewBird(name string, age int, gender string, wingColor string) *Bird {
   return &Bird{
      wingColor,
      Animal{
         name,
         age,
         gender,
      },
   }
}

func (b *Bird) Fly() {
   fmt.Println("我起飞啦！")
}

func main() {
   bird := *NewBird("小鸟", 1, "公", "绿色")
   //访问string类型成员
   fmt.Println(bird.string)
   //访问Name成员
   fmt.Println(bird.Name)
   bird.Eat()
```

上述代码运行后，控制台将输出：

> 绿色
>
> 小鸟             
>
> 小鸟 我要吃到饱！

请大家将这种简化写法与普通的写法对比，重点关注Bird结构体的定义方式、NewBird()构造函数的实现方式以及main()函数中，bird变量的字段取值和方法调用方式。

## 接口

### 定义

在Go语言中，定义接口的格式如下：

```go
type interface_name interface {
    function_name( [params] ) [return_values]
    ...
}
```

其中，type关键字表示要自定义类型；interface_name是自定义的接口名；interface表示接口类型；由大括号包裹的部分定义了要被实现方法，一个接口中可以同时存在一个或多个方法。function_name是方法名；params是方法所需的参数；return_values是方法的返回值。params和return_values可以省略，也可以存在一个或多个。

对于本例而言，接口的目的在于规范图片加载的流程。为了讲解方便，我在此将图片加载的过程简化为查找并下载图片一个步骤。

在查找并下载图片时，需要图片下载地址作为依据，并将返回图片的实际数据。因此，我们定义一个名为imageLoader的接口，接口中包含FetchImage()方法，该方法需要string类型的变量作为参数，表示下载地址，返回string类型（在实际开发中通常是byte[]），表示图片数据。

> `💡 提示： 注意到接口的命名（imageLoader）特点了吗？在为接口命名时，一般会在单词后面加上er后缀。接口中的方法名（FetchImage()）首字母大小写决定了该方法的可访问范围。`

具体代码如下：

```go
// ImageDownloader 图片加载接口
type ImageDownloader interface {
	// FetchImage 获取图片，需要传入图片地址，方法返回图片数据
	FetchImage(url string) string
}
```

如此，接口的定义便完成了。

### 接口的实现

在Go语言中，实现接口的格式如下：

```go
func (struct_variable struct_name) function_name([params]) [return_values] {
   // 方法实现 
}
```

其中，struct_name_variable和struct_name一起，表示作用的对象。对于本例而言，则是*fileCache类型的变量。紧接着的function_name是方法名，params指的是方法所需的参数，return_values指的是方法的返回值。其中，params和return_values是可选的，也允许有多个值。

我们先来实现从本地缓存中获取图片数据的部分，代码如下：

```go
type fileCache struct {
}
// FetchImage接口实现
func (f *fileCache) FetchImage(url string) string {
	return "从本地缓存中获取图片：" + url
}
```

对比FetchImage()方法的接口声明：

```go
// FetchImage 获取图片，需要传入图片地址，方法返回图片数据
FetchImage(url string) string
```

发现了吗？在实现方法时，需要满足两个条件：

- 第一是**接口中定义的的方法与实现接口的类型方法格式一致**。这要求不仅方法名称相同，参数和返回值也要相同；

- 第二就是**接口中定义的所有方法全部都要实现**。

如法炮制，继续定义负责从网络下载图片的结构体以及作用于该结构体的接口实现：

```go
// 定义从网络下载图片的结构体
type netFetch struct {
}
// FetchImage接口实现
func (n *netFetch) FetchImage(url string) string {
	return "从网络下载图片：" + url
}
```

到此，接口的定义和实现就都已完成。下一步就是回到main()函数中使用它们了。

### 接口的调用

来到main()函数，定义一个ImageDownloader类型的变量，然后通过new(fileCache)函数为其赋值，随后便可通过这个变量调用从缓存中加载图片的方法。类似地，通过new(netFetch)为其赋值，便可通过这个变量调用从网络上下载图片的方法。

> `💡 提示： 为何ImageDownloader类型的变量可以通过new(fileCache)或new(netFetch)进行赋值呢，你知道原因吗？`

从具体的业务需求分析，我们应首先检查本地缓存是否存在相应的图片数据，当找不到时再从网络中获取。因此，整个接口调用部分的示例代码如下：

```go
func main() {
	// 从本地缓存中获取数据
	var imageLoader ImageDownloader
	imageLoader = new(fileCache)
	data := imageLoader.FetchImage("https://www.example.com/a.png")
	fmt.Println(data)
	if data == "" {
		// 当本地缓存中没有数据时，从网络下载
		var imageLoader2 ImageDownloader
		imageLoader2 = new(netFetch)
		data2 := imageLoader2.FetchImage("https://www.example.com/a.png")
		fmt.Println(data2)
	}
}
```

如上所示，代码的逻辑将首先检查本地缓存，当返回值为空字符串（""）时，即表示本地无缓存。此时，应考虑去网络上下载图片。

将本讲示例代码汇总并运行，控制台可得如下输出：

> 从本地缓存中获取图片：https://www.example.com/a.png

修改针对*fileCache的FetchImage()方法，使其返回值为空字符串（""），再次运行程序，控制台上的输出将变为：

> 从网络下载图片：https://www.example.com/a.png

### 空接口与泛型

#### 泛型初体验

什么时候该使用泛型呢？举个例子，如果我们想要封装一个函数，该函数的作用便是实现传入参数数据的原样输出，该如何做呢？

利用我们已经掌握的知识，写出的代码可能会是这样：

```go
func main() {
   dataOutput("Hello")
}

func dataOutput(data string) {
   fmt.Println(data)
}
```

直接运行这段程序，控制台会输出：

> Hello

看似没有问题，但如果传入的参数不是string类型，而是数字型、布尔型呢？显然，程序是无法编译通过的，因为类型不匹配。

当然，我们也可以编写多个函数，来匹配不同的参数类型，比如：

```go
func main() {
   stringDataOutput("Hello")
   intDataOutput(123)
}

func stringDataOutput(data string) {
   fmt.Println(data)
}

func intDataOutput(data int) {
   fmt.Println(data)
}
```

如此确实可以实现，但代码整体不够优雅。况且这还只是两种类型，要是更多，日后的代码维护成本就会直线飙升了。

细心的朋友会发现，尽管类型不同，但函数体内实际执行的逻辑都是相通的。那么，有没有一种办法使函数的参数不再受限呢？当然有，那就是使用泛型。

**泛型是类型中的“万能牌”**，使用泛型作为函数参数，实际上就相当于告诉调用者：“我能兼容任何类型的参数，尽管将数据传给我就是了。”泛型以超级宽广的胸怀接纳所有类型的数据。**在Go语言中的泛型，则使用空接口来实现。** 而所谓的“空接口”，使用代码表示非常简单，就是：

```go
interface{}
```

和普通接口的定义格式不同，空接口内部无需填写任何方法。

**空接口能接纳所有类型的数据，因此可以将任何类型的数据赋值给它的变量**，请大家阅读下面这段代码：

```go
var anyTypeValue interface{}

func main() {
   anyTypeValue = 123
   anyTypeValue = true
   anyTypeValue = "Hello"
}
```

这段代码完全合法，可以编译、运行。

另一方面，**在函数参数中使用空接口，可以使其能接受所有类型的数据传入。** 以本讲一开始的示例举例，若要编写一个函数，实现传入参数数据的原样输出，只需按如下编写代码即可：

```go
func main() {
   dataOutput("Hello")
   dataOutput(123)
   dataOutput(true)
}

func dataOutput(data interface{}) {
   fmt.Println(data)
}
```

程序运行结果为：

> Hello
>
> 123
>
> true

如此编码，是不是比写一堆类似的函数要方便、简洁很多呢？还能节省开发和维护的时间。

> `💡 提示： 猜一猜，如果在dataOutput()函数中输出data变量的类型，将会如何输出呢？各位朋友不妨亲自动手一试，获取数据类型的函数是reflect.TypeOf(i interface{})。注意到了吗？这个函数所需的参数类型也是空接口类型，即泛型。`

#### 货车容量计算器

现在，我们计划进行一次搬家，正在预估需要多大容量的货车来存放全部家当。

为了讲解方便，本例将简化各种家具家电的体积计算方式。把它们简单粗暴地分为正方体、长方体和圆柱体三种体积形式，这三种形状的物品分别对应代码中的三种结构体类型。

此外，还需实现为这三种形状的物品编写体积计算的方法。如此一来，我们便可通过调用这个体积计算的方法，将其计算结果累加在一起，便可得知需要至少多大容量的货车了。

还记得如何定义一个结构体吧？以正方体为例，计算体积仅需要知道边长就可以了。所以我们定义一个名为cube的结构体，其中包含float64类型的length变量，表示边长，具体代码如下：

```go
// 正方体
type cube struct {
   // 边长
   length float64
}
```

接着，定义一个方法，名为cubeVolume，表示计算正方体的体积。作用于\*cube类型，返回float64类型值，具体代码为：

```go
// 正方体的体积计算
func (c *cube) cubeVolume() float64 {
   return c.length * c.length * c.length
}
```

如上，关于正方体的结构体和体积计算方法已经全部实现完成。依葫芦画瓢，继续实现长方体和圆柱体对应的结构体和体积计算方法。以下是具体的代码片段：

```go
// 长方体
type cuboid struct {
   // 长
   length float64
   // 宽
   width float64
   // 高
   height float64
}

// 长方体的体积计算
func (c *cuboid) cuboidVolume() float64 {
   return c.length * c.width * c.height
}

// 圆柱体
type cylinder struct {
   // 直径
   diameter float64
   // 高度
   height float64
}

// 圆柱体的体积计算
func (c *cylinder) cylinderVolume() float64 {
   return math.Pi * (c.diameter / 2) * (c.diameter / 2) * c.height
}
```

接下来是本讲的另一个重点知识。如果我们想用同样一个函数来计算所有类型物体的体积，那么“认清”家具的种类就是非常必要的一环。换言之，当传入这个函数的参数是正方体，则需要调用cubeVolume()函数进行计算；当传入这个函数的参数是长方体，则需要调用cuboidVolume()函数进行计算；当传入这个函数的参数是正方体，则需要调用cylinderVolume()函数进行计算。

**在Go语言中，用来判断某个数据是否属于某种类型的方法被称为“类型断言”。**

类型断言的使用格式为：

```
value, ok := x.(T)
```

其中，x是指某个变量，T表示类型，value是将x变量转换为T类型之后的值，ok是布尔类型，表示x是否属于T类型。

看上去有些绕口，我们用实际的例子来做演示。

前面说过，我们要实现一个函数，传入空接口类型的参数以便接收不同类型形状的家具，然后在这个函数中计算体积并返回最终的计算值。我们先以正方体为例，具体代码如下：

```go
// 计算某个物体的体积
func calcSize(material interface{}) float64 {
   cubeMaterial, cubeOk := material.(cube)
   if cubeOk {
      return cubeMaterial.cubeVolume()
   } else {
      return 0
   }
}
```

请大家仔细阅读这段代码，函数体内首行便进行了类型断言。material是传入该函数的参数，material.(cube)表示要判断material变量是否属于cube（正方体）类型。这种判断最终将返回两个结果，一个是cubeOk，它时布尔类型的值，当该值为true时，表示material是cube类型，反之则不是。另一个是cubeMaterial，它是将material变量转换为cube类型之后的变量，以便后续用它参与运算。

理解了函数中的首行代码，后面的代码便很好理解了。当cubeOK为true，即material属于cube时，使用转换后的cubeMaterial变量执行cubeVolume()方法，最终返回正方体的体积。

接下来，请大家自行编码实现长方体和圆柱体的类型断言和体积计算。

最后，整个程序完整的代码如下：

```go
package main

import (
   "fmt"
   "math"
)

func main() {
   truckSize := 0.0
   // 声明空接口类型变量materials，存放各种不同体积的家具
   var materials []interface{}
   materials = append(materials, cube{12.5})
   materials = append(materials, cuboid{25, 13, 60})
   materials = append(materials, cylinder{5, 25.3})
   // 遍历materials切片，依次计算每个家具的体积，并相加求和
   for _, singleMaterial := range materials {
      truckSize += calcSize(singleMaterial)
   }
   fmt.Println(truckSize)
}

// 计算某个物体的体积
func calcSize(material interface{}) float64 {
   cubeMaterial, cubeOk := material.(cube)
   cuboidMaterial, cuboidOk := material.(cuboid)
   cylinderMaterial, cylinderOk := material.(cylinder)
   if cubeOk {
      return cubeMaterial.cubeVolume()
   } else if cuboidOk {
      return cuboidMaterial.cuboidVolume()
   } else if cylinderOk {
      return cylinderMaterial.cylinderVolume()
   } else {
      return 0
   }
}

// 正方体
type cube struct {
   // 边长
   length float64
}

// 正方体的体积计算
func (c *cube) cubeVolume() float64 {
   return c.length * c.length * c.length
}

// 长方体
type cuboid struct {
   // 长
   length float64
   // 宽
   width float64
   // 高
   height float64
}

// 长方体的体积计算
func (c *cuboid) cuboidVolume() float64 {
   return c.length * c.width * c.height
}

// 圆柱体
type cylinder struct {
   // 直径
   diameter float64
   // 高度
   height float64
}

// 圆柱体的体积计算
func (c *cylinder) cylinderVolume() float64 {
   return math.Pi * (c.diameter / 2) * (c.diameter / 2) * c.height
}
```

程序运行的结果为：

> 21949.889338348887

如此，我们便可有依据地选择货车了。

你注意到了吗？在main()函数中，我**将空接口类型作为切片中的元素**放在了名为materials的切片中。这在实际开发中是非常巧妙的使用空接口的方式，它可以规避数据类型的不同，将不同类型的数据存放于同一个切片/数组中，对于组织大量具有不同类型的数据是非常有效的做法。

### 灵活运用接口

#### 接口的嵌套组合

我们都知道，结构体是允许嵌套使用的。实际上，接口也可以。

举例来说，我们使用浏览器进行下载文件的时候，通常会在保存、另存为和取消之间做出选择。抛开取消不谈，选择保存时，浏览器会自动执行下载和保存两个步骤；选择另存为时，浏览器会先询问文件保存的路径，再开始下载和保存。

如果我们把选择路径、下载、保存看作是待下载文件的3个接口，并用代码来表示，它很可能会是这样的：

```go
// ChooseDest 选择保存路径
type ChooseDest interface {
	chooseDest(localFile string)
}

// Download 执行下载
type Download interface {
	download()
}

// Save 保存文件
type Save interface {
	save()
}
```

细心的朋友会发现，无论何种方式下载文件，其中的下载和保存都是必需且顺序不变的。所以，我们不妨再创建一个接口，使其包含下载和保存两个接口，代码如下：

```go
// DownloadAndSave 下载和保存
type DownloadAndSave interface {
   Download
   Save
}
```

在使用时，我们便可直接声明DownloadAndSave类型的变量去执行下载和保存了，示例代码如下：

```go
func main() {
   // 声明一个file类型的变量，命名为downloadFileExample
   downloadFileExample := new(file)
   // 使用ChooseDest接口
   var chooseDest ChooseDest
   chooseDest = downloadFileExample
   chooseDest.chooseDest("")
   // 使用DownloadAndSave接口
   var downloadAndSave DownloadAndSave
   downloadAndSave = downloadFileExample
   downloadAndSave.download()
   downloadAndSave.save()
}
```

如上代码所示，无需单独声明Download和Save接口变量，仅使用DownloadAndSave接口变量便可调用download()和save()两个方法。

#### 从空接口取值

在上一讲中，曾经使用过类似下面这样的案例：

```go
func main() {
   dataOutput("Hello")
}

func dataOutput(data interface{}) {
   fmt.Println(data)
}
```

为了实现“将传入的参数按原样输出”的需求，我们编写了dataOutput()函数。该函数所需的参数是空接口，能接纳所有类型的数据，然后通过调用fmt.Println()将数据输出，满足了需求。

现在，如果想从data中获取数据，并赋值给某个变量，该如何做呢？显然，可以如下实现：

```go
func dataOutput(data interface{}) {
   fmt.Println(data)
   var stringValue string = data
   fmt.Println(stringValue)
}
```

暂且将上述方法当作方法A。

再看如下实现：

```go
func dataOutput(data interface{}) {
   fmt.Println(data)
   stringValue := data.(string)
   fmt.Println(stringValue)
}
```

暂且将该方法当作方法B。

猜一猜，哪种方法可以呢？

答案是：**方法B**。

是不是很奇怪，为什么方法A不行呢？实际上，当我们按照方法A去写时，GoLand会自动识别出问题，提示：Cannot use 'data' (type interface{}) as the type string，意思是无法将类型为interface{}的data变量作为string类型使用。

这是因为在进行类型断言前，谁也不知道data里放的是何类型。举个形象一点的例子，虽然箱子里装了某样货物，但箱子依然还是箱子，是不能将箱子当货使用的。

所以，在从空接口中取值时，切记要使用类型断言。

#### 空接口的值比较

撸起袖子，我们一起来挑战几道题。

不要用电脑编译和运行下面的代码，先猜猜它们的运行结果。

```go
func main() {
   var a interface{} = 10
   var b interface{} = "10"
   fmt.Println(a == b)
}
```

相信各位都能回答正确，上面这段代码运行结果为：

> false

挑战继续，再来试试这个：

```go
func main() {
   var a interface{} = []int{1, 2, 3, 4, 5}
   var b interface{} = []int{1, 2, 3, 4, 5}
   fmt.Println(a == b)
}
```

上面这段代码运行后，程序会发生宕机。报错信息如下：

> panic: runtime error: comparing uncomparable type []int

从字面上看，错误原因是程序比较了不可比较的类型——[]int。

在Go语言中，**有两种数据是无法比较的，它们是：Map和Slice**，强行比较会引发如上宕机错误。

数组是可以比较的，而且会比较数组中每个元素的值。因此，只需将上述代码改为：

```go
func main() {
   var a interface{} = [5]int{1, 2, 3, 4, 5}
   var b interface{} = [5]int{1, 2, 3, 4, 5}
   fmt.Println(a == b)
}
```

程序便会正常运行，输出结果：

> true

#### 接口与nil

在Go语言中，nil是一个特殊的值，它只能赋值给指针类型和接口类型。

让我们来挑战下面这段代码，还是不要用电脑编译运行，猜一猜它的输出结果：

```go
func main() {
   var a interface{} = nil
   fmt.Println(a == nil)
}
```

这段代码运行后，控制台将输出：

> true

应该没什么疑问吧？继续看下面的代码：

```go
type Person struct {
   name   string
   age    int
   gender int
}

type SayHello interface {
   sayHello()
}

func (p *Person) sayHello() {
   fmt.Println("Hello!")
}

func getSayHello() SayHello {
   var p *Person = nil
   return p
}

func main() {
   var person = new(Person)
   person.name = "David"
   person.age = 18
   person.gender = 0
   var sayHello SayHello
   sayHello = person
   fmt.Println(reflect.TypeOf(sayHello))
   fmt.Println(sayHello == nil)
   fmt.Println(getSayHello())
   fmt.Println(getSayHello() == nil)
}
```

猜一猜最终控制台将输出什么呢？

答案是：

> *main.Person
>
> false
> nil
>
> false

是不是也很奇怪？

输出第一个false无可厚非，可输出的第二个false就很耐人寻味了。第二个false来自于main()函数中调用的getSayHello()函数，该函数返回SayHello类型的接口，函数体内返回了nil值的*Person。直接输出getSayHello()函数的结果，是nil，但与nil比较时却不是true。

这是因为：**将一个带有类型的nil赋值给接口时，只有值为nil，而类型不为nil。此时，接口与nil判断将不相等。**

那么，为了规避这类问题，我们不妨在getSayHello()函数值做些特殊处理。当函数体中的p变量为nil时，直接返回nil即可。发生修改部分的代码如下：

```go
func getSayHello() SayHello {
   var p *Person = nil
   if p == nil {
      return nil
   } else {
      return p
   }
}
```

再次运行程序，控制台输出如下：

> *main.Person
>
> false
> nil
>
> true


## 包

在一开始配置好开发环境后，我们一起编写了一个能输出“Hello World”的程序：

```go
package main
import "fmt"
func main(){
    fmt.Println("Hello World!")
}
```

尽管那个程序非常简单，只有5行，但有些细节还是值得深入挖掘的。比如，第一行的package时什么意思，第二行的import到底做了什么……

这些问题看似互相独立，但都和一个话题有关，它就是——**Go程序源码的组织结构**。本讲就来带大家彻底搞清楚一个Go程序的源码是如何组织起来的。

### 包的声明

在Go源码中，**package的意思就是包，后面跟着的就是包名。Go语言通过包来组织源码，拥有相同包名的Go源码属于同一个包。每一个包就相当于一个目录。**

“封装”和“复用”等就可以用包来实现。

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/image-20250214170739330.png" alt="image-20250214170739330" style="zoom:25%;" />

在Hello World的源码中，第一行的内容是：

```go
package main
```

这句话就表示这个源码属于main包。Go语言有一个强制性要求，就是**源码文件的第一行有效代码必须声明自己所在的包**。

需要特别指出的是：**main包是一个比较特殊的包。一个Go程序必须有main包，且只能有一个main包**。

### 包的使用

使用import 导入包。go自己会默认从GO的安装目录和GOPATH环境变量中的目录，检索src下的目录进行检索包是否存在。所以导入包的时候路径要从src目录下开始写。GOPATH 就是我们自己定义的包的目录。

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/17251028e11df2b0~tplv-t2oaga2asx-jj-mark:1600:0:0:0:q75.png" style="zoom:25%;" />

我们导入包目的是要使用写在其他包内的函数，或者包里面的结构体方法等等，如果在同一个包下的内容不需要导包，可以直接使用。也可以给包起别名，如果包原有名称太长不方便使用，则可以在导入包之前加上别名。

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/172510b1a4daeb96~tplv-t2oaga2asx-jj-mark:1600:0:0:0:q75.png" style="zoom:25%;" />

### 包管理方案

程序在编写过程中往往会使用到除自己程序外的第三方包，可以使用Go命令 `go get` 来导入需要的第三方包到配置的GOPATH中。

#### dep 管理方案

但是早期的Go语言被很多开发者所诟病的一个问题是依赖包的管理，在Golang1.5版本之前需要设置GOPATH来解决所有包依赖的问题，但是这样会有很多问题，如果我们两个项目引用的包版本不一致，而GOPATH中只有一个版本，就需要使用多个GOPATH来解决这样的问题，这样来回切换GOPATH是很不方便的。于是Go在1.9之后加入包管理方案解除了GOPATH的依赖。于是出现了`dep`和`glide`在项目中加入了`vender`目录来存储所有项目中需要引入的包。

**安装dep**

> `brew install dep`

<img src="./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/1725686ababbbdbf~tplv-t2oaga2asx-jj-mark:1600:0:0:0:q75.png" style="zoom:25%;" />

使用 `dep status` 查看项目依赖的详细信息和状态。

`dep ensure` 查看所有的依赖库都已经安装，如果没有就去下载。 `dep ensure add github.com/go-sql-driver/mysql` 下载添加新的依赖库，并增量更新清单文件和校验描述文件。 dep不是每次都去下载，他会先在本地环境中找如果没有找到则会到网上下载并添加到本地仓库。

#### mod 模块化管理方案

Go.mod是Golang1.11版本新引入的官方包管理工具用于解决之前没有地方记录依赖包具体版本的问题，方便依赖包的管理。

使用`go mod` 管理项目，不需要非得把项目放到GOPATH指定目录下，可以在电脑上任何位置新建一个项目。

#### mod 初始化

使用mod需要注意的是：

* 如果Go的版本太低不能使用，建议将Go的版本升级到最新。
* 环境变量中可以增加`GOPROXY=https://goproxy.io` 这样没有梯子的情况下可以正确的加载相应的包文件。
* 环境变量`GO111MODULE`不要设置，如果已经增加了这个变量请务必设置为`GO111MODULE=auto`。
* 在项目的根目录下使用命令`go mod init projectName`。

### Go 程序是怎么跑的

#### main()函数

从示例的第3行开始到最后，都是main()函数了：

```go
func main(){
    fmt.Println("Hello World!")
}
```

在Go语言中，**main()函数是程序的入口函数，它位于main包中。如果想要编译生成可执行文件，main()函数则是必须的**。如果将示例代码中的main()函数去掉直接编译，可以看到控制台会输出如下错误：

> runtime.main_main·f: function main is undeclared in the main package

大意就是说main()函数没有在main包中声明。

我们还可以看到在main()函数中可以调用fmt包中的函数，这正是由于我们导入了fmt包才能做到的。

####  Go源码的启动流程

我们都知道，main()函数是Go程序的入口函数。实际上，Go程序还有一个init()函数，被称为“初始化”函数。我们来看下面这段代码：

```go
package main
import "fmt"
func init() {
   fmt.Println("Hello")
}
func main() {
   fmt.Println("World")
}
```

上述代码运行后，控制台将输出：

> Hello
>
> World

发现规律了吗？没错，init()函数在main()函数之前执行，经常做一些程序初始化的工作，因此它被称为初始化函数。

对于一个较为复杂的软件代码而言，通常会按照前面介绍过的“分而治之”的编码方式进行开发。特别是在多人协同开发场景中，由于每个人负责的功能模块不同，通常会将一个完整的软件产品代码分为多个包。一旦Go程序开始运行，main包中的代码便会首先得到执行，所有导入的包会执行其中的init()初始化函数。

下图较为清晰地描述了Go源码的启动过程：

![image.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/6c91ccc186824ea8b8ad06dc2b28faf8~tplv-k3u1fbpfcp-watermark.png)

我们从左上角的开始处分析这张图，可以发现Go源码的启动流程是这样的：

1. 程序开始运行后，首先来到main包，检索所有导入的包。发现代码中导入了A包，于是来到A包；
2. 发现A包代码中导入了B包，于是又来到B包；
3. B包代码没有导入任何其它的包，于是开始声明B包内的常量和变量，并执行B包中的init()函数；
4. 回到A包，进行A包内的常量和变量的声明，并执行A包中的init()函数；
5. 回到main包，执行main包内的常量和变量的声明，并执行main包中的init()函数；
6. 执行main包中的main()函数。

> `💡 提示：了解Go源码的启动加载过程，有助于编写更高效率的代码，排查程序启动缓慢等性能问题。`

## 数据库

### 集成包

现在开始动手！

前文已经说到，Go SDK中并未附带连接数据库的包，因此需要我们自己去找合适的包来使用。幸运的是，我们很快就能找到相应的包：[go-sql-driver/mysql](https://pkg.go.dev/github.com/go-sql-driver/mysql)。

> `💡 提示：还记得去哪里搜索源码包吗？当然是Go语言官方提供的package库首页：https://pkg.go.dev/ ，只需在搜索框中输入 mysql，就会看到很多搜索结果。通过查看包详情，可以得知包的作用、发布时间、使用人数、使用方法等等，由此便可做出选择。`

找到合适的包后，使用命令行将该包集成到项目中。创建一个工程，名为 go-juejin-note-book-server。启动 GoLand 中的 Terminal 视图，使用 go get 命令集成库：

```shell
go get -u github.com/go-sql-driver/mysql
```

在执行这条命令的时候，很有可能会受到网络错误的提示。解决办法很简单，只需将获取包的 GOPROXY 环境变量指向国内镜像源即可，具体如下：

```shell
$ go env -w GO111MODULE=on
$ go env -w GOPROXY=https://goproxy.cn,direct
```

其实，国内的镜像源网站不止一个，阿里云同样也支持（[阿里云 Go Module代理服务 ](http://mirrors.aliyun.com/goproxy/)）。在学习本讲内容时，若刚好上述镜像源均已失效，您还可以自行查找，完全不用担心。

集成成功后，再次回到 GoLand，打开 Project 视图，然后打开 External Libraries，可以在其中找到github.com/go-sql-driver/mysql，如下图所示：

![image-20220412144953560.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/ec79ffc24e154a29b114e015bb0f8080~tplv-k3u1fbpfcp-watermark.png)

### 实现网络请求的响应

本例将响应用户的5类请求，对应5个接口地址，具体如下：

- 根路径（/）：接受 POST/GET 请求，均返回欢迎信息和接口调用地址的含义；
- 添加一条记事本数据（/add）：仅接受 POST 请求，传入标题、正文和日期时间，添加成功后返回添加的标题；
- 根据 id 删除一条记事本数据（/delete）：接受 POST/GET 请求，传入 id，删除该 id 所属的数据，删除成功后返回成功结果；
- 根据id更新一条记事本数据（/update）：接受 POST/GET 请求，传入 id 和新的标题、正文和日期时间，用新传入的数据覆盖已有的数据，更新成功后返回成功结果；
- 查询记事本数据，可传入 id 进行精准查找（/query）：接受 POST/GET 请求，支持根据 id 进行单条数据的查找或查找全部数据，执行成功后返回查询结果集。

以下是完整的代码：

```go
package main
import (
   "fmt"
   "net/http"
   "time"
)
type notebook struct {
   Id       int
   Title    string `json:"title"`
   Content  string `json:"content"`
   DateTime string `json:"dateTime"`
}
func main() {
   launchServer()
}
// 添加数据到数据库
func add(data notebook) {
}
// 删除一条数据
func del(id string) {
}
// 更新数据到数据库
func update(id string, data notebook) {
}
// 从数据库获取数据
func query(id string) []notebook {
   var notebooks []notebook
   return notebooks
}
// 启动服务器
func launchServer() {
   //响应/
   http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
      fmt.Fprintf(w, "欢迎使用在线记事本\n")
      fmt.Fprintf(w, "▶▶ /add 添加新的数据\n")
      fmt.Fprintf(w, "▶▶ /delete 根据ID删除数据\n")
      fmt.Fprintf(w, "▶▶ /update 根据ID更新数据\n")
      fmt.Fprintf(w, "▶▶ /query 获取全部数据或根据ID获取单条数据\n")
   })
   //响应/add，从传入的参数新增一条记事本
   http.HandleFunc("/add", func(w http.ResponseWriter, r *http.Request) {
      if r.Method == "POST" {
         err := r.ParseForm()
         if err != nil {
            fmt.Fprintln(w, "错误的请求")
         } else {
            title := r.FormValue("title")
            content := r.FormValue("content")
            dateTime := r.FormValue("dateTime")
            add(notebook{Title: title, Content: content, DateTime: dateTime})
            fmt.Fprintln(w, "添加了："+title)
         }
      }
   })
   //响应/delete，从传入的参数删除一条记事本
   http.HandleFunc("/delete", func(w http.ResponseWriter, r *http.Request) {
      err := r.ParseForm()
      if err != nil {
         fmt.Fprintln(w, "错误的请求")
      } else {
         id := r.FormValue("id")
         del(id)
         fmt.Fprintln(w, "删除成功")
      }
   })
   //响应/update，更新一条数据
   http.HandleFunc("/update", func(w http.ResponseWriter, r *http.Request) {
      err := r.ParseForm()
      if err != nil {
         fmt.Fprintln(w, "错误的请求")
      } else {
         id := r.FormValue("id")
         title := r.FormValue("title")
         content := r.FormValue("content")
         dateTime := r.FormValue("dateTime")
         update(id, notebook{Title: title, Content: content, DateTime: dateTime})
         fmt.Fprintln(w, "更新成功")
      }
   })
   //响应/query，从传入的参数删除一条记事本
   http.HandleFunc("/query", func(w http.ResponseWriter, r *http.Request) {
      err := r.ParseForm()
      if err != nil {
         fmt.Fprintln(w, "错误的请求")
      } else {
         id := r.FormValue("id")
         fmt.Fprintln(w, query(id))
      }
   })
   //启动本地服务器（localhost）
   err := http.ListenAndServe(":80", nil)
   if err != nil {
      fmt.Println("启动服务失败，错误信息：", err)
   }
}
```

显然，这段代码中的 add()、del()、update() 和 query() 函数就是真正操作数据库的函数了！不过别急，如果要进行数据库的CRUD操作，首先要做的是要成功地连接到数据库，检查并创建相应的数据表，最后才是针对表的数据操作。当然，这一切的操作均要使用 mysql 包中的函数。

### 建立连接

根据 mysql 包的[说明](https://github.com/go-sql-driver/mysql)，首先需要import。具体如下：

```go
import (
   "database/sql"

   _ "github.com/go-sql-driver/mysql"
)
```

请大家留意，这里在 import 时，使用了下划线（“\_”）开头。**“\_”是一个特殊标识符，它表示仅执行包内的init()函数，不做其它之用。**

接着，创建一个名为 connectToDb() 的函数，用来与 MySQL 数据库建立连接，并返回 \*sql.DB 类型值。在后续的建表以及 CRUD 操作时会频繁用到这个值。

看到这，有些朋友或许会感到好奇：“才刚到连接的步骤，你怎么知道后续的步骤该用什么呢？”实际上，**在编码之前，如果我们使用了其它的包（在实际开发中，这是非常常见的场景），务必要先了解这个包的用法。而要了解某个包的用法，最靠谱的办法就是看官方文档。**

mysql 包的官方文档就给出了有关建表和 CRUD 操作的具体示例：[Examples · go-sql-driver/mysql Wiki (github.com)](https://github.com/go-sql-driver/mysql/wiki/Examples)。从中我们便可得知，建立连接后返回的 \*sql.DB 类型值将频繁用于后续步骤。

根据官方指导文档中所述的内容，建立连接的函数是 sql.Open()，其中需要传入数据库连接凭据。此外，我们还可以根据实际情况设置最大连接数等参数。具体代码如下：

```go
var db *sql.DB
// 连接到数据库
func connectToDb() *sql.DB {
   db, _ := sql.Open("mysql", "root:123456@/go_learn")
   // 设置可重用链接的最长时间（0为不限制）
   db.SetConnMaxLifetime(time.Hour * 1)
   // 设置连接到数据库的最大数量（默认值为0，即不限制）
   db.SetMaxOpenConns(5)
   // 设置空闲连接的最大数量（默认值为2）
   db.SetMaxIdleConns(5)
   fmt.Println("连接成功！！")
   return db
}
```

执行 sql.Open() 函数后，它将返回两个参数：一个是 \*sql.DB 类型值，我还声明了一个全局变量，以便后续使用；另一个则是包含错误信息的 error 类型值，上述代码忽略了针对连接错误的处理。

### 创建数据表

一旦数据库连接成功，就可以检查所需的数据表是否存在了，如果不存在则创建。

对于本例中的记事本应用，需要创建的数据表头为自增长的 id、标题（title）、内容（content）和时间（dateTime）。除了 id 是数值型外，其它均为字符串类型。

mysql 包提供了 db.Exec() 方法，用来执行 SQL 语句，它的方法定义格式如下：

```go
func (db *DB) Exec(query string, args ...interface{}) (Result, error)
```

在创建数据表时，需要传入的参数则是建表的 SQL 语句。因此，整个创建数据表的函数实现如下：

```go
// 创建数据表
func createTable() {
   db.Exec("CREATE TABLE IF NOT EXISTS `notebook` (" +
      "`id` bigint(20) NOT NULL AUTO_INCREMENT," +
      "`title` varchar(45) DEFAULT ''," +
      "`content` varchar(45) DEFAULT ''," +
      "`dateTime` varchar(45) DEFAULT ''," +
      "PRIMARY KEY (`id`)" +
      ") ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;")
   fmt.Println("表存在或成功创建")
}
```

这段 SQL 语句将检查名为 notebook 的数据表是否存在，如果不存在则执行建表操作。表头信息和值类型均描述得非常清晰。

> `❗️ 注意：考虑到数据量的增长，id 列的数据类型设置为 bigint 是较为妥善的处理方式。int 的取值范围受限于 4 个字节，bigint 则是 8 个字节。更大的范围意味着该数据表能容纳更多的数据，除非十分确定数据量的大小，否则建议大家将id列的类型设置为 bigint。`

数据库的连接和表的创建可以看作是完成本例的“准备工作”，完成了准备工作后，用户的请求才有可能得到正确的响应，main() 函数也可以随之得到完善了：

```go
func main() {
   db = connectToDb()
   createTable()
   launchServer()
}
```

main() 函数的函数体首先执行了数据库的连接，然后进行了数据表的检查，准备工作完成。最后执行 launchServer() 函数，启动 Http 服务。

### 数据的增、删、改操作

对于 mysql 包而言，实现数据的增、删、改都遵循相同的模式：都是**先执行 db.Prepare() 方法，将完整的 SQL 语句作为参数传入。再通过该函数的返回值调用 Exec() 方法，将对应的值依次传入** ，即可完成整个过程。

db.Prepare() 和 Stmt.Exet() 的定义格式如下：

```go
func (db *DB) Prepare(query string) (*Stmt, error)
func (s *Stmt) Exec(args ...interface{}) (Result, error)
```

以增加一条数据（add()函数）为例，具体代码片段如下：

```go
// 添加数据到数据库
func add(data notebook) {
   stmtInsert, _ := db.Prepare("INSERT INTO notebook SET title=?,content=?,dateTime=?")
   res, _ := stmtInsert.Exec(data.Title, data.Content, data.DateTime)
   idValue, _ := res.LastInsertId()
   fmt.Printf("添加了id值为%d的数据\n", idValue)
}
```

请大家观察 db.Prepare() 方法和 stmtInsert.Exec() 方法中的对应关系，前者中每个问号（“?”）对应后者中的一个参数值。至于具体是如何匹配的，我们便无需关心了。

res 变量是执行 SQL 语句后的结果，它同样是 Result 类型的。该类型提供了两个方法：**LastInsertId() 和 RowsAffected()，前者表示最新一条数据新增的 id 值，后者表示执行完 SQL 语句后受影响的行数。** 在 add() 函数中，调用了 LastInsertId() 方法，返回被添加数据的 id 值。

接下来，依葫芦画瓢，实现删除一条数据（del()）和更新一条数据（update()）函数。具体代码如下：

```go
// 删除一条数据
func del(id string) {
   stmtDelete, _ := db.Prepare("DELETE FROM notebook WHERE id=?")
   res, _ := stmtDelete.Exec(id)
   rawsCount, _ := res.RowsAffected()
   fmt.Printf("删除了%d条数据\n", rawsCount)
}

// 更新数据到数据库
func update(id string, data notebook) {
   stmtInsert, _ := db.Prepare("UPDATE notebook SET title=?, content=?, dateTime=? WHERE id=?")
   res, _ := stmtInsert.Exec(data.Title, data.Content, data.DateTime, id)
   rawsCount, _ := res.RowsAffected()
   fmt.Printf("更新了%d条数据\n", rawsCount)
}
```

如上代码所示，del() 和 update() 函数均向控制台输出了受影响的行数。由于删除和更新是通过 id 来检索的，因此受影响的行数应为 1。

### 数据的查询操作

在 mysql 包中有一个专门用于数据查询的方法，它就是db.Query()。该方法的定义格式如下：

```go
func (db *DB) Query(query string, args ...interface{}) (*Rows, error) 
```

在执行查询时，需要将 SQL 语句传入其中，通过遍历 \*Rows 类型值来获取查询结果。

本例中，要求服务端根据请求参数响应两种结果。当存在id参数时，进行 id 列条件查找；反之则返回全部数据。具体实现如下：

```go
// 从数据库获取数据
func query(id string) []notebook {
   var notebooks []notebook
   var rows *sql.Rows
   if id == "" {
      rows, _ = db.Query("SELECT * FROM notebook")
   } else {
      rows, _ = db.Query("SELECT * FROM notebook WHERE id=" + id)
   }
   for rows.Next() {
      var singleNote notebook
      rows.Scan(&singleNote.Id, &singleNote.Title, &singleNote.Content, &singleNote.DateTime)
      notebooks = append(notebooks, singleNote)
   }
   return notebooks
}
```

此外，当仅需要检索第一条与查找条件相匹配的数据时，还可调用 db.QueryRow()，该函数返回 \*Row 类型，表示单条数据。

## 并发

###  协程与线程

在 Java 中，若要创建一个线程需要斟酌再三。这是因为**线程是操作系统的资源，它的创建、切换、停止等等都属于操作系统操作，比较“重”** 。

协程看上去和线程类似，但**协程是在用户层面的，它的创建、切换、停止等等由用户操作，更“轻”** 。

线程能充分发挥多核 CPU 的优势，可以做到并行执行多任务。协程则不然，协程是为并发而生的，一个线程上可以跑多个协程。

**Go 语言中的并发是靠协程来实现的。在后端服务器软件开发中，有大量的 IO 密集操作，这正是协程最适合的场景。这也正是 Go 语言更适合高并发场景的原因。**

> `💡 提示： Go 语言的任务调度模型被称为 GPM，我将在下一讲详述GPM模型架构及原理。`

### 并发任务的启动

在 Go 语言中启动并发任务非常简单，只需要在相应的语句前面加上 go 即可。来看下面这段代码：

```go
func main() {
   // 并发调用testFunc()
   go testFunc()
   time.Sleep(time.Second * 5)
   fmt.Println("程序运行结束")
}
// 并发测试函数
func testFunc() {
   for i := 1; i <= 3; i++ {
      fmt.Printf("第%d次运行\n", i)
      time.Sleep(time.Second)
   }
}
```

在 testFunc() 函数中调用了 time.Sleep() 函数，**time.Sleep() 的作用是让当前协程暂停特定的时间**。所以整个testFunc() 函数的目的就是每隔1秒执行1次循环体中的代码，总共执行 3 次，共计耗时 3 秒。main() 函数中在调用 testFunc() 函数时前面加了 “go ”，表示创建一个 Goroutine，在另一个协程中执行 testFunc()。程序运行结果为：

> 第 1 次运行
>
> 第 2 次运行w
>
> 第 3 次运行
>
> 程序运行结束

为什么 main() 函数中要等待 5 秒呢？这是因为 testFunc() 函数需要至少 3 秒才能完成，由于 testFunc() 在另一个协程中，并不会影响 main() 函数体中后续代码的执行。因此main() 函数将迅速完成，整个程序便宣告终止了。

**一旦程序终止，所有在 main() 函数中启动的 Goroutine 也会随之终止**，我们便看不到其它协程中的输出了。所以要给 testFunc() 预留足够多的时长，等待它完成执行。这是使用并发时特别需要注意的一点。

然而，在实际开发中，我们通常无法确切地得知一个协程的准确执行时长。况且像上述代码中，过长的等待时间将会导致程序运行效率的降低。Go 语言提供了一种特别方便的方式确保执行协程任务的完整性，它来自 sync 包。下面的代码演示了它的使用方法：

```go
var goRoutineWait sync.WaitGroup
func main() {
   goRoutineWait.Add(1)
   // 并发调用testFunc()
   go testFunc()
   goRoutineWait.Wait()
   fmt.Println("程序运行结束")
}
// 并发测试函数
func testFunc() {
   defer goRoutineWait.Done()
   for i := 1; i <= 3; i++ {
      fmt.Printf("第%d次运行\n", i)
      time.Sleep(time.Second)
   }
}
```

这段代码中，声明了 sync.WaitGroup 类型的变量goRoutineWait。main() 函数体一上来调用了goRoutineWait.Add() 方法，并向其中传入 1。表示即将开启 1 个 Goroutine。紧接着便是启动 Goroutine 了。最后执行了 goRoutineWait.Wait() 方法，该方法将告知程序在此处等待协程任务的完成。在 testFunc() 函数体中，末尾调用了goRoutineWait.Done() 方法，表示协程任务执行完成。

运行这段代码，控制台将得到同样的输出，但不会傻傻地等待 5 秒了。

`💡 提示：从源码中，有一个 Goroutine 计数器。每次调用 goRoutineWait.Add() 方法时，传入的参数便作为累加值使用；调用 goRoutineWait.Done() 方法时相当于让计数器自减 1。当计数器归 0 时，goRoutineWait.Wait() 方法才会结束。`

接下来上升一点难度，如果要连续并发两次 testFunc() 任务，该如何修改上述代码呢？

答案是：

```go
var goRoutineWait sync.WaitGroup
func main() {
   // Goroutine计数器增2
   goRoutineWait.Add(2)
   // 第一次并发调用testFunc()
   go testFunc()
   // 第二次并发调用testFunc()
   go testFunc()
   goRoutineWait.Wait()
   fmt.Println("程序运行结束")
}
// 并发测试函数
func testFunc() {
   defer goRoutineWait.Done()
   for i := 1; i <= 3; i++ {
      fmt.Printf("第%d次运行\n", i)
      time.Sleep(time.Second)
   }
}
```

由于并发两次，所以要向 goRoutineWait.Add() 方法传入 2。程序运行结果为：

> 第 1 次运行
>
> 第 1 次运行
>
> 第 2 次运行
>
> 第 2 次运行
>
> 第 3 次运行
>
> 第 3 次运行
>
> 程序运行结束

在 Go 语言中开启 Goroutine，还可以**通过匿名函数的方式，当代码中只发生一次调用时特别方便**。比如：

```go
func main() {
   goRoutineWait.Add(1)
   go func() {
      defer goRoutineWait.Done()
      for i := 1; i <= 3; i++ {
         fmt.Printf("第%d次运行\n", i)
         time.Sleep(time.Second)
      }
   }()
   goRoutineWait.Wait()
   fmt.Println("程序运行结束")
}
```

这段代码依然会输出：

> 第 1 次运行
>
> 第 2 次运行
>
> 第 3 次运行
>
> 程序运行结束

细心的朋友会发现，在 testFunc() 函数体中，**使用 defer 执行 goRoutineWait.Done()。如此是为了保证即使在执行函数体时发生错误，goRoutineWait.Done() 方法也依然会被调用，从而保证main() 函数的正常运行。** 

> Go 中的 `defer` 语句与 Java 中的 `finally` 块在功能上是相似的。它们都用于确保在函数返回之前执行某些清理代码，无论函数是正常结束还是由于发生错误而提前结束。

### Go 并发原理

#### 任务调度进化史

##### 串行工作机制

1. **单核心处理器时代**：早期的CPU都是单核心，操作系统按顺序执行单个程序，导致CPU资源利用率低。
2. **性能浪费**：单进程执行时，若进程阻塞，CPU将处于闲置状态，造成资源浪费。
3. **易用性问题**：串行执行方式在现代多任务环境中显得效率低下，无法同时进行多项操作。

##### 多进程并发模式

1. **并发概念**：通过时间片切换实现单个CPU核心上的多任务执行。
2. **操作系统调度**：并发机制由操作系统负责进程的创建、切换和销毁。
3. **资源消耗**：频繁的进程切换会导致资源消耗，虽然CPU占用率高，但实际利用率并不理想。

##### 多线程并行模式

1. **超线程技术**：奔腾4处理器引入超线程技术，使得不同线程可以运行在不同CPU核心上，实现真正意义上的并行。
2. **线程分类**：线程分为内核态线程和用户态线程（协程）。内核态线程由CPU调度，协程由协程调度器调度。
3. **调度结构**：内核空间由内核态线程组成，协程在用户空间中，切换更快、更轻量。

下面这张图展示了上述调度结构：

![image-20220419093331601.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/b91b6f165ec644e4a95a29e8a5521418~tplv-k3u1fbpfcp-watermark.png)

图中的橙色线条表示绑定关系，其中隐含了协程调度器和协程队列处理器。

然而，单纯的并行模式也并非万金油。如果一个线程承载了全部协程任务，则仍然无法从分利用多核 CPU。在极端情形下，协程任务的阻塞还会引发整个线程的阻塞，后续的任务得不到执行，整个系统便会卡住。另外，当一个线程中只存在一个协程任务时，也并不会带来性能的提升。

看到这，一种更优的解决方案便浮现了出来，这种方案也是 Go 语言能实现高并发的原理。即**将多个协程绑定在多个线程中，同时将多个线程分配给不同的 CPU 核心运行。如此将并发与并行模式相结合，便打造出了较为理想的任务调度机制。**

#### GPM 任务调度模型

Go 语言中的 GPM 任务调度模型充分利用了多核 CPU 的资源。需要时，将创建与之匹配的线程，并将用户态的协程任务“智能”地分配给多个线程执行。整体上运用的是并行+并发的模式，具体如下图所示：

![图片1.png](./%E9%9B%B6%E5%9F%BA%E7%A1%80%E9%80%9A%E5%85%B3.assets/70219d596d1e4ef6bdd291469680df8f~tplv-k3u1fbpfcp-watermark.png)

从图中可以看到，整个 GPM 结构分为上下两大部分，我们一起从下往上看，正好对应的是内核空间和用户空间。

首先来看内核空间，这是一颗 4 核心的 CPU（暂时不考虑超线程的情况）。由并行的概念不难得出，4 核心的 CPU 可以由操作系统调度，执行 4 个线程。

**在 Go 程序启动时，会自动根据 CPU 的核心数设置线程的最大数量**。当然，我们也可以通过编码手动设置，稍后会讲到。当一个线程发生阻塞时，新的线程便会创建。图中黄色的线程是一个空闲的线程，它没有绑定任何协程。

再来看用户空间，最上方的全局队列存放所有等待运行的协程任务（即 Goroutine）。下方若干个协程队列，**当发起一个协程任务时，该任务会首先尝试加入到协程队列中。每个协程队列的最大任务数被限制在256个以内**。

当协程队列满了之后，协程调度器会将一半数量的任务移动至全局队列中。至于一共能有多少个协程队列，在 Go 1.5 版本之后**队列数默认为CPU核心数量，也可以通过编码来指定**。

从另一个角度讲，设置了队列数就意味着设置了程序能同时跑多少个 Goroutine 的数量。一般地，在该参数确定后，所有的队列便会一口气创建完成。

在 Go 程序运行时，一个内核空间的线程若想获取某个协程任务来执行，就需要通过协程队列处理来获取特定的协程任务。当队列为空时，全局队列中的若干协程任务，或其它队列中的一半任务会被放到空队列中。如此循环往复，周而复始。

另一方面，**协程队列处理器的数量和线程在数量上并没有绝对关系**。如果一个线程发生阻塞，协程队列处理器便会创建或切换至其它线程。因此，即使只有一个协程队列，也有可能会有多个线程。

#### 动态调整系统资源

在 Go 程序运行时，可以根据需要设置程序要使用的 CPU 资源，也可以动态调整协程任务的执行方式，实现更灵活地运行。这些操作都是通过 runtime 包来实现的。

##### 获取和设置 CPU 核心数量

在 Go 语言中，可以随时获取操作系统类型、CPU 架构类型和 CPU 核心数量，下面的示例代码输出了它们：

```go
// 获取运行当前程序的操作系统
fmt.Println(runtime.GOOS)
// 获取运行当前程序的CPU架构
fmt.Println(runtime.GOARCH)
// 获取运行当前程序的CPU核心数量
fmt.Println(runtime.NumCPU())
```

在 macOS 中，操作系统名称为darwin；在Windows中，操作系统名称即windows；在Linux中，操作系统名称为linux。

**对于 32 位的 CPU，运行结果为 386；对于 64 位的 CPU，运行结果为 amd64；对于 arm 架构 32 位的 CPU，运行结果为 arm；对于 arm 架构 64 位的 CPU，运行结果为 arm64。**

`💡 提示：若要获取Go语言支持的所有操作系统和CPU架构，可执行命令行：go tool dist list。`

若要设置可用的 CPU 核心数，可以通过 runtime.GOMAXPROCS() 函数实现。需要注意的是：该函数将返回设置之前的核心数。

比如，对于一颗多核心的 CPU，若设置程序只能使用一半数量的核心，代码为：

```go
if runtime.NumCPU() > 2 {
   runtime.GOMAXPROCS(runtime.NumCPU() / 2)
}
// 获取当前程序可用的CPU核心数
fmt.Println(runtime.GOMAXPROCS(0))
```

请留意代码最后，当向 runtime.GOMAXPROCS() 函数传入 0 时，即可实现获取可用核心数。

##### 给其它任务“让行”

在程序运行中，某些特定的情况下需要暂停当前协程，让其它协程任务先执行。首先来看下面这段代码：

```go
func main() {
    go fmt.Println("Hello World")
    fmt.Println("程序运行结束")
}
```

显然，由于输出文本被放在了另一个协程中执行。程序将很快结束，甚至在大多数情况下都不会看到 “Hello World” 输出。

若要想正常看到控制台的输出，一种方法便是使用 sync.Wait() 方法，这一招在上一讲中已经介绍过了。另一种方法还可以使主线程中的任务让出资源，优先执行输出文本。方法如下：

```go
func main() {
   go fmt.Println("Hello World")
   runtime.Gosched()
   fmt.Println("程序运行结束")
}
```

如此，便会看到控制台输出：

> Hello World
>
> 程序运行结束

##### 终止自身协程

在某些条件下，我们还希望立即停止协程任务的执行。方法便是使用调用 runtime.Goexit() 函数。下面这段示例代码演示了在满足特定条件时终止协程的方法：

```
func main() {
    syncWait.Add(1)
    go testFunc()
    syncWait.Wait()
    fmt.Println("程序运行结束")
}
func testFunc() {
    defer syncWait.Done()
    for i := 1; i < 100; i++ {
        fmt.Println(i)
        if i >= 5 {
            runtime.Goexit()
        }
    }
}
```

### 并发中的Channel

在前面的示例中，对待协程任务的态度是“放任自流”的。也就是说，一个协程被开启后，我们便不再管它，让它自生自灭，最多是为其它任务让行或终止运行。但在实际开发中，协程任务之间常常会发生通信。

举例来说，现有协程 A 和协程 B，二者都处于运行状态。协程 B 中的某些逻辑需要协程 A 的执行结果作为输入条件，此时就急需将这些结果数据从协程 A 传递给协程 B 了。由此便引出一个问题：如何在并发任务之间进行**数据共享**。

#### CSP并发模型

纵观编程领域，在多任务之间共享数据的方式主要分为两种。

一种是**多线程任务之间的内存共享**，这种方式的代表是 Java、C++、Python 等语言中的多线程开发，这种方式普遍要通过“锁”来确保数据安全。

另一种便是 Go 语言提倡的 **CSP 模型**方式，这种方式的核心思想在于**以通信的方式共享内存数据**。

这两种数据共享的区别主要在于前者是共享内存实现通信，后者是通过通信共享内存。在 Effective Go 中，谈及并发时有这样一句原文：

> Do not communicate by sharing memory; instead, share memory by communicating.

说的就是这个意思。

> `💡 提示：Go语言并非只允许CSP方式并发，它同样支持传统的多线程任务调度方式。` 

随着对 Go 并发领会的逐渐深入，使用得越来越频繁，便会遇到使用 Goroutine 的三个“陷阱”：

1. **Goroutine Leaks（协程任务泄露）**
2. **Data Race（数据竞争）**
3. **Incomplete Work（未完成的任务）**

针对上述 1 和 3，规避的方式就是**确保每一个协程任务可以正常结束**。如果一个协程运行失控，便会长期驻留在内存中，导致系统资源的浪费，出现陷阱 1。或者该执行的任务没有完全完成，导致陷阱 3。

> `💡 提示：想想如何终止协程任务，想想协程中的 defer 的使用。` 

针对上述 2，规避的方式便是**通过传递数据的方式共享数据，而非直接操作某个公共变量**，从而规避数据竞争。

协程任务之间传递数据需要借助通道（Channel）来完成。

#### 通道（Channel）类型

从本质上说，**Go 语言中的通道（Channel）也是一种类型**，只不过在使用时有些特殊，稍后会详述。从分类上看，可将其分为两种。**一种是同步通道，另一种是缓冲通道**。

同步通道有点类似于送外卖的过程。若外卖小哥和点餐顾客分别为协程 A 和协程 B，只有当协程 A 把数据（即外卖）送给协程 B（即顾客），协程 B 才能开始执行后续的操作（即吃外卖）。否则，协程 B 只能一直等待数据（即外卖）的到来。

缓冲通道则有点类似于送快递的过程。若快递员和收件人分别为协程 A 和协程 B，协程 A 可以把数据（即快递）放到缓冲区（即菜鸟驿站）。当协程 B 需要时，只要去缓冲区（即菜鸟驿站）中取数据（即快递）即可。

值得一提的是，缓冲区和菜鸟驿站真的很像，它们都有最大容量限制。一旦协程 A 发现缓冲区（即菜鸟驿站）满了，就不得不等待数据（即快递）被取走，才能将数据（即快递）放到空余的位置中。

同步和缓冲，这两种方式孰优孰劣呢？其实并没有特别明确的定论，我们只要根据实际情况，选择合适的方式就是最优的。

##### 同步通道

理论部分到此为止，接下来实际演练。我们一起实现如下编程需求：

假设我们正在饲养一只母鸡，等待其下蛋。每下一个蛋，我们就拿来做荷包蛋吃。

为了使用同步通道，我们使用两个协程来实现上述需求。协程 A 代表母鸡，它的作用是产蛋，并将产蛋的数量传给协程 B，我们将协程 A 的代码逻辑封装成名为 layEggs() 函数。协程 B 表示吃荷包蛋，等待传入可用的鸡蛋数量，然后输出文字：“吃 x 个荷包蛋”（x 表示鸡蛋数量）。我们将协程B的代码逻辑封装成名为 eatEggs() 函数。

如前文所述，通道（Channel）也是一种数据类型。因此，为了让 layEggs() 和 eatEggs() 都能使用通道类型变量，将通道声明为全局公共变量。该通道将传送鸡蛋的数量，其传送的数据类型是 int，所以我们把它命名为 intChan。具体代码实现如下：

```go
var intChan = make(chan int)
```

这句代码中，**chan 即表明通道类型，紧接着的 int 表示通道上传送的数据的类型。make() 的目的则是创建通道**。最终的 intChan 变量就是通道类型的变量了。如果使用下面的代码输出 intChan 及其类型：

```go
func main() {
   fmt.Println(intChan)
   fmt.Println(reflect.TypeOf(intChan))
}
```

可以得到如下结果：

> 0xc00001a0c0
>
> chan int

接下来实现 layEggs()函数，该函数需要向通道中传出数据，方法是**使用箭头操作符**。在传送结束后，**别忘了调用 close()函数关闭通道，关闭通道时需要指定通道**。具体实现代码如下：

```go
func layEggs() {
   intChan <- 1
   close(intChan)
}
```

如此，便可将 1 通过 intChan 传出。

接着，再来实现 eatEggs() 函数。该函数需要从通道中取数据，方法依然是**使用箭头操作符**，只不过方向上刚好和传出数据相反。具体实现代码如下：

```go
func eatEggs(intChan chan int) {
   eggCounts := <-intChan
   fmt.Printf("吃%d个荷包蛋", eggCounts)
}
```

这里的 eggCounts 便是 int 型数据了。请注意这里的箭头操作符，虽然看上去和传出数据的方向相同，但由于主体角色发生了转变，实际上是相反的。但不能将 “<-” 改为 “->” 。

最后，整合这两个函数，完善 main() 函数，并使用 sync.WaitGroup 类型变量确保协程任务能够完全执行。整体代码如下：

```go
var syncWait sync.WaitGroup
// 创建通道类型变量，该通道将传送int类型数据
var intChan = make(chan int)
func main() {
   // 执行2个协程任务
   syncWait.Add(2)
   // 开启下蛋任务
   go layEggs()
   // 开启吃荷包蛋任务
   go eatEggs(intChan)
   // 等待协程任务完成
   syncWait.Wait()
}
func layEggs() {
   // 使用断言确保协程任务正常结束
   defer syncWait.Done()
   // 向通道传送int类型值
   intChan <- 1
   // 关闭通道
   close(intChan)
}
func eatEggs(intChan chan int) {
   // 使用断言确保协程任务正常结束
   defer syncWait.Done()
   // 从通道获取int类型值
   eggCounts := <-intChan
   // 输出结果
   fmt.Printf("吃%d个荷包蛋", eggCounts)
}
```

运行这段代码，程序输出：

> 吃1个荷包蛋

>  `❗️ 注意：使用同步通道时，要确保传出数据和获取数据必须成对出现。另外，一旦通道被关闭，便不能再向其中传出数据了。`

##### 缓冲通道

和同步通道不同，带缓冲的通道有点类似于快递员（协程 A）和收件人（协程 B）的关系，在他们之间存在一个快递驿站（缓冲区）。寄送快递时，快递员会默认将快递放到驿站中，收件人可以找个合适的时间去驿站中取快递。当驿站放满快递时，新的快递便无法存入其中，必须等待旧的快递被取走。这个过程描述的便是带缓冲的通道的工作流程。

在上述同步通道的代码中，intChan 就是构建的同步通道，通道内允许传送的数据类型是 int 型。main() 函数中开启了两个协程任务，分别是 layEggs() （产蛋）和 eatEggs() （吃蛋）。前者将会向同步通道中传出 1，表示产出 1 个蛋；后者从同步通道中读取值， 结果为 1，表示拿出 1 个蛋来吃。

在现实生活中，如果要统计一只鸡一周能产多少个鸡蛋，用上述同步方法就不是特别合适了。我们通常会用一个容器来存放这只鸡每天产下的鸡蛋，然后在 7 天后数容器内的鸡蛋的数量，便可得知这只鸡在这周产下的鸡蛋总数了。这里的“容器”其实就是缓冲通道中的缓冲区了。

若要实现这种统计并非难事，只需将上述代码稍加修改即可。

首要任务就是修改通道的创建模式，根据示例要求，需要统计 7 天的产蛋总量，我们便可将缓冲区的容量定为7。具体代码修改如下：

```go
const DaysOfWeek = 7
var intChan = make(chan int, DaysOfWeek)
```

这里声明了一个常量，表示一周的天数，同时也规定了 intChan 通道的缓冲区大小就是 7。考虑到稍后在发送和接收时都需要用到缓冲区大小值，所以将该常量声明为全局可访问的。

请大家留意**同步通道和缓冲通道在声明时的区别，只在于是否定义缓冲区的大小。当缓冲区大小的值为 0 时，通道的类型将为同步通道。**

接下来只考虑产蛋的部分，即数据的发送端。假设这只鸡 7 天中每一天都会产下 1 个鸡蛋，且每天都将产下的鸡蛋拿到盛蛋的容器中。我们使用一个 for 循环结构来描述这个过程，将 layEggs() 函数修改如下：

```go
func layEggs() {
	defer syncWait.Done()
	for i := 0; i < DaysOfWeek; i++ {
		time.Sleep(time.Millisecond * 500)
		intChan <- 1
         fmt.Println("产鸡蛋了")
	}
	close(intChan)
}
```

在每次 for 循环一开始，都延迟了 0.5 秒执行，表示 1 天。

接着再来考虑收集鸡蛋的过程，和产蛋类似，该过程每天都进行一次，因此也可使用 for 循环来描述，具体代码如下：

```go
func collectEggs(intChan chan int) {
   defer syncWait.Done()
   var eggCounts int
   for i := 0; i < DaysOfWeek; i++ {
      eggCounts += <-intChan
      fmt.Println("鸡蛋被收集了")
   }
   fmt.Printf("本周共产%d个鸡蛋\n", eggCounts)
}
```

最后，保持 main() 函数不做修改，运行整个代码，可以观察到控制台如下输出：

> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 本周共产7个鸡蛋

显然，“产鸡蛋了”和“鸡蛋被收集了”成对出现 7 次。表示这只鸡每天会产 1 个鸡蛋，这颗鸡蛋也会被按天收取。最终程序输出了一周产蛋总数为 7 颗，程序运行结束。

在使用同步通道时，一个强制性的要求便是每次发送和接收都必须成对存在。反之，在使用缓冲通道时则没有如此强制性的要求。就拿上例来说，虽然这只鸡在 7 天内每天都会产鸡蛋，但如果将收集鸡蛋的工作安排在周一至周五，即 5 天，就需要将 connectEggs() 函数体中循环的终止条件改为 i<5 。如此修改后，程序依然会正常运行，产鸡蛋的工作同样会执行 7 次，但收鸡蛋的工作只会执行 5 次。具体控制台输出将如下所示：

> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 产鸡蛋了
>
> 鸡蛋被收集了
>
> 本周共产5个鸡蛋
>
> 产鸡蛋了
>
> 产鸡蛋了

可以看到，“产鸡蛋了”和“鸡蛋被收集了”成对出现 5 次。

如果更激进一些，从 main() 中去掉 collectEggs() 函数的调用，程序还能正常运行吗？

答案是：**肯定的**。试想一下，现实生活中的快递驿站并不会因某个人没取快递而关门，快递员也不会关心收件人是否取快递，只需将快递放到驿站就大功告成了。本例中的鸡产鸡蛋也是类似的道理，无论鸡蛋被怎样处理，它该下蛋还是会下蛋。

#### 构建安全的通道

在接下来的内容中，我将为大家介绍两个重要的有助于增强通道健壮性的方法，即通道的关闭和单向通道的构建。

##### 通道的关闭

不知道大家注意到没有，小册中有关通道的示例在发送数据后都会调用内置的 close() 函数关闭通道。实际上，在关闭通道方面也是有一些讲究的。

正如前面的示例那样，我们应该**只让某个通道的唯一发送者关闭该通道**，这是关闭通道的原则之一。试想，如果多个发送者共用相同的通道，且都会在某种条件下关闭。那么一旦关闭了该通道，其它发送者就再也没有机会使用通道发送数据了。

从另一个角度讲，**发送者最好使用各自的通道**。当然，如果非要多个发送者共用一个通道，**可以通过恢复机制来规避程序宕机**。但这样做是不推荐的，因为它违反了关闭通道的原则。

> `❗️ 注意：通道关闭后，无法再通过它发送数据，但不会影响数据的接收。`

除此之外，关闭通道还有一个原则是**不允许关闭一个已经关闭了的通道**。否则也会引发程序宕机，错误信息为：panic: close of closed channel。由此便引出一个问题：如何判断通道已经关闭了呢？

我们可以通过**尝试从通道中接收值来判断通道是否关闭**。我们将本讲示例代码中的 collectEggs() 函数稍加修改如下：

```go
func collectEggs(intChan chan int) {
   defer syncWait.Done()
   var eggCounts int
   for i := 0; i < DaysOfWeek; i++ {
      eggCounts += <-intChan
      fmt.Println("鸡蛋被收集了")
   }
   _, isOpen := <-intChan
   if !isOpen {
      fmt.Printf("本周共产%d个鸡蛋\n", eggCounts)
   }
}
```

请各位留意最后 5 行代码。尝试从通道接收值时，除了可以得到值本身外，还可得到一个布尔类型的值。当这个布尔类型的值为 true 时，通道打开；反之，则表示通道已经被关闭了。

如上修改后，控制台输出结果不变。

另外，使用 for-range 循环结构可简化上述代码。当通道关闭后，for-range 循环会自动跳出。下面的代码与上面的代码具有同样的运行结果。

```go
func collectEggs(intChan chan int) {
   defer syncWait.Done()
   var eggCounts int
   for intValue := range intChan {
      eggCounts += intValue
      fmt.Println("鸡蛋被收集了")
   }
   fmt.Printf("本周共产%d个鸡蛋\n", eggCounts)
}
```

##### 单向通道的使用

在实际项目中，有时候需要**特别规定数据的流向，以确保其正确性**。这有点类似于单行道和双向车道，前者只能按照规定的方向行驶，后者来去都是自由的。

本讲案例中， layEggs() 和 collectEggs() 都使用了 intChan 通道。但很明显，前者只负责数据的发送，后者只负责数据的接收。像这种情况，我们就可以基于 intChan ，构建只能发送的通道，用于 layEggs() 函数；构建只能接收的通道，用于 collectEggs() 函数。

`💡 提示：单向通道不是凭空声明的，它需要基于已有的通道。` 

结合本例，下面的代码基于已有的 intChan 创建了名为 readOnlyIntChan 的只接收通道：

```go
var readOnlyIntChan <-chan int = intChan
```

这句代码中， <-chan 表示只接收通道。与其相反， chan<- 则表示只发送通道。下面的代码基于已有的 intChan 创建了名为 sendOnlyIntChan 的只发送通道：

```go
var sendOnlyIntChan chan<- int = intChan
```

### 定时器

Go 语言中的定时器分为两种，一个是用于延迟执行的 Timer，另一个是周期性反复执行的 Ticker。它们都已经内置在 Go SDK 中的 time 包，我们先从 Timer 开始。

#### Timer

若要使用 Timer，实现预约任务，要借助 time 包中的 Timer 类型，该类型的变量通过 time.NewTimer() 函数返回。

从 Go 源码角度看，Timer 是一个结构体类型，其定义如下：

```go
type Timer struct {
    C <-chan Time
    r runtimeTimer
}
```

注意那个名为 C 的单向通道，它是一个只能读取的单向通道，通道内传送的数据类型是Time类型。

在实际使用时，先调用 time.NewTimer() 函数给定预约时间长度，然后从 C 中接收数据。接收数据消耗的时长就是之前给定的时长。下面我们来看一个示例：

> 现有一款网络下载软件，假定现在要实现一个预约下载功能，要求使用 time 包，该怎样逐步完成呢？

首先需要调用 time.NewTimer() 函数，并将其返回值赋给某个变量，代码如下：

```go
downloadTimer := time.NewTimer(time.Second * 2)
```

该延迟将执行下载任务，因此将变量命名为 downloadTimer。为了节省测试时间，暂且将延迟时间设为 2 秒。

然后，从 downloadTimer 中接收值。一旦接收值的操作开始，计时也会随之开始。代码如下：

```go
<-downloadTimer.C
```

这里将接收到 Time 类型的值，单纯的延迟执行无需关注该值，只要能成功接收到，便表示时间到了。

再然后便是要执行的具体任务了，此处输出一些文字，表示调度下载任务开始。

最后，即使在任务执行期间发生宕机，也要确保预约定时器能够顺利退出，我们使用断言（defer）停止定时器。

上述步骤完整代码如下：

```go
func main() {
   downloadTimer := time.NewTimer(time.Second * 2)
   defer downloadTimer.Stop()
   <-downloadTimer.C
   fmt.Println("开始下载")
}
```

运行这段代码，控制台一上来不会有任何输出。稍候 2 秒，可以看到“开始下载”字样。

> `❗️ 注意：预约定时器是一次性的。示例中只能从 downloadTimer 通道接收一次值，若多次接收则会引发宕机。若要重复使用 downloadTimer，可调用 downloadTimer.Reset() 函数，并传入时长。`

#### Ticker

Ticker是 Go 封装的另一种类型的定时器，就像 Mac 中的系统监视器或 Windows 中的任务管理器中的 CPU 使用率，默认会每隔几秒钟刷新一次。Ticker 在应对这样的需求非常好用且易于实现。

在 Go 语言中使用 Ticker 与使用 Timer 非常相似，区别在于 Timer 是一次性的，Ticker 是可以反复接收值的。请大家结合下面的代码理解：

```go
func main() {
   cpuUsageTicker := time.NewTicker(time.Second * 1)
   defer cpuUsageTicker.Stop()
   for {
      <-cpuUsageTicker.C
      fmt.Println("获取实时CPU使用率")
   }
}
```

这段代码模拟了获取 CPU 使用量的需求，运行这段代码后，控制台将每隔 1 秒钟输出一次“获取实时CPU使用率”。当然，最后不要忘了使用断言确保定时器的正常关闭。

> `💡 提示：无论 Timer 还是 Ticker，调用 stop() 方法会立即停止数据的发送，但很可能都不会立即关闭通道。这是为了保证正常接收而设计的，不过别担心，Go 程序会在合适的时机自动关闭通道。` 

### Select结构

在某些时候，我们还会面对另外一种情况，就是**一个数据接收结构处理多个发送者传来的数据，而且这些发送者使用的还是不同的通道。像这种情况，就要用到 Select 结构了。**

还用下载工具来举例，如果将呈现在用户面前的 UI 界面作为接收方，任务的调度（即下载开始、暂停、结束、删除等等）和下载进度的回传（即已完成的下载百分比）作为两个发送方。这两个发送方通过各自的通道同时向接收方发送数据，接收方则根据通道的不同，对数据做相应的处理和展示。

程序开始后，在第 2 秒和第 4 秒的时候添加新的下载。每隔 1 秒回传当前下载任务的总大小和已完成的大小。接收方从控制台输出新的下载文件，并以百分比表示下载进度，输出到控制台中。整个程序运行持续 10 秒，接下来我们逐步实现这个过程。

首先构建两条通道和一个结构体，结构体中保存单个任务的当前下载位置和总量，我们将其命名为 process。两条通道分别传送 process 和 int 类型的数据。相应代码片段如下：

```go
type process struct {
   current int
   total   int
}
chan1 := make(chan process)
chan2 := make(chan int)
```

接着，实现下载进度回传的发送方函数。假设文件的总大小为 10 个单位，每 1 秒可下载 1 个单位，即 10 秒钟下载完整个文件。每秒向 chan1 传送 process 类型的数据，将当前进度发送出去。整个函数的代码如下：

```go
func sendFunc1(chan1 chan process) {
   for i := 0; i < 10; i++ {
      chan1 <- process{
         current: i,
         total:   10,
      }
      time.Sleep(1 * time.Second)
   }
}
```

再来实现新增下载任务的函数。要求在第 2 和第 4 秒的时候新增任务，这部分实现起来较为简单，相关代码如下：

```go
func sendFunc2(chan2 chan int) {
   time.Sleep(2 * time.Second)
   chan2 <- 1
   time.Sleep(2 * time.Second)
   chan2 <- 1
}
```

接下来重点关注接收方的处理方式：

```go
func recvFunc(chan1 chan process, chan2 chan int) {
   for {
      select {
      case processInfo := <-chan1:
         fmt.Printf("当前任务进度：%d\n", 100.0*processInfo.current/processInfo.total)
      case <-chan2:
         fmt.Println("添加了新任务")
      }
   }
}
```

可以看到，该函数体中，首先使用了 for 循环，以便源源不断地接收和处理数据。由 select 语句开始，与由大括号括起来的部分，一起构成了 select 结构。case 后面紧跟着的是条件，即通道。如此便可分开接收和处理 chan1 和 chan2 的数据了。

最后，完善 main() 函数，使用协程的方式调用上述三个函数，完成题目要求。完整的代码如下：

```go
type process struct {
   current int
   total   int
}

func main() {
   chan1 := make(chan process)
   chan2 := make(chan int)
   go recvFunc(chan1, chan2)
   go sendFunc1(chan1)
   go sendFunc2(chan2)
   time.Sleep(10 * time.Second)
   fmt.Println("下载完成")
}

func sendFunc1(chan1 chan process) {
   for i := 0; i < 10; i++ {
      chan1 <- process{
         current: i,
         total:   10,
      }
      time.Sleep(1 * time.Second)
   }
}

func sendFunc2(chan2 chan int) {
   time.Sleep(2 * time.Second)
   chan2 <- 1
   time.Sleep(2 * time.Second)
   chan2 <- 1
}

func recvFunc(chan1 chan process, chan2 chan int) {
   for {
      select {
      case processInfo := <-chan1:
         fmt.Printf("当前任务进度：%d\n", 100.0*processInfo.current/processInfo.total)
      case <-chan2:
         fmt.Println("添加了新任务")
      }
   }
}
```

程序运行后，可以看到控制台如下输出：

> 当前任务进度：0
>
> 当前任务进度：10
>
> 添加了新任务
>
> 当前任务进度：20
>
> 当前任务进度：30
>
> 添加了新任务
>
> 当前任务进度：40
>
> 当前任务进度：50
>
> 当前任务进度：60
>
> 当前任务进度：70
>
> 当前任务进度：80
>
> 当前任务进度：90
>
> 下载完成

### 锁

我们不妨看看下面这段代码：

```go
var testInt = 0
var syncWait sync.WaitGroup
func main() {
   syncWait.Add(2)
   go testFunc()
   go testFunc()
   syncWait.Wait()
   fmt.Println(testInt)
}
func testFunc() {
   defer syncWait.Done()
   for i := 0; i < 1000; i++ {
      testInt += 1
   }
}
```

这段代码理解起来并不难。main() 函数中开启了两个相同的协程任务，具体内容是对公共变量 testInt 进行自增 1 操作。每个协程任务都会自增 1000 次，两个任务并发，理应自增 2000 次，最终输出 testInt 的值应该是 2000。

不信你试试看，反复运行程序，果不其然还真有不是 2000 的时候。最为奇怪的是，计算结果居然还会有变化！这是为何呢？

其实，这就是并发“不安全”的体现了。由于 testInt 是公共变量，两个任务同时对其操作，导致**数据竞争**，计算出错误的结果。

#### 互斥锁

互斥锁是 Go 语言中最为简单粗暴的锁，所以我们先从它学起。

从前文中的示例可以看出，发生不安全并发的根源在于公共变量 testInt，所以我们只需恰当地将其保护起来就行了。之所以说互斥锁简单粗暴，就是因为被它加锁的代码一旦运行，就必须等待其结束后才能再次运行。

它的使用方法也很简单粗暴，我们对上述示例代码稍加修改即可实现互斥锁保护了：

```go
var testInt = 0
var syncWait sync.WaitGroup
var locker sync.Mutex
func main() {
   syncWait.Add(2)
   go testFunc()
   go testFunc()
   syncWait.Wait()
   fmt.Println(testInt)
}
func testFunc() {
	defer syncWait.Done()
	defer locker.Unlock()
	locker.Lock()
	for i := 0; i < 1000; i++ {
		testInt += 1
	}
}
```

大家可以看到，locker 是一开头就声明了的 sync.Mutex 类型变量，locker.Lock() 是加锁，locker.Unlock() 是解锁。在 testFunc() 函数中，一上来便执行了加锁操作，互斥锁“锁住”的代码是自增 1000 的逻辑。最后，为了确保后续代码顺利执行，使用断言执行解锁操作。

如此修改后，反复运行这段代码，控制台将始终输出 2000。

到此，计算结果总算是正确了。但大家想一想，如此加锁后，并发和串行执行似乎没什么区别。因为虽然并发了任务，但任务中的下次计算必须等上次计算完成后才能开始，这和串行执行任务并没有本质不同。有没有什么办法既能发挥并发优势，又能确保数据安全呢？当然有，那就是使用读写互斥锁。

#### 读写互斥锁

想象一下，假如有一段庆祝生日的视频，大概 5GB 左右，现在要把它上传到百度网盘和阿里云盘中。假如同时开始上传任务，会有一方处于等待状态吗？显然，这通常是不会的。受整体带宽限制，虽然每个网盘上传的速度都变慢了，但上传还是会同时进行的。

再想象一下，当我们用网页和手机同时登录网银，同时查询账户余额时。作为服务器端，无需关心它们的顺序，只要将正确的返回值给到网页和手机客户端就行了。因为查询操作并不会改变金额，账户始终是安全的。

从上面两个例子中可以初步归纳出一个结论：**只要共享的数据不发生改变，几乎不会用到锁。反之，如果强行对“读操作”加锁，反而会影响性能**。

据此规律，我们可以用 **“读写互斥锁”充分发挥并发优势，只在写操作上串行，保证数据安全**。

具体说来，读写互斥锁的运行机制是这样的：

- 当协程任务获得读操作锁后，读操作并发运行，写操作等待；
- 当协程任务获得写操作锁后，考虑到数据可能发生变化，所以无论是读还是写操作都要等待。

使用读写互斥锁和使用简单的互斥锁很类似，不同的是**需要声明 sync.Mutex 类型变量。写操作的方法依然 locker.Lock() 是加锁，locker.Unlock() 是解锁。读操作的方法则是 locker.RLock() 和 locker.RUnlock()。**

下面用实际的代码示例来演示上述运行逻辑，以下代码模拟了读写文件的过程：

```go
var syncWait sync.WaitGroup
var locker sync.RWMutex
func main() {
   syncWait.Add(3)
   go read5Sec()
   time.Sleep(time.Millisecond * 500)
   go read3Sec()
   go read1Sec()
   syncWait.Wait()
   fmt.Println("程序运行结束", time.Now().Format("15:04:05"))
}
func read5Sec() {
   defer syncWait.Done()
   defer locker.RUnlock()
   locker.RLock()
   fmt.Println("读文件耗时5秒 开始", time.Now().Format("15:04:05"))
   time.Sleep(time.Second * 5)
   fmt.Println("读文件耗时5秒 结束", time.Now().Format("15:04:05"))
}
func read3Sec() {
   defer syncWait.Done()
   defer locker.RUnlock()
   locker.RLock()
   fmt.Println("读文件耗时3秒 开始", time.Now().Format("15:04:05"))
   time.Sleep(time.Second * 3)
   fmt.Println("读文件耗时3秒 结束", time.Now().Format("15:04:05"))
}
func read1Sec() {
   defer syncWait.Done()
   defer locker.RUnlock()
   locker.RLock()
   fmt.Println("读文件耗时1秒 开始", time.Now().Format("15:04:05"))
   time.Sleep(time.Second * 1)
   fmt.Println("读文件耗时1秒 结束", time.Now().Format("15:04:05"))
}
```

可以看到，read1Sec()、read3Sec() 和 read5Sec() 函数分别模拟了读文件的操作，所需时长分别是 1、3、5 秒。这 3 个函数中，都使用了读写互斥锁对等待时间进行了读操作的加锁和解锁。在 main() 函数中通过协程的方式首先启动了耗时 5 秒的任务，在 0.5 秒后，同时启动了剩余的 2 个任务。

程序运行后，可在控制台看到如下输出：

> 读文件耗时5秒 开始 10:42:25
>
> 读文件耗时1秒 开始 10:42:26
>
> 读文件耗时3秒 开始 10:42:26
>
> 读文件耗时1秒 结束 10:42:27
>
> 读文件耗时3秒 结束 10:42:29
>
> 读文件耗时5秒 结束 10:42:30
>
> 程序运行结束 10:42:30

显然，3个读操作的协程任务同时运行，实现了真正的并发。

> `💡 提示：上述代码中的 “15:04:05” 是为了格式化时间用的。Go  语言语法要求必须传入 2006 年1 月 2 日 15 时 04 分 05 秒 -0700 时区这个时间点（Go 语言的诞生时间）才能正常被格式化，并不是大多数编程语言中的 YMD HMS 格式。` 

接下来添加写操作协程，并修改 main() 函数，具体如下：

```go
func main() {
	syncWait.Add(6)
	go write1Sec()
	time.Sleep(time.Second * 1)
	go read5Sec()
	time.Sleep(time.Second * 2)
	go read3Sec()
	time.Sleep(time.Millisecond * 500)
	go write3Sec()
	time.Sleep(time.Millisecond * 500)
	go read1Sec()
	go write5Sec()
	syncWait.Wait()
	fmt.Println("程序运行结束", time.Now().Format("15:04:05"))
}
func write5Sec() {
   defer syncWait.Done()
   defer locker.Unlock()
   locker.Lock()
   fmt.Println("写文件耗时5秒 开始", time.Now().Format("15:04:05"))
   time.Sleep(time.Second * 5)
   fmt.Println("写文件耗时5秒 结束", time.Now().Format("15:04:05"))
}
func write3Sec() {
   defer syncWait.Done()
   defer locker.Unlock()
   locker.Lock()
   fmt.Println("写文件耗时3秒 开始", time.Now().Format("15:04:05"))
   time.Sleep(time.Second * 3)
   fmt.Println("写文件耗时3秒 结束", time.Now().Format("15:04:05"))
}
func write1Sec() {
   defer syncWait.Done()
   defer locker.Unlock()
   locker.Lock()
   fmt.Println("写文件耗时1秒 开始", time.Now().Format("15:04:05"))
   time.Sleep(time.Second * 1)
   fmt.Println("写文件耗时1秒 结束", time.Now().Format("15:04:05"))
}
```

上述代码包含 3 个模拟写文件任务的函数，分别耗时 1、3、5 秒完成。此外，还包含了对 main() 函数的修改。

我们重点关注 main() 函数。程序启动后，首先开启了耗时 1 秒（10:51:35）的写文件任务。根据读写互斥锁的运行规律，**当协程任务获得写操作锁后，考虑到数据可能发生变化，无论是读还是写操作都要等待**。

所以即使在 0.5 秒时启动了读文件的任务，也会等待到写文件完成才能干活。1 秒后（10:51:36），写文件任务完成，读文件操作开始并发执行。在这些操作开始后的 2.5 秒（大约10:51:40）时，写文件任务加入。

此时，**由于协程任务获得读操作锁，读操作可以并发运行，写操作必须等待。** 所以此时的写文件任务还要再等待 2.5 秒才能得到执行。2.5 秒后（10:51:41）读文件任务完成，写文件任务开始执行。

照此规律，此后 0.5 秒（大约10:51:42）时，又加入了读文件任务。这次的读文件需要等待写文件任务完成（10:51:44）后才能执行。随着此次读文件任务的开启，写文件任务也会同时开启。但由于读写之间互斥，只能等待其中一方运行结束后才能开始另一方的执行。

程序运行后，控制台将输出：

> 写文件耗时1秒 开始 10:51:35
>
> 写文件耗时1秒 结束 10:51:36
>
> 读文件耗时5秒 开始 10:51:36
>
> 读文件耗时3秒 开始 10:51:37
>
> 读文件耗时3秒 结束 10:51:40
>
> 读文件耗时5秒 结束 10:51:41
>
> 写文件耗时3秒 开始 10:51:41
>
> 写文件耗时3秒 结束 10:51:44
>
> 读文件耗时1秒 开始 10:51:44
>
> 读文件耗时1秒 结束 10:51:45
>
> 写文件耗时5秒 开始 10:51:45
>
> 写文件耗时5秒 结束 10:51:50
>
> 程序运行结束 10:51:50

简单对比，使用读写互斥锁运行上述任务，总耗时 15 秒。但如果使用简单的互斥锁，所有任务都会串行工作，没有任何并发优势（尽管使用了并发），耗时将长达 18 秒。

>`❗️ 注意：在使用锁或读写互斥锁时，一定要注意避免出现 A 等 B ，B 等 C，C 等 A 的情况。如此无限循环也会导致程序进入无限的循环等待中。`

### 原子操作

**所谓“原子操作”，简单理解就是指那些进行过程中不能被打断的操作**。比如本讲一上来的示例中，对 testInt 的并发 2 次循环累加就可以使用原子操作来避免结果不准的问题。当然，原子操作也会使 2 次任务串行化，无法发挥并发的优势。但原子操作是无锁的，往往直接通过 CPU 指令直接实现，某些同步技术的实现恰恰基于原子操作。

Go 语言中的原子操作通过 sync/atomic 包实现，具体特性如下：

- 原子操作**都是非入侵式**的；
- 原子操作共有五种：**增减、比较并交换、载入、存储、交换**；
- 原子操作支持的类型类型包括 **int32、int64、uint32、uint64、uintptr、unsafe.Pointer**（在本讲末尾会有详细的附录列举）。

原子操作使用起来并不难，我们直接上代码。

下面的代码演示了使用原子操作实现对 testInt 的 2 次累加：

```go
var testInt int32 = 0
var syncWait sync.WaitGroup
func main() {
   syncWait.Add(2)
   go testFunc()
   go testFunc()
   syncWait.Wait()
   fmt.Println(testInt)
}
func testFunc() {
   defer syncWait.Done()
   for i := 0; i < 1000; i++ {
      atomic.AddInt32(&testInt, 1)
   }
}
```

控制台会输出 2000。

实际上，原子操作不仅实现起来更方便，**性能也比锁更快**。感兴趣的朋友可以适当做压力测试，对比加锁和原子操作针对相同任务的耗时时长。
