---
title: 第零章 分布式架构下常见问题
tags:
  - 分布式
categories:
  - 分布式
date: '2025-01-13'
description: 欢迎使用 Curve 主题，这是你的第一篇文章
articleGPT: 这是一篇初始化文章，旨在告诉用户一些使用说明和须知。
#cover: "/images/logo/logo.webp"
---

## 分布式架构下常见问题

- 集群部署，JVM锁解决不了并发问题。
- 远程调用，Spring事务失效了。
- 数据量太大，单库单表支撑不了业务压力了。
- 分库分表，数据库自增id重复了。
- 已经登录过了，访问另外一个服务还需要重新登录。
- 集群部署，Spring任务调度执行重复了。

## 分布式锁

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20250402195430669.png" alt="image-20250402195430669" style="zoom:50%;" />

### 从扣减库存案例 深入剖析共享资源的数据

#### 需求背景

电商项目中，用户购买商品后，会对商品的库存进行扣减。

因此，我们模拟这个场景就需要**商品表**和**库存表**两张表，但业务并不是这里的重点，需要简化一下，一张简单的商品库存表足以，如下：

```sql
CREATE TABLE `tb_goods_stock`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `goods_id` bigint(20) NOT NULL COMMENT '商品id',
  `stock` int NOT NULL COMMENT '库存数',
  PRIMARY KEY (`id`)
) COMMENT = '商品库存表';
```

接着，我们创建一个`SpringBoot`的项目,在接口中实现简单的扣减库存的逻辑，示例如下：

```java
public String reductStock(Long goodsId,Integer count){
    //1.查询商品库存的库存数量
    Integer stock = stockDao.selectStockByGoodsId(goodsId);
    //2.判断商品的库存数量是否足够
    if (stock < count) return "库存不足";
    //3.如果足够，扣减库存数量
    stockDao.updateStockByGoodsId(goodsId,stock-count);
    //4.返回扣减成功
    return "库存扣减成功！";
}
```

创建成功后，先往数据库里插入一条商品id为1、库存为1的数据，便于我们测试接口的逻辑。分别执行两次调用，分别得到**库存不足**和**库存扣减成功**的提示，验证逻辑没有问题，如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20250402195537602.png" alt="image-20250402195537602" style="zoom:40%;" />

#### 发现问题

上面的例子如果是通过单次访问，那么它的执行结果也是符合我们预期的。但在高并发场景下，多个线程同时访问同一个数据就可能出现**超卖问题**。因此，我们用`JMeter`来模拟大量并发数据来进行线上抢购场景复现，如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20250402195703413.png" alt="image-20250402195703413" style="zoom:50%;" />

添加一个线程组，设定50个线程和100次循环次数，如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20250402195714703.png" alt="image-20250402195714703" style="zoom:50%;" />

 这时再将数据库里的商品id为1的数据的库存修改为`5000`，如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20250402195727503.png" alt="image-20250402195727503" style="zoom:80%;" />

接着执行HTTP请求，如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20250402195748454.png" alt="image-20250402195748454" style="zoom:50%;" />

 通过聚合报告可以看出5000次请求都执行成功，这个时候按照正常逻辑，库存应该扣完了，回到数据库查询，如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20250402195812120.png" alt="image-20250402195812120" style="zoom:80%;" />

通过查询发现还有4000多个库存，带换到线上场景，这个时候后续还有用户继续请求购买，最终实际卖出的肯定会远远超过库存，这就是经典的**超卖问题**。

#### JVM锁初显神通

`并发问题去找锁`这个几乎是大家的共识，那么这里的**超卖问题**也不例外。因此，最直接的办法就是直接在涉及扣减库存的逻辑或操作上进行`加锁`处理。首先，最先想到的就是JVM锁，只需要一个`synchronized`关键字就可以实现，代码修改如下：

```java
public synchronized String reductStock(Long goodsId,Integer count){
    //1.查询商品库存的库存数量
    Integer stock = stockDao.selectStockByGoodsId(goodsId);
    //2.判断商品的库存数量是否足够
    if (stock < count) return "库存不足";
    //3.如果足够，扣减库存数量
    stockDao.updateStockByGoodsId(goodsId,stock-count);
    //4.返回扣减成功
    return "库存扣减成功！";
}
```

我们这时候去把数据库的库存还原下，然后重新用`JMeter`进行请求（Ps:原参数不变），执行后我们先看数据库结果，如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20250402195834447.png" alt="image-20250402195834447" style="zoom:80%;" />

可以看到这次的库存就被扣减完了，但我们查看聚合报告会发现对比前面的请求，有一项指标下降了很多-吞吐量，从三千多到现在的一千多，所以加锁肯定对性能是会产生影响的，如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20250402195857036.png" alt="image-20250402195857036" style="zoom: 50%;" />

当然除了`synchronized`关键字，还有更为灵活的方式，毕竟它是作用在方法上的，而我们使用`reentrantLock`则可以实现对代码块进行加锁，如下：

```java
ReentrantLock reentrantLock = new ReentrantLock();

public String reductStock(Long goodsId,Integer count){
    //1.加锁
    reentrantLock.lock();
    try {
        //2.查询商品库存的库存数量
        Integer stock = stockDao.selectStockByGoodsId(goodsId);
        //3.判断商品的库存数量是否足够
        if (stock < count) return "库存不足";
        //4.如果足够，扣减库存数量
        stockDao.updateStockByGoodsId(goodsId,stock-count);
    } finally {
        //5.解锁
        reentrantLock.unlock();
    }
    //6.返回扣减成功
    return "库存扣减成功！";
}
```

#### JVM锁是万能的吗？

经过了上面的简单改造就让我们的扣减库存不失效了，那么是否这样就可以真正地解决线上的超卖问题呢？当然不是的，JVM锁并不是万能的，它在部分场景下是会失效的，如下：

##### 1. 多例模式

首先，我们都知道Spring默认是单例的，即每个对象都会被注册成为一个bean交给IOC容器进行管理。但是它是可以设置成多例的，只需要一个简单的注解，如下：

```java
@Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
@Service
public class StockService {

    @Autowired
    private StockDao stockDao;

    public synchronized String reductStock(Long goodsId,Integer count){
        //1.查询商品库存的库存数量
        Integer stock = stockDao.selectStockByGoodsId(goodsId);
        //2.判断商品的库存数量是否足够
        if (stock < count) return "库存不足";
        //3.如果足够，扣减库存数量
        stockDao.updateStockByGoodsId(goodsId,stock-count);
        //4.返回扣减成功
        return "库存扣减成功！";
    }
}
```

这个时候我们再次进行调用测试，结果如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20250402195922237.png" alt="image-20250402195922237" style="zoom:80%;" />

那么这是为什么呢？其实很好理解，多例模式下这个类对应的`bean`也可以有多个，也就是我们每次执行到这个方法都是一个新的`bean`，自然就根本没有锁住。

##### 2. 事务模式

事务模式就是在方法上加上事务注解（Ps：这里测试记得把上面的多例注解注释掉），代码如下：

```java
@Transactional
public synchronized String reductStock(Long goodsId,Integer count){
    //1.查询商品库存的库存数量
    Integer stock = stockDao.selectStockByGoodsId(goodsId);
    //2.判断商品的库存数量是否足够
    if (stock < count) return "库存不足";
    //3.如果足够，扣减库存数量
    stockDao.updateStockByGoodsId(goodsId,stock-count);
    //4.返回扣减成功
    return "库存扣减成功！";
}
```

再次进行调用测试，结果如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20250402195938681.png" alt="image-20250402195938681" style="zoom:80%;" />

可以看到依然会有剩余库存，那么为什么加上事务就破坏了JVM锁呢？其实也很好理解：我们看代码，在扣减库存的方法上我们加了事务，方法内部加了锁，可以理解成事务包着锁。那么当请求A执行到扣减库存的方法后，会先进入事务，然后加锁->执行业务逻辑->解锁。

**这里需要注意的是**，一旦解锁之后，请求B就会马上抢夺锁，所以这个时候就出现了旧请求还没提交事务，新请求就拿到锁开始执行了。在读已提交这个默认的隔离级别下，就可能出现新旧请求扣减了同一份库存，自然**超卖问题**就又出现了。

那么是否有解决办法呢？

答案是肯定的。这里我们分析了失效的原因，那么其实只要把锁加到事务外，确保事务提交了才释放锁就行。比如按照我们现有的例子，把`synchronized`关键字加到`controller`层就行了，这里很简单就不演示了，感兴趣的读者可以自行测试。

##### 3. 集群模式

集群模式则是最常见的情况，毕竟应该不会有生产级别的服务只部署一个实例，几乎都是部署多实例的。那么这个时候JVM锁自然就失效了，如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E4%B8%BB%E6%B5%81%E5%88%86%E5%B8%83%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.assets/image-20250402195958814.png" alt="image-20250402195958814" style="zoom:80%;" />

在这个例子中，外部的请求进入到nginx，通过负载均衡策略转发到库存服务，JVM锁只在所在的JVM内部失效，所以这里加的JVM锁其实是3个服务各加了一把锁，那各自锁各自的等于没锁，超卖问题自然就又出现了。