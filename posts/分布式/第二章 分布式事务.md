# 分布式事务

## ACID

- 原子性(Atomicity)
- 一致性(Consistency)
- 隔离性(Isolation)
- 持久性(Durability)

## CAP 定理

- 在一个分布式系统中，一致性(Consistency)、可用性 (Availability)、分区容忍性(Partition tolerance)。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾
- 一致性:在分布式系统中的所有数据备份，在同一时刻是否同样的值
- 可用性:在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求
- 分区容忍性:以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择

## BASE 理论

- 对 CAP 中的一致性和可用性进行一个权衡的结果
- 理论的核心思想就是:我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性

## 解决方案

### 二阶段提交(2PC)

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614181257472.png" alt="image-20250614181257472" style="zoom:50%;" />

- 引入一个协调者，其他的节点被称为参与者
- 阶段 1（`准备阶段`）

  - 协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果。
  - 各参与者执行事务操作，将 undo 和 redo 信息记入事务日志中(但不提交事务)
  - 参与者将自己事务执行情况反馈给协调者，同时等待协调者的下一步通知。
- 阶段 2（`提交阶段`）

  - 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息
  - 否则，发送 commit 消息

#### 存在的问题

- 性能问题

  - 所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈
- 可靠性问题

  - 如果协调者存在单点故障问题，或出现故障，提供者将一直处于锁定状态
- 数据一致性问题

  - 在阶段 2 中，协调者只发送了一部分的 `commit` 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题

#### 优缺点

- 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。(其实也不能 100% 保证强一致)
- 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景

### 三阶段提交(3PC)

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614181316863.png" alt="image-20250614181316863" style="zoom:40%;" />

- 二阶段提交上的改进版本，3PC 最关键要解决的就是协调者和参与者同时挂掉的问题
- 阶段 1 （`CanCommit`）

  - 协调者向所有参与者发出包含事务内容的 `CanCommit` 请求，询问是否可以提交事务，并等待所有参与者答复
- 阶段 2（`PreCommit`）

  - 所有参与者反馈 `yes`
  - 协调者向所有参与者发出 ` preCommit` 请求
  - 各参与者执行事务操作，将 `undo` 和 `redo` 信息记入事务日志中(但不提交事务)
  - 如参与者执行成功，给协调者反馈 `yes`，否则反馈 `no`
- 阶段 3（`DoCommit`）

  - 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(`rollback`)消
  - 否则，发送 `commit` 消息
- 相当于先提前问一下各个参与者，是否状态都 ok，ok 之后再走 2pc

> `3PC` 在很多地方进行了超时中断的处理，比如协调者在指定时间内未收到全部的确认消息则进行事务中断的处理，这样能 **减少同步阻塞的时间**

注意的是，**`3PC`** 在 **`DoCommit`** 阶段参与者如未收到协调者发送的提交事务的请求，它会在一定时间内进行事务的提交**。为什么这么做呢？是因为这个时候我们肯定**保证了在第一阶段所有的协调者全部返回了可以执行事务的响应**，这个时候我们有理由**相信其他系统都能进行事务的执行和提交**，所以**不管**协调者有没有发消息给参与者，进入第三阶段参与者都会进行事务的提交操作。

> 总之，`3PC` 通过一系列的超时机制很好的缓解了阻塞问题，但是最重要的一致性并没有得到根本的解决，比如在 `DoCommit` 阶段，当一个参与者收到了请求之后其他参与者和协调者挂了或者出现了网络分区，这个时候收到消息的参与者都会进行事务提交，这就会出现数据不一致性问题

#### 优缺点

**优点：** 相比二阶段提交，三阶段提交降低了阻塞范围，在等待超时后协调者或参与者会中断事务。 避免了协调者单点问题。阶段 3 中协调者出现问题时，参与者会继续提交事务。

**缺点：** 数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 do commite 指令时， 此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。

### 补偿事务 TCC

TCC方案分为Try Confirm Cancel三个阶段，属于补偿性分布式事务。

TCC 其实就是采用的补偿机制，其核心思想是:针对每个操作，都要注册一个与其对应的确认和补偿(撤销)操作。

- Try：尝试待执行的业务

  - 这个过程并未执行业务，只是完成所有业务的一致性检查，并预留好执行所需的全部资源

- Confirm：执行业务

  - 这个过程真正开始执行业务，由于Try阶段已经完成了一致性检查，因此本过程直接执行，而不做任何检查。并且在执行的过程中，会使用到Try阶段预留的业务资源。

- Cancel：取消执行的业务

  - 若业务执行失败，则进入Cancel阶段，它会释放所有占用的业务资源，并回滚Confirm阶段执行的操作。

> - **假入你要向 老田 转账**
> - **Try 阶段主要是对业务系统做检测及资源预留**
>
>   - **先调用远程接口把 你 和 老田 的钱给冻结起来**
> - **Confirm 阶段主要是对业务系统做确认提交**
>
>   - **执行远程调用的转账的操作，转账成功进行解冻**
> - **Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放**
>
>   - **如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)**

#### 优缺点

**优点:**

- 性能提升:具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。
- 数据最终一致性:基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。
- 可靠性:解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。

**缺点：**

- Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本

### Sage

Saga 是一种长事务（Long-running-transaction），由多个具有执行逻辑和补偿逻辑的本地事务组成，当其中的任何一个本地事务出错了，都可以通过补偿逻辑来进行恢复，从而达到事务的最终一致性。

其中，Saga 的恢复策略包括两种，向前恢复（Forward Recovery）和向后恢复（Backward Recovery）。

> Saga 事务核心思想是将"长事务拆分为多个本地短事务"，由 Saga 事务协调器协调，如果正常结束那就正常完成，  
>      如果"某个步骤失败，则根据相反顺序一次调用补偿操作"。
>
> Saga 事务基本协议如下：  
> 1、每个 Saga 事务由一系列幂等的有序子事务(sub-transaction) Ti 组成。  
> 2、每个 Ti 都有对应的幂等补偿动作 Ci，补偿动作用于撤销 Ti 造成的结果。  
> TCC事务补偿机制有一个预留(Try)动作，相当于先报存一个草稿，然后才提交；  
> Saga事务没有预留动作，直接提交。

#### 策略

**对于事务异常，Saga提供了两种恢复策略，分别如下：**

##### **1. 向前恢复**

也称之为：勇往直前，对于执行不通过的事务，会尝试重试事务，这里有一个假设就是每个子事务最终都会成功。

适用于必须要成功的场景，事务失败了重试，不需要补偿。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614181414894.png" alt="image-20250614181414894" style="zoom:50%;" />

##### **2. 向后恢复**

在执行事务失败时，补偿所有已完成的事务，是“一退到底”的方式。如下图：  

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614181426004.png" alt="image-20250614181426004" style="zoom:50%;" />

从上图可知事务执行到了支付事务T3，但是失败了，因此事务回滚需要从C3,C2,C1依次进行回滚补偿。

对应的执行顺序为：T1,T2,T3,C3,C2,C1

这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。

对应的执行顺序为：T1,T2,T3,C3,C2,C1<span data-type="text" style="font-family: var(--b3-font-family-protyle); background-color: var(--b3-theme-background); color: var(--b3-theme-on-background);">这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。</span>

这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。

#### 实现方式

**Saga事务有两种不同的实现方式，分别如下：**

##### **命令协调**

中央协调器（Orchestrator，简称 OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。整体流程如下图：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614181438054.png" alt="image-20250614181438054" style="zoom:50%;" />

上图步骤如下：

- 事务发起方的主业务逻辑请求 OSO 服务开启订单事务
- OSO 向库存服务请求扣减库存，库存服务回复处理结果。
- OSO 向订单服务请求创建订单，订单服务回复创建结果。
- OSO 向支付服务请求支付，支付服务回复处理结果。
- 主业务逻辑接收并处理 OSO 事务处理结果回复。

中央协调器必须事先知道执行整个订单事务所需的流程(例如通过读取配置)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。

基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。

##### **事件编排**

没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动。

在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。

当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614181450979.png" alt="image-20250614181450979" style="zoom:50%;" />

上图步骤如下：

- 事务发起方的主业务逻辑发布开始订单事件。
- 库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件。
- 订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件。
- 支付服务监听订单已创建事件，进行支付，并发布订单已支付事件。
- 主业务逻辑监听订单已支付事件并处理。

事件/编排是实现 Saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。如果事务涉及 2 至 4 个步骤，则可能是非常合适的。

#### 优缺点

##### 优点

命令协调设计的优点如下：

- 服务之间关系简单，避免服务之间的循环依赖关系，因为 Saga 协调器会调用 Saga 参与者，但参与者不会调用协调器。
- 程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。
- 易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试。

事件/编排设计优点如下：

- 避免中央协调器单点故障风险。
- 当涉及的步骤较少服务开发简单，容易实现。

##### 缺点

命令协调设计缺点如下：

- 中央协调器容易处理逻辑容易过于复杂，导致难以维护。
- 存在协调器单点故障风险。

事件/编排设计缺点如下：

- 服务之间存在循环依赖的风险。
- 当涉及的步骤较多，服务间关系混乱，难以追踪调测。
- 由于 Saga 模型中没有 Prepare 阶段，因此事务间不能保证隔离性。
- 当多个 Saga 事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。

### 本地消息表（异步确保）

- 消息生产方，需要额外建一个消息表，并记录消息发送状态
- 消息表和业务数据要在一个事务里提交
- 消息消费方，需要处理这个消息，并完成自己的业务逻辑
- 此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行

### 事务消息

事务消息作为一种异步确保型事务， 将两个事务分支通过 MQ 进行异步解耦，事务消息的设计流程同样借鉴了两阶段提交理论，整体交互流程如下图所示：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614181507208.png" alt="image-20250614181507208" style="zoom:40%;" />

1. 事务发起方首先发送 prepare 消息到 MQ。
2. 在发送 prepare 消息成功后执行本地事务。
3. 根据本地事务执行结果返回 commit 或者是 rollback。
4. 如果消息是 rollback，MQ 将删除该 prepare 消息不进行下发，如果是 commit 消息，MQ 将会把这个消息发送给 consumer 端。
5. 如果执行本地事务过程中，执行端挂掉，或者超时，MQ 将会不停的询问其同组的其它 producer 来获取状态。
6. Consumer 端的消费成功机制有 MQ 保证。

有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，但是市面上一些主流的 MQ 都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。