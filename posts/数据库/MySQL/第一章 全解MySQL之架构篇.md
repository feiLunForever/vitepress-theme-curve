
# 全解MySQL之架构篇

## MySQL整体结构浅析

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250603133317715.png" alt="image-20250603133317715" style="zoom:80%;" />

从上往下看，依次会分为网络连接层、系统服务层、存储引擎层、以及文件系统层，往往编写 `SQL` 后，都会遵守着 `MySQL` 的这个架构往下走。

- 连接层：主要是指数据库连接池，会负责处理所有客户端接入的工作。
- 服务层：主要包含 `SQL` 接口、解析器、优化器以及缓存缓冲区四块区域。
- 存储引擎层：这里是指 `MySQL` 支持的各大存储引擎，如 `InnoDB、MyISAM` 等。
- 文件系统层：涵盖了所有的日志，以及数据、索引文件，位于系统硬盘上。

### 网络连接层

当一个客户端尝试与 `MySQL` 建立连接时，`MySQL` 内部都会派发一条线程负责处理该客户端接下来的所有工作。而数据库的连接层负责的就是所有客户端的接入工作，`MySQL` 的连接一般都是基于 `TCP/IP` 协议建立网络连接，因此凡是可以支持 `TCP/IP` 的语言，几乎都能与 `MySQL` 建立连接。

> 其实 `MySQL` 还支持另一种连接方式，就是 `Unix` 系统下的 `Socket` 直连，但这种方式一般使用的较少。

先来看看一般是怎么连接 `MySQL` 的？如下：

```shell
mysql -h 127.0.0.1 -uroot -p12345
```

当执行这条指令后，会与 `MySQL-Server` 建立网络连接，也就是会经历[《TCP的三次握手过程》](https://juejin.cn/post/7101917676162777119#heading-38)。当然，`MySQL` 也支持 `SSL` 加密连接，如果采用这种方式建立连接，那还会经过[《SSL多次握手过程》](https://juejin.cn/post/7109497228103778311#heading-37)，当握手结束，网络建立成功后，则会开始正式的数据库连接建立工作。

`TCP` 网络连接建立成功后，`MySQL` 服务端与客户端之间会建立一个 `session` 会话，紧接着会对登录的用户名和密码进行效验，`MySQL` 首先会查询自身的用户表信息，判断输入的用户名是否存在，如果存在则会判断输入的密码是否正确。当账号及密码正确时，此时就会进入 `MySQL` 的命令行，接下来可以执行 `SQL` 操作。

经过上述流程后数据库连接就建立成功了，数据库连接建立成功后，`MySQL` 与客户端之间会采用半双工的通讯机制工作，与之对应的还有“**全双工、单工**”的工作模式：

- 全双工：代表通讯的双方在同一时间内，即可以发送数据，也可以接收数据。
- 半双工：代表同一时刻内，单方要么只能发送数据，要么只能接受数据。
- 单工：当前连接只能发送数据或只能接收数据，也就是“单向类型的通道”。

> 连接器的工作做完了，简单总结一下：
>
> *   与客户端进行 TCP 三次握手建立连接；
> *   校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
> *   如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；

### 系统服务层

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250603133502562.png" alt="image-20250603133502562" style="zoom:80%;" />

#### `SQL` 接口组件

主要作用就是负责处理客户端的 `SQL` 语句，当客户端连接建立成功之后，会接收客户端的 `SQL` 命令，比如 `DML、DDL` 语句以及存储过程、触发器等，当收到`SQL` 语句时，`SQL` 接口会将其分发给其他组件，然后等待接收执行结果的返回，最后会将其返回给客户端。

> 简单来说，也就是 `SQL` 接口会作为客户端连接传递 `SQL` 语句时的入口，并且作为数据库返回数据时的出口。

#### 解析器

客户端连接发送的 `SQL` 语句，经过 `SQL` 接口后会被分发到解析器，解析器这东西其实在所有语言中都存在，`Java、C、Go...`等其他语言都有，解析器的作用主要是做词法分析、语义分析、语法树生成...

而 `SQL解析器` 这一步的作用主要是为了验证 `SQL` 语句是否正确，以及将 `SQL` 语句解析成 `MySQL` 能看懂的机器码指令。

解析器会做如下两件事情。

第一件事情，**词法分析**。MySQL 会根据你输入的字符串识别出关键字出来，例如，SQL语句 select username from userinfo，在分析之后，会得到4个Token，其中有2个Keyword，分别为select和from：

| 关键字 | 非关键字 | 关键字 | 非关键字 |
| ------ | -------- | ------ | -------- |
| select | username | from   | userinfo |

第二件事情，**语法分析**。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250603135949557.png" alt="image-20250603135949557" style="zoom:50%;" />

如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。

#### 优化器

解析器完成相应的词法分析、语法树生成....等一系列工作后，紧接着会来到优化器，优化器的主要职责在于生成 `执行计划`，比如选择最合适的索引，选择最合适的 `join` 方式等，最终会选择出一套最优的执行计划。

### 存储引擎层

存储引擎是 `MySQL` 数据库中与磁盘文件打交道的子系统，不同的引擎底层访问文件的机制也存在些许细微差异，引擎也不仅仅只负责数据的管理，也会负责库表管理、索引管理等，`MySQL` 中所有与磁盘打交道的工作，最终都会交给存储引擎来完成。

###  文件系统层

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250603140253778.png" alt="image-20250603140253778" style="zoom:80%;" />

这一层主要可分为两个板块：①日志板块。②数据板块。

#### 日志板块

在`MySQL`中主要存在七种常用的日志类型，如下：

- ①`binlog`二进制日志，主要记录`MySQL`数据库的所有写操作（增删改）。
- ②`redo-log`重做/重写日志，`MySQL`崩溃时，对于未落盘的操作会记录在这里面，用于重启时重新落盘（`InnoDB`专有的）。
- ③`undo-logs`撤销/回滚日志：记录事务开始前[修改数据]的备份，用于回滚事务。
- ④`error-log`：错误日志：记录`MySQL`启动、运行、停止时的错误信息。
- ⑤`general-log`常规日志，主要记录`MySQL`收到的每一个查询或`SQL`命令。
- ⑥`slow-log`：慢查询日志，主要记录执行时间较长的`SQL`。
- ⑦`relay-log`：中继日志，主要用于主从复制做数据拷贝。

#### 数据模块

`MySQL`的所有数据最终都会落盘（写入到磁盘），而不同的数据在磁盘空间中，存储的格式也并不相同，因此再列举出一些`MySQL`中常见的数据文件类型：

- `db.opt`文件：主要记录当前数据库使用的字符集和验证规则等信息。
- `.frm`文件：存储表结构的元数据信息文件，每张表都会有一个这样的文件。
- `.MYD`文件：用于存储表中所有数据的文件（`MyISAM`引擎独有的）。
- `.MYI`文件：用于存储表中索引信息的文件（`MyISAM`引擎独有的）。
- `.ibd`文件：用于存储表数据和索引信息的文件（`InnoDB`引擎独有的）。
- `.ibdata`文件：用于存储共享表空间的数据和索引的文件（`InnoDB`引擎独有）。
- `.ibdata1`文件：这个主要是用于存储`MySQL`系统（自带）表数据及结构的文件。
- `.ib_logfile0/.ib_logfile1`文件：用于故障数据恢复时的日志文件。
- `.cnf/.ini`：`MySQL`的配置文件，`Windows`下是`.ini`，其他系统大多为`.cnf`。
- `......`

## sql 语句执行过程

我们通过 查询sql 和写sql 的执行过程，感受一下 mysql的整体架构。

### 查询 sql

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/mysql查询流程-20250603134808486.png" alt="查询语句执行流程" style="zoom:75%;" />

- 执行前
  - 连接 `MySQL` 服务器，TCP 三次握手
  - `连接器` 验证用户名，密码等
  - 查询用户权限表，查看是否有权限
  - 从连接池中获取连接

- 开始执行

  - 先将 `SQL` 发送给 `SQL` 接口，`SQL` 接口会对 `SQL` 语句进行 `hash` 处理。
  - sql 接口根据 hash 值检索是否有缓存
  - 缓存中未命中时，会将 `SQL` 交给解析器，解析器会判断 `SQL` 语句是否正确
  - 优化器根据 `SQL` 制定出不同的执行方案，并择选出最优的执行计划
  - 调用存储引擎执行 `sql`
  - 存储引擎进行 IO 检索数据，返回给 `sql` 接口
  - `sql`  接口将结果集处理(剔除列，合并数据)返回

### 写 sql

![image-20250603113716992](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250603113716992.png)

* 执行前
  - 连接 `MySQL` 服务器，TCP 三次握手
  - 连接器 验证用户名，密码等
  - 查询用户权限表，查看是否有权限
  - 从连接池中获取连接
* 开始执行

  * 先将 `SQL` 发送给 `SQL` 接口，`SQL` 接口会对 `SQL` 语句进行 `hash` 处理
  * sql 接口根据 hash 值检索是否有缓存，如果有，对应缓存删掉
  * 经过缓存后会将 `SQL` 交给解析器，解析器会判断 `SQL` 语句是否正确
  * 优化器制定执行计划
  * 在执行开始之前，会先记录 `undo log`（用于回滚），然后执行 SQL 修改数据到 `BufferPool`，**同时**生成 `redo log`（prepare 状态）
  * 遇到 `rollback`，在 `undo log` 中找到撤销 sql 执行，将缓冲区数据还原
  * 遇到 `commit`，利用 `checkpoint` 机制 异步刷盘，生成 `bin log`，然后将 `redo log` 改为 `commit` 状态
  * 将 `SQL` 执行耗时及操作成功的结果返回给 `SQL` 接口，再由 `SQL` 接口返回给客户端

## InnoDb 内存结构

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226163452463.png" alt="image-20250226163452463" style="zoom:80%;" />

注意观察，实际 MySQL 启动后内存结构略显复杂，但大体可分为 `MySQL工作组件`、`线程本地内存`、`MySQL共享内存`、`存储引擎缓冲区` 四大板块。

>  实际上 `MySQL` 内存模型和 `JVM` 类似，`JVM` 内存主要会划分为 `线程共享区` 和 `线程私有区`，而上图中的 `MySQL` 内存区域，左边则是 `线程私有区域`，每条工作线程中都会分配的区域，各线程之间互不影响，而右边的三大板块，则属于 `线程共享区域`，即所有线程都可访问的内存。

### MySQL Server - 工作组件

后续客户端连接时，都需要经过一系列的连接工作，处理 `SQL` 时也需要经过一系列的解析、验证、优化工作，所以 `MySQL` 会在启动时，会先将这些工作组件初始化到内存中，方便后续处理客户端的操作。

### 工作线程的本地内存

工作线程的本地内存区域，也被称之为 `线程私有区`，即 `MySQL` 在创建每条线程时，都会为其分配这些内存。

- `thread_stack`：线程堆栈，主要用于暂时存储运行的 SQL 语句及运算数据，和 Java 虚拟机栈类似。
- `sort_buffer`：排序缓冲区，执行排序 SQL 时，用于存放排序后数据的临时缓冲区。
- `join_buffer`：连接缓冲区，做连表查询时，存放符合连表查询条件的数据临时缓冲区。
- `read_buffer`：顺序读缓冲区，MySQL 磁盘 IO 一次读一页数据，这个是顺序 IO 的数据临时缓冲区。
- `read_rnd_buffer`：随机读缓冲区，当基于无序字段查询数据时，这里存放随机读到的数据。
- `net_buffer`：网络连接缓冲区，这里主要是存放当前线程对应的客户端连接信息。
- `tmp_table`：内存临时表，当 SQL 中用到了临时表时，这里存放临时表的结构及数据。
- `bulk_insert_buffer`：MyISAM 批量插入缓冲区，批量 insert 时，存放临时数据的缓冲区。
- `bin_log_buffer`：bin-log 日志缓冲区，[《日志篇》](https://juejin.cn/post/7157956679932313608#heading-11)提到过的，bin-log 的缓冲区被设计在工作线程的本地内存中。

将这些缓冲区都放在线程本地内存中，还有一点最大的好处：**能够提升多线程并发执行的性能**！这句话怎么理解呢？很简单，如果把上述的各个缓冲区放在共享内存中，然后提供给线程存放执行时的临时数据，因为多线程的缘故，所以同一时刻、同一快内存有可能出现多条线程一起操作，那就会出现线程不安全的问题，想要解决就只能加锁将多线程串行化，这自然会在很大程度上影响性能！因此将这些存临时数据的缓冲区，设计在本地内存中才最合适。

### MySQL 共享内存区

- `Key Buffer`：MyISAM 表的索引缓冲区，提升 MyISAM 表的索引读写速度。
- `Query Cache`：查询缓存区，缓冲 SQL 的查询结果，提升热点 SQL 的数据检索效率。
- `Thread Cache`：线程缓存区，存放工作线程运行期间，一些需要被共享的临时数据。
- `Table Cache`：表数据文件的文件描述符缓存，提升数据表的打开效率。
- `Table Definition Cache`：表结构文件的文件描述符缓存，提升结构表的打开效率。

#### MySQL8.x 为什么移除了查询缓存

很鸡肋，看个例子：

```sql
select * from zz_users where user_id=1;
select * from zz_users where user_id = 1;
```

`MySQL查询缓存` 是以 SQL 的 `哈希值` 来作为 Key 的，上面两条 SQL 虽然一样，但是后面的查询条件有细微差别：`user_id=1`、`user_id = 1`，也就是一条 SQL 有空格，一条没有。由于这一点点细微差异，会导致两条 SQL 计算出的哈希值完全不同，因此无法命中缓存。

### 存储引擎缓冲区(InnoDB Buffer Pool)

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226163747008.png" alt="image-20250226163747008" style="zoom:50%;" />

- `Data Page`：写入缓冲区，主要用来缓冲磁盘的表数据，将写操作转移到内存进行。
- `Index Page`：索引缓冲页，对于所有已创建的索引根节点，都会放入到内存，提升索引效率。
- `Lock Space`：锁空间，主要是存放所有创建出的锁对象，详情可参考[《MySQL 锁机制实现原理》](https://juejin.cn/post/7156111610589741063)。
- `Dict Info`：数据字典，主要用来存储 MySQL-InnoDB 引擎自带的系统表。
- `redo_log_buffer`：redo-log 缓冲区，存放写 SQL 执行时写入的 redo 记录。
- `undo_log_buffer`：undo-log 缓冲区，存放写 SQL 执行时写入的 undo 记录。
- `Adaptivity Hash`：自适应哈希索引，InnoDB 会为热点索引页，创建相应的哈希索引。
- `Insert Buffer`：写入缓冲区，对于 insert 的数据，会先放在这里，然后定期刷写磁盘。
- `Lru List`：内存淘汰页列表，对于整个缓冲池的内存管理列表（后续细聊）。
- `Free List`：空闲内存列表，这里面记录着目前未被使用的内存页。
- `Flush List`：脏页内存列表，这里主要记录未落盘的数据。

#### 缓存池的基本原理

**「读操作」:**

在数据库中进行读取页的操作，首先把从磁盘读到的页存放在缓存池中，下一次读取相同的页时，首先判断该页是不是在缓存池中。

若在，称该页在缓存池中被命中，则直接读取该页，否则，还是去读取磁盘上的页。

**「写操作」:**

对于数据库中页的修改操作，首先修改在缓存池中的页，然后在以一定的频率刷新到磁盘，并不是每次页发生改变就刷新回磁盘，而是通过 `checkpoint` 的机制把页刷新回磁盘。

若不在缓存池中，数据库将从磁盘读取需要修改的页到缓存池中。

**可以看到，无论是读操作还是写操纵，都是对缓存池进行操作，而不是直接对磁盘进行操纵。**

> **Checkpoint**：数据库在执行检查点（checkpoint）操作时，会将所有脏页写回磁盘，以确保数据的一致性。

#### 缓存池结构

Buffer Pool 是一片连续的内存空间，innodb 存储引擎是通过页的方式对这块内存进行管理的。

缓存池的结构如下图：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226163910072.png" alt="image-20250226163910072" style="zoom:50%;" />

##### 数据页（data page）

***结构***

页是 `InnoDB` 管理存储空间的基本单位，一个页的大小一般是 `16KB`。InnoDB 为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放 Insert Buffer 信息的页，存放 INODE 信息的页，存放 `undo` 日志信息的页等等。

其中，我们日常口中所称的数据记录的页，称为数据页。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226164004502.png" alt="image-20250226164004502" style="zoom:50%;" />

- File Header 文件头部

    - 双链表

    - 针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁

- Page Header 页面头部

    - 专门针对数据页记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀
- Infimum + Supremum 虚拟行记录（最大、最小）
- User Records 用户记录

    - 实际存储的行记录内容
- Free Space 空闲空间
- Page Directory 页面目录

    * 将页中的记录分组，每组最后一条记录的偏移量作为一个 slot 槽，放在 `page directory` 中
* 所以根据主键查找是先二分确定所在槽，然后根据记录中的 `next-record` 遍历，找到记录
- File Trailer 文件尾部

###### **User Records**

在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到 `User Records` 部分。但是在一开始生成页的时候，其实并没有 `User Records` 这个部分，每当我们插入一条记录，都会从 `Free Space` 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 `User Records` 部分，当 `Free Space` 部分的空间全部被 `User Records` 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226164748985.png" alt="image-20250226164748985" style="zoom:80%;" />

为了更好的管理在 `User Records` 中的这些记录，`InnoDB` 可费了一番力气呢。

----

那 行格式 是什么样的呢？

> 行格式（row\_format），就是一条记录的存储结构。
>
> InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。
>
> *   Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。
> *   由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。
> *   Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。
>
> Redundant 行格式我这里就不讲了，因为现在基本没人用了，这次重点介绍 Compact 行格式，因为 Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。
>
> 所以，弄懂了 Compact 行格式，之后你们在去了解其他行格式，很快也能看懂。

`COMPACT 行格式`

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/COMPACT.drawio.png" alt="img" style="zoom:35%;" />

可以看到，一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。

接下里，分别详细说下。

`1. 记录的额外信息`

记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。

`1.1 变长字段长度列表`

varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。

所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。

> 为了展示「变长字段长度列表」具体是怎么保存「变长字段的真实数据占用的字节数」，我们先创建这样一张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，t\_user 表中 name 和 phone 字段都是变长字段：
>
> ```sql
> CREATE TABLE `t_user` (
>   `id` int(11) NOT NULL,
>   `name` VARCHAR(20) DEFAULT NULL,
>   `phone` VARCHAR(20) DEFAULT NULL,
>   `age` int(11) DEFAULT NULL,
>   PRIMARY KEY (`id`) USING BTREE
> ) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT; 
> ```
>
> 现在 t\_user 表里有这三条记录：
>
> <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250603143950696.png" alt="image-20250603143950696" style="zoom:70%;" />
>
> 接下来，我们看看看看这三条记录的行格式中的 「变长字段长度列表」是怎样存储的。
>
> 先来看第一条记录：
>
> *   phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；
> *   age 列和 id 列不是变长字段，所以这里不用管。
>
> 这些变长字段的真实数据占用的字节数会按照列的顺序**逆序存放**（等下会说为什么要这么设计），所以「变长字段长度列表」里的内容是「 03 01」，而不是 「01 03」。
>
> <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/变长字段长度列表1.png" style="zoom:35%;" />
>
> 同样的道理，我们也可以得出**第二条记录**的行格式中，「变长字段长度列表」里的内容是「 04 02」，如下图：
>
> <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/变长字段长度列表2.png" style="zoom:35%;" />
>
> **第三条记录**中 phone 列的值是 NULL，**NULL 是不会存放在行格式中记录的真实数据部分里的**，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。
>
> <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/变长字段长度列表3.png" style="zoom:35%;" />

> 为什么「变长字段长度列表」的信息要按照逆序存放？

这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。

「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以**使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率**。

同样的道理， NULL 值列表的信息也需要逆序存放。

如果你不知道什么是 CPU Cache，可以看[这篇文章 (opens new window)](https://xiaolincoding.com/os/1_hardware/how_to_make_cpu_run_faster.html)，这属于计算机组成的知识。

> 每个数据库表的行格式都有「变长字段字节数列表」吗？

其实变长字段字节数列表不是必须的。

**当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了**，因为没必要，不如去掉以节省空间。

所以「变长字段长度列表」只出现在数据表有变长字段的时候。

`1.2 NULL 值列表`

表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。

如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。

*   二进制位的值为`1`时，代表该列的值为NULL。
*   二进制位的值为`0`时，代表该列的值不为NULL。

另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 `0`。

还是以 t\_user 表的这三条记录作为例子：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250603144339908.png" alt="image-20250603144339908" style="zoom:60%;" />

接下来，我们看看看看这三条记录的行格式中的 NULL 值列表是怎样存储的。

先来看**第一条记录**，第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示是酱紫的：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/null值列表1.png" style="zoom:50%;" />

但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0，最终用二进制来表示是酱紫的：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/null值列表2.png" style="zoom:50%;" />

所以，对于第一条数据，NULL 值列表用十六进制表示是 0x00。

接下来看**第二条记录**，第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/null值列表3.png" style="zoom:50%;" />

最后**第三条记录**，第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/null值列表4.png" style="zoom:50%;" />

我们把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/null值列表5.png" style="zoom:50%;" />

> 每个数据库表的行格式都有「NULL 值列表」吗？

NULL 值列表也不是必须的。

**当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了**。

所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。

> 「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？

「NULL 值列表」的空间不是固定 1 字节的。

当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。

`1.3 记录头信息`

我们先创建一个表：

```sql
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)
```

简化后的行格式示意图就是这样：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226164826517.png" alt="image-20250226164826517" style="zoom:90%;" />

下边我们试着向 page_demo 表中插入几条记录：

```sql
mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226164902770.png" alt="image-20250226164902770" style="zoom:110%;" />

我们对照着这个图来看看记录头信息中的各个属性是啥意思：

- `delete_mask`

    - 这个属性标记着当前记录是否被删除
    - 这些被删除的记录不立即从磁盘上移除，因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的 `垃圾链表`，在这个链表中的记录占用的空间称之为所谓的 `可重用空间`，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。
- `min_rec_mask`

    - B+ 树的每层非叶子节点中的最小记录都会添加该标记
    - 我们自己插入的四条记录的 min_rec_mask 值都是 0，意味着它们都不是 B+ 树的非叶子节点中的最小记录
- `n_owned`

    - 表示当前记录拥有的记录数
- `heap_no`

    - 这个属性表示当前记录在本 `页` 中的位置
    - 从图中可以看出来，我们插入的 4 条记录在本页中的位置分别是：`2`、`3`、`4`、`5`。是不是少了点啥？是的，怎么不见 `heap_no` 值为 `0` 和 `1` 的记录呢？

> 不管我们向页中插入了多少自己的记录，InnoDB 定义的两条伪记录分别为 `最小记录` 与 `最大记录`。他们并不存放在页的 `User Records` 部分，他们被单独放在一个称为 `Infimum + Supremum` 的部分

- `record_type`

    - 这个属性表示当前记录的类型，一共有 4 种类型的记录，0 表示普通记录，1 表示 B+ 树非叶节点记录，2 表示最小记录，3 表示最大记录。
    - 从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的 record_type 值都是 0，而最小记录和最大记录的 record_type 值分别为 2 和 3。
- `next_record`

    - 表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量
    - 比方说第一条记录的 next_record 值为 32，意味着从第一条记录的真实数据的地址处向后找 32 个字节便是下一条记录的真实数据

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226165005145.png" alt="image-20250226165005145" style="zoom:80%;" />

* 从图中可以看出来，我们的记录按照主键从小到大的顺序形成了一个单链表。`最大记录` 的 `next_record` 的值为 0，这也就是说最大记录是没有下一条记录了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第 2 条记录删掉：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226165039313.png" alt="image-20250226165039313" style="zoom:80%;" />

从图中可以看出来，删除第 2 条记录前后主要发生了这些变化：

- 第 2 条记录并没有从存储空间中移除，而是把该条记录的 `delete_mask` 值设置为 1。
- 第 2 条记录的 `next_record` 值变为了 0，意味着该记录没有下一条记录了。
- 第 1 条记录的 `next_record` 指向了第 3 条记录。
- 还有一点你可能忽略了，就是最大记录的 n_owned 值从 5 变成了 4。

`2. 记录的真实数据`

记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row\_id、trx\_id、roll\_pointer，我们来看下这三个字段是什么。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/记录的真实数据.png" style="zoom:40%;" />

*   row\_id

如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row\_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row\_id 隐藏字段。row\_id不是必需的，占用 6 个字节。

*   trx\_id

事务id，表示这个数据是由哪个事务生成的。 trx\_id是必需的，占用 6 个字节。

*   roll\_pointer

这条记录上一个版本的指针。roll\_pointer 是必需的，占用 7 个字节。

如果你熟悉 MVCC 机制，你应该就清楚 trx\_id 和 roll\_pointer 的作用了。

`1.3 行溢出怎么办`

MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 `16KB`，也就是 `16384字节`，而一个 varchar(n) 类型的列最多可以存储 `65532字节`，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会**发生行溢出，多的数据就会存到另外的「溢出页」中**。

如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。

当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/行溢出.png" style="zoom:50%;" />

上面这个是 Compact 行格式在发生行溢出后的处理。

Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。

###### ***Page Directory（页目录）***

现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？

最笨的办法：从 `Infimum记录（最小记录）` 开始，沿着链表一直往后找，总有一天会找到，这样性能太差。

InnoDB 制作了一个类似书的目录：

1. 将所有正常的记录（包括 `最大` 和 `最小记录`，不包括标记为已删除的记录）划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 `n_owned` 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的 `Page Directory`，也就是页目录（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为 `槽`（英文名：`Slot`），所以这个页面目录就是由 `槽` 组成的。

比方说现在的 page_demo 表中正常的记录共有 6 条，InnoDB 会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的 5 条记录，看下边的示意图：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226165127229.png" alt="image-20250226165127229" style="zoom:80%;" />

从这个图中我们需要注意这么几点:

- 现在 `页目录` 部分中有两个槽，也就意味着我们的记录被分成了两个组，`槽1` 中的值是 112，代表最大记录的地址偏移量（就是从页面的 0 字节开始数，数 112 个字节）；`槽0` 中的值是 99，代表最小记录的地址偏移量。
- 注意最小和最大记录的头信息中的 `n_owned` 属性

    - 最小记录的 `n_owned` 值为 1，这就代表着以最小记录结尾的这个分组中只有 1 条记录，也就是最小记录本身。
    - 最大记录的 `n_owned` 值为 5，这就代表着以最大记录结尾的这个分组中只有 5 条记录，包括最大记录本身还有我们自己插入的 4 条记录。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226165504521.png" alt="image-20250226165504521" style="zoom:80%;" />

我们一口气又往表中添加了 12 条记录，现在页里边就一共有 18 条记录了（包括最小和最大记录），这些记录被分成了 5 个组，如图所示：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226165546949.png" alt="image-20250226165546949" style="zoom:80%;" />

比方说我们想找主键值为 `6` 的记录，过程是这样的：

1. 计算中间槽的位置：`(0+4)/2=2`，所以查看 `槽2` 对应记录的主键值为 `8`，又因为 `8 > 6`，所以设置 `high=2`，`low` 保持不变。
2. 重新计算中间槽的位置：`(0+2)/2=1`，所以查看 `槽1` 对应的主键值为 `4`，又因为 `4 < 6`，所以设置 `low=1`，`high` 保持不变。
3. 因为 `high - low` 的值为 1，所以确定主键值为 `6` 的记录在 `槽2` 对应的组中。此刻我们需要找到 `槽2` 中主键值 `最小的那条记录`，然后沿着单向链表遍历 `槽2` 中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽 2 对应的记录是主键值为 8 的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到 `槽1` 对应的记录（主键值为 `4`），该条记录的下一条记录就是 `槽2` 中主键值最小的记录，该记录的主键值为 `5`。所以我们可以从这条主键值为 `5` 的记录出发，遍历 `槽2` 中的各条记录，直到找到主键值为 `6` 的那条记录即可。由于一个组中包含的记录条数只能是 1~8 条，所以遍历一个组中的记录的代价是很小的。

所以在一个数据页中查找指定主键值的记录的过程分为两步：

1. 通过 `二分法` 确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
2. 通过记录的 `next_record` 属性遍历该槽所在的组中的各个记录。

###### ***Page Header（页面头部）***

`InnoDB` 为了能得到一个 `数据页` 中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分。

###### ***File Header（文件头部）***

上边的 `Page Header` 是专门针对 `数据页` 记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀。我们现在描述的 `File Header` 针对各种类型的 `页` 都通用，也就是说不同类型的页都会以 `File Header` 作为第一个组成部分，它描述了一些针对各种 `页` 都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁。

###### ***File Trailer***

为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），`InnoDB` 在每个页的尾部都加了一个 `File Trailer` 部分，与 `File Header` 类似，都是所有类型的页通用的。

###### ***总结***

1. `InnoDB` 为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做 `数据页`。
2. 一个数据页可以被大致划分为 7 个部分，分别是

    * File Header 文件头部

        * 双链表
        * 针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁
    * Page Header 页面头部

        * 专门针对数据页记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀
    * Infimum + Supremum 虚拟行记录（最大、最小）
    * User Records 用户记录

        * 实际存储的行记录内容
    * Free Space 空闲空间
    * Page Directory 页面目录

        * `InnoDB` 会把页中的记录划分为若干个 `组`，每个组的 `最后一个` 记录的 `地址偏移量` 作为一个 `槽`，存放在 `Page Directory` 中，所以在一个 `页` 中根据 `主键` 查找记录是非常快的，分为两步：

            * 通过二分法确定该记录所在的 `槽`。
            * 通过记录的 `next_record` 属性遍历该槽所在的组中的各个记录。
    * File Trailer 文件尾部，用于检验页是否完整的部分

3. 每个记录的头信息中都有一个 `next_record` 属性，从而使页中的所有记录串联成一个 `单链表`
4. 每个数据页的 `File Header` 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个 `双链表`。
5. 为保证从内存中同步到磁盘的 `页的完整性`，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的 `LSN` 值，如果首部和尾部的校验和和 `LSN` 值校验不成功的话，就说明同步过程出现了问题。

##### 索引缓冲页（Index Page）

专门用来存放载入的索引数据，存储这些数据的缓冲页，则被称之为索引页。随着运行时间的增长，也会将一些非根节点的索引页载入内存中，这是一种对于访问频率较高的索引页，专门推出的优化机制。

##### 锁空间（Lock Space）

锁空间不仅仅只会存储锁结构，还会存储一些并发事务的链表，例如死锁检测时需要的「事务等待链表、锁的信息链表」等。

##### 数据字典（Dict Info）

在 `InnoDB` 引擎中主要存在 `SYS_TABLES`、`SYS_COLUMNS`、`SYS_INDEXES`、`SYS_FIELDS` 这四张系统表，主要是用来维护用户定义的所有表的各种信息，如下：

- SYS_TABLES

    - 这张表中会存储所有引擎为 InnoDB 的表信息。
- SYS_COLUMNS

    - 这张表用来存储所有用户定义的表字段信息。
- SYS_INDEXES

    - 这张表用来存储所有 InnoDB 引擎表的索引信息。
- SYS_FIELDS

    - 这张表用来存储所有索引的定义信息。

这四张表也被称为 `InnoDB` 的内部表，这四张表在载入内存前，位于 `.ibdata` 文件中，在 MySQL 启动时会开始加载，载入内存后就会放入到 `Dict Info` 这块区域，当利用 `show` 语句查询表的结构信息时，就会在字典信息中检索数据。

##### 日志缓冲区（Log Buffer）

`InnoDB` 的缓冲池中，主要存在两个日志缓冲区，即 `undo_log_buffer`、`redo_log_buffer`，分别对应着撤销日志和重做日志。它俩的作用主要是用来提升日志记录的写入速度，因为日志文件在磁盘中，执行 SQL 时直接往磁盘写日志，其效率太低了，因此会先写缓冲区，再由后台线程去刷写日志。

##### 自适应哈希索引（Adaptivity Hash）

哈希算法查找数据的效率非常高，在没有哈希冲突的情况下复杂度为 `O(1)`，而 `B+Tree` 检索数据的效率，取决于树的高度。建立索引时，只能选用一种数据结构来作为索引的底层结构：

- 如果选择哈希结构，虽然效率高，但数据是无序的，因此不方便做排序查询。
- 如果选择 `B+Tree` 结构，虽然有序，但查询的效率会受到树高的影响。

`InnoDB` 实现了一种名为自适应哈希索引的技术，在 MySQL 运行过程中，`InnoDB` 引擎会对表上的索引做监控，如果某些数据经常走索引查询，那 `InnoDB` 就会为其建立一个哈希索引，以此来提升数据检索的效率，并且减少走 `B+Tree` 带来的开销，由于这种哈希索引是运行过程中，`InnoDB` 根据 `B+Tree` 的索引查询次数来建立的，因此被称之为自适应哈希索引。

> `自适应哈希索引` 和 `普通哈希索引` 的区别在哪儿呢？`普通哈希索引` 是在创建索引时将结构声明为 `Hash` 结构，这种索引会以索引字段的整表数据建立哈希，而 `自适应哈希索引` 是根据缓冲池的 `B+树` 构造而来，只会基于热点数据构建，因此建立的速度会非常快，毕竟无需对整表都建立哈希索引。

##### 写入缓冲区（Insert Buffer）

如果要变更的数据页在缓冲区中存在，则会直接修改缓冲区中的数据页，然后标记一下变更过的数据页，但如果要操作的数据页并未被加载到缓冲区，那依旧会走磁盘去操作数据，走磁盘显然会影响性能，因此 `InnoDB` 就创造了一个「`写入缓冲`」。

写入缓冲对于 insert、delete、update 语句都可生效，当一条写入语句执行时，流程如下：

- ① 判断要变更的数据页是否被载入到内存。
- ② 如果内存中有对应的数据页，则直接变更缓冲区中的数据页，完成标记后则直接返回。
- ③ 如果内存中没有对应的数据页，则将要变更的数据放入到「写入缓冲」中，然后返回。

此时会发现，不管内存中是否存在相应的数据页，`InnoDB` 都不会走磁盘写数据，而是直接在内存中完成所有操作，但是要注意：**`并不是所有的写入动作，都可以在内存中完成`**，「写入缓冲」是有 `限制` 的，如下：

- 插入的数据字段不能具备 `唯一约束` 或 `唯一索引`。

为啥呢？因为如果存在唯一字段的表，在插入数据前必须要先判断表中是否存在相同值，一张表的数据不可能全部都载入数据，所以这个判断重复值的工作必须依赖磁盘中的表数据来完成，所以插入具备唯一性的数据时，就必须要走磁盘。

#### InnoDB 缓冲池 管理内存

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250603173950291.png" alt="image-20250603173950291" style="zoom:50%;" />

##### 原理

- Free 链表

    - 统一管理、分配所有未使用的缓冲页
- Flush 链表

    - 统一管理、刷写所有被标记过的缓冲页（脏页）
- Lru 链表

    - 统一管理、淘汰所有已使用、未变更过的缓冲页

- 数据转换

    - 当 LRU 链表中的一个数据页发生变更后，会从 LRU 链表转到 `Flush` 链表
    - 当标记页中的变更数据落盘后，此时标记页又会从 `Flush` 链表回到 `LRU` 链表

##### 如何提高缓存命中率？

要实现这个，最容易想到的就是 LRU（Least recently used）算法。

该算法的思路是，链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰最久没被使用的节点，从而腾出空间。

简单的 LRU 算法的实现思路是这样的：

*   当访问的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移动到链表的头部。
*   当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，还要淘汰 LRU 链表末尾的节点。

比如下图，假设 LRU 链表长度为 5，LRU 链表从左到右有 1，2，3，4，5 的页。

![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/lru.png)

如果访问了 3 号的页，因为 3 号页在 Buffer Pool 里，所以把 3 号页移动到头部即可。

![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/lru2.png)

而如果接下来，访问了 8 号页，因为 8 号页不在 Buffer Pool 里，所以需要先淘汰末尾的 5 号页，然后再将 8 号页加入到头部。

![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/lru3-20250603181657310.png)

到这里我们可以知道，Buffer Pool 里有三种页和链表来管理数据。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/bufferpoll_page.png" style="zoom:50%;" />

图中：

*   Free Page（空闲页），表示此页未被使用，位于 Free 链表；
*   Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。
*   Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表。

简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：

*   预读失效；
*   Buffer Pool 污染；

> 什么是预读失效？

先来说说 MySQL 的预读机制。程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。

所以，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。

但是可能这些**被提前加载进来的数据页，并没有被访问**，相当于这个预读是白做了，这个就是**预读失效**。

如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool空间不够的时候，还需要把末尾的页淘汰掉。

如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。

> 怎么解决预读失效而导致缓存命中率降低的问题？

我们不能因为害怕预读失效，而将预读机制去掉，大部分情况下，局部性原理还是成立的。

要避免预读失效带来影响，最好就是**让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长**。

那到底怎么才能避免呢？

MySQL 是这样做的，它改进了 LRU 算法，将 LRU 划分了 2 个区域：**old 区域 和 young 区域**。

young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/young.png" alt="young" style="zoom:70%;" />

old 区域占整个 LRU 链表长度的比例可以通过 `innodb_old_blocks_pct` 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37。

**划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部**。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。

接下来，给大家举个例子。

假设有一个长度为 10 的 LRU 链表，其中 young 区域占比 70 %，old 区域占比 30 %。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/lrutwo.drawio.png" style="zoom:70%;" />

现在有个编号为 20 的页被预读了，这个页只会被插入到 old 区域头部，而 old 区域末尾的页（10号）会被淘汰掉。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/lrutwo2.png" style="zoom:70%;" />

如果 20 号页一直不会被访问，它也没有占用到 young 区域的位置，而且还会比 young 区域的数据更早被淘汰出去。

如果 20 号页被预读后，立刻被访问了，那么就会将它插入到 young 区域的头部，young 区域末尾的页（7号），会被挤到 old 区域，作为 old 区域的头部，这个过程并不会有页被淘汰。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/lrutwo3.png" style="zoom:70%;" />

虽然通过划分 old 区域 和 young 区域避免了预读失效带来的影响，但是还有个问题无法解决，那就是 Buffer Pool 污染的问题。

> 什么是 Buffer Pool 污染？

当某一个 SQL 语句**扫描了大量的数据**时，在 Buffer Pool 空间比较有限的情况下，可能会将 **Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了**，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 **Buffer Pool 污染**。

注意， Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也会造成 Buffer Pool 污染。

比如，在一个数据量非常大的表，执行了这条语句：

```sql
select * from t_user where name like "%xiaolin%"; 
```

可能这个查询出来的结果就几条记录，但是由于这条语句会发生索引失效，所以这个查询过程是全表扫描的，接着会发生如下的过程：

*   从磁盘读到的页加入到 LRU 链表的 old 区域头部；
*   当从页里读取行记录时，也就是页被访问的时候，就要将该页放到 young 区域头部；
*   接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里；
*   如此往复，直到扫描完表中的所有记录。

经过这一番折腾，原本 young 区域的热点数据都会被替换掉。

举个例子，假设需要批量扫描：21，22，23，24，25 这五个页，这些页都会被逐一访问（读取页里的记录）。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/lruthree.drawio.png" style="zoom:70%;" />

在批量访问这些数据的时候，会被逐一插入到 young 区域头部。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/lruthree1.png" style="zoom:70%;" />

可以看到，原本在 young 区域的热点数据 6 和 7 号页都被淘汰了，这就是 Buffer Pool 污染的问题。

> 怎么解决出现 Buffer Pool 污染而导致缓存命中率下降的问题？

像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了。

LRU 链表中 young 区域就是热点数据，只要我们提高进入到 young 区域的门槛，就能有效地保证 young 区域里的热点数据不会被替换掉。

MySQL 是这样做的，进入到 young 区域条件增加了一个**停留在 old 区域的时间判断**。

具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：

*   如果后续的访问时间与第一次访问的时间**在某个时间间隔内**，那么**该缓存页就不会被从 old 区域移动到 young 区域的头部**；
*   如果后续的访问时间与第一次访问的时间**不在某个时间间隔内**，那么**该缓存页移动到 young 区域的头部**；

这个间隔时间是由 `innodb_old_blocks_time` 控制的，默认是 1000 ms。

也就说，**只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部**，这样就解决了 Buffer Pool 污染的问题 。

另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会。

#### 脏页什么时候会被刷入磁盘？

引入了 Buffer Pool 后，当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，但是磁盘中还是原数据。

因此，脏页需要被刷入磁盘，保证缓存和磁盘数据一致，但是若每次修改数据都刷入磁盘，则性能会很差，因此一般都会在一定时机进行批量刷盘。

可能大家担心，如果在脏页还没有来得及刷入到磁盘时，MySQL 宕机了，不就丢失数据了吗？

这个不用担心，InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。

下面几种情况会触发脏页的刷新：

*   当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；
*   Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；
*   MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；
*   MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；

在我们开启了慢 SQL 监控后，如果你发现 **「偶尔」会出现一些用时稍长的 SQL**，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。

如果间断出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。

#### 总结

Innodb 存储引擎设计了一个**缓冲池（_Buffer Pool_）**，来提高数据库的读写性能。

Buffer Pool 以页为单位缓冲数据，可以通过 `innodb_buffer_pool_size` 参数调整缓冲池的大小，默认是 128 M。

Innodb 通过三种链表来管理缓页：

*   Free List （空闲页链表），管理空闲页；
*   Flush List （脏页链表），管理脏页；
*   LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；

InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：

*   将 LRU 链表 分为**young 和 old 两个区域**，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。
*   当\*\*「页被访问」且「 old 区域停留时间超过 `innodb_old_blocks_time` 阈值（默认为1秒）」\*\*时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。

可以通过调整 `innodb_old_blocks_pct` 参数，设置 young 区域和 old 区域比例。

在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。
