
# 全解MySQL之架构篇

## MySQL整体结构浅析

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250303094003794.png" alt="image-20250303094003794" style="zoom:80%;" />

从上往下看，依次会分为网络连接层、系统服务层、存储引擎层、以及文件系统层，往往编写`SQL`后，都会遵守着`MySQL`的这个架构往下走。

- 连接层：主要是指数据库连接池，会负责处理所有客户端接入的工作。
- 服务层：主要包含`SQL`接口、解析器、优化器以及缓存缓冲区四块区域。
- 存储引擎层：这里是指`MySQL`支持的各大存储引擎，如`InnoDB、MyISAM`等。
- 文件系统层：涵盖了所有的日志，以及数据、索引文件，位于系统硬盘上。

## 网络连接层

当一个客户端尝试与`MySQL`建立连接时，`MySQL`内部都会派发一条线程负责处理该客户端接下来的所有工作。而数据库的连接层负责的就是所有客户端的接入工作，`MySQL`的连接一般都是基于`TCP/IP`协议建立网络连接，因此凡是可以支持`TCP/IP`的语言，几乎都能与`MySQL`建立连接。

> 其实`MySQL`还支持另一种连接方式，就是`Unix`系统下的`Socket`直连，但这种方式一般使用的较少。

先来看看一般是怎么连接`MySQL`的？如下：

```shel
mysql -h 127.0.0.1 -uroot -p123456
```

当执行这条指令后，会与`MySQL-Server`建立网络连接，也就是会经历[《TCP的三次握手过程》](https://juejin.cn/post/7101917676162777119#heading-38)。当然，`MySQL`也支持`SSL`加密连接，如果采用这种方式建立连接，那还会经过[《SSL多次握手过程》](https://juejin.cn/post/7109497228103778311#heading-37)，当握手结束，网络建立成功后，则会开始正式的数据库连接建立工作。

`TCP`网络连接建立成功后，`MySQL`服务端与客户端之间会建立一个`session`会话，紧接着会对登录的用户名和密码进行效验，`MySQL`首先会查询自身的用户表信息，判断输入的用户名是否存在，如果存在则会判断输入的密码是否正确。当账号及密码正确时，此时就会进入`MySQL`的命令行，接下来可以执行`SQL`操作。

经过上述流程后数据库连接就建立成功了，数据库连接建立成功后，`MySQL`与客户端之间会采用半双工的通讯机制工作，与之对应的还有“**全双工、单工**”的工作模式：

- 全双工：代表通讯的双方在同一时间内，即可以发送数据，也可以接收数据。
- 半双工：代表同一时刻内，单方要么只能发送数据，要么只能接受数据。
- 单工：当前连接只能发送数据或只能接收数据，也就是“单向类型的通道”。

## 系统服务层

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250303142817860.png" alt="image-20250303142817860" style="zoom:80%;" />

### `SQL`接口组件

主要作用就是负责处理客户端的`SQL`语句，当客户端连接建立成功之后，会接收客户端的`SQL`命令，比如`DML、DDL`语句以及存储过程、触发器等，当收到`SQL`语句时，`SQL`接口会将其分发给其他组件，然后等待接收执行结果的返回，最后会将其返回给客户端。

> 简单来说，也就是`SQL`接口会作为客户端连接传递`SQL`语句时的入口，并且作为数据库返回数据时的出口。

### 解析器

客户端连接发送的`SQL`语句，经过`SQL`接口后会被分发到解析器，解析器这东西其实在所有语言中都存在，`Java、C、Go...`等其他语言都有，解析器的作用主要是做词法分析、语义分析、语法树生成...

而`SQL解析器`这一步的作用主要是为了验证`SQL`语句是否正确，以及将`SQL`语句解析成`MySQL`能看懂的机器码指令。

### 优化器

解析器完成相应的词法分析、语法树生成....等一系列工作后，紧接着会来到优化器，优化器的主要职责在于生成执行计划，比如选择最合适的索引，选择最合适的`join`方式等，最终会选择出一套最优的执行计划。

## 存储引擎层

存储引擎是`MySQL`数据库中与磁盘文件打交道的子系统，不同的引擎底层访问文件的机制也存在些许细微差异，引擎也不仅仅只负责数据的管理，也会负责库表管理、索引管理等，`MySQL`中所有与磁盘打交道的工作，最终都会交给存储引擎来完成。

##  文件系统层

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250303142850427.png" alt="image-20250303142850427" style="zoom:80%;" />

这一层主要可分为两个板块：①日志板块。②数据板块。

### 日志板块

在`MySQL`中主要存在七种常用的日志类型，如下：

- ①`binlog`二进制日志，主要记录`MySQL`数据库的所有写操作（增删改）。
- ②`redo-log`重做/重写日志，`MySQL`崩溃时，对于未落盘的操作会记录在这里面，用于重启时重新落盘（`InnoDB`专有的）。
- ③`undo-logs`撤销/回滚日志：记录事务开始前[修改数据]的备份，用于回滚事务。
- ④`error-log`：错误日志：记录`MySQL`启动、运行、停止时的错误信息。
- ⑤`general-log`常规日志，主要记录`MySQL`收到的每一个查询或`SQL`命令。
- ⑥`slow-log`：慢查询日志，主要记录执行时间较长的`SQL`。
- ⑦`relay-log`：中继日志，主要用于主从复制做数据拷贝。

### 数据模块

`MySQL`的所有数据最终都会落盘（写入到磁盘），而不同的数据在磁盘空间中，存储的格式也并不相同，因此再列举出一些`MySQL`中常见的数据文件类型：

- `db.opt`文件：主要记录当前数据库使用的字符集和验证规则等信息。
- `.frm`文件：存储表结构的元数据信息文件，每张表都会有一个这样的文件。
- `.MYD`文件：用于存储表中所有数据的文件（`MyISAM`引擎独有的）。
- `.MYI`文件：用于存储表中索引信息的文件（`MyISAM`引擎独有的）。
- `.ibd`文件：用于存储表数据和索引信息的文件（`InnoDB`引擎独有的）。
- `.ibdata`文件：用于存储共享表空间的数据和索引的文件（`InnoDB`引擎独有）。
- `.ibdata1`文件：这个主要是用于存储`MySQL`系统（自带）表数据及结构的文件。
- `.ib_logfile0/.ib_logfile1`文件：用于故障数据恢复时的日志文件。
- `.cnf/.ini`：`MySQL`的配置文件，`Windows`下是`.ini`，其他系统大多为`.cnf`。
- `......`

## InnoDb 内存结构

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226163452463.png" alt="image-20250226163452463" style="zoom:80%;" />

注意观察，实际 MySQL 启动后内存结构略显复杂，但大体可分为 `MySQL工作组件`、`线程本地内存`、`MySQL共享内存`、`存储引擎缓冲区` 四大板块。

>  实际上 `MySQL` 内存模型和 `JVM` 类似，`JVM` 内存主要会划分为 `线程共享区` 和 `线程私有区`，而上图中的 `MySQL` 内存区域，左边则是 `线程私有区域`，每条工作线程中都会分配的区域，各线程之间互不影响，而右边的三大板块，则属于 `线程共享区域`，即所有线程都可访问的内存。

### MySQL Server - 工作组件

后续客户端连接时，都需要经过一系列的连接工作，处理 `SQL` 时也需要经过一系列的解析、验证、优化工作，所以 `MySQL` 会在启动时，会先将这些工作组件初始化到内存中，方便后续处理客户端的操作。

### 工作线程的本地内存

工作线程的本地内存区域，也被称之为 `线程私有区`，即 `MySQL` 在创建每条线程时，都会为其分配这些内存。

- `thread_stack`：线程堆栈，主要用于暂时存储运行的 SQL 语句及运算数据，和 Java 虚拟机栈类似。
- `sort_buffer`：排序缓冲区，执行排序 SQL 时，用于存放排序后数据的临时缓冲区。
- `join_buffer`：连接缓冲区，做连表查询时，存放符合连表查询条件的数据临时缓冲区。
- `read_buffer`：顺序读缓冲区，MySQL 磁盘 IO 一次读一页数据，这个是顺序 IO 的数据临时缓冲区。
- `read_rnd_buffer`：随机读缓冲区，当基于无序字段查询数据时，这里存放随机读到的数据。
- `net_buffer`：网络连接缓冲区，这里主要是存放当前线程对应的客户端连接信息。
- `tmp_table`：内存临时表，当 SQL 中用到了临时表时，这里存放临时表的结构及数据。
- `bulk_insert_buffer`：MyISAM 批量插入缓冲区，批量 insert 时，存放临时数据的缓冲区。
- `bin_log_buffer`：bin-log 日志缓冲区，[《日志篇》](https://juejin.cn/post/7157956679932313608#heading-11)提到过的，bin-log 的缓冲区被设计在工作线程的本地内存中。

将这些缓冲区都放在线程本地内存中，还有一点最大的好处：**能够提升多线程并发执行的性能**！这句话怎么理解呢？很简单，如果把上述的各个缓冲区放在共享内存中，然后提供给线程存放执行时的临时数据，因为多线程的缘故，所以同一时刻、同一快内存有可能出现多条线程一起操作，那就会出现线程不安全的问题，想要解决就只能加锁将多线程串行化，这自然会在很大程度上影响性能！因此将这些存临时数据的缓冲区，设计在本地内存中才最合适。

### MySQL 共享内存区

- `Key Buffer`：MyISAM 表的索引缓冲区，提升 MyISAM 表的索引读写速度。
- `Query Cache`：查询缓存区，缓冲 SQL 的查询结果，提升热点 SQL 的数据检索效率。
- `Thread Cache`：线程缓存区，存放工作线程运行期间，一些需要被共享的临时数据。
- `Table Cache`：表数据文件的文件描述符缓存，提升数据表的打开效率。
- `Table Definition Cache`：表结构文件的文件描述符缓存，提升结构表的打开效率。

#### MySQL8.x 为什么移除了查询缓存

很鸡肋，看个例子：

```sql
select * from zz_users where user_id=1;
select * from zz_users where user_id = 1;
```

`MySQL查询缓存` 是以 SQL 的 `哈希值` 来作为 Key 的，上面两条 SQL 虽然一样，但是后面的查询条件有细微差别：`user_id=1`、`user_id = 1`，也就是一条 SQL 有空格，一条没有。由于这一点点细微差异，会导致两条 SQL 计算出的哈希值完全不同，因此无法命中缓存。

### 存储引擎缓冲区(InnoDB Buffer Pool)

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226163747008.png" alt="image-20250226163747008" style="zoom:50%;" />

- `Data Page`：写入缓冲区，主要用来缓冲磁盘的表数据，将写操作转移到内存进行。
- `Index Page`：索引缓冲页，对于所有已创建的索引根节点，都会放入到内存，提升索引效率。
- `Lock Space`：锁空间，主要是存放所有创建出的锁对象，详情可参考[《MySQL 锁机制实现原理》](https://juejin.cn/post/7156111610589741063)。
- `Dict Info`：数据字典，主要用来存储 MySQL-InnoDB 引擎自带的系统表。
- `redo_log_buffer`：redo-log 缓冲区，存放写 SQL 执行时写入的 redo 记录。
- `undo_log_buffer`：undo-log 缓冲区，存放写 SQL 执行时写入的 undo 记录。
- `Adaptivity Hash`：自适应哈希索引，InnoDB 会为热点索引页，创建相应的哈希索引。
- `Insert Buffer`：写入缓冲区，对于 insert 的数据，会先放在这里，然后定期刷写磁盘。
- `Lru List`：内存淘汰页列表，对于整个缓冲池的内存管理列表（后续细聊）。
- `Free List`：空闲内存列表，这里面记录着目前未被使用的内存页。
- `Flush List`：脏页内存列表，这里主要记录未落盘的数据。

#### 缓存池的基本原理

**「读操作」:**

在数据库中进行读取页的操作，首先把从磁盘读到的页存放在缓存池中，下一次读取相同的页时，首先判断该页是不是在缓存池中。

若在，称该页在缓存池中被命中，则直接读取该页，否则，还是去读取磁盘上的页。

**「写操作」:**

对于数据库中页的修改操作，首先修改在缓存池中的页，然后在以一定的频率刷新到磁盘，并不是每次页发生改变就刷新回磁盘，而是通过 `checkpoint` 的机制把页刷新回磁盘。

若不在缓存池中，数据库将从磁盘读取需要修改的页到缓存池中。

**可以看到，无论是读操作还是写操纵，都是对缓存池进行操作，而不是直接对磁盘进行操纵。**

> **Checkpoint**：数据库在执行检查点（checkpoint）操作时，会将所有脏页写回磁盘，以确保数据的一致性。

#### 缓存池结构

Buffer Pool 是一片连续的内存空间，innodb 存储引擎是通过页的方式对这块内存进行管理的。

缓存池的结构如下图：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226163910072.png" alt="image-20250226163910072" style="zoom:50%;" />

##### 数据页（data page）

***结构***

页是 `InnoDB` 管理存储空间的基本单位，一个页的大小一般是 `16KB`。InnoDB 为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放 Insert Buffer 信息的页，存放 INODE 信息的页，存放 `undo` 日志信息的页等等。

其中，我们日常口中所称的数据记录的页，称为数据页。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226164004502.png" alt="image-20250226164004502" style="zoom:50%;" />

- File Header 文件头部

    - 双链表

    - 针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁

- Page Header 页面头部

    - 专门针对数据页记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀
- Infimum + Supremum 虚拟行记录（最大、最小）
- User Records 用户记录

    - 实际存储的行记录内容
- Free Space 空闲空间
- Page Directory 页面目录

    * 将页中的记录分组，每组最后一条记录的偏移量作为一个 slot 槽，放在 `page directory` 中
* 所以根据主键查找是先二分确定所在槽，然后根据记录中的 `next-record` 遍历，找到记录
- File Trailer 文件尾部

###### **User Records**

在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到 `User Records` 部分。但是在一开始生成页的时候，其实并没有 `User Records` 这个部分，每当我们插入一条记录，都会从 `Free Space` 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 `User Records` 部分，当 `Free Space` 部分的空间全部被 `User Records` 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226164748985.png" alt="image-20250226164748985" style="zoom:80%;" />

为了更好的管理在 `User Records` 中的这些记录，`InnoDB` 可费了一番力气呢。

**`记录头信息`**

我们先创建一个表：

```sql
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)
```

简化后的行格式示意图就是这样：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226164826517.png" alt="image-20250226164826517" style="zoom:90%;" />

下边我们试着向 page_demo 表中插入几条记录：

```sql
mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226164902770.png" alt="image-20250226164902770" style="zoom:110%;" />

我们对照着这个图来看看记录头信息中的各个属性是啥意思：

- `delete_mask`

    - 这个属性标记着当前记录是否被删除
    - 这些被删除的记录不立即从磁盘上移除，因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的 `垃圾链表`，在这个链表中的记录占用的空间称之为所谓的 `可重用空间`，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。
- `min_rec_mask`

    - B+ 树的每层非叶子节点中的最小记录都会添加该标记
    - 我们自己插入的四条记录的 min_rec_mask 值都是 0，意味着它们都不是 B+ 树的非叶子节点中的最小记录
- `n_owned`

    - 表示当前记录拥有的记录数
- `heap_no`

    - 这个属性表示当前记录在本 `页` 中的位置
    - 从图中可以看出来，我们插入的 4 条记录在本页中的位置分别是：`2`、`3`、`4`、`5`。是不是少了点啥？是的，怎么不见 `heap_no` 值为 `0` 和 `1` 的记录呢？

> 不管我们向页中插入了多少自己的记录，InnoDB 定义的两条伪记录分别为 `最小记录` 与 `最大记录`。他们并不存放在页的 `User Records` 部分，他们被单独放在一个称为 `Infimum + Supremum` 的部分

- `record_type`

    - 这个属性表示当前记录的类型，一共有 4 种类型的记录，0 表示普通记录，1 表示 B+ 树非叶节点记录，2 表示最小记录，3 表示最大记录。
    - 从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的 record_type 值都是 0，而最小记录和最大记录的 record_type 值分别为 2 和 3。
- `next_record`

    - 表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量
    - 比方说第一条记录的 next_record 值为 32，意味着从第一条记录的真实数据的地址处向后找 32 个字节便是下一条记录的真实数据

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226165005145.png" alt="image-20250226165005145" style="zoom:80%;" />

* 从图中可以看出来，我们的记录按照主键从小到大的顺序形成了一个单链表。`最大记录` 的 `next_record` 的值为 0，这也就是说最大记录是没有下一条记录了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第 2 条记录删掉：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226165039313.png" alt="image-20250226165039313" style="zoom:80%;" />

从图中可以看出来，删除第 2 条记录前后主要发生了这些变化：

- 第 2 条记录并没有从存储空间中移除，而是把该条记录的 `delete_mask` 值设置为 1。
- 第 2 条记录的 `next_record` 值变为了 0，意味着该记录没有下一条记录了。
- 第 1 条记录的 `next_record` 指向了第 3 条记录。
- 还有一点你可能忽略了，就是最大记录的 n_owned 值从 5 变成了 4。

###### ***Page Directory（页目录）***

现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？

最笨的办法：从 `Infimum记录（最小记录）` 开始，沿着链表一直往后找，总有一天会找到，这样性能太差。

InnoDB 制作了一个类似书的目录：

1. 将所有正常的记录（包括 `最大` 和 `最小记录`，不包括标记为已删除的记录）划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 `n_owned` 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的 `Page Directory`，也就是页目录（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为 `槽`（英文名：`Slot`），所以这个页面目录就是由 `槽` 组成的。

比方说现在的 page_demo 表中正常的记录共有 6 条，InnoDB 会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的 5 条记录，看下边的示意图：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226165127229.png" alt="image-20250226165127229" style="zoom:80%;" />

从这个图中我们需要注意这么几点:

- 现在 `页目录` 部分中有两个槽，也就意味着我们的记录被分成了两个组，`槽1` 中的值是 112，代表最大记录的地址偏移量（就是从页面的 0 字节开始数，数 112 个字节）；`槽0` 中的值是 99，代表最小记录的地址偏移量。
- 注意最小和最大记录的头信息中的 `n_owned` 属性

    - 最小记录的 `n_owned` 值为 1，这就代表着以最小记录结尾的这个分组中只有 1 条记录，也就是最小记录本身。
    - 最大记录的 `n_owned` 值为 5，这就代表着以最大记录结尾的这个分组中只有 5 条记录，包括最大记录本身还有我们自己插入的 4 条记录。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226165504521.png" alt="image-20250226165504521" style="zoom:80%;" />

我们一口气又往表中添加了 12 条记录，现在页里边就一共有 18 条记录了（包括最小和最大记录），这些记录被分成了 5 个组，如图所示：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250226165546949.png" alt="image-20250226165546949" style="zoom:80%;" />

比方说我们想找主键值为 `6` 的记录，过程是这样的：

1. 计算中间槽的位置：`(0+4)/2=2`，所以查看 `槽2` 对应记录的主键值为 `8`，又因为 `8 > 6`，所以设置 `high=2`，`low` 保持不变。
2. 重新计算中间槽的位置：`(0+2)/2=1`，所以查看 `槽1` 对应的主键值为 `4`，又因为 `4 < 6`，所以设置 `low=1`，`high` 保持不变。
3. 因为 `high - low` 的值为 1，所以确定主键值为 `6` 的记录在 `槽2` 对应的组中。此刻我们需要找到 `槽2` 中主键值 `最小的那条记录`，然后沿着单向链表遍历 `槽2` 中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽 2 对应的记录是主键值为 8 的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到 `槽1` 对应的记录（主键值为 `4`），该条记录的下一条记录就是 `槽2` 中主键值最小的记录，该记录的主键值为 `5`。所以我们可以从这条主键值为 `5` 的记录出发，遍历 `槽2` 中的各条记录，直到找到主键值为 `6` 的那条记录即可。由于一个组中包含的记录条数只能是 1~8 条，所以遍历一个组中的记录的代价是很小的。

所以在一个数据页中查找指定主键值的记录的过程分为两步：

1. 通过 `二分法` 确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
2. 通过记录的 `next_record` 属性遍历该槽所在的组中的各个记录。

###### ***Page Header（页面头部）***

`InnoDB` 为了能得到一个 `数据页` 中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分。

###### ***File Header（文件头部）***

上边的 `Page Header` 是专门针对 `数据页` 记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀。我们现在描述的 `File Header` 针对各种类型的 `页` 都通用，也就是说不同类型的页都会以 `File Header` 作为第一个组成部分，它描述了一些针对各种 `页` 都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁。

###### ***File Trailer***

为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），`InnoDB` 在每个页的尾部都加了一个 `File Trailer` 部分，与 `File Header` 类似，都是所有类型的页通用的。

###### ***总结***

1. `InnoDB` 为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做 `数据页`。
2. 一个数据页可以被大致划分为 7 个部分，分别是

    * File Header 文件头部

        * 双链表
        * 针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁
    * Page Header 页面头部

        * 专门针对数据页记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀
    * Infimum + Supremum 虚拟行记录（最大、最小）
    * User Records 用户记录

        * 实际存储的行记录内容
    * Free Space 空闲空间
    * Page Directory 页面目录

        * `InnoDB` 会把页中的记录划分为若干个 `组`，每个组的 `最后一个` 记录的 `地址偏移量` 作为一个 `槽`，存放在 `Page Directory` 中，所以在一个 `页` 中根据 `主键` 查找记录是非常快的，分为两步：

            * 通过二分法确定该记录所在的 `槽`。
            * 通过记录的 `next_record` 属性遍历该槽所在的组中的各个记录。
    * File Trailer 文件尾部，用于检验页是否完整的部分

3. 每个记录的头信息中都有一个 `next_record` 属性，从而使页中的所有记录串联成一个 `单链表`
4. 每个数据页的 `File Header` 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个 `双链表`。
5. 为保证从内存中同步到磁盘的 `页的完整性`，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的 `LSN` 值，如果首部和尾部的校验和和 `LSN` 值校验不成功的话，就说明同步过程出现了问题。

##### 索引缓冲页（Index Page）

专门用来存放载入的索引数据，存储这些数据的缓冲页，则被称之为索引页。随着运行时间的增长，也会将一些非根节点的索引页载入内存中，这是一种对于访问频率较高的索引页，专门推出的优化机制。

##### 锁空间（Lock Space）

锁空间不仅仅只会存储锁结构，还会存储一些并发事务的链表，例如死锁检测时需要的「事务等待链表、锁的信息链表」等。

##### 数据字典（Dict Info）

在 `InnoDB` 引擎中主要存在 `SYS_TABLES`、`SYS_COLUMNS`、`SYS_INDEXES`、`SYS_FIELDS` 这四张系统表，主要是用来维护用户定义的所有表的各种信息，如下：

- SYS_TABLES

    - 这张表中会存储所有引擎为 InnoDB 的表信息。
- SYS_COLUMNS

    - 这张表用来存储所有用户定义的表字段信息。
- SYS_INDEXES

    - 这张表用来存储所有 InnoDB 引擎表的索引信息。
- SYS_FIELDS

    - 这张表用来存储所有索引的定义信息。

这四张表也被称为 `InnoDB` 的内部表，这四张表在载入内存前，位于 `.ibdata` 文件中，在 MySQL 启动时会开始加载，载入内存后就会放入到 `Dict Info` 这块区域，当利用 `show` 语句查询表的结构信息时，就会在字典信息中检索数据。

##### 日志缓冲区（Log Buffer）

`InnoDB` 的缓冲池中，主要存在两个日志缓冲区，即 `undo_log_buffer`、`redo_log_buffer`，分别对应着撤销日志和重做日志。它俩的作用主要是用来提升日志记录的写入速度，因为日志文件在磁盘中，执行 SQL 时直接往磁盘写日志，其效率太低了，因此会先写缓冲区，再由后台线程去刷写日志。

##### 自适应哈希索引（Adaptivity Hash）

哈希算法查找数据的效率非常高，在没有哈希冲突的情况下复杂度为 `O(1)`，而 `B+Tree` 检索数据的效率，取决于树的高度。建立索引时，只能选用一种数据结构来作为索引的底层结构：

- 如果选择哈希结构，虽然效率高，但数据是无序的，因此不方便做排序查询。
- 如果选择 `B+Tree` 结构，虽然有序，但查询的效率会受到树高的影响。

`InnoDB` 实现了一种名为自适应哈希索引的技术，在 MySQL 运行过程中，`InnoDB` 引擎会对表上的索引做监控，如果某些数据经常走索引查询，那 `InnoDB` 就会为其建立一个哈希索引，以此来提升数据检索的效率，并且减少走 `B+Tree` 带来的开销，由于这种哈希索引是运行过程中，`InnoDB` 根据 `B+Tree` 的索引查询次数来建立的，因此被称之为自适应哈希索引。

> `自适应哈希索引` 和 `普通哈希索引` 的区别在哪儿呢？`普通哈希索引` 是在创建索引时将结构声明为 `Hash` 结构，这种索引会以索引字段的整表数据建立哈希，而 `自适应哈希索引` 是根据缓冲池的 `B+树` 构造而来，只会基于热点数据构建，因此建立的速度会非常快，毕竟无需对整表都建立哈希索引。

##### 写入缓冲区（Insert Buffer）

如果要变更的数据页在缓冲区中存在，则会直接修改缓冲区中的数据页，然后标记一下变更过的数据页，但如果要操作的数据页并未被加载到缓冲区，那依旧会走磁盘去操作数据，走磁盘显然会影响性能，因此 `InnoDB` 就创造了一个「`写入缓冲`」。

写入缓冲对于 insert、delete、update 语句都可生效，当一条写入语句执行时，流程如下：

- ① 判断要变更的数据页是否被载入到内存。
- ② 如果内存中有对应的数据页，则直接变更缓冲区中的数据页，完成标记后则直接返回。
- ③ 如果内存中没有对应的数据页，则将要变更的数据放入到「写入缓冲」中，然后返回。

此时会发现，不管内存中是否存在相应的数据页，`InnoDB` 都不会走磁盘写数据，而是直接在内存中完成所有操作，但是要注意：**`并不是所有的写入动作，都可以在内存中完成`**，「写入缓冲」是有 `限制` 的，如下：

- 插入的数据字段不能具备 `唯一约束` 或 `唯一索引`。

为啥呢？因为如果存在唯一字段的表，在插入数据前必须要先判断表中是否存在相同值，一张表的数据不可能全部都载入数据，所以这个判断重复值的工作必须依赖磁盘中的表数据来完成，所以插入具备唯一性的数据时，就必须要走磁盘。

#### InnoDB 缓冲池 管理内存

- 原理

    - Free 链表

        - 统一管理、分配所有未使用的缓冲页
    - Flush 链表

        - 统一管理、刷写所有被标记过的缓冲页（脏页）
    - Lru 链表

        - 统一管理、淘汰所有已使用、未变更过的缓冲页
- 数据转换

    - 当 LRU 链表中的一个数据页发生变更后，会从 LRU 链表转到 Flush 链表
    - 当标记页中的变更数据落盘后，此时标记页又会从 Flush 链表回到 LRU 链表
- 在内存的淘汰机制方面，InnoDB 基于末尾淘汰机制做了两点改善：

    - ① 将 Lru 链表划分为了 young、old 两个分区，用来解决预读失效导致的内存占用问题。
    - ② 引入了 young 区的晋升限制，解决了全表扫描时，young 区的热点数据页被换出的问题。
