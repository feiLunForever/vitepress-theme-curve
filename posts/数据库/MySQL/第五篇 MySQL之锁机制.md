---
title: 第五篇 MySQL之锁机制篇
tags:
  - MySQL
categories:
  - 数据库
date: '2025-05-23'
description: 欢迎使用 Curve 主题，这是你的第一篇文章
articleGPT: 这是一篇初始化文章，旨在告诉用户一些使用说明和须知。
#cover: "/images/logo/logo.webp"

---

# MySQL之锁机制

## MySQL锁分类

- 锁粒度

  - ①表锁

    - 全局锁
      - `LOCK TABLES table_name READ;`
      - `LOCK TABLES table_name WRITE;`
    - 意向锁
      - 当 事务 `A` 想获取某个表的 `表`锁 的时候，需要对该表下的每一行记录进行 [遍历](https://so.csdn.net/so/search?q=遍历&spm=1001.2101.3001.7020)，查看是否有其他事务进行了锁的获取，如果存在排它锁，则需要等待其他事务释放所有锁才能后的表锁。其中的遍历成本大，所以引入了 `意向锁`。
    - 自增锁（ `AUTO-INC` 锁）
      - 自增锁主要负责维护并发事务下自增列的顺序

  - ②行锁

    - 记录锁（`Record` 锁）

      - 锁一条记录

    - 间隙锁（`Gap` 锁）

      - ```sql
        SELECT * FROM `zz_users`;
        +---------+-----------+----------+----------+---------------------+
        | user_id | user_name | user_sex | password | register_time       |
        +---------+-----------+----------+----------+---------------------+
        |       1 | 熊猫      | 女       | 6666     | 2022-08-14 15:22:01 |
        |       2 | 竹子      | 男       | 1234     | 2022-09-14 16:17:44 |
        |       3 | 子竹      | 男       | 4321     | 2022-09-16 07:42:21 |
        |       4 | 猫熊      | 女       | 8888     | 2022-09-27 17:22:59 |
        |       9 | 黑竹      | 男       | 9999     | 2022-09-28 22:31:44 |
        +---------+-----------+----------+----------+---------------------+
        ```

      - 解决幻读

      - select * from  users where id = 6 lock in share mode;

      - 未命中记录时，锁(4,9)，左右开区间

    - 临建锁（`Next-Key` 锁）

      - 锁定的范围是左右开区间，但不包含当前这一条真实数据，只锁间隙区域
      - 间隙锁的升级版，同时具备`记录锁` + `间隙锁`的功能

- 互斥性

  - 共享锁（`S` 锁）
    - `SELECT ... FOR SHARE`
  - 排他锁（`X` 锁）
    - `SELECT ... FOR UPTATE`
  - 共享排他锁（`SX` 锁）

- 操作类型

  - 读锁
  - 写锁

- 思想

  - 乐观锁
  - 悲观锁

## 共享锁与排他锁

共享锁又被称之为`S`锁，它是`Shared Lock`的简称，而排他锁又被称之为`X`锁。

### 共享锁（S）

共享锁的意思很简单，也就是不同事务之间不会排斥，可以同时获取锁并执行。但这里所谓的不会排斥，仅仅只是指不会排斥其他事务来读数据，但其他事务尝试写数据时，就会出现排斥性。

在`MySQL`中，我们可以在`SQL`语句后加上相关的关键字来使用共享锁，语法如下：

```sql
SELECT ... LOCK IN SHARE MODE;
-- MySQL8.0之后也优化了写法，如下：
SELECT ... FOR SHARE;
```

### 排他锁（X）

排他锁并不是只能用于写操作，对于一个读操作，咱们也可以手动的指定为获取排他锁，当一个事务在读数据时，获取了排他锁，那当其他事务来读、写同一数据时，都会被排斥。

```sql
SELECT ... FOR UPTATE;
```

### 共享排他锁（SX）

为何在`MySQL5.7.2`版本中引入这种锁呢？聊它之前需要先理解`SMO`问题：

> 在 `SQL` 执行期间一旦更新操作触发 `B+Tree` 叶子节点分裂，那么就会对整棵 `B+Tree` 加排它锁，这不但阻塞了后续这张表上的所有的更新操作，同时也阻止了所有试图在 `B+Tree` 上的读操作，也就是会导致所有的读写操作都被阻塞，其影响巨大。
>
> 因此，这种大粒度的排它锁成为了 `InnoDB` 支持高并发访问的主要瓶颈，而这也是 `MySQL 5.7` 版本中引入 `SX` 锁要解决的问题。

最简单的方式就是减小 `SMO` 问题发生时，锁定的 `B+Tree` 粒度，当发生 `SMO` 问题时，就只锁定 `B+Tree` 的某个分支，而并不是锁定整颗 `B+` 树，从而做到不影响其他分支上的读写操作。

> `SX `锁的特性，它不会阻塞`S`锁，但是会阻塞`X、SX`锁

首先得搞清楚`SQL`执行时的几个概念：

- 读取操作：基于`B+Tree`去读取某条或多条行记录。
- 乐观写入：不会改变`B+Tree`的索引键，仅会更改索引值，比如主键索引树中不修改主键字段，只修改其他字段的数据，不会引起节点分裂。
- 悲观写入：会改变`B+Tree`的结构，也就是会造成节点分裂，比如无序插入、修改索引键的字段值。

> 在`MySQL5.6`版本中，一旦有操作导致了树结构发生变化，就会对整棵树加上排他锁，阻塞所有的读写操作，而`MySQL5.7`版本中，为了解决该问题，对于不同的`SQL`执行，流程就做了调整。

#### 并发事务冲突分析

对于 **读操作**、**乐观写入** 操作而言，并不会加 `SX` 锁，**共享排他锁** 仅针对于 **悲观写入** 操作会加，由于 **读操作**、**乐观写入** 执行前对整颗树加的是 `S` 锁，因此 **悲观写入** 时加的 `SX` 锁并不会 **阻塞** **乐观写入 **和 **读** 操作，但当另一个事务尝试执行 `SMO` 操作变更树结构时，也需要先对树加上一个 `SX` 锁，这时两个**悲观写入** 的并发事务就会出现冲突，新来的事务会被阻塞。

> 但是要注意：当第一个事务寻找到要修改的节点后，会对其分支加上 `X` 锁，紧接着会释放 `B+Tree` 上的 `SX` 锁，这时另外一个执行 `SMO` 操作的事务就能获取 `SX` 锁啦！

### MySQL锁的释放

在不同的隔离级别中也并不相同，比如在“读未提交”级别中，是`SQL`执行完成后就立马释放锁；而在“可重复读”级别中，是在事务结束后才会释放。

## MySQL 表锁

不同的存储引擎的表锁在使用方式上也有些不同，比如 `InnoDB` 是一个支持多粒度锁的存储引擎，它的锁机制是基于聚簇索引实现的，当`SQL`执行时，如果能在聚簇索引命中数据，则加的是行锁，如无法命中聚簇索引的数据则加的是表锁，比如：

```sql
select * from `zz_users` for update;
```

这条`SQL`就无法命中聚簇索引，此时自然加的就是表级别的排他锁，但是这个表级锁，并不是真正意义上的表锁，是一个“伪表锁”，但作用是相同的，锁了整张表。

而反观 `MyISAM` 引擎，由于它并不支持聚簇索引，所以无法再以 `InnoDB` 的这种形式去对表上锁，因此如若要在 `MyISAM` ·引擎中使用表锁，又需要使用额外的语法，如下：

```sql
-- MyISAM引擎中获取读锁（具备读-读可共享特性）
LOCK TABLES `table_name` READ;

-- MyISAM引擎中获取写锁（具备写-读、写-写排他特性）
LOCK TABLES `table_name` WRITE;

-- 查看目前库中创建过的表锁（in_use>0表示目前正在使用的表锁）
SHOW OPEN TABLES WHERE in_use > 0;

-- 释放已获取到的锁
UNLOCK TABLES;
```

实际上除开最基本的表锁外，还有其他几种表锁，即元数据锁、意向锁、自增锁、全局锁。

### 元数据锁（`Meta Data Lock`）

`Meta Data Lock`元数据锁，也被简称为 `MDL` 锁，这是基于表的元数据加锁。

这个锁主要是用于：**更改表结构时使用**，比如你要向一张表创建/删除一个索引、修改一个字段的名称/数据类型、增加/删除一个表字段等这类情况。

### 意向锁（Intention Lock）

> `InnoDB` 引擎是一种支持多粒度锁的引擎，而意向锁则是 `InnoDB` 中为了支持多粒度的锁，为了兼容行锁、表锁而设计的。

先来看一个例子：

假设一张表中有一千万条数据，现在事务 `T1` 对 `ID=8888888` 的这条数据加了一个行锁，此时来了一个事务 `T2`，想要获取这张表的表级别写锁，是不是得先判断一下表中是否存在其他事务在操作？但因为 `InnoDB` 中有行锁的概念，所以表中任何一行数据上都有可能存在事务加锁操作，为了能精准的知道答案，`MySQL` 就得将整张表的 `1000W` 条数据全部遍历一次，然后逐条查看是否有锁存在，那这个效率自然会非常的低。

而且由于 `MySQL `是支持并发事务的，前面扫描过的行，后面万一又加了行锁怎么办？

> 也正是由于行锁和表锁之间存在兼容性问题，所以意向锁它来了！
>
> 意向锁实际上也是一种特殊的表锁，意向锁其实是一种“挂牌告知”的思想，好比日常生活中的出租车，一般都会有一个牌子，表示它目前是“空车”还是“载客”状态，而意向锁也是这个思想。

比如当事务 `T1 `打算对 `ID=8888888` 这条数据加一个 `行锁` 之前，就会先加一个表级别的 `意向锁`，比如目前 `T1` 要加一个行级别的读锁，就会先添加一个表级别的意向共享锁，如果`T1`要加行级别的写锁，亦是同理。

此时当事务 `T2` 尝试获取一个 `表` 级锁时，就会先看一下表上是否有 `意向锁` ，如果有的话再判断一下与自身是否冲突，比如表上存在一个意向共享锁，目前`T2`要获取的是表级别的读锁，那自然不冲突可以获取。但反之，如果 `T2 `要获取一个表级别的写锁时，就会出现冲突，`T2 `事务则会陷入阻塞，直至 `T1` 释放了锁（事务结束）为止。

### 自增锁（`AUTO-INC Lock`）

- 自增锁主要负责维护并发事务下自增列的顺序
- 三种模式
  - 传统模式
    - 事务 `T1` 获取自增锁插入数据，事务 `T2` 也要插入数据，此时事务 `T2` 只能阻塞等待
    - 同时只允许一条线程执行，性能低
  - 连续模式
    - 插入之前就确定了数据量，所以直接分配范围自增值
  - 交错模式
    - 指通过 `INSERT INTO table_name(id,...) VALUES(1,...),(NULL,...),(3,...)` 这种方式插入，其中一部分指定 ID，一部分不指定
    - 交错预分配
    - 好比给 `T1` 分配{1、3、5、7、9....}，给 `T2` 分配 {2、4、6、8、10....}

### 全局锁

全局锁其实是一种尤为特殊的表锁，其实将它称之为库锁也许更合适，因为全局锁是基于整个数据库来加锁的，加上全局锁之后，整个数据库只能允许读，不允许做任何写操作，一般全局锁是在对整库做数据备份时使用。

```sql
-- 获取全局锁的命令
FLUSH TABLES WITH READ LOCK;

-- 释放全局锁的命令
UNLOCK TABLES;
```

从上述的命令也可以看出，为何将其归纳到表锁范围，因为获取锁以及释放锁的命令都是表锁的命令。

## MySQL行锁

### InnoDB的行锁实现

放眼望去，在 `MySQL`诸多的存储引擎中，仅有 `InnoDB` 引擎支持行锁，这是由于什么原因导致的呢？

> `InnoDB`会将表数据存储在聚簇索引中，每条行数据都会存储在树中的叶子节点上，因此行数据是“分开的”，所以可以对每一条数据上锁，但其他引擎大部分都不支持聚簇索引，表数据都是一起存储在一块的，所以只能基于整个表数据上锁，这也是为什么其他引擎不支持行锁的原因。

### 记录锁（Record Lock）

`Record Lock`记录锁，实际上就是行锁，一行表数据、一条表记录本身就是同一个含义，因此行锁也被称为记录锁。

那如何使用行锁呢？

```sql
-- 获取行级别的 共享锁
select * from `zz_users` where user_id = 1 lock in share mode;

-- 获取行级别的 排他锁
select * from `zz_users` where user_id = 1 for update;
```

如果你的 `SQL` 能命中索引数据，那也就自然加的就是行锁，反之则是表锁。

### 间隙锁（Gap Lock）

间隙锁是对行锁的一种补充，主要是用来解决幻读问题的。

```sql
SELECT * FROM `zz_users`;
+---------+-----------+----------+----------+---------------------+
| user_id | user_name | user_sex | password | register_time       |
+---------+-----------+----------+----------+---------------------+
|       1 | 熊猫      | 女       | 6666     | 2022-08-14 15:22:01 |
|       2 | 竹子      | 男       | 1234     | 2022-09-14 16:17:44 |
|       3 | 子竹      | 男       | 4321     | 2022-09-16 07:42:21 |
|       4 | 猫熊      | 女       | 8888     | 2022-09-27 17:22:59 |
|       9 | 黑竹      | 男       | 9999     | 2022-09-28 22:31:44 |
+---------+-----------+----------+----------+---------------------+
```

上述这张表最后两条数据，`ID`字段之间从`4`跳到了`9`，那么`4 ~ 9`两者之间的范围则被称为“间隙”，而间隙锁则主要锁定的是这块范围。

> 好比拿上述表举例子，现在要将 `ID>3` 的用户密码重置为 `1234`，因此事务 `T1` 先查到了 `ID>3` 的`4、9`两条数据并上锁了，然后开始更改用户密码，但此时事务 `T2` 过来又插入了一条 `ID=6、password=7777` 的数据并提交，等 `T1` 修改完了 `4、9` 两条数据后，此时再次查询 `ID>3 `的数据时，结果发现了 `ID=6` 的这条数据并未被重置密码。

那如何解决呢？这时就用到了 `间隙锁`。此时锁住的就是(3, 4) 、（4,9）和（9，+∞）范围，所以 `ID=6` 的数据就插入不了了。

如果是对一个不存在的数据加锁呢？比如：

```sql
select * from `zz_users` where user_id = 6 lock in share mode;
```

此时锁住的就是(4, 9)范围，左开右开区间。

### 临键锁（Next-Key Lock）

临键锁是间隙锁的`Plus`版本，或者可以说成是一种由记录锁+间隙锁组成的锁：

- 记录锁：锁定的范围是表中具体的一条行数据。
- 间隙锁：锁定的范围是左右开区间，但不包含当前这一条真实数据，只锁间隙区域。
- 临键锁：两者的结合体，加锁后，即锁定左开右闭的区间，也会锁定当前行数据。

那为什么需要临键锁呢？

还是以更新 `ID>3` 为例，`间隙锁`。此时锁住的就是(3, 4) 、（4,9）和（9，+∞）范围，不包含现有记录的，所以 T2 事务仍然可以更新 ID=4 的记录，导致 `不可重复读`。

而临键锁则会锁定 (3, 4]、(4, 9] 和 （9，+∞），左开右闭区间，这样就能解决  `不可重复读`。

## 死锁

### 死锁产生条件

- 互斥
- 请求与保持
- 环路等待
- 不可剥夺

### 避免死锁

- 以固定的顺序访问表和行
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源
- 避免大事务，将大事务拆成多个小事务
- 尽量用主键查询数据

### MySQL中的死锁现象

一句话来概述 死锁：**死锁是指两个或两个以上的线程（或进程）在运行过程中，因为资源竞争而造成相互等待、相互僵持的现象**，一般当程序中出现死锁问题后，若无外力介入，则不会解除“僵持”状态，它们之间会一直相互等待下去，直到天荒地老、海枯石烂~

```sql
-- T1事务：竹子向熊猫转账
UPDATE `zz_account` SET balance = balance - 888 WHERE user_name = "竹子";
UPDATE `zz_account` SET balance = balance + 888 WHERE user_name = "熊猫";

-- T2事务：熊猫向竹子转账
UPDATE `zz_account` SET balance = balance - 666 WHERE user_name = "熊猫";
UPDATE `zz_account` SET balance = balance + 666 WHERE user_name = "竹子";
```

此时就会出现问题，`T1`等待`T2`释放锁、`T2`等待`T1`释放锁，双方各自等待对方释放锁，一直如此僵持下去，最终就引发了死锁问题。

### MySQL中死锁如何解决

- 锁超时机制：事务/线程在等待锁时，超出一定时间后自动放弃等待并返回。
  - 默认的锁超时时间是 `50`s
  - 但实际业务中，`50s` 时间太长了，会导致越来越多的事务阻塞
  - 如果调小等待锁时间参数，会容易误伤友军
- 外力介入打破僵局：第三者介入，将死锁情况中的某个事务/线程强制结束，让其他事务继续执行。

### Mysql是如何发现死锁的呢？

> 死锁检测算法 - wait-for graph

`wait-for graph` 算法被启用后，会要求 MySQL 收集两个信息：

- 锁的信息链表：目前持有每个锁的事务是谁。
- 事务等待链表：阻塞的事务要等待的锁是谁。

套个例子来理解，好比目前库中有 `T1`、`T2`、`T3` 三个事务、有 `X1`、 `X2`、 `X3` 三个锁，事务与锁的关系如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250523181344680.png" alt="image-20250523181344680" style="zoom:95%;" />

此时当T3事务需要阻塞等待获取X1锁时，就会触发一次 `wait-for graph` 算法，流程如下：

- ①先根据 `T3` 要获取的 `X1` 锁，在「锁的信息链表」中找到 `X1` 锁的持有者 `T1` 。
- ②再在「事务等待链表」中查找，看看 `T1` 是否在等待获取其他锁，此时会得知 `T1` 等待 `X2`。
- ③再去「锁的信息链表」中找到 `X2` 锁的持有者 `T2`，再看看 `T2` 是否在阻塞等待获取其他锁。
- ④再在「事务等待链表」中查找 `T2`，发现 `T2` 正在等待获取 `X3` 锁，再找 `X3` 锁的持有者。

经过上述一系列算法过程后，最终会发现 `X3` 锁的持有者为 `T3` ，而本次算法又正是 `T3` 事务触发的，此时又回到了 `T3` 事务，也就代表着产生了“闭环”，因此也可以证明这里出现了死锁现象，所以 MySQL 会强制回滚其中的一个事务，来抵达解除死锁的目的。

> 但出现死锁问题时，MySQL会选择哪个事务回滚呢？
>
> 之前分析过，当一个事务在执行 SQL 更改数据时，都会记录在 `Undo-log` 日志中，`Undo` 量越小的事务，代表它对数据的更改越少，同时回滚的代价最低，因此会选择 `Undo` 量最小的事务回滚（如若两个事务的 `Undo` 量相同，会选择回滚触发死锁的事务）。
