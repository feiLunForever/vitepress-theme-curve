# MySQL之锁机制

## MySQL锁分类

- 锁粒度

  - ①表锁

    - 全局锁
      - `LOCK TABLES table_name READ;`
      - `LOCK TABLES table_name WRITE;`
    - 意向锁
      - 当 事务 `A` 想获取某个表的 `表`锁 的时候，需要对该表下的每一行记录进行 [遍历](https://so.csdn.net/so/search?q=遍历&spm=1001.2101.3001.7020)，查看是否有其他事务进行了锁的获取，如果存在排它锁，则需要等待其他事务释放所有锁才能后的表锁。其中的遍历成本大，所以引入了 `意向锁`。
    - 自增锁（ `AUTO-INC` 锁）
      - 自增锁主要负责维护并发事务下自增列的顺序

  - ②行锁

    - 记录锁（`Record` 锁）

      - 锁一条记录

    - 间隙锁（`Gap` 锁）

      - ```sql
        SELECT * FROM `zz_users`;
        +---------+-----------+----------+----------+---------------------+
        | user_id | user_name | user_sex | password | register_time       |
        +---------+-----------+----------+----------+---------------------+
        |       1 | 熊猫      | 女       | 6666     | 2022-08-14 15:22:01 |
        |       2 | 竹子      | 男       | 1234     | 2022-09-14 16:17:44 |
        |       3 | 子竹      | 男       | 4321     | 2022-09-16 07:42:21 |
        |       4 | 猫熊      | 女       | 8888     | 2022-09-27 17:22:59 |
        |       9 | 黑竹      | 男       | 9999     | 2022-09-28 22:31:44 |
        +---------+-----------+----------+----------+---------------------+
        ```

      - 解决幻读

      - select * from  users where id = 6 lock in share mode;

      - 未命中记录时，锁(4,9)，左右开区间

    - 临建锁（`Next-Key` 锁）

      - 锁定的范围是左右开区间，但不包含当前这一条真实数据，只锁间隙区域
      - 间隙锁的升级版，同时具备`记录锁` + `间隙锁`的功能

- 互斥性

  - 共享锁（`S` 锁）
    - `SELECT ... FOR SHARE`
  - 排他锁（`X` 锁）
    - `SELECT ... FOR UPTATE`
  - 共享排他锁（`SX` 锁）

- 操作类型

  - 读锁
  - 写锁

- 思想

  - 乐观锁
  - 悲观锁

## 共享锁与排他锁

共享锁又被称之为`S`锁，它是`Shared Lock`的简称，而排他锁又被称之为`X`锁。

### 共享锁（S）

共享锁的意思很简单，也就是不同事务之间不会排斥，可以同时获取锁并执行。但这里所谓的不会排斥，仅仅只是指不会排斥其他事务来读数据，但其他事务尝试写数据时，就会出现排斥性。

在`MySQL`中，我们可以在`SQL`语句后加上相关的关键字来使用共享锁，语法如下：

```sql
SELECT ... LOCK IN SHARE MODE;
-- MySQL8.0之后也优化了写法，如下：
SELECT ... FOR SHARE;
```

### 排他锁（X）

排他锁并不是只能用于写操作，对于一个读操作，咱们也可以手动的指定为获取排他锁，当一个事务在读数据时，获取了排他锁，那当其他事务来读、写同一数据时，都会被排斥。

```sql
SELECT ... FOR UPTATE;
```

### 共享排他锁（SX）

为何在`MySQL5.7.2`版本中引入这种锁呢？聊它之前需要先理解`SMO`问题：

> 在 `SQL` 执行期间一旦更新操作触发 `B+Tree` 叶子节点分裂，那么就会对整棵 `B+Tree` 加排它锁，这不但阻塞了后续这张表上的所有的更新操作，同时也阻止了所有试图在 `B+Tree` 上的读操作，也就是会导致所有的读写操作都被阻塞，其影响巨大。
>
> 因此，这种大粒度的排它锁成为了 `InnoDB` 支持高并发访问的主要瓶颈，而这也是 `MySQL 5.7` 版本中引入 `SX` 锁要解决的问题。

最简单的方式就是减小 `SMO` 问题发生时，锁定的 `B+Tree` 粒度，当发生 `SMO` 问题时，就只锁定 `B+Tree` 的某个分支，而并不是锁定整颗 `B+` 树，从而做到不影响其他分支上的读写操作。

> `SX `锁的特性，它不会阻塞`S`锁，但是会阻塞`X、SX`锁

首先得搞清楚`SQL`执行时的几个概念：

- 读取操作：基于`B+Tree`去读取某条或多条行记录。
- 乐观写入：不会改变`B+Tree`的索引键，仅会更改索引值，比如主键索引树中不修改主键字段，只修改其他字段的数据，不会引起节点分裂。
- 悲观写入：会改变`B+Tree`的结构，也就是会造成节点分裂，比如无序插入、修改索引键的字段值。

> 在`MySQL5.6`版本中，一旦有操作导致了树结构发生变化，就会对整棵树加上排他锁，阻塞所有的读写操作，而`MySQL5.7`版本中，为了解决该问题，对于不同的`SQL`执行，流程就做了调整。

#### 并发事务冲突分析

对于 **读操作**、**乐观写入** 操作而言，并不会加 `SX` 锁，**共享排他锁** 仅针对于 **悲观写入** 操作会加，由于 **读操作**、**乐观写入** 执行前对整颗树加的是 `S` 锁，因此 **悲观写入** 时加的 `SX` 锁并不会 **阻塞** **乐观写入 **和 **读** 操作，但当另一个事务尝试执行 `SMO` 操作变更树结构时，也需要先对树加上一个 `SX` 锁，这时两个**悲观写入** 的并发事务就会出现冲突，新来的事务会被阻塞。

> 但是要注意：当第一个事务寻找到要修改的节点后，会对其分支加上 `X` 锁，紧接着会释放 `B+Tree` 上的 `SX` 锁，这时另外一个执行 `SMO` 操作的事务就能获取 `SX` 锁啦！

### MySQL锁的释放

在不同的隔离级别中也并不相同，比如在“读未提交”级别中，是`SQL`执行完成后就立马释放锁；而在“可重复读”级别中，是在事务结束后才会释放。

## MySQL 表锁

不同的存储引擎的表锁在使用方式上也有些不同，比如 `InnoDB` 是一个支持多粒度锁的存储引擎，它的锁机制是基于聚簇索引实现的，当`SQL`执行时，如果能在聚簇索引命中数据，则加的是行锁，如无法命中聚簇索引的数据则加的是表锁，比如：

```sql
select * from `zz_users` for update;
```

这条`SQL`就无法命中聚簇索引，此时自然加的就是表级别的排他锁，但是这个表级锁，并不是真正意义上的表锁，是一个“伪表锁”，但作用是相同的，锁了整张表。

而反观 `MyISAM` 引擎，由于它并不支持聚簇索引，所以无法再以 `InnoDB` 的这种形式去对表上锁，因此如若要在 `MyISAM` ·引擎中使用表锁，又需要使用额外的语法，如下：

```sql
-- MyISAM引擎中获取读锁（具备读-读可共享特性）
LOCK TABLES `table_name` READ;

-- MyISAM引擎中获取写锁（具备写-读、写-写排他特性）
LOCK TABLES `table_name` WRITE;

-- 查看目前库中创建过的表锁（in_use>0表示目前正在使用的表锁）
SHOW OPEN TABLES WHERE in_use > 0;

-- 释放已获取到的锁
UNLOCK TABLES;
```

实际上除开最基本的表锁外，还有其他几种表锁，即元数据锁、意向锁、自增锁、全局锁。

### 元数据锁（`Meta Data Lock`）

`Meta Data Lock`元数据锁，也被简称为 `MDL` 锁，这是基于表的元数据加锁。

这个锁主要是用于：**更改表结构时使用**，比如你要向一张表创建/删除一个索引、修改一个字段的名称/数据类型、增加/删除一个表字段等这类情况。

### 意向锁（Intention Lock）

> `InnoDB` 引擎是一种支持多粒度锁的引擎，而意向锁则是 `InnoDB` 中为了支持多粒度的锁，为了兼容行锁、表锁而设计的。

先来看一个例子：

假设一张表中有一千万条数据，现在事务 `T1` 对 `ID=8888888` 的这条数据加了一个行锁，此时来了一个事务 `T2`，想要获取这张表的表级别写锁，是不是得先判断一下表中是否存在其他事务在操作？但因为 `InnoDB` 中有行锁的概念，所以表中任何一行数据上都有可能存在事务加锁操作，为了能精准的知道答案，`MySQL` 就得将整张表的 `1000W` 条数据全部遍历一次，然后逐条查看是否有锁存在，那这个效率自然会非常的低。

而且由于 `MySQL `是支持并发事务的，前面扫描过的行，后面万一又加了行锁怎么办？

> 也正是由于行锁和表锁之间存在兼容性问题，所以意向锁它来了！
>
> 意向锁实际上也是一种特殊的表锁，意向锁其实是一种“挂牌告知”的思想，好比日常生活中的出租车，一般都会有一个牌子，表示它目前是“空车”还是“载客”状态，而意向锁也是这个思想。

比如当事务 `T1 `打算对 `ID=8888888` 这条数据加一个 `行锁` 之前，就会先加一个表级别的 `意向锁`，比如目前 `T1` 要加一个行级别的读锁，就会先添加一个表级别的意向共享锁，如果`T1`要加行级别的写锁，亦是同理。

此时当事务 `T2` 尝试获取一个 `表` 级锁时，就会先看一下表上是否有 `意向锁` ，如果有的话再判断一下与自身是否冲突，比如表上存在一个意向共享锁，目前`T2`要获取的是表级别的读锁，那自然不冲突可以获取。但反之，如果 `T2 `要获取一个表级别的写锁时，就会出现冲突，`T2 `事务则会陷入阻塞，直至 `T1` 释放了锁（事务结束）为止。

>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。
>
>那么有了「意向锁」,由于在对记录加独占锁前,先会加上表级别的意向独占锁,那么在加「独占表锁」时,直接查该表是否有意向独占锁,如果有就意味着表里已经有记录被加了独占锁,这样就不用去遍历表里的记录。
>
>所以，意向锁的目的是为了 `快速判断表里是否有记录被加锁`。

### 自增锁（`AUTO-INC Lock`）

- 自增锁主要负责维护并发事务下自增列的顺序
- 三种模式
  - 传统模式
    - 事务 `T1` 获取自增锁插入数据，事务 `T2` 也要插入数据，此时事务 `T2` 只能阻塞等待
    - 同时只允许一条线程执行，性能低
  - 连续模式
    - 插入之前就确定了数据量，所以直接分配范围自增值
  - 交错模式
    - 指通过 `INSERT INTO table_name(id,...) VALUES(1,...),(NULL,...),(3,...)` 这种方式插入，其中一部分指定 ID，一部分不指定
    - 交错预分配
    - 好比给 `T1` 分配{1、3、5、7、9....}，给 `T2` 分配 {2、4、6、8、10....}

### 全局锁

全局锁其实是一种尤为特殊的表锁，其实将它称之为库锁也许更合适，因为全局锁是基于整个数据库来加锁的，加上全局锁之后，整个数据库只能允许读，不允许做任何写操作，一般全局锁是在对整库做数据备份时使用。

```sql
-- 获取全局锁的命令
FLUSH TABLES WITH READ LOCK;

-- 释放全局锁的命令
UNLOCK TABLES;
```

从上述的命令也可以看出，为何将其归纳到表锁范围，因为获取锁以及释放锁的命令都是表锁的命令。

## MySQL行锁

### InnoDB的行锁实现

放眼望去，在 `MySQL`诸多的存储引擎中，仅有 `InnoDB` 引擎支持行锁，这是由于什么原因导致的呢？

> `InnoDB`会将表数据存储在聚簇索引中，每条行数据都会存储在树中的叶子节点上，因此行数据是“分开的”，所以可以对每一条数据上锁，但其他引擎大部分都不支持聚簇索引，表数据都是一起存储在一块的，所以只能基于整个表数据上锁，这也是为什么其他引擎不支持行锁的原因。

### 记录锁（Record Lock）

`Record Lock`记录锁，实际上就是行锁，一行表数据、一条表记录本身就是同一个含义，因此行锁也被称为记录锁。

那如何使用行锁呢？

```sql
-- 获取行级别的 共享锁
select * from `zz_users` where user_id = 1 lock in share mode;

-- 获取行级别的 排他锁
select * from `zz_users` where user_id = 1 for update;
```

如果你的 `SQL` 能命中索引数据，那也就自然加的就是行锁，反之则是表锁。

### 间隙锁（Gap Lock）

间隙锁是对行锁的一种补充，主要是用来解决幻读问题的。

```sql
SELECT * FROM `zz_users`;
+---------+-----------+----------+----------+---------------------+
| user_id | user_name | user_sex | password | register_time       |
+---------+-----------+----------+----------+---------------------+
|       1 | 熊猫      | 女       | 6666     | 2022-08-14 15:22:01 |
|       2 | 竹子      | 男       | 1234     | 2022-09-14 16:17:44 |
|       3 | 子竹      | 男       | 4321     | 2022-09-16 07:42:21 |
|       4 | 猫熊      | 女       | 8888     | 2022-09-27 17:22:59 |
|       9 | 黑竹      | 男       | 9999     | 2022-09-28 22:31:44 |
+---------+-----------+----------+----------+---------------------+
```

上述这张表最后两条数据，`ID`字段之间从`4`跳到了`9`，那么`4 ~ 9`两者之间的范围则被称为“间隙”，而间隙锁则主要锁定的是这块范围。

> 好比拿上述表举例子，现在要将 `ID>3` 的用户密码重置为 `1234`，因此事务 `T1` 先查到了 `ID>3` 的`4、9`两条数据并上锁了，然后开始更改用户密码，但此时事务 `T2` 过来又插入了一条 `ID=6、password=7777` 的数据并提交，等 `T1` 修改完了 `4、9` 两条数据后，此时再次查询 `ID>3 `的数据时，结果发现了 `ID=6` 的这条数据并未被重置密码。

那如何解决呢？这时就用到了 `间隙锁`。此时锁住的就是(3, 4) 、（4,9）和（9，+∞）范围，所以 `ID=6` 的数据就插入不了了。

如果是对一个不存在的数据加锁呢？比如：

```sql
select * from `zz_users` where user_id = 6 lock in share mode;
```

此时锁住的就是(4, 9)范围，左开右开区间。

### 临键锁（Next-Key Lock）

临键锁是间隙锁的`Plus`版本，或者可以说成是一种由记录锁+间隙锁组成的锁：

- 记录锁：锁定的范围是表中具体的一条行数据。
- 间隙锁：锁定的范围是左右开区间，但不包含当前这一条真实数据，只锁间隙区域。
- 临键锁：两者的结合体，加锁后，即锁定左开右闭的区间，也会锁定当前行数据。

那为什么需要临键锁呢？

还是以更新 `ID>3` 为例，`间隙锁`。此时锁住的就是(3, 4) 、（4,9）和（9，+∞）范围，不包含现有记录的，所以 T2 事务仍然可以更新 ID=4 的记录，导致 `不可重复读`。

而临键锁则会锁定 (3, 4]、(4, 9] 和 （9，+∞），左开右闭区间，这样就能解决  `不可重复读`。

## MySQL 加行级锁规则

行级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。

**加锁的对象是索引，加锁的基本单位是 next-key lock**，它是由记录锁和间隙锁组合而成的，**next-key lock 是前开后闭区间，而间隙锁是前开后开区间**。

但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。

那到底是什么场景呢？总结一句，**在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁**。

这次会以下面这个表结构来进行实验说明：

```sql
CREATE TABLE `user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(30) COLLATE utf8mb4_unicode_ci NOT NULL,
  `age` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `index_age` (`age`) USING BTREE
) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci; 
```

其中，id 是主键索引（唯一索引），age 是普通索引（非唯一索引），name 是普通的列。

表中的有这些行记录：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/user.png" style="zoom:70%;" />

### 唯一索引等值查询

当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：

*   当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 `next-key lock` 会**退化成「记录锁」**。
*   当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 `next-key lock` 会**退化成「间隙锁」**。

> TIP
>
> 我本篇文章的「唯一索引」是用「主键索引」作为案例说明的，加锁只加在主键索引项上。
>
> 然后，很多同学误以为如果是二级索引的「唯一索引」，加锁也是只加在二级索引项上。
>
> 其实这是不对的，所以这里特此说明下，如果是用二级索引（不管是不是非唯一索引，还是唯一索引）进行锁定读查询的时候，除了会对二级索引项加行级锁（如果是唯一索引的二级索引，加锁规则和主键索引的案例相同），而且还会对查询到的记录的主键索引项上加「记录锁」。
>
> 在文章的「非唯一索引」的案例中，我就是用二级索引作为例子，在后面的章节我有说明，对二级索引进行锁定读查询的时候，因为存在两个索引（二级索引和主键索引），所以两个索引都会加锁。

接下里用两个案例来说明。

#### 1、记录存在的情况

假设事务 A 执行了这条等值查询语句，查询的记录是「存在」于表中的。

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from user where id = 1 for update;
+----+--------+-----+
| id | name   | age |
+----+--------+-----+
|  1 | 路飞   |  19 |
+----+--------+-----+
1 row in set (0.02 sec) 
```

那么，事务 A 会为 id 为 1 的这条记录就会加上 **X 型的记录锁**。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/唯一索引记录锁.drawio.png" style="zoom:80%;" />

接下来，如果有其他事务，对 id 为 1 的记录进行更新或者删除操作的话，这些操作都会被阻塞，因为更新或者删除操作也会对记录加 X 型的记录锁，而 X 锁和 X 锁之间是互斥关系。

通过 `select * from performance_schema.data_locks\G;` 这条语句，查看事务执行 SQL 过程中加了什么锁。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/事务a加锁分析.png" style="zoom:40%;" />

从上图可以看到，共加了两个锁，分别是：

*   表锁：X 类型的意向锁；
*   行锁：X 类型的记录锁；

这里我们重点关注行级锁，图中 LOCK\_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。

通过 LOCK\_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：

*   如果 LOCK\_MODE 为 `X`，说明是 next-key 锁；
*   如果 LOCK\_MODE 为 `X, REC_NOT_GAP`，说明是记录锁；
*   如果 LOCK\_MODE 为 `X, GAP`，说明是间隙锁；

因此，**此时事务 A 在 id = 1 记录的主键索引上加的是记录锁，锁住的范围是 id 为 1 的这条记录**。 这样其他事务就无法对 id 为 1 的这条记录进行更新和删除操作了。

从这里我们也可以得知，**加锁的对象是针对索引**，因为这里查询语句扫描的 B+ 树是聚簇索引树，即主键索引树，所以是对主键索引加锁。将对应记录的主键索引加 记录锁后，就意味着其他事务无法对该记录进行更新和删除操作了。

> 为什么唯一索引等值查询并且查询记录存在的场景下，该记录的索引中的 `next-key lock` 会退化成记录锁？

原因就是在唯一索引等值查询并且查询记录存在的场景下，仅靠记录锁也能避免幻读的问题。

*   由于主键具有唯一性，所以**其他事务插入 id = 1 的时候，会因为主键冲突，导致无法插入 id = 1 的新记录**。这样事务 A 在多次查询 id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。

*   由于对 id = 1 加了记录锁，**其他事务无法删除该记录**，这样事务 A 在多次查询 id = 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。

#### 2、记录不存在的情况

假设事务 A 执行了这条等值查询语句，查询的记录是「不存在」于表中的。

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from user where id = 2 for update;
Empty set (0.03 sec) 
```

通过 `select * from performance_schema.data_locks\G;` 这条语句，查看事务执行 SQL 过程中加了什么锁。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/事务a分析1.png" style="zoom:40%;" />

从上图可以看到，共加了两个锁，分别是：

*   表锁：X 类型的意向锁；
*   行锁：X 类型的间隙锁；

因此，**此时事务 A 在 id = 5 记录的主键索引上加的是间隙锁，锁住的范围是 (1, 5)。** 

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/唯一索引间隙锁.drawio.png" style="zoom:50%;" />

接下来，如果有其他事务插入 id 值为 2、3、4 这一些记录的话，这些插入语句都会发生阻塞。

> 为什么唯一索引等值查询并且查询记录「不存在」的场景下，在索引树找到第一条大于该查询记录的记录后，要将该记录的索引中的 `next-key lock` 会退化成「间隙锁」？

原因就是在唯一索引等值查询并且查询记录不存在的场景下，仅靠间隙锁就能避免幻读的问题。

*   为什么 id = 5 记录上的主键索引的锁不可以是 next-key lock？
    *   如果是 `next-key lock`，就意味着其他事务无法删除 id = 5 这条记录，但是这次的案例是查询 id = 2 的记录，只要保证前后两次查询 id = 2 的结果集相同，就能避免幻读的问题了，所以即使 id =5 被删除，也不会有什么影响，那就没必须加 next-key lock，因此只需要在 id = 5 加间隙锁，避免其他事务插入 id = 2 的新记录就行了。
*   为什么不可以针对不存在的记录加记录锁？
    *   锁是加在 `索引` 上的，而这个场景下查询的记录是不存在的，自然就没办法锁住这条不存在的记录。

### 唯一索引范围查询

`范围查询` 和 `等值查询` 的加锁规则是不同的。

当唯一索引进行范围查询时，**会对每一个扫描到的索引加 `next-key` 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁**：

*   情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 `next-key` 锁会**退化成记录锁**。
*   情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：
    *   当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，**扫描到终止范围查询的记录时，该记录的索引的 `next-key` 锁会退化成间隙锁**，其他扫描到的记录，都是在这些记录的索引上加 `next-key` 锁。
    *   当条件值的记录在表中，如果是「小于」条件的范围查询，**扫描到终止范围查询的记录时，该记录的索引的 `next-key` 锁会退化成间隙锁**，其他扫描到的记录，都是在这些记录的索引上加 `next-key` 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 `next-key` 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 `next-key` 锁。

#### 1、针对「大于或者大于等于」的范围查询

> 实验一：针对「大于」的范围查询的情况。

假设事务 A 执行了这条范围查询语句：

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from user where id > 15 for update;
+----+-----------+-----+
| id | name      | age |
+----+-----------+-----+
| 20 | 香克斯    |  39 |
+----+-----------+-----+
1 row in set (0.01 sec) 
```

事务 A 加锁变化过程如下：

1.  最开始要找的第一行是 id = 20，由于查询该记录不是一个等值查询（不是大于等于条件查询），所以对该主键索引加的是范围为 (15, 20\] 的 next-key 锁；
2.  由于是范围查找，就会继续往后找存在的记录，虽然我们看见表中最后一条记录是 id = 20 的记录，但是实际在 Innodb 存储引擎中，会用一个特殊的记录来标识最后一条记录，该特殊的记录的名字叫 supremum pseudo-record ，所以扫描第二行的时候，也就扫描到了这个特殊记录的时候，会对该主键索引加的是范围为 (20, +∞\] 的 next-key 锁。
3.  停止扫描。

可以得知，事务 A 在主键索引上加了两个 X 型 的 `next-key` 锁：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/唯一索引范围查询大于15.drawio.png" style="zoom:60%;" />



*   在 id = 20 这条记录的主键索引上，加了范围为 (15, 20\] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。
*   在特殊记录（ supremum pseudo-record）的主键索引上，加了范围为 (20, +∞\] 的 next-key 锁，意味着其他事务无法插入 id 值大于 20 的这一些新记录。

我们也可以通过 `select * from performance_schema.data_locks\G;` 这条语句来看看事务 A 加了什么锁。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/范围查询大于.png" style="zoom:50%;" />

从上图中的分析中，也可以得到**事务 A 在主键索引上加了两个 X 型 的next-key 锁：** 

*   在 id = 20 这条记录的主键索引上，加了范围为 (15, 20\] 的 next-key 锁，意味着其他事务即无法更新或者删除 id = 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。
*   在特殊记录（ supremum pseudo-record）的主键索引上，加了范围为 (20, +∞\] 的 next-key 锁，意味着其他事务无法插入 id 值大于 20 的这一些新记录。

> 实验二：针对「大于等于」的范围查询的情况。

假设事务 A 执行了这条范围查询语句：

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from user where id >= 15 for update;
+----+-----------+-----+
| id | name      | age |
+----+-----------+-----+
| 15 | 乌索普    |  20 |
| 20 | 香克斯    |  39 |
+----+-----------+-----+
2 rows in set (0.00 sec) 
```

事务 A 加锁变化过程如下：

1.  最开始要找的第一行是 id = 15，由于查询该记录是一个等值查询（等于 15），所以该主键索引的 next-key 锁会**退化成记录锁**，也就是仅锁住 id = 15 这一行记录。
2.  由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 20，于是对该主键索引加的是范围为 (15, 20\] 的 next-key 锁；
3.  接着扫描到第三行的时候，扫描到了特殊记录（ supremum pseudo-record），于是对该主键索引加的是范围为 (20, +∞\] 的 next-key 锁。
4.  停止扫描。

可以得知，事务 A 在主键索引上加了三个 X 型 的锁，分别是：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/唯一索引范围查询大于等于15.drawio.png" style="zoom:60%;" />

*   在 id = 15 这条记录的主键索引上，加了记录锁，范围是 id = 15 这一行记录；意味着其他事务无法更新或者删除 id = 15 的这一条记录；
*   在 id = 20 这条记录的主键索引上，加了 next-key 锁，范围是 (15, 20\] 。意味着其他事务即无法更新或者删除 id = 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。
*   在特殊记录（ supremum pseudo-record）的主键索引上，加了 next-key 锁，范围是 (20, +∞\] 。意味着其他事务无法插入 id 值大于 20 的这一些新记录。

我们也可以通过 `select * from performance_schema.data_locks\G;` 这条语句来看看事务 A 加了什么锁。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/范围查询大于等于.png" style="zoom:50%;" />

通过前面这个实验，我们证明了：

*   针对「大于等于」条件的唯一索引范围查询的情况下， 如果条件值的记录存在于表中，那么由于查询该条件值的记录是包含一个等值查询的操作，所以该记录的索引中的 `next-key` 锁会**退化成记录锁**。

#### 2、针对「小于或者小于等于」的范围查询

> 实验一：针对「小于」的范围查询时，查询条件值的记录「不存在」表中的情况。

假设事务 A 执行了这条范围查询语句，注意查询条件值的记录（id 为 6）并不存在于表中。

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from user where id < 6 for update;
+----+--------+-----+
| id | name   | age |
+----+--------+-----+
|  1 | 路飞   |  19 |
|  5 | 索隆   |  21 |
+----+--------+-----+
3 rows in set (0.00 sec) 
```

事务 A 加锁变化过程如下：

1.  最开始要找的第一行是 id = 1，于是对该主键索引加的是范围为 (-∞, 1\] 的 `next-key` 锁；
2.  由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，所以对该主键索引加的是范围为 (1, 5\] 的 `next-key` 锁；
3.  由于扫描到的第二行记录（id = 5），满足 id < 6 条件，而且也没有达到终止扫描的条件，接着会继续扫描。
4.  扫描到的第三行是 id = 10，该记录不满足 id < 6 条件的记录，所以 id = 10 这一行记录的锁会**退化成间隙锁**，于是对该主键索引加的是范围为 (5, 10) 的间隙锁。
5.  由于扫描到的第三行记录（id = 10），不满足 id < 6 条件，达到了终止扫描的条件，于是停止扫描。

从上面的分析中，可以得知事务 A 在主键索引上加了三个 X 型的锁：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/唯一索引范围查询小于等于6.drawio.png" style="zoom:60%;" />

*   在 id = 1 这条记录的主键索引上，加了范围为 (-∞, 1\] 的 `next-key` 锁，意味着其他事务即无法更新或者删除 id = 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录。
*   在 id = 5 这条记录的主键索引上，加了范围为 (1, 5\] 的 `next-key` 锁，意味着其他事务即无法更新或者删除 id = 5 的这一条记录，同时也无法插入 id 值为 2、3、4 的这一些新记录。
*   在 id = 10 这条记录的主键索引上，加了范围为 (5, 10) 的间隙锁，意味着其他事务无法插入 id 值为 6、7、8、9 的这一些新记录。

> TIP
>
>  select \*from user where id<6 for update; 为什么id(5,10)要加间隙锁呢？ 不加 也不会发生幻读吧 ？
>
> - 第三个间隙锁是加在id=10 索引上的，这个例子不太好说明，如果是id<7，id=10索引不加间隙锁的话，中途插入一个 6，就发生幻读了

我们也可以通过 `select * from performance_schema.data_locks\G;` 这条语句来看看事务 A 加了什么锁。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/唯一索引范围查询小于6.png" style="zoom:50%;" />

从上图中的分析中，也可以得知事务 A 在主键索引加的三个锁，就是我们前面分析出那三个锁。

虽然这次范围查询的条件是「小于」，但是查询条件值的记录不存在于表中（ id 为 6 的记录不在表中），所以如果事务 A 的范围查询的条件改成 <= 6 的话，加的锁还是和范围查询条件为 < 6 是一样的。 大家自己也验证下这个结论。

因此，**针对「小于或者小于等于」的唯一索引范围查询，如果条件值的记录不在表中，那么不管是「小于」还是「小于等于」的范围查询，扫描到终止范围查询的记录时，该记录中索引的 `next-key` 锁会退化成间隙锁，其他扫描的记录，则是在这些记录的索引上加 `next-key` 锁**。

> 实验二：针对「小于等于」的范围查询时，查询条件值的记录「存在」表中的情况。

假设事务 A 执行了这条范围查询语句，注意查询条件值的记录（id 为 5）存在于表中。

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from user where id <= 5 for update;
+----+--------+-----+
| id | name   | age |
+----+--------+-----+
|  1 | 路飞   |  19 |
|  5 | 索隆   |  21 |
+----+--------+-----+
2 rows in set (0.00 sec) 
```

事务 A 加锁变化过程如下：

1.  最开始要找的第一行是 id = 1，于是对该记录加的是范围为 (-∞, 1\] 的 `next-key` 锁；
2.  由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，于是对该记录加的是范围为 (1, 5\] 的 `next-key` 锁。
3.  由于主键索引具有唯一性，不会存在两个 id = 5 的记录，所以不会再继续扫描，于是停止扫描。

从上面的分析中，可以得到**事务 A 在主键索引上加了 2 个 X 型的锁**：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/唯一索引范围查询小于等于5.drawio-20250603162158604.png" style="zoom:65%;" />

*   在 id = 1 这条记录的主键索引上，加了范围为 (-∞, 1\] 的 `next-key` 锁。意味着其他事务即无法更新或者删除 id = 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录。
*   在 id = 5 这条记录的主键索引上，加了范围为 (1, 5\] 的 `next-key` 锁。意味着其他事务即无法更新或者删除 id = 5 的这一条记录，同时也无法插入 id 值为 2、3、4 的这一些新记录。

我们也可以通过 `select * from performance_schema.data_locks\G;` 这条语句来看看事务 A 加了什么锁。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/范围查询小于等于-20250603162235763.png" style="zoom:50%;" />

从上图中的分析中，可以得到事务 A 在主键索引上加了两个 X 型 `next-key` 锁，分别是：

*   在 id = 1 这条记录的主键索引上，加了范围为 (-∞, 1\] 的 `next-key` 锁；
*   在 id = 5 这条记录的主键索引上，加了范围为(1, 5 \] 的 `next-key` 锁。

> 实验三：再来看针对「小于」的范围查询时，查询条件值的记录「存在」表中的情况。

如果事务 A 的查询语句是小于的范围查询，且查询条件值的记录（id 为 5）存在于表中。

```sql
select * from user where id < 5 for update; 
```

事务 A 加锁变化过程如下：

1.  最开始要找的第一行是 id = 1，于是对该记录加的是范围为 (-∞, 1\] 的 `next-key` 锁；
2.  由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id = 5，该记录是第一条不满足 id < 5 条件的记录，于是**该记录的锁会退化为间隙锁，锁范围是 (1,5)**。
3.  由于找到了第一条不满足 id < 5 条件的记录，于是停止扫描。

可以得知，此时**事务 A 在主键索引上加了两种 X 型锁：** 

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/唯一索引范围查询小于5.drawio.png" style="zoom:60%;" />

*   在 id = 1 这条记录的主键索引上，加了范围为 (-∞, 1\] 的 `next-key` 锁，意味着其他事务即无法更新或者删除 id = 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录。

*   在 id = 5 这条记录的主键索引上，加了范围为 (1,5) 的间隙锁，意味着其他事务无法插入 id 值为 2、3、4 的这一些新记录。

我们也可以通过 `select * from performance_schema.data_locks\G;` 这条语句来看看事务 A 加了什么锁。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/唯一索引范围查询小于.png" style="zoom:50%;" />

从上图中的分析中，可以得到事务 A 在主键索引上加了 **X 型的范围为 (-∞, 1\] 的 `next-key` 锁，和 X 型的范围为 (1, 5) 的间隙锁**。

因此，通过前面这三个实验，可以得知。

在针对「小于或者小于等于」的唯一索引（主键索引）范围查询时，存在这两种情况会将索引的 `next-key` 锁会退化成间隙锁的：

*   当条件值的记录「不在」表中时，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的主键索引中的 `next-key` 锁会**退化成间隙锁**，其他扫描到的记录，都是在这些记录的主键索引上加 `next-key` 锁。
*   当条件值的记录「在」表中时：
    *   如果是「小于」条件的范围查询，扫描到终止范围查询的记录时，该记录的主键索引中的 `next-key` 锁会**退化成间隙锁**，其他扫描到的记录，都是在这些记录的主键索引上，加 `next-key` 锁。
    *   如果是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的主键索引中的 `next-key` 锁「不会」退化成间隙锁，其他扫描到的记录，都是在这些记录的主键索引上加 `next-key` 锁。

### 非唯一索引等值查询

当我们用非唯一索引进行等值查询的时候，**因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁**。

针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：

*   当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是**非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 `next-key` 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 `next-key` 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁**。
*   当查询的记录「不存在」时，**扫描到第一条不符合条件的二级索引记录，该二级索引的 `next-key` 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁**。

接下里用两个实验来说明。

#### 1、记录不存在的情况

> 实验一：针对非唯一索引等值查询时，查询的值不存在的情况。

先来说说非唯一索引等值查询时，查询的记录不存在的情况，因为这个比较简单。

假设事务 A 对非唯一索引（age）进行了等值查询，且表中不存在 age = 25 的记录。

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from user where age = 25 for update;
Empty set (0.00 sec) 
```

事务 A 加锁变化过程如下：

*   定位到第一条不符合查询条件的二级索引记录，即扫描到 age = 39，于是**该二级索引的 `next-key` 锁会退化成间隙锁，范围是 (22, 39)**。
*   停止查询

事务 A 在 age = 39 记录的二级索引上，加了 X 型的间隙锁，范围是 (22, 39)。意味着其他事务无法插入 age 值为 23、24、25、26、....、38 这些新记录。不过对于插入 age = 22 和 age = 39 记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，会在后面说。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/非唯一索引等值查询age=25.drawio.png" style="zoom:60%;" />

我们也可以通过 `select * from performance_schema.data_locks\G;` 这条语句来看看事务 A 加了什么锁。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/非唯一索引等值查询age=25-20250603162623487.png" style="zoom:50%;" />

从上图的分析，可以看到，事务 A 在 age = 39 记录的二级索引上（INDEX\_NAME: index\_age ），加了范围为 (22, 39) 的 X 型间隙锁。

此时，如果有其他事务插入了 age 值为 23、24、25、26、....、38 这些新记录，那么这些插入语句都会发生阻塞。不过对于插入 age = 39 记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，接下来我们就说！

> 当有一个事务持有二级索引的间隙锁 (22, 39) 时，什么情况下，可以让其他事务的插入 age = 22 或者 age = 39 记录的语句成功？又是什么情况下，插入 age = 22 或者 age = 39 记录时的语句会被阻塞？

我们先要清楚，什么情况下插入语句会发生阻塞。

**插入语句在插入一条记录之前，需要先定位到该记录在 B+树 的位置，如果插入的位置的下一条记录的索引上有间隙锁，才会发生阻塞**。

> 在分析二级索引的间隙锁是否可以成功插入记录时，我们要先要知道二级索引树是如何存放记录的？

二级索引树是按照二级索引值（age列）按顺序存放的，在相同的二级索引值情况下， 再按主键 id 的顺序存放。知道了这个前提，我们才能知道执行插入语句的时候，插入的位置的下一条记录是谁。

基于前面的实验，事务 A 是在 age = 39 记录的二级索引上，加了 X 型的间隙锁，范围是 (22, 39)。

插入 age = 22 记录的成功和失败的情况分别如下：

*   当其他事务插入一条 age = 22，id = 3 的记录的时候，在二级索引树上定位到插入的位置，而**该位置的下一条是 id = 10、age = 22 的记录，该记录的二级索引上没有间隙锁，所以这条插入语句可以执行成功**。
*   当其他事务插入一条 age = 22，id = 12 的记录的时候，在二级索引树上定位到插入的位置，而**该位置的下一条是 id = 20、age = 39 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功**。

插入 age = 39 记录的成功和失败的情况分别如下：

*   当其他事务插入一条 age = 39，id = 3 的记录的时候，在二级索引树上定位到插入的位置，而**该位置的下一条是 id = 20、age = 39 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功**。

*   当其他事务插入一条 age = 39，id = 21 的记录的时候，在二级索引树上定位到插入的位置，而**该位置的下一条记录不存在，也就没有间隙锁了，所以这条插入语句可以插入成功**。

所以，**当有一个事务持有二级索引的间隙锁 (22, 39) 时，插入 age = 22 或者 age = 39 记录的语句是否可以执行成功，关键还要考虑插入记录的主键值，因为「二级索引值（age列）+主键值（id列）」才可以确定插入的位置，确定了插入位置后，就要看插入的位置的下一条记录是否有间隙锁，如果有间隙锁，就会发生阻塞，如果没有间隙锁，则可以插入成功**。

知道了这个结论之后，我们再回过头看，非唯一索引等值查询时，查询的记录不存在时，执行`select * from performance_schema.data_locks\G;` 输出的结果。

![](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/行级锁/非唯一索引等值查询age=25_1.png)

在前面分析输出结果的时候，我说的结论是：「_事务 A 在 age = 39 记录的二级索引上（INDEX\_NAME: index\_age ），加了范围为 (22, 39) 的 X 型间隙锁_」。这个结论其实还不够准确，因为只考虑了 LOCK\_DATA 第一个数值（39），没有考虑 LOCK\_DATA 第二个数值（20）。

那 `LOCK_DATA：39，20` 是什么意思？

*   LOCK\_DATA 第一个数值，也就是 39， 它代表的是 age 值。从前面我们也知道了，LOCK\_DATA 第一个数值是 next-key 锁和间隙锁**锁住的范围的右边界值**。
*   LOCK\_DATA 第二个数值，也就是 20， 它代表的是 id 值。

之所以 LOCK\_DATA 要多显示一个数值（ID值），是因为针对「当某个事务持有非唯一索引的 (22, 39) 间隙锁的时候，其他事务是否可以插入 age = 39 新记录」的问题，还需要考虑插入记录的 id 值。而 **LOCK\_DATA 的第二个数值，就是说明在插入 age = 39 新记录时，哪些范围的 id 值是不可以插入的**。

因此， `LOCK_DATA：39，20` + `LOCK_MODE : X, GAP` 的意思是，事务 A 在 age = 39 记录的二级索引上（INDEX\_NAME: index\_age ），加了 age 值范围为 (22, 39) 的 X 型间隙锁，\*\*同时针对其他事务插入 age 值为 39 的新记录时，不允许插入的新记录的 id 值小于 20 \*\*。如果插入的新记录的 id 值大于 20，则可以插入成功。

但是我们无法从`select * from performance_schema.data_locks\G;` 输出的结果分析出「在插入 age =22 新记录时，哪些范围的 id 值是可以插入成功的」，这时候就**得自己画出二级索引的 B+ 树的结构，然后确定插入位置后，看下该位置的下一条记录是否存在间隙锁，如果存在间隙锁，则无法插入成功，如果不存在间隙锁，则可以插入成功**。

#### 2、记录存在的情况

> 实验二：针对非唯一索引等值查询时，查询的值存在的情况。

假设事务 A 对非唯一索引（age）进行了等值查询，且表中存在 age = 22 的记录。

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from user where age = 22 for update;
+----+--------+-----+
| id | name   | age |
+----+--------+-----+
| 10 | 山治   |  22 |
+----+--------+-----+
1 row in set (0.00 sec) 
```

事务 A 加锁变化过程如下：

*   由于不是唯一索引，所以肯定存在值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，最开始要找的第一行是 age = 22，于是对该二级索引记录加上范围为 (21, 22\] 的 `next-key` 锁。同时，因为 age = 22 符合查询条件，于是对 age = 22 的记录的主键索引加上记录锁，即对 id = 10 这一行加记录锁。
*   接着继续扫描，扫描到的第二行是 age = 39，该记录是第一个不符合条件的二级索引记录，所以该二级索引的 next-key 锁会**退化成间隙锁**，范围是 (22, 39)。
*   停止查询。

可以看到，事务 A 对主键索引和二级索引都加了 X 型的锁：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/非唯一索引等值查询存在.drawio.png" style="zoom:65%;" />

*   主键索引：
    *   在 id = 10 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 10 的这一行记录。
*   二级索引（非唯一索引）：
    *   在 age = 22 这条记录的二级索引上，加了范围为 (21, 22\] 的 `next-key` 锁，意味着其他事务无法更新或者删除 age = 22 的这一些新记录，不过对于插入 age = 21 和 age = 22 新记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，会在后面说。
    *   在 age = 39 这条记录的二级索引上，加了范围 (22, 39) 的间隙锁。意味着其他事务无法插入 age 值为 23、24、..... 、38 的这一些新记录。不过对于插入 age = 22 和 age = 39 记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，会在后面说。

我们也可以通过 `select * from performance_schema.data_locks\G;` 这条语句来看看事务 A 加了什么锁。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/非唯一索引等值查询（存在）.png" style="zoom:50%;" />

从上图的分析，可以看到，事务 A 对二级索引（INDEX\_NAME: index\_age ）加了两个 X 型锁，分别是：

*   在 age = 22 这条记录的二级索引上，加了范围为 (21, 22\] 的 `next-key` 锁，意味着其他事务无法更新或者删除 age = 22 的这一些新记录，针对是否可以插入 age = 21 和 age = 22 的新记录，分析如下：
    *   是否可以插入 age = 21 的新记录，还要看插入的新记录的 id 值，**如果插入 age = 21 新记录的 id 值小于 5，那么就可以插入成功**，因为此时插入的位置的下一条记录是 id = 5，age = 21 的记录，该记录的二级索引上没有间隙锁。**如果插入 age = 21 新记录的 id 值大于 5，那么就无法插入成功**，因为此时插入的位置的下一条记录是 id = 10，age = 22 的记录，该记录的二级索引上有间隙锁。
    *   是否可以插入 age = 22 的新记录，还要看插入的新记录的 id 值，从 `LOCK_DATA : 22, 10` 可以得知，其他事务插入 age 值为 22 的新记录时，**如果插入的新记录的 id 值小于 10，那么插入语句会发生阻塞；如果插入的新记录的 id 大于 10，还要看该新记录插入的位置的下一条记录是否有间隙锁，如果没有间隙锁则可以插入成功，如果有间隙锁，则无法插入成功**。
*   在 age = 39 这条记录的二级索引上，加了范围 (22, 39) 的间隙锁。意味着其他事务无法插入 age 值为 23、24、..... 、38 的这一些新记录，针对是否可以插入 age = 22 和 age = 39 的新记录，分析如下：
    *   是否可以插入 age = 22 的新记录，还要看插入的新记录的 id 值，**如果插入 age = 22 新记录的 id 值小于 10，那么插入语句会被阻塞，无法插入**，因为此时插入的位置的下一条记录是 id = 10，age = 22 的记录，该记录的二级索引上有间隙锁（ age = 22 这条记录的二级索引上有 next-key 锁）。**如果插入 age = 22 新记录的 id 值大于 10，也无法插入**，因为此时插入的位置的下一条记录是 id = 20，age = 39 的记录，该记录的二级索引上有间隙锁。
    *   是否可以插入 age = 39 的新记录，还要看插入的新记录的 id 值，从 `LOCK_DATA : 39, 20` 可以得知，其他事务插入 age 值为 39 的新记录时，**如果插入的新记录的 id 值小于 20，那么插入语句会发生阻塞，如果插入的新记录的 id 大于 20，则可以插入成功**。

同时，事务 A 还对主键索引（INDEX\_NAME: PRIMARY ）加了 X 型的记录锁：

*   在 id = 10 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 10 的这一行记录。

> 为什么这个实验案例中，需要在二级索引索引上加范围 (22, 39) 的间隙锁？

要找到这个问题的答案，我们要明白 MySQL 在可重复读的隔离级别场景下，为什么要引入间隙锁？其实**是为了避免幻读现象的发生**。

如果这个实验案例中：

```sql
select * from user where age = 22 for update; 
```

如果事务 A 不在二级索引索引上加范围 (22, 39) 的间隙锁，只在二级索引索引上加范围为 (21, 22\] 的 next-key 锁的话，那么就会有幻读的问题。

前面我也说过，在非唯一索引上加了范围为 (21, 22\] 的 next-key 锁，是无法完全锁住 age = 22 新记录的插入，因为对于是否可以插入 age = 22 的新记录，还要看插入的新记录的 id 值，从 `LOCK_DATA : 22, 10` 可以得知，其他事务插入 age 值为 22 的新记录时，如果插入的新记录的 id 值小于 10，那么插入语句会发生阻塞，**如果插入的新记录的 id 值大于 10，则可以插入成功**。

也就是说，只在二级索引索引（非唯一索引）上加范围为 (21, 22\] 的 next-key 锁，其他事务是有可能插入 age 值为 22 的新记录的（比如插入一个 age = 22，id = 12 的新记录），那么如果事务 A 再一次查询 age = 22 的记录的时候，前后两次查询 age = 22 的结果集就不一样了，这时就发生了幻读的现象。

**那么当在 age = 39 这条记录的二级索引索引上加了范围为 (22, 39) 的间隙锁后，其他事务是无法插入一个 age = 22，id = 12 的新记录，因为当其他事务插入一条 age = 22，id = 12 的新记录的时候，在二级索引树上定位到插入的位置，而该位置的下一条是 id = 20、age = 39 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功，这样就避免幻读现象的发生**。

所以，为了避免幻读现象的发生，就需要在二级索引索引上加范围 (22, 39) 的间隙锁。

### 非唯一索引范围查询

非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于**非唯一索引范围查询，索引的 `next-key lock` 不会有退化为间隙锁和记录锁的情况**，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 `next-key` 锁。

就带大家简单分析一下，事务 A 的这条范围查询语句：

```sql
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from user where age >= 22  for update;
+----+-----------+-----+
| id | name      | age |
+----+-----------+-----+
| 10 | 山治      |  22 |
| 20 | 香克斯    |  39 |
+----+-----------+-----+
2 rows in set (0.01 sec) 
```

事务 A 的加锁变化：

*   最开始要找的第一行是 age = 22，虽然范围查询语句包含等值查询，但是这里不是唯一索引范围查询，所以是不会发生退化锁的现象，因此对该二级索引记录加 `next-key` 锁，范围是 (21, 22\]。同时，对 age = 22 这条记录的主键索引加记录锁，即对 id = 10 这一行记录的主键索引加记录锁。
*   由于是范围查询，接着继续扫描已经存在的二级索引记录。扫面的第二行是 age = 39 的二级索引记录，于是对该二级索引记录加 `next-key` 锁，范围是 (22, 39\]，同时，对 age = 39 这条记录的主键索引加记录锁，即对 id = 20 这一行记录的主键索引加记录锁。
*   虽然我们看见表中最后一条二级索引记录是 age = 39 的记录，但是实际在 Innodb 存储引擎中，会用一个特殊的记录来标识最后一条记录，该特殊的记录的名字叫 supremum pseudo-record ，所以扫描第二行的时候，也就扫描到了这个特殊记录的时候，会对该二级索引记录加的是范围为 (39, +∞\] 的 next-key 锁。
*   停止查询

可以看到，事务 A 对主键索引和二级索引都加了 X 型的锁：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/非唯一索引范围查询age大于等于22.drawio.png" style="zoom:50%;" />

*   主键索引（id 列）：
    *   在 id = 10 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 10 的这一行记录。
    *   在 id = 20 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id = 20 的这一行记录。
*   二级索引（age 列）：
    *   在 age = 22 这条记录的二级索引上，加了范围为 (21, 22\] 的 next-key 锁，意味着其他事务无法更新或者删除 age = 22 的这一些新记录，不过对于是否可以插入 age = 21 和 age = 22 的新记录，还需要看新记录的 id 值，有些情况是可以成功插入的，而一些情况则无法插入，具体哪些情况，我们前面也讲了。
    *   在 age = 39 这条记录的二级索引上，加了范围为 (22, 39\] 的 next-key 锁，意味着其他事务无法更新或者删除 age = 39 的这一些记录，也无法插入 age 值为 23、24、25、...、38 的这一些新记录。不过对于是否可以插入 age = 21 ，还需要看新记录的 id 值，有些情况是可以成功插入的，而一些情况则无法插入，比如新记录（ age=21，id 小 5）都是可以正常插入，而新记录（ age=21，id 大于 5）则是无法正常插入，因为插入位置的下一条记录上是有间隙锁。对于是否可以插入 age =22，不管新记录 age=22 的 id 是什么值都是无法插入的，因为插入位置的下一条记录上都是有间隙锁。
    *   在特殊的记录（supremum pseudo-record）的二级索引上，加了范围为 (39, +∞\] 的 next-key 锁，意味着其他事务无法插入 age 值大于 39 的这些新记录。

> 在 age >= 22 的范围查询中，明明查询 age = 22 的记录存在并且属于等值查询，为什么不会像唯一索引那样，将 age = 22 记录的二级索引上的 next-key 锁退化为记录锁？

因为 age 字段是非唯一索引，不具有唯一性，所以如果只加记录锁（记录锁无法防止插入，只能防止删除或者修改），就会导致其他事务插入一条 age = 22 的记录，这样前后两次查询的结果集就不相同了，出现了幻读现象。

> TIP
>
> 这里的查询条件如果是age <= 22，验证了一下确实都是临键锁，不过感觉age=39那里加一个间隙锁就可以避免幻读了，为什么age=39也要加临键锁额外的把39也锁住了。
>
> - 这里属于能优化，但是 mysql 没有做这方面的优化，具体原因未知，官方文档也没解释，大概率是作者忘记了😂

### 没有加索引的查询

前面的案例，我们的查询语句都有使用索引查询，也就是查询记录的时候，是通过索引扫描的方式查询的，然后对扫描出来的记录进行加锁。

**如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 `next-key` 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞**。

不只是锁定读查询语句不加索引才会导致这种情况，update 和 delete 语句如果查询条件不加索引，那么由于扫描的方式是全表扫描，于是就会对每一条记录的索引上都会加 `next-key` 锁，这样就相当于锁住的全表。

因此，**在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了**，这是挺严重的问题。

### 总结

唯一索引等值查询：

*   当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 n`ext-key lock` 会**退化成「记录锁」**。
*   当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 `next-key lock` 会**退化成「间隙锁」**。

非唯一索引等值查询：

*   当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后**在扫描的过程中，对扫描到的二级索引记录加的是 `next-key` 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 `next-key` 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁**。
*   当查询的记录「不存在」时，**扫描到第一条不符合条件的二级索引记录，该二级索引的 `next-key` 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁**。

非唯一索引和主键索引的范围查询的加锁规则不同之处在于：

*   唯一索引在满足一些条件的时候，索引的 `next-key lock` 退化为间隙锁或者记录锁。
*   非唯一索引范围查询，索引的 `next-key lock` 不会退化为间隙锁和记录锁。

> 其实理解 MySQL 为什么要这样加锁，主要要以避免幻读角度去分析，这样就很容易理解这些加锁的规则了。

还有一件很重要的事情，在线上在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，**如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了**，这是挺严重的问题。

## 死锁

### 死锁产生条件

- 互斥
- 请求与保持
- 环路等待
- 不可剥夺

### 避免死锁

- 以固定的顺序访问表和行
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源
- 避免大事务，将大事务拆成多个小事务
- 尽量用主键查询数据

### MySQL中的死锁现象

一句话来概述 死锁：**死锁是指两个或两个以上的线程（或进程）在运行过程中，因为资源竞争而造成相互等待、相互僵持的现象**，一般当程序中出现死锁问题后，若无外力介入，则不会解除“僵持”状态，它们之间会一直相互等待下去，直到天荒地老、海枯石烂~

#### 更新相互依赖示例

```sql
-- T1事务：竹子向熊猫转账
UPDATE `zz_account` SET balance = balance - 888 WHERE user_name = "竹子";
UPDATE `zz_account` SET balance = balance + 888 WHERE user_name = "熊猫";

-- T2事务：熊猫向竹子转账
UPDATE `zz_account` SET balance = balance - 666 WHERE user_name = "熊猫";
UPDATE `zz_account` SET balance = balance + 666 WHERE user_name = "竹子";
```

此时就会出现问题，`T1` 等待 `T2` 释放锁、`T2 `等待 `T1` 释放锁，双方各自等待对方释放锁，一直如此僵持下去，最终就引发了死锁问题。

> 这个例子太过简单，一般都不会这些写 sql 的，再举个其他例子说明。

#### next_key 依赖示例

我建了一张订单表，其中 id 字段为主键索引，`order_no` 字段普通索引，也就是非唯一索引：

```sql
CREATE TABLE `t_order` (
  `id` int NOT NULL AUTO_INCREMENT,
  `order_no` int DEFAULT NULL,
  `create_date` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `index_order` (`order_no`) USING BTREE
) ENGINE=InnoDB ; 
```

然后，先 `t_order` 表里现在已经有了 6 条记录：

![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/54fc00f9f87a60ab7b5ba92d824a892d.png)

假设这时有两事务，一个事务要插入订单 1007 ，另外一个事务要插入订单 1008，因为需要对订单做幂等性校验，所以两个事务先要查询该订单是否存在，不存在才插入记录，过程如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/90c1e01d0345de639e3426cea0390e80.png" style="zoom:70%;" />

可以看到，两个事务都陷入了等待状态（前提没有打开死锁检测），也就是发生了死锁，因为都在相互等待对方释放锁。

这里在查询记录是否存在的时候，使用了 `select ... for update` 语句，目的为了防止事务执行的过程中，有其他事务插入了记录，而出现幻读的问题。

如果没有使用 `select ... for update` 语句，而使用了单纯的 select 语句，如果是两个订单号一样的请求同时进来，就会出现两个重复的订单，有可能出现幻读，如下图：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/8ae18f10f1a89aac5e93f0e9794e469e.png" style="zoom:70%;" />

事务 A 在执行下面这条语句的时候：

```sql
select id from t_order where order_no = 1007 for update; 
```

我们可以通过 `select * from performance_schema.data_locks\G;` 这条语句，查看事务执行 SQL 过程中加了什么锁。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1cf8614eba3b45b9874dc6204b4d0cd1.png" style="zoom:50%;" />

从上图可以看到，共加了两个锁，分别是：

*   表锁：X 类型的意向锁；
*   行锁：X 类型的next-key 锁（临键锁）

这里我们重点关注行锁，图中 LOCK\_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思，通过 LOCK\_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：

*   如果 LOCK\_MODE 为 `X`，说明是 X 型的 next-key 锁；
*   如果 LOCK\_MODE 为 `X, REC_NOT_GAP`，说明是 X 型的记录锁；
*   如果 LOCK\_MODE 为 `X, GAP`，说明是 X 型的间隙锁；

**因此，此时事务 A 在二级索引（INDEX\_NAME : index\_order）上加的是 X 型的 next-key 锁，锁范围是`(1006, +∞]`**。

next-key 锁的范围 (1006, +∞\]，是怎么确定的？

根据我的经验，如果 LOCK\_MODE 是 next-key 锁或者间隙锁，那么 LOCK\_DATA 就表示锁的范围最右值，此次的事务 A 的 LOCK\_DATA 是 supremum pseudo-record，表示的是 +∞。然后锁范围的最左值是 t\_order 表中最后一个记录的 index\_order 的值，也就是 1006。因此，`next-key` 锁的范围 (1006, +∞\]。

当事务 B 往事务 A `next-key` 锁的范围 (1006, +∞\] 里插入 id = 1008 的记录就会被锁住：

```sql
Insert into t_order (order_no, create_date) values (1008, now()); 
```

因为当我们执行以下插入语句时，会在插入间隙上获取插入意向锁，**而 `插入意向锁` 与 `间隙锁` 是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放 `间隙锁` 之后，才能获取到 `插入意向锁` 。而 `间隙锁` 与 `间隙锁` 之间是兼容的，所以所以两个事务中 `select ... for update` 语句并不会相互影响**。

案例中的事务 A 和事务 B 在执行完后 `select ... for update` 语句后都持有范围为`(1006,+∞]`的 `next-key` 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，导致死锁。

> 为什么 `间隙锁` 与 `间隙锁` 之间是兼容的？

**间隙锁的意义只在于阻止区间被插入**，因此是可以共存的。**一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁**，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁。

> 插入意向锁是什么？

如果说 `间隙锁` 锁住的是一个区间，那么「`插入意向锁`」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。

`插入意向锁` 与 `间隙锁` 的另一个非常重要的差别是：尽管「`插入意向锁`」也属于 `间隙锁`，但两个事务却不能在同一时间内，一个拥有 `间隙锁`，另一个拥有该间隙区间内的 `插入意向锁`（当然，插入意向锁如果不在间隙锁区间内则是可以的）。

另外，我补充一点，插入意向锁的生成时机：

*   每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了 `间隙锁`，如果已加 `间隙锁` ，此时会生成一个 `插入意向锁`，然后锁的状态设置为等待状态
*   （`PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁`），现象就是 Insert 语句会被阻塞。

> 本次案例中，事务 A 和事务 B 在执行完后 for update 语句后都持有范围为 `(1006, +∞]` 的间隙锁，而接下来的插入操作为了获取到 `插入意向锁`，都在等待对方事务的 `间隙锁` 释放，于是就造成了循环等待，满足了死锁的四个条件：互斥、占有且等待、不可强占用、循环等待，因此发生了死锁。

> 为什么需要插入意向锁？

为了**优化并发插入操作的效率，同时与间隙锁（Gap Lock）配合解决幻读问题**。

- **无插入意向锁**：事务A 锁定间隙(10,20) 后，事务B即使想插入id=15（与A无冲突）也会被阻塞。
- **有插入意向锁**：事务A 持有间隙锁时，事务B的插入意向锁被阻塞；若间隙未被锁定，事务B 和 C 可同时在不同位置插入（如id=15 和 id=18）

以表`users`（现有id=1, 5, 10）为例：

1. **事务A** 插入`id=3` → 对间隙 (1,5) 加插入意向锁。

2. **事务B** 插入`id=7` → 对间隙 (5,10) 加插入意向锁。

   → 两者不冲突，并发插入成功

3. **事务C** 执行 `SELECT ... FOR UPDATE WHERE age>80`（锁定间隙） 

   → **事务A / B的插入意向锁被阻塞**，直到事务C释放锁

### MySQL中死锁如何解决

- 锁超时机制：事务/线程在等待锁时，超出一定时间后自动放弃等待并返回。
  - 默认的锁超时时间是 `50`s
  - 但实际业务中，`50s` 时间太长了，会导致越来越多的事务阻塞
  - 如果调小等待锁时间参数，会容易误伤友军
- **开启主动死锁检测。**
  - 主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 `innodb_deadlock_detect` 设置为 on,表示开启这个逻辑,默认就开启。
  - 当检测到死锁后，就会出现下面这个提示：![image-20250603164319993](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250603164319993.png)

- 外力介入打破僵局：第三者介入，将死锁情况中的某个事务/线程强制结束，让其他事务继续执行。

### Mysql是如何发现死锁的呢？

> 死锁检测算法 - wait-for graph

`wait-for graph` 算法被启用后，会要求 MySQL 收集两个信息：

- 锁的信息链表：目前持有每个锁的事务是谁。
- 事务等待链表：阻塞的事务要等待的锁是谁。

套个例子来理解，好比目前库中有 `T1`、`T2`、`T3` 三个事务、有 `X1`、 `X2`、 `X3` 三个锁，事务与锁的关系如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250523181344680.png" alt="image-20250523181344680" style="zoom:95%;" />

此时当T3事务需要阻塞等待获取X1锁时，就会触发一次 `wait-for graph` 算法，流程如下：

- ①先根据 `T3` 要获取的 `X1` 锁，在「锁的信息链表」中找到 `X1` 锁的持有者 `T1` 。
- ②再在「事务等待链表」中查找，看看 `T1` 是否在等待获取其他锁，此时会得知 `T1` 等待 `X2`。
- ③再去「锁的信息链表」中找到 `X2` 锁的持有者 `T2`，再看看 `T2` 是否在阻塞等待获取其他锁。
- ④再在「事务等待链表」中查找 `T2`，发现 `T2` 正在等待获取 `X3` 锁，再找 `X3` 锁的持有者。

经过上述一系列算法过程后，最终会发现 `X3` 锁的持有者为 `T3` ，而本次算法又正是 `T3` 事务触发的，此时又回到了 `T3` 事务，也就代表着产生了“闭环”，因此也可以证明这里出现了死锁现象，所以 MySQL 会强制回滚其中的一个事务，来抵达解除死锁的目的。

> 但出现死锁问题时，MySQL会选择哪个事务回滚呢？
>
> 之前分析过，当一个事务在执行 SQL 更改数据时，都会记录在 `Undo-log` 日志中，`Undo` 量越小的事务，代表它对数据的更改越少，同时回滚的代价最低，因此会选择 `Undo` 量最小的事务回滚（如若两个事务的 `Undo` 量相同，会选择回滚触发死锁的事务）。
