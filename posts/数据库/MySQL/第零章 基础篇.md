# 基础篇

## MyISAM 对比 InnoDB

- MyISAM 只有表锁，InnoDB 表锁，行锁
- MyISAM 不支持事务，InnoDB 支持
- MyISAM 不支持外键，InnoDB 支持
- MyISAM 不支持 MVCC，InnoDB 支持

## sql 执行慢的原因

### 偶尔慢

- flush 刷新脏页

  - redo log 写满了
  - 内存不够
  - mysql 认为系统空闲
  - mysql 正常关闭
- 竞争锁

  - show processlist

### 一直很慢

- sql 慢查询

  - 没有用到索引，考虑索引失效
  - 表数据量太大，考虑分表分库
  - 优化器选错了索引，考虑 force index

## 一颗 b+ 树存储多少条数据

- B+ 树存放的总记录数 = `根节点指针数` * `单个叶子节点记录行数`
- innoDb 页大小默认是 16KB，假设索引字段是 bigint，长度 8 字节，指针是 6 字节，非叶子节点（一页）可以存储 16384 / 14 = 1170 个指针
- 假设一行数据的大小是 1k 字节，16K / 1K = 16，一页是 16 条数据
- 树深=2 时，1170 * 16 = 1.87w 条数据
- 树深=3 时，1170 * 1170 * 16 = 2.2kw 的数据
- 一张 2000w 左右的表，最多 3 次 IO

## cpu 飙升

- top 观察是否是 mysql 导致
- `show processlist` 查看 sql 运行
- 找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大

**如何处理：**

1. kill 掉这些线程 (同时观察 cpu 使用率是否下降)
2. 进行相应的调整 (比如说加索引、改 sql、改内存参数)
3. 重新跑这些 SQL。

**其他情况：**

1. 也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的新 session 连接进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。

## **百万级别或以上的数据如何删除**

关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加，修改，删除，都会产生额外的对索引文件的操作,这些操作需要消耗额外的 IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询 MySQL 官方手册得知删除数据的速度和创建的索引数量是成正比的。

1. 所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）
2. 然后删除其中无用数据（此过程需要不到两分钟）
3. 删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。
4. 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。

## 深度分页，limit 1000000

- 如果 id 是连续的，返回上次查询的最大记录(偏移量)，再往下 limit

```sql
select id，name from employee where id>1000000 limit 10
```

- order by + 索引（id 为索引）

```sql
select id，name from employee order by id limit 1000000，10
```

- 延迟关联（先快速定位需要获取的 id 段，然后再关联）

```sql
SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id = b.id
```

## count(1)、count(*)、count(列)

- count(1) 忽略列，统计行数，不忽略 null
- count(*) 包括列，统计行数，不忽略 null
- count(列) 统计行数，忽略 null

## union、unionAll

- union 两个结果并集，去重，默认排序
- union all 不去重，不排序
- UNION ALL 的效率高于 UNION

## 一条 Sql 的执行顺序

- from< 左表的名字 >
- on join< 条件 >
- where< 条件 >
- group by
- having< 条件 >
- select
- distinct
- order by
- limit

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226163045987.png" alt="image-20250226163045987" style="zoom:40%;" />

## sql 语句执行过程

### 查询 sql

- 执行前

  - 验证用户名，密码等
  - 建立 DB 连接，从连接池中获取连接
  - 查询用户权限表，查看是有有权限
- 开始执行

  - sql 发送给 sql 接口，对 sql 进行 hash 处理
  - sql 接口根据 hash 值检索是否有缓存
  - 缓存未命中，交给解析器，校验 sql 是否正确
  - 优化器制定执行计划
  - 调用存储引擎执行 sql
  - 存储引擎进行 IO 检索数据，返回给 sql 接口
  - sql 接口将结果集处理(剔除列，合并数据)返回

### 写 sql

* 执行前

  * 验证用户名，密码等
  * 建立 DB 连接，从连接池中获取连接
  * 查询用户权限表，查看是有有权限
* 开始执行

  * sql 发送给 sql 接口，对 sql 进行 hash 处理
  * sql 接口根据 hash 值检索是否有缓存，如果有，对应缓存删掉
  * SQL 交给解析器，校验 sql 是否正确
  * 优化器制定执行计划
  * 在执行开始之前，先记录一下 undo-log 日志和 redo-log(prepare 状态)日志
  * 在缓冲区中查找是否存在数据

    * 存在，对缓冲区进行写操作，利用 checkpoint 机制刷盘
    * 不在，调用存储引擎，从磁盘上的数据库文件中读取相应的数据页到缓冲池
  * 写操作完成后，记录 bin-log 日志，同时将 redo-log 日志中的记录改为 commit 状态
  * 将 SQL 执行耗时及操作成功的结果返回给 SQL 接口，再由 SQL 接口返回给客户端

## mysql 架构

### 连接层

- 主要是指数据库连接池，会负责处理所有客户端接入的工作

### 服务层

- SQL 接口

  - 当收到 SQL 语句时，SQL 接口会将其分发给其他组件，然后等待接收执行结果的返回，最后会将其返回给客户端
- 解析器

  - 词法分析、语义分析、语法树生成...这类
- 优化器

  - 生成执行计划
- 缓存区 innodb_buffer_pool

  - 当你对数据库进行写操作时，都会先从缓冲区中查询是否有你要操作的页，如果有，则直接对内存中的数据页进行操作（例如修改、删除等），对缓冲区中的数据操作完成后，会直接给客户端返回成功的信息，然后 MySQL 会在后台利用一种名为 Checkpoint 的机制，将内存中更新的数据刷写到磁盘。

### 存储引擎层

- MySQL 数据库中与磁盘文件打交道的子系统，执行 sql

### 文件系统层

- 日志模块

  - binlog
  - redo-log
  - undo-log
  - slow-log
  - relay-log
  - error-log
- 数据板块

  - 所有数据最终都会落盘（写入到磁盘）

## InnoDb 内存结构

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226163452463.png" alt="image-20250226163452463" style="zoom:80%;" />

注意观察，实际 MySQL 启动后内存结构略显复杂，但大体可分为 `MySQL工作组件`、`线程本地内存`、`MySQL共享内存`、`存储引擎缓冲区` 四大板块。

>  实际上 `MySQL` 内存模型和 `JVM` 类似，`JVM` 内存主要会划分为 `线程共享区` 和 `线程私有区`，而上图中的 `MySQL` 内存区域，左边则是 `线程私有区域`，每条工作线程中都会分配的区域，各线程之间互不影响，而右边的三大板块，则属于 `线程共享区域`，即所有线程都可访问的内存。

### MySQL Server - 工作组件

后续客户端连接时，都需要经过一系列的连接工作，处理 `SQL` 时也需要经过一系列的解析、验证、优化工作，所以 `MySQL` 会在启动时，会先将这些工作组件初始化到内存中，方便后续处理客户端的操作。

### 工作线程的本地内存

工作线程的本地内存区域，也被称之为 `线程私有区`，即 `MySQL` 在创建每条线程时，都会为其分配这些内存。

- `thread_stack`：线程堆栈，主要用于暂时存储运行的 SQL 语句及运算数据，和 Java 虚拟机栈类似。
- `sort_buffer`：排序缓冲区，执行排序 SQL 时，用于存放排序后数据的临时缓冲区。
- `join_buffer`：连接缓冲区，做连表查询时，存放符合连表查询条件的数据临时缓冲区。
- `read_buffer`：顺序读缓冲区，MySQL 磁盘 IO 一次读一页数据，这个是顺序 IO 的数据临时缓冲区。
- `read_rnd_buffer`：随机读缓冲区，当基于无序字段查询数据时，这里存放随机读到的数据。
- `net_buffer`：网络连接缓冲区，这里主要是存放当前线程对应的客户端连接信息。
- `tmp_table`：内存临时表，当 SQL 中用到了临时表时，这里存放临时表的结构及数据。
- `bulk_insert_buffer`：MyISAM 批量插入缓冲区，批量 insert 时，存放临时数据的缓冲区。
- `bin_log_buffer`：bin-log 日志缓冲区，[《日志篇》](https://juejin.cn/post/7157956679932313608#heading-11)提到过的，bin-log 的缓冲区被设计在工作线程的本地内存中。

将这些缓冲区都放在线程本地内存中，还有一点最大的好处：**能够提升多线程并发执行的性能**！这句话怎么理解呢？很简单，如果把上述的各个缓冲区放在共享内存中，然后提供给线程存放执行时的临时数据，因为多线程的缘故，所以同一时刻、同一快内存有可能出现多条线程一起操作，那就会出现线程不安全的问题，想要解决就只能加锁将多线程串行化，这自然会在很大程度上影响性能！因此将这些存临时数据的缓冲区，设计在本地内存中才最合适。

### MySQL 共享内存区

- `Key Buffer`：MyISAM 表的索引缓冲区，提升 MyISAM 表的索引读写速度。
- `Query Cache`：查询缓存区，缓冲 SQL 的查询结果，提升热点 SQL 的数据检索效率。
- `Thread Cache`：线程缓存区，存放工作线程运行期间，一些需要被共享的临时数据。
- `Table Cache`：表数据文件的文件描述符缓存，提升数据表的打开效率。
- `Table Definition Cache`：表结构文件的文件描述符缓存，提升结构表的打开效率。

#### MySQL8.x 为什么移除了查询缓存

很鸡肋，看个例子：

```sql
select * from zz_users where user_id=1;
select * from zz_users where user_id = 1;
```

`MySQL查询缓存` 是以 SQL 的 `哈希值` 来作为 Key 的，上面两条 SQL 虽然一样，但是后面的查询条件有细微差别：`user_id=1`、`user_id = 1`，也就是一条 SQL 有空格，一条没有。由于这一点点细微差异，会导致两条 SQL 计算出的哈希值完全不同，因此无法命中缓存。

### 存储引擎缓冲区(InnoDB Buffer Pool)

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226163747008.png" alt="image-20250226163747008" style="zoom:50%;" />

- `Data Page`：写入缓冲区，主要用来缓冲磁盘的表数据，将写操作转移到内存进行。
- `Index Page`：索引缓冲页，对于所有已创建的索引根节点，都会放入到内存，提升索引效率。
- `Lock Space`：锁空间，主要是存放所有创建出的锁对象，详情可参考[《MySQL 锁机制实现原理》](https://juejin.cn/post/7156111610589741063)。
- `Dict Info`：数据字典，主要用来存储 MySQL-InnoDB 引擎自带的系统表。
- `redo_log_buffer`：redo-log 缓冲区，存放写 SQL 执行时写入的 redo 记录。
- `undo_log_buffer`：undo-log 缓冲区，存放写 SQL 执行时写入的 undo 记录。
- `Adaptivity Hash`：自适应哈希索引，InnoDB 会为热点索引页，创建相应的哈希索引。
- `Insert Buffer`：写入缓冲区，对于 insert 的数据，会先放在这里，然后定期刷写磁盘。
- `Lru List`：内存淘汰页列表，对于整个缓冲池的内存管理列表（后续细聊）。
- `Free List`：空闲内存列表，这里面记录着目前未被使用的内存页。
- `Flush List`：脏页内存列表，这里主要记录未落盘的数据。

#### 缓存池的基本原理

 **「读操作」:**

在数据库中进行读取页的操作，首先把从磁盘读到的页存放在缓存池中，下一次读取相同的页时，首先判断该页是不是在缓存池中。

若在，称该页在缓存池中被命中，则直接读取该页，否则，还是去读取磁盘上的页。

 **「写操作」:**

对于数据库中页的修改操作，首先修改在缓存池中的页，然后在以一定的频率刷新到磁盘，并不是每次页发生改变就刷新回磁盘，而是通过 `checkpoint` 的机制把页刷新回磁盘。

若不在缓存池中，数据库将从磁盘读取需要修改的页到缓存池中。

**可以看到，无论是读操作还是写操纵，都是对缓存池进行操作，而不是直接对磁盘进行操纵。**

> **Checkpoint**：数据库在执行检查点（checkpoint）操作时，会将所有脏页写回磁盘，以确保数据的一致性。

#### 缓存池结构

Buffer Pool 是一片连续的内存空间，innodb 存储引擎是通过页的方式对这块内存进行管理的。

缓存池的结构如下图：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226163910072.png" alt="image-20250226163910072" style="zoom:30%;" />

##### 数据页（data page）

***结构***

页是 `InnoDB` 管理存储空间的基本单位，一个页的大小一般是 `16KB`。InnoDB 为了不同的目的而设计了许多种不同类型的页，比如存放表空间头部信息的页，存放 Insert Buffer 信息的页，存放 INODE 信息的页，存放 `undo` 日志信息的页等等。

其中，我们日常口中所称的数据记录的页，称为数据页。

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226164004502.png" alt="image-20250226164004502" style="zoom:40%;" />

- File Header 文件头部

    - 双链表

    - 针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁

- Page Header 页面头部

  - 专门针对数据页记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀
- Infimum + Supremum 虚拟行记录（最大、最小）
- User Records 用户记录

  - 实际存储的行记录内容
- Free Space 空闲空间
- Page Directory 页面目录

  * 将页中的记录分组，每组最后一条记录的偏移量作为一个 slot 槽，放在 `page directory` 中
* 所以根据主键查找是先二分确定所在槽，然后根据记录中的 `next-record` 遍历，找到记录
- File Trailer 文件尾部

###### **User Records**

在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到 `User Records` 部分。但是在一开始生成页的时候，其实并没有 `User Records` 这个部分，每当我们插入一条记录，都会从 `Free Space` 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 `User Records` 部分，当 `Free Space` 部分的空间全部被 `User Records` 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了，这个过程的图示如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226164748985.png" alt="image-20250226164748985" style="zoom:50%;" />

为了更好的管理在 `User Records` 中的这些记录，`InnoDB` 可费了一番力气呢。

**`记录头信息`**

我们先创建一个表：

```sql
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)
```

简化后的行格式示意图就是这样：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226164826517.png" alt="image-20250226164826517" style="zoom:50%;" />

下边我们试着向 page_demo 表中插入几条记录：

```sql
mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226164902770.png" alt="image-20250226164902770" style="zoom:50%;" />

我们对照着这个图来看看记录头信息中的各个属性是啥意思：

- `delete_mask`

  - 这个属性标记着当前记录是否被删除
  - 这些被删除的记录不立即从磁盘上移除，因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的 `垃圾链表`，在这个链表中的记录占用的空间称之为所谓的 `可重用空间`，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。
- `min_rec_mask`

  - B+ 树的每层非叶子节点中的最小记录都会添加该标记
  - 我们自己插入的四条记录的 min_rec_mask 值都是 0，意味着它们都不是 B+ 树的非叶子节点中的最小记录
- `n_owned`

  - 表示当前记录拥有的记录数
- `heap_no`

  - 这个属性表示当前记录在本 `页` 中的位置
  - 从图中可以看出来，我们插入的 4 条记录在本页中的位置分别是：`2`、`3`、`4`、`5`。是不是少了点啥？是的，怎么不见 `heap_no` 值为 `0` 和 `1` 的记录呢？

> 不管我们向页中插入了多少自己的记录，InnoDB 定义的两条伪记录分别为 `最小记录` 与 `最大记录`。他们并不存放在页的 `User Records` 部分，他们被单独放在一个称为 `Infimum + Supremum` 的部分

- `record_type`

  - 这个属性表示当前记录的类型，一共有 4 种类型的记录，0 表示普通记录，1 表示 B+ 树非叶节点记录，2 表示最小记录，3 表示最大记录。
  - 从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的 record_type 值都是 0，而最小记录和最大记录的 record_type 值分别为 2 和 3。
- `next_record`

  - 表示从当前记录的真实数据到下一条记录的真实数据的地址偏移量
  - 比方说第一条记录的 next_record 值为 32，意味着从第一条记录的真实数据的地址处向后找 32 个字节便是下一条记录的真实数据

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226165005145.png" alt="image-20250226165005145" style="zoom:50%;" />

* 从图中可以看出来，我们的记录按照主键从小到大的顺序形成了一个单链表。`最大记录` 的 `next_record` 的值为 0，这也就是说最大记录是没有下一条记录了，它是这个单链表中的最后一个节点。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第 2 条记录删掉：  

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226165039313.png" alt="image-20250226165039313" style="zoom:50%;" />

从图中可以看出来，删除第 2 条记录前后主要发生了这些变化：

- 第 2 条记录并没有从存储空间中移除，而是把该条记录的 `delete_mask` 值设置为 1。
- 第 2 条记录的 `next_record` 值变为了 0，意味着该记录没有下一条记录了。
- 第 1 条记录的 `next_record` 指向了第 3 条记录。
- 还有一点你可能忽略了，就是最大记录的 n_owned 值从 5 变成了 4。

###### ***Page Directory（页目录）***

现在我们了解了记录在页中按照主键值由小到大顺序串联成一个单链表，那如果我们想根据主键值查找页中的某条记录该咋办呢？

最笨的办法：从 `Infimum记录（最小记录）` 开始，沿着链表一直往后找，总有一天会找到，这样性能太差。

InnoDB 制作了一个类似书的目录：

1. 将所有正常的记录（包括 `最大` 和 `最小记录`，不包括标记为已删除的记录）划分为几个组。
2. 每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的 `n_owned` 属性表示该记录拥有多少条记录，也就是该组内共有几条记录。
3. 将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页的尾部的地方，这个地方就是所谓的 `Page Directory`，也就是页目录（此时应该返回头看看页面各个部分的图）。页面目录中的这些地址偏移量被称为 `槽`（英文名：`Slot`），所以这个页面目录就是由 `槽` 组成的。

比方说现在的 page_demo 表中正常的记录共有 6 条，InnoDB 会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的 5 条记录，看下边的示意图：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226165127229.png" alt="image-20250226165127229" style="zoom:50%;" />

从这个图中我们需要注意这么几点:

- 现在 `页目录` 部分中有两个槽，也就意味着我们的记录被分成了两个组，`槽1` 中的值是 112，代表最大记录的地址偏移量（就是从页面的 0 字节开始数，数 112 个字节）；`槽0` 中的值是 99，代表最小记录的地址偏移量。
- 注意最小和最大记录的头信息中的 `n_owned` 属性

  - 最小记录的 `n_owned` 值为 1，这就代表着以最小记录结尾的这个分组中只有 1 条记录，也就是最小记录本身。
  - 最大记录的 `n_owned` 值为 5，这就代表着以最大记录结尾的这个分组中只有 5 条记录，包括最大记录本身还有我们自己插入的 4 条记录。

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226165504521.png" alt="image-20250226165504521" style="zoom:50%;" />

我们一口气又往表中添加了 12 条记录，现在页里边就一共有 18 条记录了（包括最小和最大记录），这些记录被分成了 5 个组，如图所示：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E7%AF%87.assets/image-20250226165546949.png" alt="image-20250226165546949" style="zoom:50%;" />

比方说我们想找主键值为 `6` 的记录，过程是这样的：

1. 计算中间槽的位置：`(0+4)/2=2`，所以查看 `槽2` 对应记录的主键值为 `8`，又因为 `8 > 6`，所以设置 `high=2`，`low` 保持不变。
2. 重新计算中间槽的位置：`(0+2)/2=1`，所以查看 `槽1` 对应的主键值为 `4`，又因为 `4 < 6`，所以设置 `low=1`，`high` 保持不变。
3. 因为 `high - low` 的值为 1，所以确定主键值为 `6` 的记录在 `槽2` 对应的组中。此刻我们需要找到 `槽2` 中主键值 `最小的那条记录`，然后沿着单向链表遍历 `槽2` 中的记录。但是我们前边又说过，每个槽对应的记录都是该组中主键值最大的记录，这里槽 2 对应的记录是主键值为 8 的记录，怎么定位一个组中最小的记录呢？别忘了各个槽都是挨着的，我们可以很轻易的拿到 `槽1` 对应的记录（主键值为 `4`），该条记录的下一条记录就是 `槽2` 中主键值最小的记录，该记录的主键值为 `5`。所以我们可以从这条主键值为 `5` 的记录出发，遍历 `槽2` 中的各条记录，直到找到主键值为 `6` 的那条记录即可。由于一个组中包含的记录条数只能是 1~8 条，所以遍历一个组中的记录的代价是很小的。

所以在一个数据页中查找指定主键值的记录的过程分为两步：

1. 通过 `二分法` 确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
2. 通过记录的 `next_record` 属性遍历该槽所在的组中的各个记录。

###### ***Page Header（页面头部）***

`InnoDB` 为了能得到一个 `数据页` 中存储的记录的状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中定义了一个叫 Page Header 的部分。

###### ***File Header（文件头部）***

上边的 `Page Header` 是专门针对 `数据页` 记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀。我们现在描述的 `File Header` 针对各种类型的 `页` 都通用，也就是说不同类型的页都会以 `File Header` 作为第一个组成部分，它描述了一些针对各种 `页` 都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁。

###### ***File Trailer***

为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），`InnoDB` 在每个页的尾部都加了一个 `File Trailer` 部分，与 `File Header` 类似，都是所有类型的页通用的。

###### ***总结***

1. `InnoDB` 为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做 `数据页`。
2. 一个数据页可以被大致划分为 7 个部分，分别是

    * File Header 文件头部

      * 双链表
      * 针对各种页都通用的一些信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁
    * Page Header 页面头部

      * 专门针对数据页记录的各种状态信息，比方说页里头有多少个记录了呀，有多少个槽了呀
    * Infimum + Supremum 虚拟行记录（最大、最小）
    * User Records 用户记录

      * 实际存储的行记录内容
    * Free Space 空闲空间
    * Page Directory 页面目录

      * `InnoDB` 会把页中的记录划分为若干个 `组`，每个组的 `最后一个` 记录的 `地址偏移量` 作为一个 `槽`，存放在 `Page Directory` 中，所以在一个 `页` 中根据 `主键` 查找记录是非常快的，分为两步：

        * 通过二分法确定该记录所在的 `槽`。
        * 通过记录的 `next_record` 属性遍历该槽所在的组中的各个记录。
    * File Trailer 文件尾部，用于检验页是否完整的部分

3. 每个记录的头信息中都有一个 `next_record` 属性，从而使页中的所有记录串联成一个 `单链表`
4. 每个数据页的 `File Header` 部分都有上一个和下一个页的编号，所以所有的数据页会组成一个 `双链表`。
5. 为保证从内存中同步到磁盘的 `页的完整性`，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的 `LSN` 值，如果首部和尾部的校验和和 `LSN` 值校验不成功的话，就说明同步过程出现了问题。

##### 索引缓冲页（Index Page）

专门用来存放载入的索引数据，存储这些数据的缓冲页，则被称之为索引页。随着运行时间的增长，也会将一些非根节点的索引页载入内存中，这是一种对于访问频率较高的索引页，专门推出的优化机制。

##### 锁空间（Lock Space）

锁空间不仅仅只会存储锁结构，还会存储一些并发事务的链表，例如死锁检测时需要的「事务等待链表、锁的信息链表」等。

##### 数据字典（Dict Info）

在 `InnoDB` 引擎中主要存在 `SYS_TABLES`、`SYS_COLUMNS`、`SYS_INDEXES`、`SYS_FIELDS` 这四张系统表，主要是用来维护用户定义的所有表的各种信息，如下：

- SYS_TABLES

  - 这张表中会存储所有引擎为 InnoDB 的表信息。
- SYS_COLUMNS

  - 这张表用来存储所有用户定义的表字段信息。
- SYS_INDEXES

  - 这张表用来存储所有 InnoDB 引擎表的索引信息。
- SYS_FIELDS

  - 这张表用来存储所有索引的定义信息。

这四张表也被称为 `InnoDB` 的内部表，这四张表在载入内存前，位于 `.ibdata` 文件中，在 MySQL 启动时会开始加载，载入内存后就会放入到 `Dict Info` 这块区域，当利用 `show` 语句查询表的结构信息时，就会在字典信息中检索数据。

##### 日志缓冲区（Log Buffer）

`InnoDB` 的缓冲池中，主要存在两个日志缓冲区，即 `undo_log_buffer`、`redo_log_buffer`，分别对应着撤销日志和重做日志。它俩的作用主要是用来提升日志记录的写入速度，因为日志文件在磁盘中，执行 SQL 时直接往磁盘写日志，其效率太低了，因此会先写缓冲区，再由后台线程去刷写日志。

##### 自适应哈希索引（Adaptivity Hash）

哈希算法查找数据的效率非常高，在没有哈希冲突的情况下复杂度为 `O(1)`，而 `B+Tree` 检索数据的效率，取决于树的高度。建立索引时，只能选用一种数据结构来作为索引的底层结构：

- 如果选择哈希结构，虽然效率高，但数据是无序的，因此不方便做排序查询。
- 如果选择 `B+Tree` 结构，虽然有序，但查询的效率会受到树高的影响。

`InnoDB` 实现了一种名为自适应哈希索引的技术，在 MySQL 运行过程中，`InnoDB` 引擎会对表上的索引做监控，如果某些数据经常走索引查询，那 `InnoDB` 就会为其建立一个哈希索引，以此来提升数据检索的效率，并且减少走 `B+Tree` 带来的开销，由于这种哈希索引是运行过程中，`InnoDB` 根据 `B+Tree` 的索引查询次数来建立的，因此被称之为自适应哈希索引。

> `自适应哈希索引` 和 `普通哈希索引` 的区别在哪儿呢？`普通哈希索引` 是在创建索引时将结构声明为 `Hash` 结构，这种索引会以索引字段的整表数据建立哈希，而 `自适应哈希索引` 是根据缓冲池的 `B+树` 构造而来，只会基于热点数据构建，因此建立的速度会非常快，毕竟无需对整表都建立哈希索引。

##### 写入缓冲区（Insert Buffer）

如果要变更的数据页在缓冲区中存在，则会直接修改缓冲区中的数据页，然后标记一下变更过的数据页，但如果要操作的数据页并未被加载到缓冲区，那依旧会走磁盘去操作数据，走磁盘显然会影响性能，因此 `InnoDB` 就创造了一个「`写入缓冲`」。

写入缓冲对于 insert、delete、update 语句都可生效，当一条写入语句执行时，流程如下：

- ① 判断要变更的数据页是否被载入到内存。
- ② 如果内存中有对应的数据页，则直接变更缓冲区中的数据页，完成标记后则直接返回。
- ③ 如果内存中没有对应的数据页，则将要变更的数据放入到「写入缓冲」中，然后返回。

此时会发现，不管内存中是否存在相应的数据页，`InnoDB` 都不会走磁盘写数据，而是直接在内存中完成所有操作，但是要注意：**`并不是所有的写入动作，都可以在内存中完成`**，「写入缓冲」是有 `限制` 的，如下：

- 插入的数据字段不能具备 `唯一约束` 或 `唯一索引`。

为啥呢？因为如果存在唯一字段的表，在插入数据前必须要先判断表中是否存在相同值，一张表的数据不可能全部都载入数据，所以这个判断重复值的工作必须依赖磁盘中的表数据来完成，所以插入具备唯一性的数据时，就必须要走磁盘。

#### InnoDB 缓冲池 管理内存

- 原理

  - Free 链表

    - 统一管理、分配所有未使用的缓冲页
  - Flush 链表

    - 统一管理、刷写所有被标记过的缓冲页（脏页）
  - Lru 链表

    - 统一管理、淘汰所有已使用、未变更过的缓冲页
- 数据转换

  - 当 LRU 链表中的一个数据页发生变更后，会从 LRU 链表转到 Flush 链表
  - 当标记页中的变更数据落盘后，此时标记页又会从 Flush 链表回到 LRU 链表
- 在内存的淘汰机制方面，InnoDB 基于末尾淘汰机制做了两点改善：

  - ① 将 Lru 链表划分为了 young、old 两个分区，用来解决预读失效导致的内存占用问题。
  - ② 引入了 young 区的晋升限制，解决了全表扫描时，young 区的热点数据页被换出的问题。