
# 基础篇

## MyISAM 对比 InnoDB

- MyISAM 只有表锁，InnoDB 表锁，行锁
- MyISAM 不支持事务，InnoDB 支持
- MyISAM 不支持外键，InnoDB 支持
- MyISAM 不支持 MVCC，InnoDB 支持

## sql 执行慢的原因

### 偶尔慢

- flush 刷新脏页

  - redo log 写满了
  - 内存不够
  - mysql 认为系统空闲
  - mysql 正常关闭
- 竞争锁

  - show processlist

### 一直很慢

- sql 慢查询

  - 没有用到索引，考虑索引失效
  - 表数据量太大，考虑分表分库
  - 优化器选错了索引，考虑 force index

## 一颗 b+ 树存储多少条数据

- B+ 树存放的总记录数 = `根节点指针数` * `单个叶子节点记录行数`
- innoDb 页大小默认是 16KB，假设索引字段是 bigint，长度 8 字节，指针是 6 字节，非叶子节点（一页）可以存储 16384 / 14 = 1170 个指针
- 假设一行数据的大小是 1k 字节，16K / 1K = 16，一页是 16 条数据
- 树深=2 时，1170 * 16 = 1.87w 条数据
- 树深=3 时，1170 * 1170 * 16 = 2.2kw 的数据
- 一张 2000w 左右的表，最多 3 次 IO

## cpu 飙升

- top 观察是否是 mysql 导致
- `show processlist` 查看 sql 运行
- 找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大

**如何处理：**

1. kill 掉这些线程 (同时观察 cpu 使用率是否下降)
2. 进行相应的调整 (比如说加索引、改 sql、改内存参数)
3. 重新跑这些 SQL。

**其他情况：**

1. 也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的新 session 连接进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。

## **百万级别或以上的数据如何删除**

关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加，修改，删除，都会产生额外的对索引文件的操作,这些操作需要消耗额外的 IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询 MySQL 官方手册得知删除数据的速度和创建的索引数量是成正比的。

1. 所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）
2. 然后删除其中无用数据（此过程需要不到两分钟）
3. 删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。
4. 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。

## 深度分页，limit 1000000

- 如果 id 是连续的，返回上次查询的最大记录(偏移量)，再往下 limit

```sql
select id，name from employee where id>1000000 limit 10
```

- order by + 索引（id 为索引）

```sql
select id，name from employee order by id limit 1000000，10
```

- 延迟关联（先快速定位需要获取的 id 段，然后再关联）

```sql
SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id = b.id
```

## count(1)、count(*)、count(列)

- count(1) 忽略列，统计行数，不忽略 null
- count(*) 包括列，统计行数，不忽略 null
- count(列) 统计行数，忽略 null

### 哪种性能最好

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/af711033aa3423330d3a4bc6baeb9532.png" alt="图片" style="zoom:40%;" />

### count() 是什么？

假设 count() 函数的参数是字段名，如下：

```sql
select count(name) from t_order; 
```

这条语句是统计「 t\_order 表中，name 字段不为 NULL 的记录」有多少个。也就是说，如果某一条记录中的 name 字段的值为 NULL，则就不会被统计进去。

再来假设 count() 函数的参数是数字 1 这个表达式，如下：

```sql
select count(1) from t_order; 
```

这条语句是统计「 t\_order 表中，1 这个表达式不为 NULL 的记录」有多少个。

1 这个表达式就是单纯数字，它永远都不是 NULL，所以上面这条语句，其实是在统计 t\_order 表中有多少个记录。

### count(主键字段) 执行过程是怎样的？

在通过 count 函数统计有多少个记录时，MySQL 的 server 层会维护一个名叫 count 的变量。

server 层会循环向 InnoDB 读取一条记录，如果 count 函数指定的参数不为 NULL，那么就会将变量 count 加 1，直到符合查询的全部记录被读完，就退出循环。最后将 count 变量的值发送给客户端。

InnoDB 是通过 B+ 树来保存记录的，根据索引的类型又分为聚簇索引和二级索引，它们区别在于，聚簇索引的叶子节点存放的是实际数据，而二级索引的叶子节点存放的是主键值，而不是实际数据。

用下面这条语句作为例子：

```sql
//id 为主键值
select count(id) from t_order; 
```

如果表里只有主键索引，没有二级索引时，那么，InnoDB 循环遍历聚簇索引，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。

但是，如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。

这是因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。

### count(1) 执行过程是怎样的？

用下面这条语句作为例子：

```sql
select count(1) from t_order; 
```

如果表里只有主键索引，没有二级索引时。

那么，InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，**但是不会读取记录中的任何字段的值**，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。

可以看到，count(1) 相比 count(主键字段) 少一个步骤，就是不需要读取记录中的字段值，所以通常会说 count(1) 执行效率会比 count(主键字段) 高一点。

但是，如果表里有二级索引时，InnoDB 循环遍历的对象就二级索引了。

### count(\*) 执行过程是怎样的？

看到 `*` 这个字符的时候，是不是大家觉得是读取记录中的所有字段值？

对于 `selete *` 这条语句来说是这个意思，但是在 count(\*) 中并不是这个意思。

**count(`*`) 其实等于 count(`0`)**，也就是说，当你使用 count(`*`) 时，MySQL 会将 `*` 参数转化为参数 0 来处理。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/27b229f049b27898f3a86c7da7e26114.png" style="zoom:60%;" />

所以，**count(\*) 执行过程跟 count(1) 执行过程基本一样的**，性能没有什么差异。

### count(字段) 执行过程是怎样的？

count(字段) 的执行效率相比前面的 count(1)、 count(\*)、 count(主键字段) 执行效率是最差的。

用下面这条语句作为例子：

```sql
// name不是索引，普通字段
select count(name) from t_order; 
```

对于这个查询来说，会采用全表扫描的方式来计数，所以它的执行效率是比较差的。

### 小结

count(1)、 count(\*)、 count(主键字段)在执行的时候，如果表里存在二级索引，优化器就会选择二级索引进行扫描。

所以，如果要执行 count(1)、 count(\*)、 count(主键字段) 时，尽量在数据表上建立二级索引，这样优化器会自动采用 key\_len 最小的二级索引进行扫描，相比于扫描主键索引效率会高一些。

再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。

## union、unionAll

- union 两个结果并集，去重，默认排序
- union all 不去重，不排序
- UNION ALL 的效率高于 UNION

## 一条 Sql 的执行顺序

- from< 左表的名字 >
- on join< 条件 >
- where< 条件 >
- group by
- having< 条件 >
- select
- distinct
- order by
- limit

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/image/image-20250226163045987.png" alt="image-20250226163045987" style="zoom:40%;" />

## 数据库连接池的必要性

众所周知，当要在`Java`中创建一个数据库连接时，首先会去读取配置文件中的连接地址、账号密码等信息，然后根据配置的地址信息，发起网络请求获取数据库连接对象。在这个过程中，由于涉及到了网络请求，那此时必然会先经历`TCP`三次握手的过程，同时获取到连接对象完成`SQL`操作后，又要释放这个数据库连接，此时又需要经历`TCP`四次挥手过程。

> 从上面的描述中可以明显感知出，在Java中创建、关闭数据库连接的过程，过程开销其实比较大，而在程序上线后，又需要频繁进行数据库操作。因此如果每次操作数据库时，都获取新的连接对象，那整个`Java`程序至少会有四分之一的时间内在做`TCP`三次握手/四次挥手工作，这对整个系统造成的后果可想而知....

也正是由于上述原因，因此大名鼎鼎的「数据库连接池」登场了，「数据库连接池」和「线程池」的思想相同，会将数据库连接这种较为珍贵的资源，利用池化技术对这种资源进行维护。也就代表着之后需要进行数据库操作时，不需要自己去建立连接了，而是直接从「数据库连接池」中获取，用完之后再归还给连接池，以此达到复用的效果。

> 当然，连接池中维护的连接对象也不会一直都在，当长时间未进行`SQL`操作时，连接池也会销毁这些连接对象，而后当需要时再次创建，不过何时创建、何时销毁、连接数限制等等这些工作，都交给了连接池去完成，无需开发者自身再去关注。

OK~，回到前面抛出的问题，有了`MySQL`连接池为何还需要在客户端维护一个连接池？

> 对于这个问题，相信大家在心里多少都有点答案了，原因很简单，两者都是利用池化技术去达到复用资源、节省开销、提升性能的目的，只不过针对的方向不同。

`MySQL`的连接池主要是为了实现复用线程的目的，因为每个数据库连接在`MySQL`中都会使用一条线程维护，而每次为客户端分配连接对象时，都需要经历创建线程、分配栈空间....这些繁重的工作，这个过程需要时间，同时资源开销也不小，所以`MySQL`利用池化技术解决了这些问题。

而客户端的连接池，主要是为了实现复用数据库连接的目的，因为每次`SQL`操作都需要经过`TCP`三次握手/四次挥手的过程，过程同样耗时且占用资源，因此也利用池化技术解决了这个问题。

> 其实也可以这样理解，`MySQL`连接池维护的是工作线程，客户端连接池则维护的是网络连接。
