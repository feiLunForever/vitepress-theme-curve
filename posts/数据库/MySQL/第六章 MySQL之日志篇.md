
# MySQL之日志篇

## undo log 回滚日志

> `Undo-log`主要用于实现 事务回滚 和 基于 `Undo` 版本链实现 `MVCC` 机制。

当一条写入类型的 `SQL` 执行时，都会记录 `Undo-log` 日志，会生成相应的反 `SQL` 放入到 `Undo-log` 中：

- 如果是 `insert`，则生成 `delete` 操作
- 如果是 `delete`，则是将 `deleted_bit` 设为 0
- 如果是 `update`，则是将数据改回事务发生前的样子

> 针对 `delete` 操作和 `update` 操作会有一些特殊的处理：
>
> *   `delete` 操作实际上不会立即直接删除，而是将 `delete` 对象打上 `delete` flag，标记为删除，最终的删除操作是 `purge` 线程完成的。
> *   `update` 分为两种情况：`update` 的列是否是主键列。
>     *   如果不是主键列，在 `undo log` 中直接反向记录是如何 `update` 的。即 `update` 是直接进行的。
>     *   如果是主键列，`update` 分两部执行：先删除该行，再插入一行目标行。

## redo log 重做日志

> `Redo-log` 用来实现数据的恢复。

### 作用

> `MySQL`绝大部分引擎都是是基于 `磁盘` 存储数据的，但如若每次读写数据都走 `磁盘` ，其效率必然十分低下，因此 `InnoDB` 引擎在设计时，当 `MySQL` 启动后就会在内存中创建一个 `BufferPool`，运行过程中会将大量操作汇集在内存中进行，比如写入数据时，先写到 `内存` 中，然后由后台线程再刷写到 `磁盘`。

因为数据写到内存后有丢失风险，这明显违背了事务 `ACID` 原则中的持久性，所以 `Redo-log` 的出现就是为了解决该问题。

`Redo-log` 是一种预写式日志，即在向 `内存` 写入数据前，会先写日志，当后续数据未被刷写到磁盘、`MySQL `崩溃时，就可以通过日志来恢复数据，确保所有提交的事务都会被持久化。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/wal.png" style="zoom:50%;" />

### redolog 与 undolog 区别

*   redo log 记录了此次事务「**修改后**」的数据状态，记录的是更新**之后**的值，**主要用于事务崩溃恢复，保证事务的持久性**。
*   undo log 记录了此次事务「**修改前**」的数据状态，记录的是更新**之前**的值，**主要用于事务回滚，保证事务的原子性**。

### Redo-log 两阶段提交

- 事务开始时，会先记录 `undo log`（用于回滚），然后执行 SQL 修改数据到 `BufferPool`，**同时**生成 `redo log`（prepare 状态）
- 遇到 `rollback`，在 `undo log` 中找到撤销 sql 执行，将缓冲区数据还原
- 遇到 `commit`，利用 `checkpoint` 机制 异步刷盘，生成 `bin log`，然后将 `redo log` 改为 `commit` 状态

![image-20250528105933933](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528105933933.png)

### 事务的恢复机制

> 现在再来思考一个问题，有没有这么一种可能呢？也就是当 SQL 执行时，数据还没被刷写到 `磁盘` 中,结果数据库宕机了，那数据是不是就丢了啊？

对于这个问题呢实际上并不需要担心，因为 `redo-log` 是一种预写式日志，会先记录日志再去更新缓冲区中的数据，所以就算缓冲区的数据未被刷写到磁盘，在 MySQL 重启时，依旧可以通过 `redo-log` 日志重新恢复未落盘的数据，从而确保数据的持久化特性。

> 或许又会问：那如果在记录 `redo-log` 日志时， MySQL 芭比Q了咋整？

其实这个问题不必多虑，为啥？推导一下。

首先看看前面的那种情况：**数据被更新到 `缓冲区` 但没刷盘，然后 MySQL 宕机了, MySQL 会通过日志恢复数据。**

这里要注意的是：数据被更新到 `缓冲区` 代表着 SQL 执行成功了，此时客户端会收到 MySQL 返回的写入成功提示，只是没有落盘而言，所以 MySQL 重启后只需要再次落盘即可。

但如果在记录日志的时候 MySQL 宕机了，这代表着 SQL 都没执行成功， SQL没执行成功的话， MySQL也不会向客户端返回任何信息，因为 MySQL 一直没返回执行结果，因此会导致客户端连接超时，而一般客户端都会有超时补偿机制的，比如会超时后重试，如果MySQL做了热备/灾备，这个重试的时间足够 MySQL 重启完成了，因此用户的操作依旧不会丢失（对于超时补偿机制，在各大数据库连接池中是有实现的）。

> 若又有小伙伴纠结：我 MysQL 也没做热备/灾备这类的方案呐，此时咋整呢？

如果是这样的情况，那就只能自认倒霉了，毕竟 MySQL 挂了一直不重启，不仅仅当前的 SQL 会丢失，后续平台上所有的用户操作都会无响应，这属于系统崩溃级别的灾难了,因此只能靠完善系统架构来解决。

`三处崩溃`：

`redo-log` 被设计成了两阶段提交模式，设置成两阶段提交后，整个执行过程有三处崩溃点：

- `redo-log(prepare)`：在写入准备状态的 `redo` 记录时宕机，事务还未提交，不会影响一致性。
- `bin-log`：在写 `bin` 记录时崩溃，重启后会根据 `redo` 记录中的事务 `ID`，回滚前面已写入的数据。
- `redo-log(commit)`：在 `bin-log` 写入成功后，写 `redo(commit)` 记录时崩溃，因为 `bin-log` 中已经写入成功了，所以从机也可以同步数据，因此重启时直接再次提交事务，写入一条 `redo(commit)` 记录即可。

#### 保证数据一致性

此时 MySQL 的崩溃恢复机制会通过 **两阶段提交的协调** 保证数据一致性：

1. **崩溃恢复流程**：
   MySQL 重启后，会扫描 `redo log`，找到所有处于 `prepare` 状态的事务，然后检查对应的 `binlog`：
   - 如果 `binlog` 中存在该事务的完整记录（`XID` 事件），则重放 `redo log` 并将事务标记为 `commit`（视为成功提交）。
   - 如果 `binlog` 中无该事务记录，则回滚事务（用 `undo log` 撤销修改）。
2. **关键设计**：
   - `binlog` 和 `redo log` 通过全局事务 ID (`XID`) 关联，确保两者的记录可以匹配。
   - `binlog` 的写入必须在 `redo log` 状态改为 `commit` 之前完成（通过 `sync_binlog` 参数控制是否强制刷盘）。
   - 只要 `binlog` 完整，即使 `redo log` 未标记为 `commit`，MySQL 仍会提交事务（恢复时补标 `commit`）。如果 `binlog` 不完整，则回滚事务。

### 刷盘策略

简单来说就是刷盘的时机由 `innodb_flush_log_at_trx_commit` 参数来控制：

- 0：有事务提交的情况下，每间隔 `一秒` 时间刷写一次日志到磁盘
- 1：每次 `提交事务` 时，都刷写一次日志到磁盘（性能最差，最安全，默认策略）
- 2： 每当事务提交时，把日志记录放到内核缓冲区，刷写的时机交给 OS 控制（性能最佳）

### Redo-log中为何“多此一举”？

> 再来思考一个问题：既然 `Redo-log` 要写磁盘，那为何不在写日志的时候，直接把数据写到 `磁盘` 里面去呢？

先刷写一次 `Redo-log` 日志到磁盘，后台线程再根据 `Redo-log` 日志把数据落盘，这个动作似乎看起来有些多余对吧？但实际上这样做好处很大：

- ①日志比数据先落入磁盘，因此就算 `MySQL` 崩溃也可以通过日志恢复数据。
- ②写日志时是以 **追加** 形式写到末尾，而写数据时则是计算数据位置，随机插入。

> 写日志的时候，只需要将记录追加到日志文件的尾部即可，这是按顺序写入，但写入表数据时，还需要先先计算数据的位置，比如修改一条数据时，需要先判断这条数据在磁盘文件中的那个位置，找到了位置再写入，这是随机写入，顺序写入的速度会比随机写入快很多很多。

### 日志格式

`Redo-log`的本地磁盘文件个数 默认是两个，因为 `MySQL` 通过来回写这两个文件的形式记录 `Redo-log` 日志，用两个日志文件组成一个“环形”，如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528103731925.png" alt="image-20250528103731925" style="zoom:40%;" />

- `write pos`
  - 记录写到了哪里
- `check point`
  - 记录哪些 Redo-log 记录已经失效（可以被覆盖）

两根指针中间区域，也就是图中的 `红色` 区域，代表是可以写入日志记录的可用空间，而 `蓝色` 区域则表示日志落盘但数据还未落盘的记录。

> 当一个事务写了 `redo-log` 日志、并将数据写入缓冲区后，但数据还未写到本地的表数据文件中，此时这个事务对应的 `redo-log` 记录就为上图中的蓝色，而当一个事务所写的数据也落盘后，对应的 `redo-log` 记录就会变为红色。
>
> 当 `write pos` 指针追上 `check point `指针时，红色区域就会消失，也就代表 `Redo-log` 文件满了，再当 `MySQL` 执行写操作时就会被阻塞，因为无法再写入 `redo-log` 日志了，所以会触发 `checkpoint` 刷盘机制，将 `redo-log` 记录对应的事务数据，全部刷写到磁盘中的表数据文件后，阻塞的写事务才能继续执行。

## binlog 变更日志（二进制日志）

> 作用与 `Redo-log` 类似，主要是记录所有对数据库表结构变更和表数据修改的操作，对于 `select、show` 这类读操作并不会记录。`bin-log `是 `MySQL-Server` 级别的日志，也就是所有引擎都能用的日志，而 `redo-log、undo-log` 都是 `InnoDB` 引擎专享的，无法跨引擎生效。

![image-20250528104636974](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528104636974.png)

这张写 `SQL `的执行流程图，重点观察里面的 第`⑨`步 ，无论当前表使用的是什么引擎，实际上都需要完成记录 `bin-log` 日志这步操作，和之前分析的两种日志相同，`bin-log `也由内存日志缓冲区+本地磁盘文件两部分组成，这也就意味着：写 `bin-log` 日志时，也会先写缓冲区，然后由后台线程去刷盘。

### bin-log的缓冲区

为啥要单独把 `bin-log` 的缓冲区拎出来讲呢？因为它跟 `redo-log、undo-log` 的缓冲区并不同，前面分析的两种日志缓冲区，都位于 `InnoDB` 创建的共享`BufferPool `中，而 `bin_log_buffer` 是位于每条线程中的，关系图如下：

![image-20250528104830871](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528104830871.png)

> 也就是说，`MySQL-Server  `会给每一条工作线程，都分配一个 `bin_log_buffer`，而并不是放在共享缓冲区中，这是为啥呢？因为 `MySQL` 设计时要兼容所有引擎，直接将 `bin-log` 的缓冲区，设计在线程的工作内存中，这样就能够让所有引擎通用，并且不同线程/事务之间，由于写的都是自己工作内存中的 `bin-log `缓冲，因此并发执行时也不会冲突！

### 刷盘机制

`sync_binlog`:

- 0 : 交给 OS 控制 （默认）
- 1： 每次提交 `事务` 都会刷盘
- N (N>1) 的：每次提交事务都 write，但累积 N 个事务后才 fsync。

### 日志文件的格式

`bin-log `的本地日志文件，采用的是追加写的模式，也就是一直向文件末尾写入新的日志记录，当一个日志文件写满后，会创建一个新的 `bin-log` 日志文件，每个日志文件的命名为 `mysql-bin.000001、mysql-bin.000002、mysql-bin.00000x....`，可以通过 `show binary logs;` 命令查看已有的 `bin-log` 日志文件。

在 `bin-log `的本地文件中，其中存储的日志记录共有 `Statment、Row、Mixed` 三种格式：

- `statment`
  - 每一条会修改数据的 sql 都会被记录在 `binlog` 中，如 inserts, updates, deletes
  - 不需要记录每一行的变化，减少了 binlog 日志量
  - 在某些情况下会导致主从数据不一致，比如执行 sysdate()、now()，或者 where 条件变更
- `row`
  - 仅需记录哪条数据被修改
  - 会产生大量的日志
- mixed
  - `Mixed`：这种被称为混合模式，即 `Statment、Row` 的结合版，因为 `Statment` 模式会导致数据出现不一致，而 `Row` 模式数据量又会很大
  - 因 此`Mixed `模式结合了两者的优劣势，对于可以复制的 `SQL` 采用 `Statment` 模式记录，对于无法复制的 `SQL` 采用 `Row` 记录。

### redo log 和 bin log 区别

- ① 生效范围不同，`Redo-log` 是 `InnoDB` 专享的，`Bin-log `是所有引擎通用的。
- ② 写入方式不同，`Redo-log` 是用两个文件循环写，而 `Bin-log` 是不断创建新文件追加写。
- ③ 文件格式不同，`Redo-log ` 中记录的都是变更后的数据，而`Bin-log `会记录变更 `SQL` 语句。
- ④ 使用场景不同，`Redo-log` 主要实现故障情况下的数据恢复，`Bin-log` 则用于数据灾备、同步。
  - `Redo-log` 采用循环写的方式，一边写会一边擦，里面无法得到完整的数据，而 `Bin-log` 是追加写的模式，一般空间够的话，数据都是完整的，用于同步非常方便

## error log

`MySQL` 线上 由于非外在因素（断电、硬件损坏...）导致崩溃时，辅助线上排错的日志。

## slow-log

系统响应缓慢时，用于定位问题 `SQL` 的日志，其中记录了查询时间较长的 `SQL`。

## relay log 中继日志

- 在主从同步的时候使用到，它是一个临时的日志文件，用于存储从 `master` 节点同步过来的 `binlog` 日志内容
- 主要为了区别主库和从库产生的日志

> 既然有了 `binlog` ，为什么还需要 `relay log`？

- **解耦主从复制的两个线程**
  - **I/O 线程**：从主库拉取 `binlog` 事件并写入 `relay log`
  - **SQL 线程**：从 `relay log` 中读取事件并执行，更新从库数据

- **解耦的优势**：
  - **异步处理**：I/O 线程可以持续拉取主库的 `binlog`，即使 SQL 线程执行较慢，也不会阻塞 I/O 线程
  - **故障隔离**：若从库执行失败（如 SQL 错误），只需重放 `relay log`，无需重新请求主库的 `binlog`
