
# MySQL之索引篇

## MySQL的索引分类

### 数据结构层次

`MySQL`索引支持的数据结构如下：

- `B+Tree`类型：`MySQL`中最常用的索引结构，大部分引擎支持，有序。
- `Hash`类型：大部分存储引擎都支持，字段值不重复的情况下查询最快，无序。
- `R-Tree`类型：`MyISAM`引擎支持，也就是空间索引的默认结构类型。
- `T-Tree`类型：`NDB-Cluster`引擎支持，主要用于`MySQL-Cluster`服务中。

### 功能层次

- 普通索引
  - 一个列
- 唯一索引
- 复合索引
  - 多个列
- 前缀索引
  - 字段的前 N 个字符，创建索引
- 。。。

### 存储方式层次

- 聚集索引（主键索引）
  - 叶子节点 -> 索引列和行数据
  - 一张表只能有一个聚簇索引
- 非聚集索引
  - 叶子节点 -> 索引列和主键 id
  - 回表
  - 索引覆盖

## 索引最佳应用

### 各个索引优劣势分析

首先来聊聊索引机制带来的利害关系，有句古话曾说过：**“凡事有利必有弊”**，而`MySQL`的索引机制也不例外，引入索引机制后，能够给数据库带来的优势很明显：

- ①整个数据库中，数据表的查询速度直线提升，数据量越大时效果越明显。
- ②通过创建唯一索引，可以确保数据表中的数据唯一性，无需额外建立唯一约束。
- ③在使用分组和排序时，同样可以显著减少`SQL`查询的分组和排序的时间。
- ④连表查询时，基于主外键字段上建立索引，可以带来十分明显的性能提升。
- ⑤索引默认是`B+Tree`有序结构，基于索引字段做范围查询时，效率会明显提高。
- ⑥从`MySQL`整体架构而言，减少了查询`SQL`的执行时间，提高了数据库整体吞吐量。

看着上面一条又一条的好处，似乎感觉索引好处很大啊，对于这点确实毋庸置疑，但只有好处吗？`No`，同时也会带来一系列弊端，如：

- ①建立索引会生成本地磁盘文件，需要额外的空间存储索引数据，磁盘占用率会变高。
- ②写入数据时，需要额外维护索引结构，增、删、改数据时，都需要额外操作索引。
- ③写入数据时维护索引需要额外的时间开销，执行写`SQL`时效率会降低，性能会下降。

当然，但对数据库整体来说，索引带来的优势会大于劣势。不过也正由于索引存在弊端，因此索引不是越多越好，合理建立索引才是最佳选择。

#### 主键索引存在的陷阱

相信大家数据库的表中，主键一般都是使用自增`ID`，但这是为什么呢？有人可能会回答自增`ID`不会重复，确保了主键唯一性。这样也确实没错，但不会重复的又不仅仅只有自增`ID`，比如我使用随机的`UUID`也不会重复，为何不使用`UUID`呢？这是由于索引存在一个陷阱！

> 众所周知，一张表中大多数情况下，会将主键索引以聚簇的形式存在磁盘中，上篇文章也聊到过，聚簇索引在存储数据时，表数据和索引数据是一起存放的。同时，`MySQL`默认的索引结构是`B+Tree`，也就代表着索引节点的数据是有序的。

此时结合上面给出的一些信息，主键索引是聚簇索引，表数据和索引数据在一块、索引结构是有序的，那再反推前面给出的疑惑，为何不使用`UUID`呢？因为`UUID`是无序的，如果使用`UUID`作为主键，那么每当插入一条新数据，都有可能破坏原本的树结构，如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250303110838016.png" alt="image-20250303110838016" style="zoom:80%;" />

比如上图中的灰色节点，是一条新插入的数据，此时经过计算后，应该排第二个位置，那就代表着后面的三个节点需要移动，然后给灰色节点挪出一个位置存储，从而确保索引的有序性。

因此大家数据表的主键，最好选用带顺序性的值，否则有可能掉入主键索引的“陷阱”中。

#### 联合索引存在的矛盾

为了多条件查询时的效率更高，一般都会同时对多个字段建立联合索引，但之前也聊到过，联合索引存在一个致命的问题，比如在用户表中，通过`id、name、age`三个字段建立一个联合索引，此时来了一条查询`SQL`，如下：

```sql
SELECT * FROM `zz_user` WHERE name = "竹子" AND age = "18";
```

而这条`SQL`语句是无法使用联合索引的，为什么呢？因为查询条件中，未包含联合索引的第一个字段，想要使用联合索引，那么查询条件中必须包含索引的第一个字段，如下：

```sql
SELECT * FROM `zz_user` WHERE name = "竹子" AND id = 6;
```

上面这条`SQL`才是能命中多列索引的语句，因此在建立索引时也需要考虑这个问题，确保建立出的联合索引能够命中率够高。

#### 前缀索引存在的弊端

前缀索引的特点是短小精悍，我们可以利用一个字段的前`N`个字符创建索引，以这种形式创建的索引也被称之为前缀索引，相较于使用一个完整字段创建索引，前缀索引能够更加节省存储空间，当数据越多时，带来的优势越明显。

> 不过前缀索引虽然带来了节省空间的好处，但也正由于其索引节点中，未存储一个字段的完整值，所以`MySQL`也无法通过前缀索引来完成`ORDER BY、GROUP BY`等分组排序工作，同时也无法完成覆盖扫描等操作。

#### 唯一索引存在的快慢问题

唯一索引有个很大的好处，就是查询数据时会比普通索引效率更高，因为基于普通索引的字段查询数据，例如：

```sql
sql

 代码解读
复制代码SELECT * FROM TABLE_XX WHERE COLUMN_XX = "XX";
```

假设`COLUMN_XX`字段上建立了一个普通索引，此时基于这个字段查询数据时，当查询到一条`COLUMN_XX = "XX"`的数据后，此时会继续走完整个索引树，因为可能会存在多条字段值相同的数据。

> 但如果`COLUMN_XX`字段上建立的是唯一索引，当找到一条数据后就会立马停下检索，因此本身建立唯一索引的字段值就具备唯一性。

因此唯一索引查询数据时，会比普通索引快上一截，但插入数据时就不同了，因为要确保数据不重复，所以插入前会检查一遍表中是否存在相同的数据。但普通索引则不需要考虑这个问题，因此普通索引的数据插入会快一些。

#### 哈希索引的致命问题

要比起查询速度，哈希索引绝对是`MySQL`中当之无愧的魁首！因为采用哈希结构的索引，会以哈希表的形式存储索引字段值，当基于该字段查询数据时，只需要经过一次哈希计算就可获取到数据。

> 但哈希结构的致命问题在于无序，也就是无法基于哈希索引的字段做排序、分组等工作。

因此如果你确定一个表中，不会做排序这类的工作，那可以适当选用哈希结构作为索引的数据结构，它会给你带来意想不到的性能收益~

### 建立索引时需要遵守的原则

下面我们就一起来看看建立索引时，需要遵守的一些原则：

- ①经常频繁用作查询条件的字段应酌情考虑为其创建索引。
- ②表的主外键或连表字段，必须建立索引，因为能很大程度提升连表查询的性能。
- ③建立索引的字段，一般值的区分性要足够高，这样才能提高索引的检索效率。
- ④建立索引的字段，值不应该过长，如果较长的字段要建立索引，可以选择前缀索引。
- ⑤建立联合索引，应当遵循最左前缀原则，将多个字段之间按优先级顺序组合。
- ⑥经常根据范围取值、排序、分组的字段应建立索引，因为索引有序，能加快排序时间。
- ⑦对于唯一索引，如果确认不会利用该字段排序，那可以将结构改为`Hash`结构。
- ⑧尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。

同时，除开上述一些建立索引的原则外，在建立索引时还需有些注意点：

- ❶值经常会增删改的字段，不合适建立索引，因为每次改变后需维护索引结构。
- ❷一个字段存在大量的重复值时，不适合建立索引，比如之前举例的性别字段。
- ❸索引不能参与计算，因此经常带函数查询的字段，并不适合建立索引。
- ❹一张表中的索引数量并不是越多越好，一般控制在`3`，最多不能超过`5`。
- ❺建立联合索引时，一定要考虑优先级，查询频率最高的字段应当放首位。
- ❻当表的数据较少，不应当建立索引，因为数据量不大时，维护索引反而开销更大。
- ❼索引的字段值无序时，不推荐建立索引，因为会造成页分裂，尤其是主键索引。

### 索引失效

- 查询中带有OR会导致索引失效
- 模糊查询中like以%开头导致索引失效
- 隐式转换
- 函数计算
- 违背最左前缀原则
- 负向条件 !=, not in

### 使用索引的正确姿势

对于如何使用索引才是正确的呢？总结如下：

- ①查询`SQL`中尽量不要使用`OR`关键字，可以使用多`SQL`或子查询代替。
- ②模糊查询尽量不要以`%`开头，如果实在要实现这个功能可以建立全文索引。
- ③编写`SQL`时一定要注意字段的数据类型，否则`MySQL`的隐式转换会导致索引失效。
- ④一定不要在编写`SQL`时让索引字段执行计算工作，尽量将计算工作放在客户端中完成。
- ⑤对于索引字段尽量不要使用计算类函数，一定要使用时请记得将函数计算放在`=`后面。
- ⑥多条件的查询`SQL`一定要使用联合索引中的第一个字段，否则会打破最左匹配原则。
- ⑦对于需要对比多个字段的查询业务时，可以拆分为连表查询，使用临时表代替。
- ⑧在`SQL`中不要使用反范围性的查询条件，大部分反范围性、不等性查询都会让索引失效。
- ⑨`.......`

#### 索引覆盖

由于表中只能存在一个聚簇索引，一般都为主键索引，而建立的其他索引都为辅助索引，包括联合索引也不例外，最终索引节点上存储的都是指向主键索引的值，拿前面的用户表为例：

```sql
SELECT * FROM `zz_users` WHERE `user_name`="竹子" AND `user_sex`="男";
```

虽然这条`SQL`会走联合索引查询，但是基于联合索引查询出来的值仅是一个指向主键索引的`ID`，然后会拿着这个`ID`再去主键索引中查一遍，这个过程之前聊过，被称为`回表`过程。

那如果要查询的列，在使用的索引中已经包含，被所使用的索引覆盖，这种情况称之为`索引覆盖`。



<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250303131009054.png" alt="image-20250303131009054" style="zoom:100%;" />

#### 索引下推

> 将 Server 层筛选数据的工作，下推到引擎层处理

- 用户表建立 name，sex 联合索引

- ```sql
  select * from user where name like '竹%' and sex = '男' 
  ```

由于 % 模糊查询，只能用到 name 索引，返回多条 id 给到 server 层，回表扫描，逐条判断，筛选出数据

整个查询过程如下：

- ① 利用联合索引中的 `user_name` 字段找出「竹子、竹竹」两个索引节点。
- ② 返回索引节点存储的值「2、5」给 Server 层，然后去逐一做回表扫描。
- ③ 在 Server 层中根据 `user_sex="男"` 这个条件逐条判断，最终筛选到「竹子」这条数据。

假如索引下推之后是这样：

- ① 利用联合索引中的 `user_name` 字段找出「竹子、竹竹」两个索引节点。
- ② 根据 `user_sex="男"` 这个条件在索引节点中逐个判断，从而得到「竹子」这个节点。
- ③ 最终将「竹子」这个节点对应的「2」返回给 Server 层，然后聚簇索引中回表拿数据。

相较于没有索引下推之前，原本需要做「`2、5`」两次回表查询，但在拥有索引下推之后，仅需做「`2`」一次回表查询。

#### MRR(Multi-Range Read)机制

> 针对于辅助索引的回表查询，减少离散 IO，并且将随机 IO 转换为顺序 IO，从而提高查询效率

- 查找的数据，可能分布在不同的页中，可能来回来切换
- 对于辅助索引中查询出的 ID，会将其放到缓冲区
- 达到一定大小后，排序
- 再顺序 IO 去取数据

#### Index Skip Scan索引跳跃式扫描

在讲联合索引时，咱们提到过最左前缀匹配原则，也就是`SQL`的查询条件中必须要包含联合索引的第一个字段，这样才能命中联合索引查询，但实际上这条规则也并不是`100%`遵循的。因为在`MySQL8.x`版本中加入了一个新的优化机制，也就是索引跳跃式扫描，这种机制使得咱们即使查询条件中，没有使用联合索引的第一个字段，也依旧可以使用联合索引，看起来就像跳过了联合索引中的第一个字段一样，这也是跳跃扫描的名称由来。

比如此时通过`(A、B、C)`三个列建立了一个联合索引，此时有如下一条`SQL`：

```sql
SELECT * FROM `tb_xx` WHERE B = `xxx` AND C = `xxx`;
```

按理来说，这条`SQL`既不符合最左前缀原则，也不具备使用索引覆盖的条件，因此绝对是不会走联合索引查询的，但思考一个问题，这条`SQL`中都已经使用了联合索引中的两个字段，结果还不能使用索引，这似乎有点亏啊对不？因此`MySQL8.x`推出了跳跃扫描机制，但跳跃扫描并不是真正的“跳过了”第一个字段，而是优化器为你重构了`SQL`，比如上述这条`SQL`则会重构成如下情况：

```sql
SELECT * FROM `tb_xx` WHERE B = `xxx` AND C = `xxx`
UNION ALL
SELECT * FROM `tb_xx` WHERE B = `xxx` AND C = `xxx` AND A = "yyy"
......
SELECT * FROM `tb_xx` WHERE B = `xxx` AND C = `xxx` AND A = "zzz";
```

其实也就是`MySQL`优化器会自动对联合索引中的第一个字段的值去重，然后基于去重后的值全部拼接起来查一遍，一句话来概述就是：**虽然你没用第一个字段，但我给你加上去，今天这个联合索引你就得用，不用也得给我用**。

> 但是跳跃扫描机制也有很多限制，比如多表联查时无法触发、`SQL`条件中有分组操作也无法触发、`SQL`中用了`DISTINCT`去重也无法触发.....，总之有很多限制条件，具体的可以参考[《MySQL官网8.0-跳跃扫描》](https://link.juejin.cn/?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F8.0%2Fen%2Frange-optimization.html)。

其实这个跳跃性扫描机制，只有在唯一性较差的情况下，才能发挥出不错的效果，如果你联合索引的第一个字段，是一个值具备唯一性的字段，那去重一次再拼接，几乎就等价于走一次全表。

## MySQL索引原理

### MySQL索引为何使用B+树结构？

先讲一下查询算法的升级策略：

* 二分法

  * 不支持动态插入和删除操作
* 二叉查找树 BST

  * 解决了排序的基本问题，但是由于无法保证平衡，可能退化为链表
* 平衡二叉树 AVL

  * 通过旋转解决了平衡的问题，但是旋转操作效率太低
* 红黑树

  * 通过舍弃严格的平衡和引入红黑节点，解决了 AVL 旋转效率过低的问题，但是在磁盘等场景下，树仍然太高，IO 次数太多；
* 多路平衡查找树 B 树

  * 通过将二叉树改为多路平衡查找树，解决了树过高的问题；
* B+ 树

  * 更少的 IO 次数
  * 更适用于范围查找
  * 更稳定的查询效率

> - 所有叶子节点包含了全部信息
> - 各叶子节点用指针进行连接，范围查询更加高效。
> - 在 B 树的基础上，将非叶子节点改造成只存储 key 的信息，进一步降低了树的高度

###  索引内部查询与维护的过程

查询 `SQL` 执行时，如果选中了索引，索引内部的检索过程是什么样的呢？

#### 聚簇索引查找数据的过程

如果当前 `SQL` 使用的是主键/聚簇索引，比如：

```sql
SELECT * FROM `product` WHERE `ID` = 5;
```

此时首先会根据条件字段，去内存中找到聚簇索引的根节点，然后根据节点中记录的地址去找次级的叶节点，最后再根据叶节点中的指针地址，找到最下面的叶子节点，从而获取其中的行数据，过程如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/btree.drawio.png" alt="主键索引 B+Tree" style="zoom:70%;" />

查询过程是这样的，B+Tree 会自顶向下逐层进行查找：

*   将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；
*   在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；
*   在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。

#### 非聚簇索引查找数据的过程

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1546632-20200919225813936-1490118290.png" alt="InnoDB非主键索引原理图" style="zoom:80%;" />

相较于聚簇索引而言，非聚簇索引前面的步骤都是相同的，仅是最后一步有些许不同罢了，非聚簇索引经过一系列查询步骤后，最终会取到一个聚簇索引的字段值，然后再做一次回表查询，也就是再去聚簇索引中查一次才能取到数据。

#### 联合索引查找数据过程

主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：

*   主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
*   二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/二级索引btree.drawio.png" style="zoom:70%;" />

其中非叶子的 key 值是 product\_no（图中橙色部分），叶子节点存储的数据是主键值（图中绿色部分）。

如果我用 product\_no 二级索引查询商品，如下查询语句：

```sql
select * from product where product_no = '0002'; 
```

会先检二级索引中的 B+Tree 的索引值（商品编码，product\_no），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。**这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据**。如下图（图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行）：

![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/回表.drawio.png)







比如 

```sql
INDEX idx_book_id_hero_name (book_id, hero_name) USING BTREE
```

即对`book_id, hero_name`两列建立了一个联合索引。

联合索引是多列按照次序一列一列比较大小，拿`idx_book_id_hero_name`这个联合索引来说，先比较`book_id`，book_id小的排在左边，book_id大的排在右边，book_id相同时再比较`hero_name`。如下图所示：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1546632-20200920111026527-1672463564.png" alt="InnoDB联合索引原理图" style="zoom:80%;" />

了解了联合索引的结构，就能引入`最左前缀法则`：

> 就是说联合索引中的多列是按照列的次序排列的，如果查询的时候不能满足列的次序，比如说where条件中缺少`col1 = ?`，直接就是`col2 = ? and col3 = ?`，那么就走不了联合索引，从上面联合索引的结构图应该能明显看出，只有`col2`列无法通过索引树检索符合条件的数据。

#### 写SQL执行时索引的维护过程

如果是`Hash`结构的索引，直接增删改对应的索引键即可，但`B+Tree`结构的索引，因为要内部节点是有序的，所以需要维护有序性。

##### 插入数据时索引的变化

同样假设用户表上有两个索引，一是基于自增`ID`建立的主键索引，第二个则是基于姓名字段建立的普通索引。当表中插入这条数据后，索引又会发生什么变化呢？

```sql
INSERT INTO `zz_user` VALUES(6,"上海市黄浦区xx街道666号","棕熊","男",30);
```

`主键/聚簇索引的变化`

因为主键索引字段，也就是`ID`字段是顺序递增的，因此只需要在本地索引文件的`B+Tree`结构中，按照树结构找到最后的位置，将当前插入的`ID:6`作为索引键，以当前插入的行数据作为索引值，然后插入到最后的节点中即可。如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/750c7cb5fd5e4fcfa7cb6baef4878a19~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.gif" alt="750c7cb5fd5e4fcfa7cb6baef4878a19~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0" style="zoom:80%;" />

`普通/非聚簇索引的变化`

因为姓名字段本身的数据类型是字符串，与数值型字段天生的有序不同，字符串类型是无序的，因此首先需要根据已经配置好的排序规则，先对插入的`name：棕熊`这个值进行计算，然后根据计算出的值，决定当前数据在`B+Tree`中的索引位置，计算好之后再执行插入工作，过程如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/b594b2fe0dd64adeabb34b9fa0e8649b~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.gif" alt="b594b2fe0dd64adeabb34b9fa0e8649b~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0" style="zoom:80%;" />

相较于主键字段的顺序`ID`，插入字符串类型的`name`值会复杂一些，因为从这里可以明显看到，插入的“棕熊”数据经过计算后，它并不排最后面，而是排中间，所以要将这个值插入到对应的位置，此时树的节点就会发生裂变，后续的所有叶子节点都需要往后移动，这个开销是较大的。

##### 删除数据时索引的变化

```sql
DELETE FROM `zz_user` WHERE ID = 5;
```

例如上述这条删除语句，当执行后则会先根据`ID`在索引树中查找索引信息，然后先删除非聚簇索引上的索引信息，紧接着再去聚簇索引上删除主键索引信息和行数据。

##### 更改数据时索引的变化

```sql
UPDATE `zz_user` SET name = "狗熊" WHERE ID = 6;
```

对于上述这条修改语句，索引维护的过程相信大家自己也能推测出来，毕竟修改的本质就是先删再插入，首先在聚簇索引上查到`ID=6`这条数据，获取原本的`name`字段值：“棕熊”，然后以该值去非聚簇索引上找到对应的索引信息，然后先将聚簇索引中的数据行改掉，接着删除次级（非聚簇）索引的信息，最后再插入一个“狗熊”的次级索引信息。

> 会先更新数据行，再修改次级索引的值，但次级索引的修改是先删后改，而聚簇索引不会删数据，因为聚簇索引上保存着行数据，是直接对行数据进行修改（先读到内存中，改完覆盖原本的数据）。

修改聚簇索引数据行的过程：首先会在聚簇索引上根据`ID=6`找到对应的行数据，然后将行数据中的`name`字段更新为“狗熊”。

> *PS：实际索引更新数据时，具体的过程也会复杂一些，会牵扯到锁机制，也包括会判断修改的新值与原值的大小，如果大小相同则直接在原空间做修改（直接插入覆盖），如果不同才会先删再改。*

#### 主键为何推荐使用自增整数ID？

当使用字符串（`UUID`）作为主键字段时，在 **插入** 数据的时候会频繁破坏原有的树结构，造成树分裂以及后续节点的挪动，一两个条数据插入倒还没关系，但是每一条插入的数据都有可能导致树的结构调整一次，这个过程的开销可想而知`.....`

> 但是自增的整数 `ID` 就不会有这个问题，因为插入的 `ID` 本身就是按序递增的，因此插入的每一条新数据，都会直接放到 `B+Tree` 最后的节点中存储。

同时，除开上述原因外，还有一个原因就是 `UUID` 比整数自增 `ID` 长，`UUID `至少占位 `32` 字节，但 `int` 类型只占 `4` 字节，存储一个 `UUID` 的空间，可以存 `8` 个自增整数 `ID`。也就代表着单个节点中，能存储的自增 `ID` 会比 `UUID` 多很多，单个节点存储的索引键越多`.....`（后面这一排就不讲了，前面复述过两次了，大家应该也懂哈~）
