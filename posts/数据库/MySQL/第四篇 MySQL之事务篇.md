---
title: 第四篇 MySQL之事务篇
tags:
  - MySQL
categories:
  - 数据库
date: '2025-05-23'
description: 欢迎使用 Curve 主题，这是你的第一篇文章
articleGPT: 这是一篇初始化文章，旨在告诉用户一些使用说明和须知。
#cover: "/images/logo/logo.webp"
---

# MySQL之事务篇

## 事务的ACID原则

`ACID`主要涵盖四条原则，即：

- 原子性（A/Atomicity）

  - > 组成一个事务的一组 `SQL` 要么全部执行成功，要么全部执行失败

  - 使用 `undo log` 实现，如果事务执行出错或者执行了 `rollback`，通过 `undo log` 恢复

- 一致性（C/Consistency）

  - > 一个事务中的所有操作，要么一起改变数据库中的数据，要么都不改变

  - 通过其他三个特性实现

- 隔离性（I/Isolation）

  - > 多个事务之间都是独立的

  - 通过 `锁` 以及 `MVCC` 实现

- 持久性（D/Durability）

  - > 一个事务一旦被提交，它会保持永久性，也就是持久化

  - `redo log` 实现持久化，系统崩了，通过 `redo log` 恢复

### MySQL事务的隔离机制

在`MySQL`中，事务隔离机制分为了四个级别：

- ①`Read uncommitted/RU`：读未提交
- ②`Read committed/RC`：读已提交
- ③`Repeatable read/RR`：可重复读
- ④`Serializable`：序列化/串行化

上述四个级别，越靠后并发控制度越高，也就是在多线程并发操作的情况下，出现问题的几率越小，但对应的也性能越差，`MySQL`的事务隔离级别，默认为第三级别：`Repeatable read`可重复读。

#### 脏写、脏读、幻读、不可重复读问题

- 脏写
  - 是多个事务一起操作同一条数据，就会造成数据覆盖，或者主键冲突的问题，这个问题也被称之为更新丢失问题
- 脏读
  - 事务 `A` 正在访问数据，读到了事务 `B` 未提交事务的数据
- 不可重复读
  - 同一事务内，多次读取一条记录发现其中某些列的`值被修改`
- 幻读
  - 同一事务内，多次读取发现记录`变多`或者`变少`了

#### 四大隔离级别

- `RU` 读未提交（READ-UNCOMMITTE）

  - 读操作不加锁，写操作加 `X`（排他锁）

  - 由于写使用 `X record` 则不会产生脏写，会产生 脏读、不可重复读、幻读

- `RC` 读已提交（READ-COMMITTED）

  - 读使用 `mvcc`（每次读生成 `read view` 快照，然后依据这个 `快照` 去选择一个可读的数据 `版本` ），写使用 `X record`（排他锁）

  - 会有 不可重复读、幻读

- `RR` 可重复读（REPEATABLE-READ）

  - 读使用 `mvcc`（第一次读生成 `read view`），写使用`X next key`（临键锁，即读操作执行时，不允许其他事务改动数据）

  - 会有 幻读（基本解决）

- 串行化（SERIALIZABLE）

  - 所有写操作加 `临键锁`（具备互斥特性），所有读操作加 `共享锁` 。

  - 由于所有写操作在执行时，都会获取临键锁，所以写-写、读-写、写-读这类并发场景都会互斥，而由于读操作加的是共享锁，因此在Serializable级别中，只有读-读场景可以并发执行。

  - 不会产生脏写、脏读、不可重复读、幻读

> 虽然 `DBMS` 中要求在序列化级别再解决幻读问题，但在MySQL中，`RR` 级别中就已经解决了幻读问题，因此 MySQ L中可以将 `RR` 级别视为最高级别，而Serializable 级别几乎用不到，因为序列化级别中解决的问题，在 `RR` 级别中基本上已经解决了，再将 MySQL 调到 Serializable 级别反而会降低性能。
>
> 当然，`RR` 级别下有些极端的情况，依旧会出现幻读问题，但线上100%不会出现。

#### 小争议：MVCC机制是否彻底解决了幻读问题呢？

MVCC并没有彻底解决幻读问题，在一种奇葩的情况下依旧会出现问题。

```sql
-- 开启一个事务T1
begin;
-- 查询表中 ID>10 的数据
SELECT * FROM `zz_users` where user_id > 10;
```

因为用户表中不存在ID>10的数据，所以T1查询时没有结果。

```sql
-- 再开启一个事务T2
begin;
-- 向表中插入一条 ID=11 的数据
INSERT INTO `zz_users` VALUES(11,"墨竹","男","2222","2022-10-07 23:24:36");
-- 提交事务T2
commit;
```

此时T2事务插入一条ID=11的数据并提交，此时再回到T1事务中：

```sql
-- 在T1事务中，再次查询表中 ID>10 的数据
SELECT * FROM `zz_users` where user_id > 10;
```

结果很明显，依旧未查询到ID>10的数据，因为这里是通过第一次生成的快照文件在读，所以读不到T2新增的“幻影数据”，似乎没问题对嘛？

```sql
-- 在T1事务中，对 ID=11 的数据进行修改
UPDATE `zz_users` SET `password` = "1111" where `user_id` = 11;

-- 在T1事务中，再次查询表中 ID>10 的数据
SELECT * FROM `zz_users` where user_id > 10;
+---------+-----------+----------+----------+---------------------+
| user_id | user_name | user_sex | password | register_time       |
+---------+-----------+----------+----------+---------------------+
|      11 | 墨竹      | 男       | 1111     | 2022-10-07 23:24:36 |
+---------+-----------+----------+----------+---------------------+
```

嗯？！？？此时会发现，T1事务中又能查询到ID=11的这条幻影记录了，这是啥原因导致的呢？因为我们在T1中修改了ID=11的数据，在[《MVCC机制原理剖析》](https://juejin.cn/post/7155359629050904584)中曾讲过MVCC通过快照检索数据的过程，这里T1根据原本的快照文件检索数据时，因为发现ID=11这条数据上的隐藏列trx_id是自己，因此就能看到这条幻影数据了。

> 实际上这个问题有点四不像，可以理解成幻读问题，也可以理解成是不可重复读问题，总之不管怎么说，就是MVCC机制存在些许问题！但这种情况线下一般不会发生，毕竟不同事务之间都是互不相知的，在一个事务中，不可能会去主动修改一条“不存在”的记录。

#### 实现原理

MySQL 的事务机制是基于 `日志` 实现的。

- `start transaction`; 关闭自动提交机制
- 生成 `redo log`（prepare状态），并生成 `undo log`，执行 sql，将数据更新到 `BufferPool` 缓冲区中，生成 `bin log`
- 遇到 `rollback`，在 `undo log` 中找到 撤销sql 执行，将缓冲区数据还原
- 遇到 `commit`，`redo log` 改为 `commit` 状态，异步刷盘

### 事务的恢复机制

当`SQL`执行时，数据还没被刷写到磁盘中，结果数据库宕机了，那数据是不是就丢了啊？毕竟本地磁盘中的数据，在`MySQL`重启后依旧存在，但缓冲区中还未被刷到磁盘的数据呢？

**数据被更新到缓冲区但没刷盘，然后`MySQL`宕机了，`MySQL`会通过日志恢复数据**。

> 这里要注意的是：数据被更新到缓冲区代表着`SQL`执行成功了（已经生成了`redo log` 和 `undo log`），此时客户端会收到`MySQL`返回的写入成功提示，只是没有落盘而言，所以`MySQL`重启后只需要再次落盘即可。
>
> 所以在`MySQL`重启时，依旧可以通过`redo-log`日志重新恢复未落盘的数据，从而确保数据的持久化特性。

那如果在记录`redo-log`日志时，`MySQL`芭比Q了咋整？

如果在记录日志的时候`MySQL`宕机了，这代表着`SQL`都没执行成功，`SQL`没执行成功的话，`MySQL`也不会向客户端返回任何信息，因为`MySQL`一直没返回执行结果，因此会导致客户端连接超时，而一般客户端都会有超时补偿机制的，比如会超时后重试，如果`MySQL`做了热备/灾备，这个重试的时间足够`MySQL`重启完成了，因此用户的操作依旧不会丢失（对于超时补偿机制，在各大数据库连接池中是有实现的）。