

# MySQL之库表设计篇

实际上设计 `DB` 库表结构时，有一些共同需要遵守的规范，这些规范在数据库设计中被称为“范式”，理解并掌握这些设计时的规范，能让咱们在项目之初，设计的库表结构更为合理且优雅。数据库范式中，声名远扬的有三大范式，但除此之外也有一些其他设计规范，如：

- ①数据库三大范式（`1NF、2NF、3NF`）
- ③第四范式(`4NF`）和第五范式：完美范式（`5NF`）
- ②巴斯-科德范式（`BCNF`）
- ④反范式设计

## 数据库三大范式

三大范式之间，它们是递进的关系，也就是后续的范式都基于前一个范式的基础上推行。

### 第一范式（1NF）

库表设计时的第一范式，主要是为了确保 `原子性`的，也就是存储的数据具备 `不可再分性`。

```sql
SELECT * FROM `zz_student`;
+----------------------+--------+-------+
| student              | course | score |
+----------------------+--------+-------+
| 竹子，男，185cm      | 语文   |    95 |
| 竹子，男，185cm      | 数学   |   100 |
| 竹子，男，185cm      | 英语   |    88 |
| 熊猫，女，170cm      | 语文   |    99 |
| 熊猫，女，170cm      | 数学   |    90 |
| 熊猫，女，170cm      | 英语   |    95 |
+----------------------+--------+-------+
```

在上述的学生表中，其中有一个 `student` 学生列，这一列存储的数据则明显不符合 **第一范式** ：`原子性`的规定，因为这一列的数据还可以再拆分为姓名、性别、身高三项数据，因此为了符合 **第一范式**，应该将表结构更改为：

```sql
+--------------+-------------+----------------+--------+-------+
| student_name | student_sex | student_height | course | score |
+--------------+-------------+----------------+--------+-------+
| 竹子         | 男          | 185cm          | 语文   |    95 |
| 竹子         | 男          | 185cm          | 数学   |   100 |
| 竹子         | 男          | 185cm          | 英语   |    88 |
| 熊猫         | 女          | 170cm          | 语文   |    99 |
| 熊猫         | 女          | 170cm          | 数学   |    90 |
| 熊猫         | 女          | 170cm          | 英语   |    95 |
+--------------+-------------+----------------+--------+-------+
```

> 那此刻思考一下：如果不去拆分列满足第一范式，会造成什么影响呢？
>
> - 客户端语言和表之间无法很好的生成映射关系。
> - 查询到数据后，需要处理数据时，还需要对`student`字段进行额外拆分。
> - 插入数据时，对于第一个字段的值还需要先拼装后才能进行写入。

### 第二范式（2NF）

第二范式的要求表中的所有列，其数据都必须依赖于 `主键`，也就是一张表只存储 `同一类型` 的数据，不能有任何一列数据与 `主键` 没有关系。

```sql
+--------------+-------------+----------------+--------+-------+
| student_name | student_sex | student_height | course | score |
+--------------+-------------+----------------+--------+-------+
| 竹子         | 男          | 185cm          | 语文   |    95 |
| 竹子         | 男          | 185cm          | 数学   |   100 |
| 竹子         | 男          | 185cm          | 英语   |    88 |
| 熊猫         | 女          | 170cm          | 语文   |    99 |
| 熊猫         | 女          | 170cm          | 数学   |    90 |
| 熊猫         | 女          | 170cm          | 英语   |    95 |
+--------------+-------------+----------------+--------+-------+
```

虽然此时已经满足了数据库的第一范式，但此刻观察 `course` 课程、 `score` 分数这两列数据，跟前面的几列数据实际上 `依赖关系` 并不大，同时也由于这样的结构，导致前面几列的数据出现了 `大量冗余` ，所以此时可以再次拆分一下表结构：

```sql
SELECT * FROM `zz_student`;
+------------+--------+------+--------+--------------+--------------+
| student_id | name   | sex  | height | department   | dean         |
+------------+--------+------+--------+--------------+--------------+
|          1 | 竹子   | 男   | 185cm  | 计算机系     | 竹子老大     |
|          2 | 熊猫   | 女   | 170cm  | 金融系       | 熊猫老大     |
+------------+--------+------+--------+--------------+--------------+

SELECT * FROM `zz_course`;
+-----------+-------------+
| course_id | course_name |
+-----------+-------------+
|         1 | 语文        |
|         2 | 数学        |
|         3 | 英语        |
+-----------+-------------+

SELECT * FROM `zz_score`;
+----------+------------+-----------+-------+
| score_id | student_id | course_id | score |
+----------+------------+-----------+-------+
|        1 |          1 |         1 |    95 |
|        2 |          1 |         2 |   100 |
|        3 |          1 |         3 |    88 |
|        4 |          2 |         1 |    99 |
|        5 |          2 |         2 |    90 |
|        6 |          2 |         3 |    95 |
+----------+------------+-----------+-------+
```

原本的学生表有六条学生记录，其中有四条是冗余数据，此时的学生表则只有两条数据，同时这张学生表中只存储学生信息相关的数据。

经过本次结构优化后，每张表的业务属性都具备 “`唯一性`”，也就是每张表都只会描述了“一件事情”，不会存在一张表中会出现两个业务属性（例如之前的学生表包含了学生信息和课程成绩）。

### 第三范式（3NF）

第三范式要求表中每一 `列` 数据不能与主键之外的字段有直接关系。

怎么理解呢？基于上述的例子：

```sql
+------------+--------+------+--------+--------------+--------------+
| student_id | name   | sex  | height | department   | dean         |
+------------+--------+------+--------+--------------+--------------+
|          1 | 竹子   | 男   | 185cm  | 计算机系     | 竹子老大     |
|          2 | 熊猫   | 女   | 170cm  | 金融系       | 熊猫老大     |
+------------+--------+------+--------+--------------+--------------+
```

比如这张学生表，目前即符合第一范式，也符合第二范式，但看最后的两个字段，`department `表示当前学生所属的院校，`dean `则表示这个院系的院长是谁。

一般来说，一个学生的院长是谁，首先是取决于学生所在的院系的，因此最后的 `dean` 字段明显与 `department` 字段存在依赖关系，因此需要进一步调整表结构：

```sql
SELECT * FROM `department`;
+---------------+-----------------+-----------------+
| department_id | department_name | department_dean |
+---------------+-----------------+-----------------+
|             1 | 计算机系        | 竹子老大        |
|             2 | 金融系          | 熊猫老大        |
+---------------+-----------------+-----------------+

SELECT * FROM `zz_student`;
+------------+--------+------+--------+---------------+
| student_id | name   | sex  | height | department_id |
+------------+--------+------+--------+---------------+
|          1 | 竹子   | 男   | 185cm  |             1 |
|          2 | 熊猫   | 女   | 170cm  |             2 |
+------------+--------+------+--------+---------------+
```

至此，学生表中的每个非主键字段与其他非主键字段之间，都是相互独立的，之间不会再存在任何依赖性，所有的字段都依赖于主键。

> 那这里为什么要调整呢？不调整不行吗？还真不行，来简单思考一下不调整结构的情况下会发生什么问题：
>
> - ① 当一个院系的院长换人后，需要同时修改学生表中的多条数据。
> - ② 当一个院长离职后，需要删除该院长的记录，会同时删除多条学生信息。
> - ......
>
> 也就是如果设计的表结构，无法满足第三范式，在操作表时就会出现异常，使得整个表较难维护。

### 三大范式总结

- `第一范式 （1NF）`：确保 `原子性`，表中每一个列数据都必须是不可再分的字段。
- `第二范式（2NF）`：确保 `唯一性`，每张表都只描述一种业务属性，一张表只描述一件事。
- `第三范式（3NF）`：确保 `独立性` ，表中除主键外，每个字段之间不存在任何依赖，都是独立的。

经过三范式的示例后，数据库中的表数量也逐渐多了起来，似乎设计符合三范式的库表结构，反而更加麻烦了对吗？答案并非如此，因为在没有按照范式设计时，会存在几个问题：

- ① 整张表数据比较冗余，同一个学生信息会出现多条。
- ② 表结构特别臃肿，不易于操作，要新增一个学生信息时，需添加大量数据。
- ③ 需要更新其他业务属性的数据时，比如院系院长换人了，需要修改所有学生的记录。

但按照三范式将表结构拆开后，假设要新增一条学生数据，就只需要插入学生相关的信息即可，同时如果某个院系的院长换人了，只需要修改院系表中的院长就行，学生表中的数据无需发生任何更改。

> 因此，经过三范式的设计优化后，整个库中的所有表结构，会显得更为优雅，灵活性也会更强。

## 巴斯-科德范式与第四、五范式

### 巴斯-科德范式（BCNF）

在了解后续这些范式之前，首先得弄明白一个概念，一般在一张表中，可以用于区分每行数据的一个列，通常会被咱们设为主键，例如常用的 `ID` 字段就是如此，这类主键通常被称为单一主键，即一个列组成的主键。

巴斯-科德范式也被称为 `3.5NF`，至于为何不称为第四范式，这主要是由于它是第三范式的补充版，第三范式的要求是：任何非主键字段不能与其他非主键字段间存在依赖关系，也就是要求每个非主键字段之间要具备独立性。而巴斯-科德范式在第三范式的基础上，进一步要求：**任何主属性不能对其他主键子集存在依赖**。

大白话说简单一点，也就是规定了 `联合主键` 中的某列值，不能与 `联合主键` 中的其他列存在依赖关系。

```sql
+-------------------+---------------+--------+------+--------+
| classes           | class_adviser | name   | sex  | height |
+-------------------+---------------+--------+------+--------+
| 计算机-2201班     | 熊竹老师      | 竹子   | 男   | 185cm  |
| 金融-2201班       | 竹熊老师      | 熊猫   | 女   | 170cm  |
| 计算机-2201班     | 熊竹老师      | 子竹   | 男   | 180cm  |
+-------------------+---------------+--------+------+--------+
```

例如这张学生表，此时假设以 `classes` 班级字段、`class_adviser `班主任字段、`name `学生姓名字段，组合成一个联合主键，在这里我们可以通过联合主键，确定学生表中任何一个学生的信息，比如：

```sql
where classes = '计算机-2201班' and class_adviser = '熊竹老师' and name = '竹子'
```

可以确定唯一一条记录。

到这里，咱们分析一下，假设以「班级、班主任、学生姓名」三个字段组成联合主键，当前这张表是否符合前面的三大范式呢？

- `第一范式`：表中每列数据都不可再分，具备原子性，满足。
- `第二范式`：表中每行数据都仅描述了学生信息这一种业务属性，具备唯一性，满足。
- `第三范式`：除主键外，表中非主键字段之间都不存在依赖关系，具备独立性，满足。

经过上述分析后，当前这张表也符合前面聊到的 三大范式，但没有问题了吗？

有的，在这张表中，一条学生信息中的班主任，取决于学生所在的班级，比如「竹子同学、子竹同学」在「计算机-2201班」，所以它们的班主任都是「熊竹老师」，因此班主任字段其实也依赖于班级字段。那会造成什么问题呢？

- ①当一个班级的班主任老师换人后，需要同时修改学生表中的多条数据。
- ②当一个班主任老师离职后，需要删除该老师的记录，会同时删除多条学生信息。
- ③想要增加一个班级时，同时必须添加学生姓名数据，因为主键不允许为空。

通过上述分析可以明显得知，如果联合主键中的一个字段依赖于另一个字段，同样也会造成不小的问题，使得整张表的维护性变差，因此这里需要进一步调整结构：

```sql
SELECT * FROM `zz_classes`;
+------------+-------------------+---------------+
| classes_id | classes_name      | class_adviser |
+------------+-------------------+---------------+
|          1 | 计算机-2201班     | 熊竹老师      |
|          2 | 金融-2201班       | 竹熊老师      |
+------------+-------------------+---------------+

SELECT * FROM `zz_student`;
+------------+--------+------+--------+
| classes_id | name   | sex  | height |
+------------+--------+------+--------+
|          1 | 竹子   | 男   | 185cm  |
|          2 | 熊猫   | 女   | 170cm  |
|          1 | 子竹   | 男   | 180cm  |
+------------+--------+------+--------+
```

经过结构调整后，原本的学生表则又被拆为了班级表、学生表两张，在学生表中只存储班级 `ID`，然后使用 `classes_id` 班级 `ID`和 `name` 学生姓名两个字段作为联合主键。

> 第三范式只要求 `非主键` 字段之间，不能存在 `依赖` 关系，但没要求 `联合主键` 中的字段不能存在 `依赖`，因此第三范式并未考虑完善，巴斯-科德范式修正的就是这点。

### 第四范式（4NF）

第四范式是基于 `BC` 范式之上的，但在理解第四范式之前，首先得理解“ `多值依赖` ”的概念：

> 一个表中至少需要有 `三个独立` 的字段才会出现 `多值依赖` 问题，`多值依赖` 是指表中的字段之间存在 `一对多的` 关系，也就是一个字段的具体值会由多个字段来决定。

```sql
SELECT * FROM `zz_user_role_permission`;
+-----------+----------+-------+------------+
| user_name | user_sex | role  | permission |
+-----------+----------+-------+------------+
| 竹子      | 男       | ROOT  | *          |
| 熊猫      | 女       | ADMIN | BACKSTAGE  |
| 竹子      | 男       | ADMIN | BACKSTAGE  |
| 熊猫      | 女       | USER  | LOGIN      |
| 竹子      | 男       | USER  | LOGIN      |
| 子竹      | 男       | USER  | LOGIN      |
+-----------+----------+-------+------------+
```

假设以「用户名、角色、权限」三个字段作为联合主键，先来分析一下这张表是否满足之前的范式：

- 表中每列数据都不可再分，具备 `原子性`，满足第一范式。
- 表中数据都仅描述了用户权限这一种业务属性，具备 `唯一性` ，满足第二范式。
- 除主键外，表中其他字段不存在依赖关系，具备 `独立性` ，满足第三范式。
- 联合主键中的用户、角色、权限都为独立字段，不存在依赖性，满足`BC`范式。

> 此时假设我们需要 新增 一条数据，那表中的 `权限` 字段究竟填什么？
>
> 这个值是需要 `依赖` 多个字段决定的，权限来自于角色，而角色则来自于用户。
>
> 也就是说，一个用户可以拥有多个角色，同时一个角色可以拥有多个权限，所以此时咱们无法单独根据用户名去确定权限值，权限值必须依赖用户、角色两个字段来决定，这种一个字段的值取决于多个字段才能确定的情况，就被称为 `多值依赖`。

正是由于多值依赖的情况出现，又会导致表中出现时数据冗余、新增、删除异常等问题出现。因此第四范式的定义就是要消除表中的多值依赖关系。

```sql
SELECT * FROM `zz_users`;
+---------+-----------+----------+----------+---------------------+
| user_id | user_name | user_sex | password | register_time       |
+---------+-----------+----------+----------+---------------------+
|       1 | 熊猫      | 女       | 6666     | 2022-08-14 15:22:01 |
|       2 | 竹子      | 男       | 1234     | 2022-09-14 16:17:44 |
|       3 | 子竹      | 男       | 4321     | 2022-09-16 07:42:21 |
+---------+-----------+----------+----------+---------------------+

SELECT * FROM `zz_roles`;
+---------+-----------+---------------------+
| role_id | role_name | created_time        |
+---------+-----------+---------------------+
|       1 | ROOT      | 2022-08-14 15:12:00 |
|       2 | ADMIN     | 2022-08-14 15:12:00 |
|       3 | USER      | 2022-08-14 15:12:00 |
+---------+-----------+---------------------+

SELECT * FROM `zz_permissions`;
+---------------+-----------------+---------------------+
| permission_id | permission_name | created_time        |
+---------------+-----------------+---------------------+
|             1 | *               | 2022-08-14 15:12:00 |
|             2 | BACKSTAGE       | 2022-08-14 15:12:00 |
|             3 | LOGIN           | 2022-08-14 15:12:00 |
+---------------+-----------------+---------------------+

SELECT * FROM `zz_users_roles`;
+----+---------+---------+
| id | user_id | role_id |
+----+---------+---------+
|  1 |       1 |       1 |
|  2 |       1 |       2 |
|  3 |       1 |       3 |
|  4 |       2 |       2 |
|  5 |       2 |       3 |
|  6 |       3 |       3 |
+----+---------+---------+

SELECT * FROM `zz_roles_permissions`;
+----+---------+---------------+
| id | role_id | permission_id |
+----+---------+---------------+
|  1 |       1 |             1 |
|  2 |       2 |             2 |
|  3 |       3 |             3 |
+----+---------+---------------+
```

如果有做过权限设计，或用过 `Shiro` 框架的小伙伴应该会感到额外的亲切，这个正是大名鼎鼎的权限五表，将原本的用户角色权限表，拆分成了用户表、角色表、权限表、用户角色关系表、角色权限关系表。经过这次拆分之后，一方面用户表、角色表、权限表中都不会有数据冗余，第二方面无论是要删除亦或新增一个角色、权限时，都不会影响其他表。

### 第五范式（5NF）/完美范式

第五范式的定义：**建立在 `4NF` 的基础上，进一步消除表中的连接依赖，直到表中的连接依赖都是主键所蕴含的**。

第五范式解决的是无损连接问题，但对于第五范式我自个儿也没理解透彻，因此不再讲解第五范式了。

### 六大范式小结

经过一系列的阐述后，其实不难发现，越到后面的范式，越难令人理解，同时为了让表满足更高级别的范式，越往后付出代价也越大，而且拆分出的表数量也会越多，所以一般实际开发中，对于库表的设计最高满足 `BC` 范式即可，再往后就没意义了，因为表数量一多，查询也好，写入也罢，性能会越来越差。

![image-20250527171503777](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250527171503777.png)

- 第一范式：原子性，每个字段的值不能再分。
- 第二范式：唯一性，表内每行数据必须描述同一业务属性的数据。
- 第三范式：独立性，表中每个非主键字段之间不能存在依赖性。
- 巴斯范式：主键字段独立性，联合主键字段之间不能存在依赖性。
- 第四范式：表中字段不能存在多值依赖关系。
- 第五范式：表中字段的数据之间不能存在连接依赖关系。
- 域键范式：试图研究出一个库表设计时的终极完美范式。

## 数据库反范式设计

遵循数据库范式设计的结构优点很明显，它避免了大量的数据冗余，节省了大量存储空间，同时让整体结构更为优雅，能让`SQL`操作更加便捷且减少出错。但随着范式的级别越高，设计出的结构会更加精细化，原本一张表的数据会被分摊到多张表中存储，表的数量随之越来越多。

 但随之而来的不仅仅只有好处，也存在一个致命问题，也就是当同时需要这些数据时，只能采用联表查询的形式检索数据，有时候甚至为了一个字段的数据，也需要做一次连表查询才能获得。这其中的开销无疑是花费巨大的，尤其是当连接的表不仅两三张而是很多张时，有可能还会造成索引失效，这种情况带来的资源、时间开销简直是一个噩梦，这会严重地影响整个业务系统的性能。

> 因此，也正是由于上述一些问题，在设计库表结构时，我们不一定要`100%`遵守范式准则。这种违反数据库范式的设计方法，就被称之为 **反范式设计**。

遵循范式设计也好，反范式设计也罢，本身两者之间并没有优劣之分，只要能够对业务更有利，那就可以称之为好的设计方案。范式的目的仅在于让我们设计的结构更优雅合理，有时候在表中多增加一个字段，从数据库的角度来看，数据会存在冗余问题，会让表结构违反范式的定义，但如若能够在实际情况中减少大量的连表查询，这种设计自然也是可取的。

> 一般而言，库表结构设计的是否合理，区别如下：

- 不合理的结构设计会造成的问题：
  - 数据冗余，会浪费一定程度上的存储空间
  - 不便于常规`SQL`操作（例如插入、删除），甚至会出现异常
- 合理的结构设计带来的好处：
  - 节省空间，`SQL`执行时能节省内存空间，数据存储时能节省磁盘空间
  - 数据划分较为合理，`DB`性能整体较高，并且数据也非常完整
  - 结构便于维护和进行常规`SQL`操作
