---
title: 第七篇 MySQL之调优篇
tags:
  - MySQL
categories:
  - 数据库
date: '2025-05-28'
description: 欢迎使用 Curve 主题，这是你的第一篇文章
articleGPT: 这是一篇初始化文章，旨在告诉用户一些使用说明和须知。
#cover: "/images/logo/logo.webp"


---

# 调优篇

## 调优核心思想

从优化类型上而言，主体可以分为三类：

- ①**结构/架构优化**：优化应用系统整体架构做到性能提升的目的。如：读写分离、集群热备、分布式架构、引入缓存/消息/搜索中间件、分库分表、中台架构（大数据中台、基础设施中台）等。
- ②**配置/参数优化**：调整应用系统中各层面的配置文件、启动参数达到优化性能的目标。如：JVM、服务器、数据库、操作系统、中间件、容器、网关参数调整等。
- ③**代码/操作优化**：开发者编写程序时，从代码、操作方面进行调节，达到效率更高的初衷。如：代码中使用更优秀的算法思想/设计模式、SQL优化、对中间件的操作优化等。

通常而言，性能优化的步骤可分为如下几步：

- ① 发现性能瓶颈：如有监控系统，那它会主动发出警报；如若没有，那出现瓶颈时应用肯定会出问题，如：无响应、响应缓慢、频繁宕机等。
- ② 排查瓶颈原因：排查瓶颈是由于故障问题导致的，还是真的存在性能瓶颈。
- ③ 定位瓶颈位置：往往一个系统都会由多个层面协同工作，然后对外提供服务，当发现性能瓶颈时，应当确定瓶颈的范围，如：网络带宽瓶颈、Java应用瓶颈、数据库瓶颈等。
- ④ 解决性能瓶颈：定位到具体的瓶颈后对症下药，从结构、配置、操作等方面出发，着手解决瓶颈问题。

## MySQL的性能优化实践

### MySQL调优的五个维度

聊到MySQL的性能优化，其实也可以从多个维度出发，共计优化项如下：

- ① 客户端与连接层的优化：调整客户端 DB 连接池的参数和 DB 连接层的参数。
- ② MySQL结构的优化：合理的设计库表结构，表中字段根据业务选择合适的数据类型、索引。
- ③ MySQL参数优化：调整参数的默认值，根据业务将各类参数调整到合适的大小。
- ④ 整体架构优化：引入中间件减轻数据库压力，优化 MySQL 架构提高可用性。
- ⑤ 编码层优化：根据库表结构、索引结构优化业务 SQL 语句，提高索引命中率。

### MySQL连接层优化策略

> 合理的连接数才是最好的，而并非越大越好。

对于最佳连接数的计算，首先要把 `CPU核数` 放首位考虑，紧接着是 `磁盘`，最后是 `网络带宽` ，因为带宽会影响SQL执行时间，综合考虑后才能计算出最合适的连接数大小。

实际业务中，需要考虑 `SQL` 的执行时长，比如一类业务的 `SQL` 执行只需`10ms`，而另一类 `SQL` 由于业务过为繁琐，每次调用时会产生一个大事务，一次执行下来可能需要`5s+`，还是要根据 压测 和 实际情况确定连接数。

### MySQL结构的优化方案

所谓的 MySQL 结构优化，主要是指三方面，即 `表结构`、`字段结构` 以及 `索引结构`，这些结构如果不合理，在某些场景下也会影响数据库的性能。

#### 表结构的优化

①表结构设计时的第一条也是最重要的一条，字段数量一定不要太多。

> InnoDB引擎基本上都会将数据操作放到内存中完成，而当一张表的字段数量越多，那么能载入内存的数据页会越少，当操作时数据不在内存，又不得不去磁盘中读取数据，这显然会很大程度上影响MySQL性能。

> 一张表最多最多只能允许设计30个字段左右，否则会导致查询时的性能明显下降。

②主键的选择一定要合适。主键最好是顺序递增的数值类型，最好为int类型。

> 例如学生表中的学号、职工表中的工号....，如果一张表的业务中不带有这类字段，那也可以设计一个与业务无关、无意义的数值序列字段作为主键，因为这样做最适合维护表数据（跟聚簇索引有关）。

③对于实时性要求不高的数据建立中间表。

> 很多时候咱们为了统计一些数据时，通常情况下都会基于多表做联查，以此来确保得到统计所需的数据，但如若对于实时性的要求没那么高，就可以在库中建立相应的中间表，然后每日定期更新中间表的数据，从而达到减小连表查询的开销，同时也能进一步提升查询速度。

④根据业务特性为每张不同的表选择合适的存储引擎。

> 其实存储引擎这块主要是在InnoDB、MyISAM两者之间做抉择，对于一些经常查询，很少发生变更的表，就可以选择MyISAM引擎，比如字典表、标签表、权限表....，因为读远大于写的表中，MyISAM性能表现会更佳，其他的表则可以使用默认的InnoDB引擎。

#### 字段结构的优化

字段结构的优化其实主要指选择合适的数据类型。

> 大多数开发在设计表字段结构时，如果要使用数值类型一般会选择int，使用字符串类型一般会选择varchar，但这些字段类型可以适当的做些调整。
>
> - 对于一些显然不会拥有太多数据的表，主键ID的类型可以从 int 换成tinyint、smallint、mediumit。
> - 对于一些固定值的字段，如性别、状态、省份、国籍等字段，可以选择使用数值型代替字符串，如果必须使用字符串类型，最好使用enum枚举类型代替varchar 类型。
> - 对于姓名字段，一般都会限制用户名长度，这时不要无脑用 varchar，使用char类型更好。

总之在选择字段的数据类型时有三个原则：

- ① 在保证足够使用的范围内，选择最小数据类型，因为它们会占用更少的磁盘、内存和CPU缓存，同时在处理速度也会更快。
- ② 尽量避免索引字段值为 NULL，定义字段时应尽可能使用 NOT NULL关键字，因为字段空值过多会影响索引性能。
- ③ 在条件允许的情况下，尽量使用最简单的类型代替复杂的类型，如 IP 的存储可以使用 int 而并非 varchar，因为简单的数据类型，操作时通常需要的 CPU资源更少。

#### 索引结构的优化

索引结构优化主要是指根据业务创建更合适的索引。

- ① 索引字段的组成尽量选择多个，如果一个表中需要建立多个索引，应适当根据业务去将多个单列索引组合成一个 `联合索引` ，这样做一方面可以节省磁盘空间，第二方面还可以充分使用 `索引覆盖` 的方式查询数据，能够在一定程度上提升数据库的整体性能。
- ② 对一个值较长的字段建立索引时，可以选用字段值的前N个字符创建索引，也就是对于值较长的字段尽量建立 `前缀索引`，而不是通过完整的字段值建立索引
  - 索引字段值越小，单个 B+Tree 的节点中能存储的索引键会越多，一个节点存下的索引键越多，索引树会越矮，查询性能自然会越高。
- ③ 索引类型的选择一定要合理，对于经常做 `模糊查询` 的字段，可以建立 `全文索引` 来代替普通索引，因为基于普通索引做 like 查询会导致索引失效，而采用全文索引的方式做模糊查询效率会更高更快，并且全文索引的功能更为强大。
- ④ 索引结构的选择可以根据业务进行调整，在某些不会做范围查询的字段上建立索引时，可以选用 `hash` 结构代替 B+Tree 结构，因为 `Hash` 结构的索引是所有数据结构中最快的，散列度足够的情况下，复杂度仅为 `O(1)`。

### MySQL参数优化策略

#### 调整InnoDB缓冲区

在 MySQL 参数中，首先最值得调整的就是 `InnoDB` 缓冲区的大小，因为 `InnoDB` 将是 MySQL 启动后使用最多的引擎，所以为其分配一个足够大的缓冲区，能够在最大程度上提升 MySQL 的性能，但是缓冲区该分配多少内存呢？

> 最佳比例应该控制在 `70~75%` 左右，比如一台服务器的内存为 32GB，将 `innodb_buffer_pool_size` = 22938M（23GB）左右最合理。

同时当 InnoDB 缓冲区空间大于 1GB 时，`InnoDB` 会自动将缓冲区划分为多个实例空间，这样做的好处在于：多线程并发执行时，可以减少并发冲突。

MySQL 官方的建议是每个缓冲区实例必须大于 1GB，因此如果机器内存较小时，例如 8/16GB，可以指定为 1GB，但是机器内存够大时，比如达到了32GB/64GB 甚至更高，哪可以适当将每个缓冲区实例调整到 2GB 左右。

> 比如现在假设缓冲区共计拥有 40GB 内存，哪设置将缓冲区实例设置为 `innodb_buffer_pool_instances` = 20个比较合适。

#### 调整工作线程的缓冲区

这几个区域属于线程私有区域，也就意味着每条线程都拥有这些区域：

- `sort_buffer_size`：排序缓冲区大小，影响 group by、order by...等排序操作。
- `read_buffer_size`：读取缓冲区大小，影响 select...查询操作的性能。
- `join_buffer_size`：联查缓冲区大小，影响 join 多表联查的性能。

> 对于这些区域，最好根据机器内存来设置为一到两倍MB，啥意思呢？
>
> 比如 4GB 的内存，建议将其调整为 4/8MB、8GB 的内存，建议将其调整为 8/16MB.....，但这些区域的大小最好控制在 64MB 以下，因为线程每次执行完一条 SQL 后，就会将这些区域释放，所以再调大也没有必要了。

#### 调整临时表空间

同时还可以调整 `tmp_table_size、max_heap_table_size` 两个参数，这两个参数主要是限制临时表可用的内存空间，当创建的临时表空间占用超过`tmp_table_size` 时，就会将其他新创建的临时表转到磁盘中创建，这显然是十分违背临时表的设计初衷，毕竟创建临时表的目的就是用来加快查询速度，结果又最后又把临时表放到磁盘中去了，这反而还多了一步开销。

> 那么这两个参数该设置多大呢？
>
> 这要根据 `show global status like 'created_tmp%';` 的统计信息来决定，用统计出来的信息：`Created_tmp_disk_tables / Created_tmp_tables * 100% = 120%` ，达到这个标准就比较合适，但调整这个区域的值需要反复重启 MySQL 以及压测，因此比较费时间，如果你在项目中很少使用临时表，哪也可以不关心这块参数的调整。

### 架构优化方案

#### 引入缓存中间件解决读压力

正常的项目业务中，往往 `读` 请求的数量远超 `写` 请求，如果将所有的读请求都落入数据库处理，这自然会对 MySQL 造成巨大的访问压力，严重的情况下甚至会由于流量过大，直接将数据库打到宕机，因此为了解决这系列问题，通常都会在应用程序和数据库之间架设一个缓存，例如最常用的 Redis。

在项目中引入 Redis 作为缓存后，在缓存 Key 设计合理的情况下，至少能够为 MySQL 分担 `70%` 以上的读压力，查询 MySQL 之前先查询一次 Redis，Redis 中有缓存数据则直接返回，没有数据时再将请求交给 MySQL 处理，从 MySQL 查询到数据后，再次将数据写入 Redis，后续有相同请求再来读取数据时，直接从Redis 返回数据即可。

#### 引入消息中间件解决写压力

前面项目中引入Redis后，能够在很大程度上减轻 MySQL 的读请求压力，但当业务系统中的写操作也较为频繁时又该怎么办呢？

Redis 在这里似乎只能分担读操作的流量呀？这时就可以引入 MQ 消息中间件做 `削峰填谷`。

![image-20250528123004584](./%E7%AC%AC%E4%B8%83%E7%AF%87%20MySQL%E4%B9%8B%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20250528123004584.png)

经过 `MQ` 做了流量的削峰填谷后，这能够在极大的程度上减轻 MySQL 的写压力，能够将写压力控制到一个相较平缓的程度，防止由于大量写请求直接到达MySQL，避免负载过高造成的宕机现象出现。

#### MySQL主从读写分离

![image-20250528123036968](./%E7%AC%AC%E4%B8%83%E7%AF%87%20MySQL%E4%B9%8B%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20250528123036968.png)

实现读写分离，由于读操作并不会变更数据，所以对于读请求可以分发到从节点上处理，对于会引发数据变更的写请求，则分发到主节点处理，这样从而能够进一步提升 MySQL 的整体性能。

> 主从读写分离的方案，更适用于一些读大于写的业务。

#### MySQL双主双写热备

对于一些类似于仓储这种 `写大于读` 的项目业务，这种方案带来的性能收益不见得有多好，因此从机分担的读压力，可能仅是系统的 `10~20%` 流量，因此对于这种场景下，双主双写（双主热备）方案才是最佳选择，其架构图如下：

![image-20250528123158278](./%E7%AC%AC%E4%B8%83%E7%AF%87%20MySQL%E4%B9%8B%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20250528123158278.png)

这里的两个 MySQL 节点都为主，同时它们也都为从，啥意思呢？

其实就是指这两个节点互为主从，两者之间相互同步数据，同时都具备处理读/写请求的能力，当出现数据库的读/写操作时，可以将请求抛给其中任意一个节点处理。

> 为了兼容两者之间的数据，对于每张表的主键要处理好，如果表的主键是 int 自增类型的，请一定要手动设置一下自增步长和起始值，比如这里有两个MySQL 节点，那么可以将步长设置为2，起始值分别为1、2，这样做的好处是啥？能够确保主键的唯一性，设置后两个节点自增 ID 的序列如下：
>
> - 节点1：[1、3、5、7、9、11、13、15、17、19.....]
> - 节点2：[2、4、6、8、10、12、14、16、18、20.....]

当插入数据的 SQL 语句发往节点1时，会按照奇数序列自增 ID，发往节点2 时会以偶数序列自增 ID，然后双方相互同步数据，最终两个 MySQL 节点都会具备完整的数据，因此后续的读请求，无论发往哪个节点都可以读到数据。

> 有人或许会思考，既然两个节点互为主从可以实现双主双写，哪能不能搞三个节点、四个节点呢？
>
> 答案是当然可以，不过没必要这么做，因为当需要上三主、四主....的项目，直接就做分库分表更实在，因为这种多主模式存在一个天大的弊端！！

#### MySQL分库分表思想

多主模式有一个天大的弊端！

这个弊端是指存储 `容量的上限` + `木桶` 效应，因为多主模式中的每个节点都会存储完整的数据，因此当数据增长达到硬件的最大容量时，就无法继续写入数据了，此时只能通过加大磁盘的形式进一步提高存储容量，但硬件也不可能无限制的加下去，而且由于多主是基于主从架构实现的，因为具备木桶效应，要加得所有节点一起加，否则另一个节点无法同步写入数据时，就会造成所有节点无法写入数据。

![image-20250528123343167](./%E7%AC%AC%E4%B8%83%E7%AF%87%20MySQL%E4%B9%8B%E8%B0%83%E4%BC%98%E7%AF%87.assets/image-20250528123343167.png)

### SQL优化策略