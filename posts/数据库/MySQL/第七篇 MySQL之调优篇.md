---
title: 第七篇 MySQL之调优篇
tags:
  - MySQL
categories:
  - 数据库
date: '2025-05-28'
description: 欢迎使用 Curve 主题，这是你的第一篇文章
articleGPT: 这是一篇初始化文章，旨在告诉用户一些使用说明和须知。
#cover: "/images/logo/logo.webp"


---

# 调优篇

## 调优核心思想

从优化类型上而言，主体可以分为三类：

- ①**结构/架构优化**：优化应用系统整体架构做到性能提升的目的。如：读写分离、集群热备、分布式架构、引入缓存/消息/搜索中间件、分库分表、中台架构（大数据中台、基础设施中台）等。
- ②**配置/参数优化**：调整应用系统中各层面的配置文件、启动参数达到优化性能的目标。如：JVM、服务器、数据库、操作系统、中间件、容器、网关参数调整等。
- ③**代码/操作优化**：开发者编写程序时，从代码、操作方面进行调节，达到效率更高的初衷。如：代码中使用更优秀的算法思想/设计模式、SQL优化、对中间件的操作优化等。

通常而言，性能优化的步骤可分为如下几步：

- ① 发现性能瓶颈：如有监控系统，那它会主动发出警报；如若没有，那出现瓶颈时应用肯定会出问题，如：无响应、响应缓慢、频繁宕机等。
- ② 排查瓶颈原因：排查瓶颈是由于故障问题导致的，还是真的存在性能瓶颈。
- ③ 定位瓶颈位置：往往一个系统都会由多个层面协同工作，然后对外提供服务，当发现性能瓶颈时，应当确定瓶颈的范围，如：网络带宽瓶颈、Java应用瓶颈、数据库瓶颈等。
- ④ 解决性能瓶颈：定位到具体的瓶颈后对症下药，从结构、配置、操作等方面出发，着手解决瓶颈问题。

## MySQL的性能优化实践

### MySQL调优的五个维度

聊到MySQL的性能优化，其实也可以从多个维度出发，共计优化项如下：

- ① 客户端与连接层的优化：调整客户端 DB 连接池的参数和 DB 连接层的参数。
- ② MySQL结构的优化：合理的设计库表结构，表中字段根据业务选择合适的数据类型、索引。
- ③ MySQL参数优化：调整参数的默认值，根据业务将各类参数调整到合适的大小。
- ④ 整体架构优化：引入中间件减轻数据库压力，优化 MySQL 架构提高可用性。
- ⑤ 编码层优化：根据库表结构、索引结构优化业务 SQL 语句，提高索引命中率。

### MySQL连接层优化策略

> 合理的连接数才是最好的，而并非越大越好。

对于最佳连接数的计算，首先要把 `CPU核数` 放首位考虑，紧接着是 `磁盘`，最后是 `网络带宽` ，因为带宽会影响SQL执行时间，综合考虑后才能计算出最合适的连接数大小。

实际业务中，需要考虑 `SQL` 的执行时长，比如一类业务的 `SQL` 执行只需`10ms`，而另一类 `SQL` 由于业务过为繁琐，每次调用时会产生一个大事务，一次执行下来可能需要`5s+`，还是要根据 压测 和 实际情况确定连接数。

### MySQL结构的优化方案

所谓的 MySQL 结构优化，主要是指三方面，即 `表结构`、`字段结构` 以及 `索引结构`，这些结构如果不合理，在某些场景下也会影响数据库的性能。

#### 表结构的优化

①表结构设计时的第一条也是最重要的一条，字段数量一定不要太多。

> InnoDB引擎基本上都会将数据操作放到内存中完成，而当一张表的字段数量越多，那么能载入内存的数据页会越少，当操作时数据不在内存，又不得不去磁盘中读取数据，这显然会很大程度上影响MySQL性能。

> 一张表最多最多只能允许设计30个字段左右，否则会导致查询时的性能明显下降。

②主键的选择一定要合适。主键最好是顺序递增的数值类型，最好为int类型。

> 例如学生表中的学号、职工表中的工号....，如果一张表的业务中不带有这类字段，那也可以设计一个与业务无关、无意义的数值序列字段作为主键，因为这样做最适合维护表数据（跟聚簇索引有关）。

③对于实时性要求不高的数据建立中间表。

> 很多时候咱们为了统计一些数据时，通常情况下都会基于多表做联查，以此来确保得到统计所需的数据，但如若对于实时性的要求没那么高，就可以在库中建立相应的中间表，然后每日定期更新中间表的数据，从而达到减小连表查询的开销，同时也能进一步提升查询速度。

④根据业务特性为每张不同的表选择合适的存储引擎。

> 其实存储引擎这块主要是在InnoDB、MyISAM两者之间做抉择，对于一些经常查询，很少发生变更的表，就可以选择MyISAM引擎，比如字典表、标签表、权限表....，因为读远大于写的表中，MyISAM性能表现会更佳，其他的表则可以使用默认的InnoDB引擎。

#### 字段结构的优化

字段结构的优化其实主要指选择合适的数据类型。

> 大多数开发在设计表字段结构时，如果要使用数值类型一般会选择int，使用字符串类型一般会选择varchar，但这些字段类型可以适当的做些调整。
>
> - 对于一些显然不会拥有太多数据的表，主键ID的类型可以从 int 换成tinyint、smallint、mediumit。
> - 对于一些固定值的字段，如性别、状态、省份、国籍等字段，可以选择使用数值型代替字符串，如果必须使用字符串类型，最好使用enum枚举类型代替varchar 类型。
> - 对于姓名字段，一般都会限制用户名长度，这时不要无脑用 varchar，使用char类型更好。

总之在选择字段的数据类型时有三个原则：

- ① 在保证足够使用的范围内，选择最小数据类型，因为它们会占用更少的磁盘、内存和CPU缓存，同时在处理速度也会更快。
- ② 尽量避免索引字段值为 NULL，定义字段时应尽可能使用 NOT NULL关键字，因为字段空值过多会影响索引性能。
- ③ 在条件允许的情况下，尽量使用最简单的类型代替复杂的类型，如 IP 的存储可以使用 int 而并非 varchar，因为简单的数据类型，操作时通常需要的 CPU资源更少。

#### 索引结构的优化

索引结构优化主要是指根据业务创建更合适的索引。

- ① 索引字段的组成尽量选择多个，如果一个表中需要建立多个索引，应适当根据业务去将多个单列索引组合成一个 `联合索引` ，这样做一方面可以节省磁盘空间，第二方面还可以充分使用 `索引覆盖` 的方式查询数据，能够在一定程度上提升数据库的整体性能。
- ② 对一个值较长的字段建立索引时，可以选用字段值的前N个字符创建索引，也就是对于值较长的字段尽量建立 `前缀索引`，而不是通过完整的字段值建立索引
  - 索引字段值越小，单个 B+Tree 的节点中能存储的索引键会越多，一个节点存下的索引键越多，索引树会越矮，查询性能自然会越高。
- ③ 索引类型的选择一定要合理，对于经常做 `模糊查询` 的字段，可以建立 `全文索引` 来代替普通索引，因为基于普通索引做 like 查询会导致索引失效，而采用全文索引的方式做模糊查询效率会更高更快，并且全文索引的功能更为强大。
- ④ 索引结构的选择可以根据业务进行调整，在某些不会做范围查询的字段上建立索引时，可以选用 `hash` 结构代替 B+Tree 结构，因为 `Hash` 结构的索引是所有数据结构中最快的，散列度足够的情况下，复杂度仅为 `O(1)`。

### MySQL参数优化策略

#### 调整InnoDB缓冲区

在 MySQL 参数中，首先最值得调整的就是 `InnoDB` 缓冲区的大小，因为 `InnoDB` 将是 MySQL 启动后使用最多的引擎，所以为其分配一个足够大的缓冲区，能够在最大程度上提升 MySQL 的性能，但是缓冲区该分配多少内存呢？

> 最佳比例应该控制在 `70~75%` 左右，比如一台服务器的内存为 32GB，将 `innodb_buffer_pool_size` = 22938M（23GB）左右最合理。

同时当 InnoDB 缓冲区空间大于 1GB 时，`InnoDB` 会自动将缓冲区划分为多个实例空间，这样做的好处在于：多线程并发执行时，可以减少并发冲突。

MySQL 官方的建议是每个缓冲区实例必须大于 1GB，因此如果机器内存较小时，例如 8/16GB，可以指定为 1GB，但是机器内存够大时，比如达到了32GB/64GB 甚至更高，哪可以适当将每个缓冲区实例调整到 2GB 左右。

> 比如现在假设缓冲区共计拥有 40GB 内存，哪设置将缓冲区实例设置为 `innodb_buffer_pool_instances` = 20个比较合适。

#### 调整工作线程的缓冲区

这几个区域属于线程私有区域，也就意味着每条线程都拥有这些区域：

- `sort_buffer_size`：排序缓冲区大小，影响 group by、order by...等排序操作。
- `read_buffer_size`：读取缓冲区大小，影响 select...查询操作的性能。
- `join_buffer_size`：联查缓冲区大小，影响 join 多表联查的性能。

> 对于这些区域，最好根据机器内存来设置为一到两倍MB，啥意思呢？
>
> 比如 4GB 的内存，建议将其调整为 4/8MB、8GB 的内存，建议将其调整为 8/16MB.....，但这些区域的大小最好控制在 64MB 以下，因为线程每次执行完一条 SQL 后，就会将这些区域释放，所以再调大也没有必要了。

#### 调整临时表空间

同时还可以调整 `tmp_table_size、max_heap_table_size` 两个参数，这两个参数主要是限制临时表可用的内存空间，当创建的临时表空间占用超过`tmp_table_size` 时，就会将其他新创建的临时表转到磁盘中创建，这显然是十分违背临时表的设计初衷，毕竟创建临时表的目的就是用来加快查询速度，结果又最后又把临时表放到磁盘中去了，这反而还多了一步开销。

> 那么这两个参数该设置多大呢？
>
> 这要根据 `show global status like 'created_tmp%';` 的统计信息来决定，用统计出来的信息：`Created_tmp_disk_tables / Created_tmp_tables * 100% = 120%` ，达到这个标准就比较合适，但调整这个区域的值需要反复重启 MySQL 以及压测，因此比较费时间，如果你在项目中很少使用临时表，哪也可以不关心这块参数的调整。

### 架构优化方案

#### 引入缓存中间件解决读压力

正常的项目业务中，往往 `读` 请求的数量远超 `写` 请求，如果将所有的读请求都落入数据库处理，这自然会对 MySQL 造成巨大的访问压力，严重的情况下甚至会由于流量过大，直接将数据库打到宕机，因此为了解决这系列问题，通常都会在应用程序和数据库之间架设一个缓存，例如最常用的 Redis。

在项目中引入 Redis 作为缓存后，在缓存 Key 设计合理的情况下，至少能够为 MySQL 分担 `70%` 以上的读压力，查询 MySQL 之前先查询一次 Redis，Redis 中有缓存数据则直接返回，没有数据时再将请求交给 MySQL 处理，从 MySQL 查询到数据后，再次将数据写入 Redis，后续有相同请求再来读取数据时，直接从Redis 返回数据即可。

#### 引入消息中间件解决写压力

前面项目中引入Redis后，能够在很大程度上减轻 MySQL 的读请求压力，但当业务系统中的写操作也较为频繁时又该怎么办呢？

Redis 在这里似乎只能分担读操作的流量呀？这时就可以引入 MQ 消息中间件做 `削峰填谷`。

![image-20250528123004584](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528123004584.png)

经过 `MQ` 做了流量的削峰填谷后，这能够在极大的程度上减轻 MySQL 的写压力，能够将写压力控制到一个相较平缓的程度，防止由于大量写请求直接到达MySQL，避免负载过高造成的宕机现象出现。

#### MySQL主从读写分离

![image-20250528123036968](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528123036968.png)

实现读写分离，由于读操作并不会变更数据，所以对于读请求可以分发到从节点上处理，对于会引发数据变更的写请求，则分发到主节点处理，这样从而能够进一步提升 MySQL 的整体性能。

> 主从读写分离的方案，更适用于一些读大于写的业务。

#### MySQL双主双写热备

对于一些类似于仓储这种 `写大于读` 的项目业务，这种方案带来的性能收益不见得有多好，因此从机分担的读压力，可能仅是系统的 `10~20%` 流量，因此对于这种场景下，双主双写（双主热备）方案才是最佳选择，其架构图如下：

![image-20250528123158278](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528123158278.png)

这里的两个 MySQL 节点都为主，同时它们也都为从，啥意思呢？

其实就是指这两个节点互为主从，两者之间相互同步数据，同时都具备处理读/写请求的能力，当出现数据库的读/写操作时，可以将请求抛给其中任意一个节点处理。

> 为了兼容两者之间的数据，对于每张表的主键要处理好，如果表的主键是 int 自增类型的，请一定要手动设置一下自增步长和起始值，比如这里有两个MySQL 节点，那么可以将步长设置为2，起始值分别为1、2，这样做的好处是啥？能够确保主键的唯一性，设置后两个节点自增 ID 的序列如下：
>
> - 节点1：[1、3、5、7、9、11、13、15、17、19.....]
> - 节点2：[2、4、6、8、10、12、14、16、18、20.....]

当插入数据的 SQL 语句发往节点1时，会按照奇数序列自增 ID，发往节点2 时会以偶数序列自增 ID，然后双方相互同步数据，最终两个 MySQL 节点都会具备完整的数据，因此后续的读请求，无论发往哪个节点都可以读到数据。

> 有人或许会思考，既然两个节点互为主从可以实现双主双写，哪能不能搞三个节点、四个节点呢？
>
> 答案是当然可以，不过没必要这么做，因为当需要上三主、四主....的项目，直接就做分库分表更实在，因为这种多主模式存在一个天大的弊端！！

#### MySQL分库分表思想

多主模式有一个天大的弊端！

这个弊端是指存储 `容量的上限` + `木桶` 效应，因为多主模式中的每个节点都会存储完整的数据，因此当数据增长达到硬件的最大容量时，就无法继续写入数据了，此时只能通过加大磁盘的形式进一步提高存储容量，但硬件也不可能无限制的加下去，而且由于多主是基于主从架构实现的，因为具备木桶效应，要加得所有节点一起加，否则另一个节点无法同步写入数据时，就会造成所有节点无法写入数据。

![image-20250528123343167](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528123343167.png)

### SQL优化策略

#### 分页优化（避免深度分页）

- 根据自增且连续主键排序的分页查询

```sql
select xx,xx,xx from t1 limit 100000,10; 
```

> 在`MySQL`的实际执行过程中，首先会查询出 `100010` 条数据，然后丢弃掉前面的 `10W` 条数据，将最后的 `10` 条数据返回，这个过程无异极其浪费资源。 

如果查询出的结果集，存在递增且连续的字段，可以基于有序字段来进一步做筛选后再获取分页数据，如下：

=>

```sql
select * from t1 where id > 99000 limit 2;
```

- 查询根据非主键字段排序的分页查询（延迟关联）

```sql
select * from t1 order by a limit 99000, 2;  
```

  =>

```sql
SELECT * FROM t1 f INNER JOIN (SELECT id FROM t1 ORDER BY a LIMIT 99000, 2) g ON f.id = g.id;
```

#### Join 语句优化（以小驱大）

> 多表查询时，一定要以小驱大。

所谓的 以小驱大 即是指用小的数据集去驱动大的数据集，说简单一点就是先查小表，再用小表的结果去大表中检索数据，其实在 `MySQL` 的优化器也会有驱动表的优化，当执行多表联查时，`MySQL`的关联算法为 `Nest Loop Join`，该算法会依照驱动表的结果集作为循环基础数据，然后通过该结果集中一条条数据，作为过滤条件去下一个表中查询数据，最后合并结果得到最终数据集，`MySQL`优化器选择驱动表的逻辑如下：

- ① 如果指定了连接条件，满足查询条件的小数据表作为驱动表。
- ② 如果未指定连接条件，数据总行数少的表作为驱动表。

> 举个例子感受一下两者之间的区别，假设`zz_student `学生表中有`10000`条数据，`zz_class `班级表中有 `100` 条数据，当需要关联这两张表查询数据时，`SQL`如下：
>
> ```sql
> -- 大表在前，小表在后
> select * from zz_student as s left join zz_class as c on s.class_id = c.class_id;
> -- 小表在前，大表在后
> select * from zz_class as c left join zz_student as s on c.class_id = s.class_id;
> ```
>
> 如果学生表在前作为驱动表，根据 `Nest Loop Join` 算法会循环一万次查询数据，而反之如果班级表在前，则只需要循环`100`次即可查询出数据。

```sql
select * from A left join B ON A.id = B.id
```

##### 简单嵌套循环连接（NLJ 算法）

算法很简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到 `result` 中...以此类推，驱动表A中的每一条记录与被驱动表B的记录进行判断：

![image-20250528151510349](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528151510349.png)

这种方式效率非常低，表A 数据 100 条，表B 数据 1000 条计算的话，则 A*B=10w次。

##### 被驱动表加索引 (Index NLJ算法）

优化思路：`减少内层表数据的匹配次数`，所以被驱动表必须加上索引。这样，通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表每条记录去比较，极大减少了对内层表的匹配次数。

![image-20250528151547045](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528151547045.png)

##### 块嵌套循环连接（BNL 算法）

优化思路：不再逐条获取驱动表的数据，而是一块一块的获取，引入了 `join buffer 缓冲区`，将驱动表 join 相关的部分数据列（大小受 join buffer 的限制）缓存到 `join buffer` 中，然后再全表扫描被驱动表，被驱动表的每一条记录一次性和 `join buffer` 中所有的驱动表记录进行匹配（内存中操作），将简单嵌套循环中的多次比较合并成一次，降低了被驱动表访问频率。

> 注意：这里缓存的不只是关联表的列，select 后面的列也会被缓存起来
>
> 在一个有 N 个 `join` 关联的sql中，会分配 N-1 个 `join buffer`。
>
> 所以查询的时候，尽量减少不必要的字段，可以让 `join buffer` 中可以存放更多的列。

![image-20250528151742535](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528151742535.png)

##### 总结

- 永远用小结果集驱动大结果集（本质就是减少外层循环的数据数量）
- 为被驱动表匹配的条件，增加索引（减少内层表的循环匹配次数）
- 适当增大 `join buffer` 大小（一次性缓存的数据越多，那么内层扫描次数就越少）
- 减少驱动表不必要的字段查询（字段越少，`join buffer` 所缓存的数据就越多）

#### 子查询优化

子查询执行效率不高的原因：

1. 执行子查询时，InnoDb 需要为内层查询语句的查询结果，建立一张 `临时表`，然后外层查询语句从临时表中查询记录。查询完后，再 `撤销这些临时表`。这样会消耗过多的 CPU 和 IO 资源
2. 子查询的结果集都放到了临时表，不管是内存临时表还是磁盘临时表，都不会存在索引，所以查询性能会受到影响。

优化思路：

可以尝试用 `join` 查询来替代子查询。连接查询不需要建立临时表，如果关联条件都用上了索引的话，性能会比较好。

#### 其他查询优化策略

##### in 和 exists

```sql
select * from A  where id in (select id from B)
select * from A where exists (select id from B where B.id = A.id)
```

- （1） 使用上的区别：`exists` 中放一个子查询有记录返回 true，无记录返回 false（NULL 也算有记录），`in` 中查询结果集只能有一个字
- （2） 性能上的区别：`in` 要把缓存到内存中，`exists` 不需要缓存结果
  - `in()` 适合 `驱动表`（A 表）数据 大于  `被驱动表` （B 表）
  - `exists()` 适合 `驱动表`（A 表）数据 小于  `被驱动表` （B 表）
- 当 A 表数据 与 B 表数据一样大时，`in` 与 `exists` 效率差不多，可任选一个使用

> 在这个查询中，驱动表（也称为外层表或主表）通常是指被最外层查询首先访问的表，而被驱动表（也称为内层表或从表）是嵌套查询中涉及的表。
>
> 根据这个查询：
>
> - 驱动表是A，因为查询从表A开始，试图找到满足条件的行。
> - 被驱动表是B，因为它的数据被用来确定哪些行应该从表A中检索。

- 当 A > B 时，用 `in()`，因为 `in()` 的实现，实现逻辑类似于：

```java
// 优化器可能将 IN 转换为类似 Hash Join：
HashSet B_ids = execute("SELECT id FROM B");  // 先物化 B 表
for (row in A) {
    if (B_ids.contains(row.id)) { ... }       // 快速哈希查找
}
```

> 当 B 表（被驱动表）较小时，哈希表构建成本低，此时即使 A 表较大，整体效率更高。

- 当 A < B 时，用 `exists()`，因为 `exists()` 的实现，相当于外表循环，实现逻辑类似于：

```java
for (row in A) {	// 驱动表 A 较小
    if (exists("SELECT 1 FROM B WHERE B.id = row.id")) {  // 利用 B 表索引
        ...
    }
}
```

> 当 A 表（驱动表）较小时，且 B 表连接字段有索引时，逐行查找效率高。

##### LIMIT 1 对优化的影响

如果确定结果集只有一条，那就加上 `limit 1`，加快查询速度

##### where + order by 建立联合索引

##### where 优于 having

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528152604274.png" alt="image-20250528152604274" style="zoom:50%;" />

`where` 效率高于`having`，能写在 `where` 限定的条件，就不要写在 `having` 中。

##### 查询时尽量不要使用*

其实主要有如下几方面的原因：

- ① 分析成本变高。
  - 一条 `SQL` 在执行前都会经过分析器解析，当使用 `*` 时，解析器需要先去解析出当前要查询的表上 `*` 表示哪些字段，因此会额外增加解析成本。
  - 但如果明确写出了查询字段，分析器则不会有这一步解析 `*` 的开销。

- ② 网络开销变大。
  - 当使用 `*` 时，查询时每条数据会返回所有字段值

- ③ 内存占用变高。
  - 当查询一条数据时都会将其 `结果集` 放入到 `BufferPool` 的数据缓冲页中，如果每次用 `*` 来查询数据，查到的 `结果集` 自然会更大，占用的内存也会越大，单个结果集的数据越大，整个内存缓冲池中能存下的数据也就越少，当其他`SQL`操作时，在内存中找不到数据，又会去触发磁盘`IO`，最终导致`MySQL`整体性能下降

#### 注意索引失效

- 不要使用 `like` 左模糊和全模糊查询

- 查询时尽量不要对字段做空值判断
  - 判断 `null` 的情况不会走索引
  - 如果想为空的字段，可以设计一个`0、""`这类空字符代替

- 不要在条件查询 `=` 前对字段做任何运算

  - ```sql
    select * from zz_users where user_id * 2 = 8;
    select * from zz_users where trim(user_name) = "熊猫";
    ```

- !=、!<>、not in、not like、or...要慎用

### 索引优化

#### explain 工具

![image-20250528164102639](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250528164102639.png)

- id
  - id 越大，执行优先级越高
- `select_type` 查询类型
  - `SIMPLE`
    - 简单的 `select` 查询语句，不包含 union、子查询语句
  - `UNION`
  - `SUBQUEPY`
    - 子查询
- `table`
  - 数据集，有可能是表名，子查询结果等
- `type` 当前语句执行的类型
  - `all`
    - 全表扫描
  - `index`
    - 索引全扫描
  - `range`
    - 索引范围扫描
  - `ref`
    - 非主键非唯一索引等值扫描
  - `eq_ref`
    - 主键索引(`primary key`)或者非空唯一索引(`unique not null`)等值扫描
    - a left join b on a.id = b.a_id
  - `const`
    - 通过索引一趟查找后就能获取到数据，基于唯一、主键索引字段查询数据时的情况
    - where id = 1
  - `system`
    - 表中只有一行数据，这是 const 的一种特例
- `possible_keys`
  - 可能用到的索引
- `key`
  - 具体使用的索引
  - `possible_keys` 有值，`key` 为空，多半是数据不多，直接全表扫描
  - `possible_keys`、`key` 都为空 未使用索引
- `key_len`
  - 索引字段长度，判断联合索引，匹配了几个
- `ref` 显示索引的哪一列被使用了
  - const
    - select ... where 主键字段 = 主键值
  - 具体的字段名
    - 表示目前会基于该字段查询数据
  - func
    - 当前索引字段匹配的值是一个函数
- `rows`
  - 预计会扫描的行数，不准
- `extra`
  - `Using index`
    - 表示查询的列均被 `索引覆盖`，无需回表
  - `Using where`
    - 表示查询的列未被索引覆盖，所以需要回表读取数据
  - `Using temporary`
    - 使用临时表，意味着 SQL 语句在执行 order by、group by、union 等操作的过程中，需要临时表来存储中间结果集
  - `Using filesort`
    - 使用文件排序，意味着 SQL 语句在进行 order by 操作的时候，所对应的列没有用到索引

> - SQL 语句在进行多表关联时，如果使用了非驱动表中的字段进行 order by 操作，就会在 Extra 列中出现 Using temporary 和 Using filesort。
> - 驱动表就是在 SQL 语句执行过程中，优先被读取的表，那非驱动表就是没有被优化读取的表。

#### 索引优化参考项

在做索引优化时，值得咱们参考的几个字段为：

- `key`：如果该值为空，则表示未使用索引查询，此时需要调整 `SQL` 或建立索引。
- `type`：这个字段决定了查询的类型，如果为 `index、all` 就需要进行优化。
- `rows`：这个字段代表着查询时可能会扫描的数据行数，较大时也需要进行优化。
- `filtered`：这个字段代表着查询时，表中不会扫描的数据行占比，较小时需要进行优化。
- `Extra`：这个字段代表着查询时的具体情况，在某些情况下需要根据对应信息进行优化。