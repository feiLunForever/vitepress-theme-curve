---
title: 数据结构
tags:
  - JAVA
categories:
  - JAVA
date: '2025-01-03'
description: 欢迎使用 Curve 主题，这是你的第一篇文章
articleGPT: 这是一篇初始化文章，旨在告诉用户一些使用说明和须知。
#cover: "/images/logo/logo.webp"
---
# 数据结构

# 数据结构

## List

### ArrayList

* **内部实现**：基于数组。
* **默认容量**：10。
* **扩容机制**：每次增加至原容量的1.5倍。
* **访问特性**：支持快速随机访问。
* **扩容缺点**：需要复制整个数组，效率较低。

#### 插入和删除元素的时间复杂度

对于插入：

* **头部插入**：O(n)，因需后移所有元素。
* **尾部插入**：通常O(1)，但扩容时O(n)。
* **指定位置插入**：O(n)，平均移动n/2个元素。

对于删除：

* **头部删除**：O(n)，因需前移所有元素。
* **尾部删除**：O(1)，直接移除末尾元素。
* **指定位置删除**：O(n)，平均移动n/2个元素。

### Vector

> ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，性能很差（用 `synchronized`​修饰 method）

### LinkList

* **存储结构**：基于链表。
* **适用场景**：适合动态插入和删除操作。
* **访问速度**：随机访问和遍历速度较慢。

#### 插入和删除元素的时间复杂度？

* **头部插入/删除**：O(1)，只需修改头结点指针。
* **尾部插入/删除**：O(1)，只需修改尾结点指针。
* **指定位置插入/删除**：O(n)，平均移动n/2个元素。

#### `ArrayList 和 LinkedList 的区别`​

* **数据结构**：

  * ArrayList：动态数组。
  * LinkedList：双向链表。
* **随机访问效率**：

  * ArrayList：较高。
  * LinkedList：较低，需线性查找。
* **增删效率**：

  * 非首尾操作：LinkedList 更高。
  * ArrayList：增删影响其他元素下标。
* **内存占用**：

  * LinkedList：更占内存，因节点含额外引用。
* **线程安全**：

  * ArrayList 和 LinkedList：均不保证线程安全。

> 使用建议
>
> * **频繁读取**：推荐使用 ArrayList。
> * **频繁插入/删除**：推荐使用 LinkedList。

### ArrayBlockingQueue

* **数据结构**：基于循环数组的有界阻塞队列。
* **容量特性**：队列容量固定。
* **排序原则**：按照FIFO（先进先出）原则排序。
* **元素顺序**：队列头部为最久元素，尾部为最新元素。

#### 特点

* **插入操作**：若队列已满，插入操作将阻塞，直到队列有空位。
* **检索操作**：若队列为空，检索操作将阻塞，直到队列有新元素。

#### 使用场景

适用于需要固定容量且线程安全的场景，如生产者-消费者模式。

#### 核心源码分析

源码解析

## Set

### HashSet

* **哈希值判断**：首先比较元素的哈希值。
* **equals 方法**：哈希值相同的情况下，通过`equals`​方法判断是否为同一元素。
* **处理冲突**：哈希值相同但`equals`​为`false`​的元素视为冲突，存储在同一哈希桶中。

### TreeSet

* **排序原理**：基于二叉树（红黑树）对新添加的元素进行排序。
* **排序方式**：默认为升序，可自定义排序规则。
* **对象要求**：

  * ​`Integer`​和`String`​对象可进行默认排序。
  * 自定义类对象需实现`Comparable`​接口并覆写`compareTo()`​方法。

## Map

### HashMap

> * 非线程安全的
> * key null 只能一个，value null 可以多个
> * 默认 16。扩容 2n，总是使用 2 的幂作为哈希表的大小
> * 链表 len>8 && 数组 size>64 会转换为 **红黑树**

#### 底层数据结构

* JDK 1.8之前：数组+链表，即链表散列。

* JDK 1.8之后：数组+链表/红黑树，提高效率。

#### **put 方法流程**

* 计算`key`​的`hash`​值。

  * ​`(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);`​
  * 实际是让 `key.hashCode()`​与 `key.hashCode() >>> 16`​ 进行异或操作，高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞。
  * ‍
* 计算插入的数组索引。

  * 计算下标 `index = (table.lenth - 1) & hash`​
* 判断`table[i]`​是否为`null`​或`TreeNode`​。

  * 如果是`TreeNode`​，直接在树中插入键值对。
  * 如果不是`TreeNode`​，开始遍历链表，判断链表长度是否 > 8

    * 如果 > 8 ，首先判断是否`tab.length`​是否 > 64

      * 如果> 64 转成红黑树，在树中执行插入操作
      * 如果<= 64 先扩容一次
    * 如果 <= 8，就在链表中执行插入

#### `resize 扩容`​​

* 键值对数量超过阈值时，或初始化时，调用resize方法进行扩容。
* 每次扩容大小为原来的2倍。
* 扩容后，Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。

> 这也是JDK1.8版本的一个优化的地方，在1.7 中，扩容之后需要重新去计算其`Hash`​值，根据`Hash`​值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断`(e.hash & oldCap)`​是否为0，重新进行`hash`​分配后，该元素的位置 要么`停留在原始位置`​，要么移动到`原始位置+增加的数组大小`​这个位置上。

因为hashMap在扩容时，都是翻两倍，比如16的容量扩大到32。HashMap进行扩容的方法是比较巧妙的，扩容后，与原来的下标`(n-1)&hash`​相对，其实只是多了`1`​bit位。

下面给出例子，比如从容量为16扩容到32时，画图表示：

​![image](/assets/image-20231205171318-qs8oys8.png)​

进行扩容，扩大到原来的两倍：

​![image](/assets/image-20231205171326-kyfacen.png)​

到这一步，下标`(n-1) & hash`​，扩容后的数据10101和原来的00101相比，其实就是多了1bit，10101是十进制的21，而21=5+16，就是“原位置+旧容量”，还有另外一种情况是保持为0的情况，这种情况是不改变位置的

#### `HashMap 的长度为什么是2的幂次方`​

为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。 这个算法应该如何设计呢?

* 我们首先可能会想到采用%取余的操作来实现。但是，重点来了:“取余(%)操作中如果除数是 2的幂次则等价于与其除数减一的与(&)操作(也就是说`hash%length==hash&(length-1)`​的 前提是 length 是2的 n 次方;)。”
* 并且采用二进制位操作 &，相对于%能够提高运算效 率，这就解释了 HashMap 的长度为什么是2的幂次方。

#### hashmap 死循环

* 头插法
* A -> B -> C
* T1 C -> B -> A
* T2 A -> B -> A
* ​![img](/assets/1698750028686-cef77360-5939-472b-8762-386da261a533-20231204140254-w99o26z.png)​

#### `JDK1.7 VS JDK1.8 比较`​

JDK1.8主要解决或优化了一下问题:

1. resize 扩容优化
2. 引入了红黑树，目的是避免单条链表过长而影响查询效率
3. 解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。

​![image](/assets/image-20231205164629-cqwx48a.png)​

### ConcurrentHashMap

* 1.7

  * ​`Segment[]`​ + `HashEntry[]`​ + `链表`​
  * ​`Segment`​ -> `hashEntry[]`​（hashmap）
  * ​`Segment`​ 初始化后补不能改变，并发能力（ReentrantLock），默认 16
  * ​![image](/assets/image-20231205172525-0d7ex50.png)​
* 1.8

  * ​`Node[]`​ + `链表 / 红黑树`​
  * ​`Synchronized`​ + `CAS`​
  * ​`synchronized`​只锁定当前链表或红黑二叉树的`首节点`​，这样只要`hash`​不冲突，就不会产生并发，效率又提升N倍
  * ​![image](/assets/image-20231205172611-jj9wgy5.png)​

### Hashtable

* 线程安全（`synchronized`​）
* 不允许有 `null`​ 键和 `null`​ 值，`NPE`​
* 默认 11，扩容 2n+1

## 树

### 二叉搜索树 BST

### 平衡二叉树 AVL

### B 树

### B+ 树

### 红黑树

* 性质

  * 根节点 黑
  * 叶子节点 黑
  * 红色节点不能连续（红色节点的孩子和父亲都是黑）
  * 任何路径上（根-> 叶子） 黑色节点数量一致
  * 与 4 阶 B 树等价
* 操作

  * 左旋

    * 右子节点 -> 父节点
    * 右子节点的左子节点 -> 旋转节点的右子节点
    * ​![image.png](/assets/net-img-1698829755575-094243d3-0953-4deb-817c-ae80392601bc-20231204142818-u3w6yf3.png)​
  * 右旋

    * 左子结点 -> 父节点
    * 左子结点的右子节点 -> 旋转节点的左子结点
    * ​![image.png](/assets/net-img-1698829827370-47e25228-ecc3-414d-8657-4410498dbe37-20231204142818-tvp2ckp.png)​
  * 变色
* 插入

  * **场景 1：红黑树为空树**

    * 红黑树的性质 2：根结点必须是黑色
    * **处理**：直接把插入结点设成黑色并作为根结点
  * **场景 2：插入结点的 key 已存在**

    * 直接替换（已平衡）
  * **场景 3：插入结点的父结点为黑色**

    * 插入的结点默认是红色的，当它的父结点是黑色时，并不会破坏平衡
  * **场景 4：插入结点的父结点为红色**

    * **如果插入结点的父结点为红色，那么父结点不可能为根结点，所以插入结点总是存在祖父结点。这点很重要，后续的旋转操作需要祖父结点的参与。**
    * **场景 4.1：存在叔父结点，且为红色**

      * **由红黑树性质 4 可知：红色结点不能连续。那么此时该插入子树的红黑层数的情况是：黑-红-红。显然最简单的处理方式就是将其改为：红-黑-红。**
      * 父结点和叔父结点-> 黑色
      * 祖父结点-> 红色
      * ​![image.png](/assets/net-img-1698749874969-358eb457-6607-42c7-95bf-d06f01685037-20231204142818-0n9vz5m.png)​
    * **场景 4.2：叔父结点不存在或为黑色，插入结点的父结点是祖父结点的左子结点**

      * **这种场景下，叔父结点所在的子树的黑色结点就比父结点所在子树的多，不满足红黑树的性质 5。**
      * ​![image.png](/assets/net-img-1698831317526-c1f2ab2f-dcd1-4393-a89c-20f6efbbd024-20231204142818-w3mbwyd.png)​
      * **场景 4.2.1：插入结点是左子树**

        * 父结点 -> 黑色
        * 祖父结点 -> 红色
        * 祖父结点右旋
        * ​![image.png](/assets/net-img-1698749885952-459e69e3-b397-4dc3-90b9-65adf6698819-20231204142819-dpbtj7x.png)​
      * **场景 4.2.2：插入结点是右子树**

        * 将父结点进行左旋
        * 左旋后，满足 4.2.1
        * ​![image.png](/assets/net-img-1698749892270-b5dbd726-c430-4fa2-93e8-7aa7cde73b64-20231204142819-j4lh1cv.png)​
    * **场景 4.3：叔父结点不存在或为黑色，插入结点的父结点是祖父结点的右子结点**

      * 相当于场景 4.2 的方向反转
      * **场景 4.3.1：插入结点是左子树**

        * 父结点 -> 黑色
        * 祖父结点 -> 红色
        * 祖父结点左旋
        * ​![image.png](/assets/net-img-1698749901751-220a33bc-531c-4de1-983a-ccaefc06b33f-20231204142819-xak0f53.png)​
      * **场景 4.3.2：插入结点是右子树**

        * 将父结点进行右旋
        * 右左旋后，满足 4.3.1
        * ​![image.png](/assets/net-img-1698749908233-24f80b18-9bba-4926-b561-83123f04606a-20231204142819-hmtii5g.png)​
  * 删除

    * 删除节点无子节点

      * 直接删
    * 删除节点只有一个子节点

      * 子节点替换
    * 删除节点有两个子节点

      * 后继结点替换（大于删除节点的最小节点）

‍
