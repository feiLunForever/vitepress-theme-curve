# 网络

## OSI 七层模型

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614171805175.png" alt="image-20250614171805175" style="zoom:60%;" />

### 应用层

- 计算机用户与网络之间的接口
- 常见的协议有：HTTP、FTP、 SMTP、TELNET

### 表示层

- 数据的表示、安全、压缩
- 将应用处理的信息转换为适合网络传输的格式

### 会话层

- 建立和管理本地主机与远程主机之间的会话

### 传输层

- 定义传输数据的协议端口号，以及流控和差错校验，保证报文能正确传输
- 协议有 TCP、UDP

### 网络层

- 进行逻辑地址寻址，实现不同网络之间的路径选择
- 协议有 IP、ICMP

### 数据链路层

- 每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的
- 在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路

### 物理层

- 建立、维护、断开物理连接。

## TCP/IP 四层模型

### 应用层

- 应用层、表示层、会话层

### 传输层

- 对应 OSI 的传输层
- 为应用层实体提供端到端的通信功能，保证了数据 包的顺序传送及数据的完整性

### 网际层

- 对应于 OSI 参考模型的网络层
- 主要解决主机到主机的通信问题

### 网络接口层

- 数据链路层、物理层

## 五层体系结构

### 应用层

- 应用层、表示层、会话层

### 传输层

- 对应 OSI 的传输层
- 为应用层实体提供端到端的通信功能，保证了数据 包的顺序传送及数据的完整性

### 网络层

- 对应于 OSI 参考模型的网络层
- 主要解决主机到主机的通信问题

### 数据链路层

### 物理层

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614171838542.png" alt="image-20250614171838542" style="zoom:70%;" />

## TCP 报文

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614171857234.png" alt="image-20250614171857234" style="zoom:80%;" />

### 源端口、目的端口

- 表示数据从哪个进程来，去往哪个进程

### 序号

- TCP 连接中传送的数据每一个字节都会有一个序号

### 确认号

- 另一方发送的 tcp 报文段的响应

### 数据偏移

- 表示 TCP 报文段的数据距离 TCP 报文段的起始处有多远

### 6 位标志位

- URG

  - 紧急指针是否有效
- ACK

  - 确认号是否有效
- PSH

  - 提示接收端应用程序立刻将数据从 tcp 缓冲区读走
- RST

  - 表示要求对方重新建立连接
- SYN

  - 这是一个连接请求或连接接受的报文
- FIN

  - 告知对方本端要关闭连接

### 窗口大小

- 用于 TCP 流量控制，告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。

### 校验和

- 由发送端填充，接收端对 TCP 报文段执行 CRC 算法以检验 TCP 报文段在传输过程中是否损坏。

### 紧急指针

- 它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号，用于发送端向接收端发送紧急数据。

## TCP 和 UDP

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614171917229.png" alt="image-20250614171917229" style="zoom:40%;" />

### TCP

- 面向连接(如打电话需要先拨号)
- 提供可靠的服务
- 面向字节流
- 数据传输慢
- 适用于邮件、文件传输

### UDP

- 面向无连接(即发送数据前不需要 建立连接)
- 无法保证
- 面向报文
- 数据传输快
- 适用于语音广播，直播

## TCP 三次握手

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614171938537.png" alt="image-20250614171938537" style="zoom:40%;" />

- 客户端发送(seq=x)，客户端进入 SYN_SEND 状态

  - 我想建立连接
- 服务端响应(Seq=y, Ack=x+1)，服务器端就进入 SYN_RCV 状态

  - 好，我收到了，你能收到我的消息吗
- 客户端收到服务端的确认后，发送(Ack=y+1)，客户端进入 ESTABLISHED 状态；当服务器端接收到这个包时，也进入 ESTABLISHED 状态

  - 我能收到

## TCP 四次挥手

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614171959051.png" alt="image-20250614171959051" style="zoom:40%;" />

- 客户端向服务端发送连接释放报文

  - 我没有需要的数据了，现在可以关闭了
- 服务端收到连接释放报文后，立即发出确认报文。这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据

  - 好，我知道了，但是我这边还没传完
- 服务端向客户端发送连接释放报文

  - 我传完了，我这边要关闭了
- 客户端收到服务端的连接释放报文后，立即发出确认报文。

  - 好，江湖再见

## TCP 四次挥手过程中，为什么需要等待 2MSL,才进入 CLOSED 关闭状态

### 目的

- 为了保证客户端发送的最后一个 ACK 报文段能够到达服务端

### 背景

- MSL 是报文段在网络上最大存活时间
- 2MSL 的时间是从客户端(A)接收到 FIN 后发送 ACK 开始计时的
- 如果在 TIME-WAIT 时间内，因为客户端(A)的 ACK 没有传输到服务端(B)，客户端(A)又接收到了服务端(B)重发的 FIN 报文，那么 2MSL 时间会被重置

### 使得原来连接的数据包在网络中消失

- 最坏情况是：去向 ACK 消息最大存活时间（MSL) + 来向 FIN 消息的最大存活时间(MSL)。这刚好是 2MSL

### 保证 ACK 能被服务端接收到从而正确关闭链接

- 假设客户端不等待 2MSL ，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就无法正常的进入关闭连接状态

## TCP 的重传机制

### 超时重传

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614172016879.png" alt="image-20250614172016879" style="zoom:60%;" />

- 在发送数据报文时，设定一个定时器，每间隔一段时间间隔，如果没收到对方的 ACK 应答报文，就会重发该报文

#### 缺点

- 当一个报文段丢失时，会等待一定的超时周期然后才重传分组，增加了端到端的时延
- 当一个报文段丢失时，在其等待超时的过程中，可能会出现这种情况:
  其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间

### 快速重传

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614172032582.png" alt="image-20250614172032582" style="zoom:70%;" />

- 不以时间驱动，而是以数据驱动。它基于接收端的反馈信息来引发重传

#### 过程

- 发送端发送了 1，2，3，4，5,6 份数据
- 第一份 Seq=1 先送到了，于是就 Ack 回 2
- 第二份 Seq=2 也送到了，假设也正常，于是 ACK 回 3
- 第三份 Seq=3 由于网络等其他原因，没送到
- 第四份 Seq=4 也送到了，但是因为 Seq3 没收到。所以 ACK 回 3
- 后面的 Seq=4,5 的也送到了，但是 ACK 还是回复 3，因为 Seq=3 没收到
- 发送端连着收到三个重复冗余 ACK=3 的确认，便知道哪个报文段在传输过程中丢失了，
  于是在定时器过期之前，重传该报文段
- 最后，接收到收到了 Seq3，此时因为 Seq=4，5，6 都收到了，于是 ACK 回 7

#### 问题

- ACK 只向发送端告知最大的有序报文段，到底 是哪个报文丢失了呢?
  并不确定

### 带选择确认的重传

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614172104853.png" alt="image-20250614172104853" style="zoom:50%;" />

- 在快速重传的基础上，接收端返回最近收到的报文段的序列号范围
- 这样发送端就知道接收端哪些数据包没收到

## TCP 的粘包和拆包

### 概念

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614172119150.png" alt="image-20250614172119150" style="zoom:30%;" />

- TCP 是面向流，没有界限的一串数据
- TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分
- 一 个完整的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送

### 原因

- 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包
- 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包
- 待发送数据大于 MSS(最大报文长度)，TCP 在传输前将进行拆包。即 TCP 报文长度-TCP 头部长度 >MSS

### 解决方案

- 发送端将每个数据包封装为固定长度
- 在数据尾部增加特殊字符进行分割
- 将数据分为两部分，一部分是头部，一部分是内容体;
  其中头部结构大小固定，且有一个字段声明内容体的大小

## TCP 协议是如何保证数据的顺序

- 大数据拆包成多个片段，对每个片段用 Sequence Number 编号，接收数据的时候，通过 Seq 进行排序
- <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180239071.png" alt="image-20250614180239071" style="zoom:80%;" />

## TCP 的滑动窗口

### 概念

TCP 头部有个字段叫 win，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到流量控制的目的

### 产生原因

- TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。
  这样的话就会有个缺点:效率会比较低
- 为了解决这个问题，TCP 引入了窗口，它是操作系统开辟的一个缓存空间

### 分类

#### 发送窗口

- 已发送且已收到 ACK 确认
- 已发送但未收到 ACK 确认
- 未发送但可以发送
- 未发送也不可以发送
- <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180257152.png" alt="image-20250614180257152" style="zoom:60%;" />

#### 接收窗口

- 已成功接收并确认
- 未收到数据但可以接收
- 未收到数据并不可以接收的数据
- <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180320049.png" alt="image-20250614180320049" style="zoom:60%;" />

## TCP 的流量控制

### 原因

- TCP 三次握手完成，发送方和接收方就可以开始传输数据
- 但是发送方不能疯狂地向接收方发送数据，因为接收方接收不过来的话，接收方就只能把处理不过来的数据存在缓存区里了
- 如果缓存区都满了，发送方还在疯狂发送数据的话，接收方只能把收到的数据包丢掉，这就浪费了网络资源

### 简要流程

- 首先双方三次握手，初始化各自的窗口大小，假设均为 400 个字节
- 假如当前发送方给接收方发送了 200 个字节，那么，发送方的 SND.NXT 会右移 200 个字节，也就是说当前的可用窗口减少了 200 个字节
- 接受方收到后，放到缓冲队列里面，REV.WND =400-200=200 字节，所以 win=200 字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口 200 字节
- 发送方又发送 200 字节过来，200 字节到达，继续放到缓冲队列。不过这时候， 由于大量负载的原因，接受方处理不了这么多字节，只能处理 100 字节，剩余的 100 字节继续放到缓冲队列。这时候，REV.WND = 400-200-100=100 字节， 即 win=100 返回发送方
- 发送方继续干活，发送 100 字节过来，这时候，接受窗口 win 变为 0
- 发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到 win > 0，才继续开始发送

## TCP 拥塞控制

### 背景

- 目标主要是最大化利用网络上瓶颈链路的带宽
- 发送方维护一个拥塞窗口的变量，用来估算在一段时间内这条链路可以承载和运输的数据的数量
- 只要网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据包发送出去，但只要网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数

### TCP 拥塞控制和流量控制区别

- 流量控制是为了解决发送方和接收方速度不同而导致的数据丢失问题,当发送方发送的太快,接收方来不及接受就会导致数据丢失,流量控制用滑动窗口的形式解决问题
- 拥塞控制是为了解决过多的数据注入到网络,导致网络奔溃,超过负荷.当发送方发送数据大量的数据会注入到网络,如果没有限制,网络就会超负荷变卡,拥塞控制的用的是拥塞窗口解决的问题的

### 分类

#### 慢启动

- TCP 建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度
- 由小到大逐渐增加 拥塞窗口的大小，如果没有出现丢包，每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1
- 每轮次发送窗口增加一倍，呈指数增长
- 如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段
- <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180340855.png" alt="image-20250614180340855" style="zoom:80%;" />

#### 拥塞避免

- 慢启动阀值 ssthresh 是 65535 字节，cwnd 到达慢启动阀值后

  - 每收到一个 ACK 时，cwnd = cwnd + 1/cwnd
  - 当每过一个 RTT 时，cwnd = cwnd + 1
- <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180354676.png" alt="image-20250614180354676" style="zoom:80%;" />

#### 拥塞发生

当网络拥塞发生丢包时，会有两种情况:

- RTO 超时重传
- 快速重传

##### RTO 超时重传

- 使用拥塞发生算法

  - 慢启动阀值 sshthresh = cwnd /2
  - cwnd 重置为 1
  - 进入新的慢启动过程

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180411295.png" alt="image-20250614180411295" style="zoom:60%;" />

这真的是辛辛苦苦几十年，一朝回到解放前。其实还有更好的处理方式，就是快速重传。

##### 快速重传

- 发送方收到 3 个连续重复的 ACK 时，就会快速地重传，不必等待 RTO 超时再重传
- 拥塞窗口大小 cwnd = cwnd/2
- 慢启动阀值 ssthresh = cwnd
- 进入快速恢复算法

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180427055.png" alt="image-20250614180427055" style="zoom:30%;" />

#### 快速恢复

快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。

正如前面所说，进入快速恢复之前，cwnd 和 sshthresh 已被更新:

- cwnd = cwnd /2
- sshthresh = cwnd

然后，真正的快速算法如下:

- cwnd = sshthresh + 3
- 重传重复的那几个 ACK(即丢失的那几个数据包)
- 如果再收到重复的 ACK，那么 cwnd = cwnd +1
- 如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。
- <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180450458.png" alt="image-20250614180450458" style="zoom:70%;" />

## TCP 保证传输过程的可靠性

> - 连接和断开的可靠性(三次握手，四次挥手)
> - 有状态(哪些数据发送了，哪些没发)
> - 可控制(超时重传、流量控制、拥塞控制等)

首先，TCP 的连接是基于三次握手，而断开则是基于四次挥手。确保连接和断开的可靠性。

其次，TCP 的可靠性，还体现在有状态：TCP 会记录哪些数据发送了，哪些数据被接收了，哪些没有被接受，并且保证数据包按序到达，保证数据传输不出差错。

再次，TCP 的可靠性，还体现在可控制：它有数据包校验、ACK 应答、**超时重传(发送方)** 、失序数据重传(接收方)、丢弃重复数据、流量控制(滑动窗口) 和拥塞控制等机制。

## HTTP 协议

- 基于 TCP 协议实现，是一个超文本传输协议
- 超文本

  - 用超链接，将各种不同空间的文字信息组织在一起的网状文本
  - 比如说 html，内部定义了很多图片视频的链接，放在浏览器上就呈现出了画面
- 协议

  - 约定俗成的东西，彼此之间共同约定好的就叫做协议
- 传输

## GET 和 POST

|**区别**|**GET**|**POST**|
| ----------------| -------------------------------------------------------------------------------------------| ---------------------------------------------------|
|数据传输方式|从服务器获取数据|向服务器提交数据|
|对数据长度的限制|当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）|无限制|
|对数据类型的限制|只允许 ASCII 字符|无限制|
|安全性|较差，所发送的数据是 URL 的一部分，会显示在网页上|较好，参数不会被保存在浏览器历史或 WEB 服务器日志中|
|可见性|显示在 URL 上|不显示|
|收藏为书签|可以|不可以|
|历史记录|可以被保留在历史记录当中|不可以被保留|
|缓存|能被缓存|不可以被缓存|

### 对数据长度的限制

- GET 方法向 URL 添加数据，URL 的最大长度是 2048 个字符
- POST 方法无限制

### 数据类型的限制

- GET 只允许 ASCII 字符
- 无限制

### 安全性和可见性

- GET 参数显示在 URL 上
- POST 方法 无

## HTTP 常用的请求方式

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180514467.png" alt="image-20250614180514467" style="zoom:20%;" />

## HTTP 状态码

|**1xx**|**信息，服务器收到请求，需要请求者继续执行操作**|
| ---| ----------------------------------------------|
|2xx|成功，操作被成功接收并处理|
|3xx|重定向，需要进一步的操作以完成请求|
|4xx|客户端错误，请求包含语法错误或无法完成请求|
|5xx|服务器错误，服务器在处理请求的过程中发生了错误|

## HTTP1.0、1.1 和 HTTP 2.0

### HTTP 1.0

- 默认使用短连接，每次请求都需要建立一个 TCP 连接
- 可以设置 Connection: keep-alive，强制开启长连接

### HTTP 1.1

- TCP 连接默认不关闭，可以被多个请求复用
- 分块传输编码，即服务端每产生一块数据，就发送一块
- 管道机制，即在同一个 TCP 连接里面，客户端可以同时发送多个请求

### HTTP 2.0

- 完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应， 而且不用按照顺序一一对应
- 服务端推送，允许服务器未经请求，主动向客户端发送资源
- 报头压缩，头信息压缩机制

## HTTP 与 HTTPS

### 原因

- HTTP 基于 TCP/IP 通信协议来传递明文数据
- 请求信息是明文传输，容易被窃听截取
- 没有验证对方身份，存在被冒充的风险
- 数据的完整性未校验，容易被中间人篡改

### https

- HTTPS = HTTP + SSL/TLS
- 在 HTTP 的基础上加入了 SSL/TLS 协议，SSL/TLS 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密

## HTTPS 访问流程

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180534713.png" alt="image-20250614180534713" style="zoom:50%;" />

> - 一般情况下，客户端与服务器都是采用对称加密（加密和解密使用同一密钥 ）
> - 缺点：如何安全将密钥传输给另一方，如果秘钥被窃取，那就凉凉
> - HTTPS 就是解决这个问题，服务器将公钥发给客户端，客户端用公钥将自己的秘钥加密，服务器用自己的私钥解密后，就得到了客户端的秘钥。
> - 这样客户端，服务器就可以用秘钥进行对称加密了
> - 一个问题，服务器如何安全把自己的公钥发给客户端，就用 CA 认证，证书证明自己的合法性

- 客户端发起 Https 请求，连接到服务器的 443 端口
- 服务器必须要有一套数字证书(证书内容有公钥、证书颁发机构、失效日期等)
- 服务器将自己的数字证书发送给客户端(公钥在证书里面，私钥由服务器持有)
- 客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密
- 客户端将公钥加密后的密钥发送到服务器
- 服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦
- 服务器将加密后的密文返回到客户端
- 客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据

## HTTP 协议是无状态

- 当浏览器第一次发送请求给服务器时，服务器响应了
- 如果同个浏览器发第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器

## 对称加密与非对称加密

### 对称加密

- 加密和解密使用同一密钥
- 优点是运算速度较快
- 缺点是如何安全将密钥传输给另一方
- 常见的对称加密算法有:DES、AES 等

### 非对称加密

- 公钥与私钥配对出现
- 公钥对数据加密，私钥对数据解密
- 常用的如：RSA、DSS

## 浏览器地址栏输入 url 到显示主页的过程

- 解析网址，生成 HTTP 请求信息
- 根据 DNS 服务器查询真实请求的 IP 地址，如果本地服务器有缓存则直接返回
- 得到了 IP 以后，向服务器发送 TCP 连接，TCP 连接经过三次握手
- 接收 TCP 报文后，对连接进行处理，对 HTTP 协议解析
- 服务器返回响应
- 浏览器接收响应，显示页面，渲染页面
- TCP 四次挥手，连接结束

## DNS 的解析过程

- 首先会查找浏览器的缓存,看看是否能找到 www.baidu.com 对应的 IP 地址， 找到就直接返回
- 将请求发往给本地 DNS 服务器，如果查找到也直接返回，否则继续进行下一步
- 本地 DNS 服务器向根域名服务器发送请求，根域名服务器返回负责.com 的顶级域名服务器的 IP 地址的列表
- 本地 DNS 服务器再向其中一个负责.com 的顶级域名服务器发送一个请求，返回负责.baidu 的权威域名服务器的 IP 地址列表
- 本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，返回 www.baidu.com 所对应的 IP 地址

## 负载均衡

### DNS

- ⼀般⽤于实现地理级别的负载均衡，不同地域的⽤户通过 DNS 的解析可以返回不同的 IP 地址
- 负载均衡简单，但是扩展性太差，控制权在域名服务商

### 部署 Nginx 等反向代理

- 部署简单，成本低，⽽且容易扩展

## Session 和 Cookie

### Cookie

- Cookie 是保存在客户端的一小块文本串的数据
- 客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来
- 在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器
- 服务器就是根据这个 Cookie 来确认身份的

### session

- 服务器和客户端一次会话的过程
- Session 对象存储着特定用户会话所需的属性及配置信息，包括 cookie

### 区别

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180554735.png" alt="image-20250614180554735" style="zoom:40%;" />

### 流程

- 用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器， 浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入 Cookie 中， 同时 Cookie 记录此 SessionID 是属于哪个域名。
- 当用户第二次访问服务器时，请求会自动判断此域名下是否存在 Cookie 信息， 如果存在，则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获 取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到， 说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行 后面操作。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180611709.png" alt="image-20250614180611709" style="zoom:35%;" />

## 分布式 Session

### 客户端存储

- 直接将信息存储在 cookie 中

### 共享 Session

- 将用户的 Session 等信息使用缓存中间件，如 redis

## 网络攻击

### CSRF 攻击

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180630836.png" alt="image-20250614180630836" style="zoom:80%;" />

- 跨站请求伪造

#### 过程

- Tom 登陆银行，没有退出，浏览器包含了 Tom 在银行的身份认证信息
- 黑客 Jerry 将伪造的转账请求，包含在在帖子
- Tom 在银行网站保持登陆的情况下，浏览帖子
- 将伪造的转账请求连同身份认证信息，发送到银行网站
- 银行网站看到身份认证信息，以为就是 Tom 的合法操作，最后造成 Tom 资金损失

#### 解决方案

- 检查 Referer 字段。HTTP 头中有一个 Referer 字段，这个字段用以标明请求来源于哪个地址
- 添加校验 token （添加 token 时，判断如果是本网站生成的，则添加）

### XSS 攻击

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180648322.png" alt="image-20250614180648322" style="zoom:70%;" />

- 跨站脚本攻击

#### 过程

- 发送带有恶意的 xss 脚本链接
- 用户点击了链接，访问正常的服务器
- 服务器将正常的页面以及 xss 返回给用户
- 用户浏览器解析了 xss，做了一些泄密的请求，GG

#### 解决方案

- 不相信用户的输入，对输入进行过滤，过滤标签等，只允许合法值
- HTML 转义
- 对于链接跳转，如 <a href="xxx" 等，要校验内容，禁止以 script 开头的非法链接
- 限制输入长度等等

### DDoS 攻击

- 对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务

#### 解决方案

- 高防服务器
- 黑名单

## IP 和 mac

- ip 可变，mac 不可变，一般配合使用
- 同一子网的 IP 地址的前缀是一样的，如果只用 mac 的话，需要记录每个 mac 地址在哪个子网上，浪费空间
- IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的

## ARP 协议

> 地址解析协议，是一个由 IP 地址获取 MAC 物理地址的 TCP/IP 协议

### 为什么需要 ARP 协议

- 在网络访问层中，同一局域网中的一台主机要和另一台主机进行通信，需要通过 MAC 地址进行定位，然后才能进行数据包的发送
- 而在网络层和传输层中，计算机之间是通过 IP 地址定位目标主机，对应的数据报文只包含目标主机的 IP 地址，而没有 MAC 地址
- 因此，在发送之前需要根据 IP 地址获取 MAC 地址，然后才能将数据包发送到正确的目标主机，而这个获取过程是通过 ARP 协议完成的

### 工作流程

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250614180707924.png" alt="image-20250614180707924" style="zoom:40%;" />

- 当主机 A 与主机 B 要通信时
- 查询本地 ARP 缓存表,看是否有 IP 地址及其对应的 MAC 地址
- 如果没匹配到主机 B 的 MAC 地址，主机 A 会在局域网内广播发送一个 ARP 请求分组，局域网内所有主机都会收到该请求分组
- 主机 B 收到请求分组报文，发现报文中的 IP 与自己匹配，就 A 的 IP 和 MAC 地址添加到本地 ARP 缓存表中
- 主机 B 向主机 A 响应一个含自身 MAC 地址的报文
- 主机 A 收到报文后，将 B 的 IP 和 MAC 地址添加至 ARP 缓存表中

## URI 和 URL

### URI

- 统一资源标志符
- 唯一标识一个资源

### URL

- 统一资源定位符
- 提供资源的路径

> URI 像是身份证，可以唯一标识一个 人，而 URL 更像一个住址，可以通过 URL 找到这个人