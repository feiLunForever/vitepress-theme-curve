# 设计

## 数组设计类

### 380.「 [常数时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)」

> 实现RandomizedSet 类：
>
> - RandomizedSet() 初始化 RandomizedSet 对象
> - bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。
> - bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。
> - int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 **相同的概率** 被返回。
>
> 你必须实现类的所有函数，并满足每个函数的 **平均** 时间复杂度为 O(1) 。

就是让我们实现如下一个类：

```java
class RandomizedSet {
public:
    /** 如果 val 不存在集合中，则插入并返回 true，否则直接返回 false */
     bool insert(int val) {}
  
    /** 如果 val 在集合中，则删除并返回 true，否则直接返回 false */
    bool remove(int val) {}
  
    /** 从集合中等概率地随机获得一个元素 */
    int getRandom() {}
}
```

本题的难点在于两点：

**1、插入，删除，获取随机元素这三个操作的时间复杂度必须都是 O(1)** 。

**2、getRandom 方法返回的元素必须等概率返回随机元素**，也就是说，如果集合里面有 n 个元素，每个元素被返回的概率必须是 1/n。

我们先来分析一下：对于插入，删除，查找这几个操作，哪种数据结构的时间复杂度是 O(1)？

HashSet 肯定算一个对吧。哈希集合的底层原理就是一个大数组，我们把元素通过哈希函数映射到一个索引上；如果用拉链法解决哈希冲突，那么这个索引可能连着一个链表或者红黑树。

那么请问对于这样一个标准的 HashSet，你能否在 O(1) 的时间内实现 getRandom 函数？

其实是不能的，因为根据刚才说到的底层实现，元素是被哈希函数「分散」到整个数组里面的，更别说还有拉链法等等解决哈希冲突的机制，所以做不到 O(1) 时间「等概率」随机获取元素。

除了 HashSet，还有一些类似的数据结构，比如哈希链表 LinkedHashSet，我们后文 [手把手实现LRU算法](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-daeca/suan-fa-ji-03840/) 和 [手把手实现LFU算法](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-daeca/suan-fa-ji-181f9/) 讲过这类数据结构的实现原理，本质上就是哈希表配合双链表，元素存储在双链表中。

但是，LinkedHashSet 只是给 HashSet 增加了有序性，依然无法按要求实现我们的 getRandom 函数，因为底层用链表结构存储元素的话，是无法在 O(1) 的时间内访问某一个元素的。

根据上面的分析，对于 getRandom 方法，如果想「等概率」且「在 O(1) 的时间」取出元素，一定要满足：**底层用数组实现，且数组必须是紧凑的**。

这样我们就可以直接生成随机数作为索引，从数组中取出该随机索引对应的元素，作为随机元素。

**但如果用数组存储元素的话，插入，删除的时间复杂度怎么可能是 O(1) 呢**？

可以做到！对数组尾部进行插入和删除操作不会涉及数据搬移，时间复杂度是 O(1)。

**所以，如果我们想在 O(1) 的时间删除数组中的某一个元素 val，可以先把这个元素交换到数组的尾部，然后再 pop 掉**。  
交换两个元素必须通过索引进行交换对吧，那么我们需要一个哈希表 valToIndex 来记录每个元素值对应的索引。

有了思路铺垫，我们直接看代码：

```java
class RandomizedSet {

    private final ArrayList<Integer> data = new ArrayList<>(); // 存放元素的值

    private final Map<Integer, Integer> val2Index = new HashMap<>(); // key -> item, value -> index

    private final Random random = new Random();

    public RandomizedSet() {

    }

    public boolean insert(int val) {
        if (!val2Index.containsKey(val)) {  // 若val不存在，插入到nums尾部，并记录val对应的索引值
            val2Index.put(val, data.size());
            data.add(val);
            return true;
        }
        return false; // 若 val 已存在，不用再插入
    }

    public boolean remove(int val) {
        if (val2Index.containsKey(val)) {
            int index = val2Index.get(val); // 需要删除节点的下标
            int last = data.get(data.size() - 1); // 当前最后一个值
            data.set(index, last); // 将最后一个值的下标替换成要删除节点的下标
            val2Index.put(last, index); // 更新索引映射
            data.remove(data.size() - 1); // 删除最后一个值
            val2Index.remove(val); // 删除索引映射
            return true;
        }
        return false;
    }

    public int getRandom() {
        return data.get(random.nextInt(data.size()));
    }
}
```

注意 remove(val) 函数，对 nums 进行插入、删除、交换时，都要记得修改哈希表 valToIndex，否则会出现错误。  
至此，这道题就解决了，每个操作的复杂度都是 O(1)，且随机抽取的元素概率是相等的。

### 710.「 [黑名单中的随机数](https://leetcode.cn/problems/random-pick-with-blacklist/)」

> 给定一个整数 `n`​ 和一个 **无重复** 黑名单整数数组 `blacklist`​ 。设计一种算法，从 `[0, n - 1]`​ 范围内的任意整数中选取一个 **未加入** 黑名单 `blacklist`​ 的整数。任何在上述范围内且不在黑名单 `blacklist`​ 中的整数都应该有 **同等的可能性** 被返回。
>
> 优化你的算法，使它最小化调用语言 **内置** 随机函数的次数。
>
> 实现 Solution 类:
>
> - Solution(int n, int[] blacklist) 初始化整数 n 和被加入黑名单 blacklist 的整数
> - int pick() 返回一个范围为 [0, n - 1] 且不在黑名单 blacklist 中的随机整数

pick 函数会被多次调用，每次调用都要在区间 [0,N) 中「等概率随机」返回一个「不在 blacklist 中」的整数。

这应该不难理解吧，比如给你输入 N = 5, blacklist = [1,3]，那么多次调用 pick 函数，会等概率随机返回 0, 2, 4 中的某一个数字。

**而且题目要求，在 pick 函数中应该尽可能少调用随机数生成函数 rand()** 。

这句话什么意思呢，比如说我们可能想出如下拍脑袋的解法：

```java
int pick() {
    int res = rand() % N;
    while (res exists in blacklist) {
        // 重新随机一个结果
        res = rand() % N;
    }
    return res;
}
```

这个函数会多次调用 rand() 函数，执行效率竟然和随机数相关，不是一个漂亮的解法。

**聪明的解法类似上一道题，我们可以将区间 [0,N) 看做一个数组，然后将 blacklist 中的元素移到数组的最末尾，同时用一个哈希表进行映射**：

根据这个思路，我们可以写出第一版代码（还存在几处错误）：

```cpp
class Solution {
public:
    int sz;
    unordered_map<int, int> mapping;
  
    Solution(int N, vector<int>& blacklist) {
        // 最终数组中的元素个数
        sz = N - blacklist.size();
        // 最后一个元素的索引
        int last = N - 1;
        // 将黑名单中的索引换到最后去
        for (int b : blacklist) {
            mapping[b] = last;
            last--;
        }
    }
};
```

![1675059905042-91d03a09-9826-455f-9386-2df19115d98e](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059905042-91d03a09-9826-455f-9386-2df19115d98e-20240325155004-mv9m2zc.jpeg)  
如上图，相当于把黑名单中的数字都交换到了区间 [sz, N) 中，同时把 [0, sz) 中的黑名单数字映射到了正常数字。

根据这个逻辑，我们可以写出 pick 函数：

```cpp
int pick() {
    // 随机选取一个索引
    int index = rand() % sz;
    // 这个索引命中了黑名单，
    // 需要被映射到其他位置
    if (mapping.count(index)) {
        return mapping[index];
    }
    // 若没命中黑名单，则直接返回
    return index;
}
```

这个 pick 函数已经没有问题了，但是构造函数还有两个问题。

**第一个问题**，如下这段代码：

```cpp
int last = N - 1;
// 将黑名单中的索引换到最后去
for (int b : blacklist) {
    mapping[b] = last;
    last--;
}
```

我们将黑名单中的 b 映射到 last，但是我们能确定 last 不在 blacklist 中吗？

比如下图这种情况，我们的预期应该是 1 映射到 3，但是错误地映射到 4：

![1675059905050-804691bd-2915-443d-ad75-2c3ce94b167f](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059905050-804691bd-2915-443d-ad75-2c3ce94b167f-20240325155005-042zkws.jpeg)

**在对 mapping[b] 赋值时，要保证 last 一定不在 blacklist 中**，可以如下操作：

```cpp
// 构造函数
Solution(int N, vector<int>& blacklist) {
    sz = N - blacklist.size();
    // 先将所有黑名单数字加入 map
    for (int b : blacklist) { 
        // 这里赋值多少都可以
        // 目的仅仅是把键存进哈希表
        // 方便快速判断数字是否在黑名单内
        mapping[b] = 666;
    }

    int last = N - 1;
    for (int b : blacklist) {
        // 跳过所有黑名单中的数字
        while (mapping.count(last)) {
            last--;
        }
        // 将黑名单中的索引映射到合法数字
        mapping[b] = last;
        last--;
    }
}
```

**第二个问题**，如果 blacklist 中的黑名单数字本身就存在区间 [sz, N) 中，那么就没必要在 mapping 中建立映射，比如这种情况：

![1675059905149-4053e6e2-b87f-47ed-b683-d2408e494ace](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059905149-4053e6e2-b87f-47ed-b683-d2408e494ace-20240325155005-g03ntgi.jpeg)  
我们根本不用管 4，只希望把 1 映射到 3，但是按照 blacklist 的顺序，会把 4 映射到 3，显然是错误的。

我们可以稍微修改一下，写出正确的解法代码：

```java
class Solution {

    private final Map<Integer, Integer> mappings;

    private final int sz;

    private final Random random = new Random();

    public Solution(int n, int[] blacklist) {
        mappings = new HashMap<>(blacklist.length);
        for (int black : blacklist) {
            mappings.put(black, -1);
        }
        sz = n - blacklist.length;
        int last = n - 1;
        for (int black : blacklist) {
            if (black >= sz) continue; // 如果已经在 [sz, n) 区间内，则忽略
            while (mappings.containsKey(last)) { // 从后往前找到第一个不是黑名单的元素
                --last;
            }
            mappings.put(black, last); // 更新角标映射
            --last;
        }
    }

    public int pick() {
        int index = random.nextInt(sz);
        return mappings.getOrDefault(index, index); // 如果映射到黑名单，则返回映射值，否则直接返回
    }
}
```

至此，这道题也解决了，总结一下本文的核心思想：

1、如果想高效地，等概率地随机获取元素，就要使用数组作为底层容器。

2、如果要保持数组元素的紧凑性，可以把待删除元素换到最后，然后 pop 掉末尾的元素，这样时间复杂度就是 O(1) 了。当然，我们需要额外的哈希表记录值到索引的映射。

3、对于第二题，数组中含有「空洞」（黑名单数字），也可以利用哈希表巧妙处理映射关系，让数组在逻辑上是紧凑的，方便随机取元素。

## 队列设计类

### 练习题

#### **LCR 160.「**​[数据流中的中位数](https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/description/)」

> **中位数** 是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。
>
> 例如，
>
> [2,3,4] 的中位数是 3
>
> [2,3] 的中位数是 (2 + 3) / 2 = 2.5
>
> 设计一个支持以下两种操作的数据结构：
>
> - void addNum(int num) - 从数据流中添加一个整数到数据结构中。
> - double findMedian() - 返回目前所有元素的中位数。
>
> **示例 1：**
>
> 输入： ["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"] [[],[1],[2],[],[3],[]]  
> 输出：[null,null,null,1.50000,null,2.00000]

**我们必然需要有序数据结构，本题的核心思路是使用两个优先级队列**。

中位数是有序数组最中间的元素算出来的对吧，我们可以把「有序数组」抽象成一个倒三角形，宽度可以视为元素的大小，那么这个倒三角的中部就是计算中位数的元素对吧：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679057340343-2cf9532f-6df8-4d89-9915-ce42be2d6e62-20240407151225-ly01p7t.png)

然后我把这个大的倒三角形从正中间切成两半，变成一个小倒三角和一个梯形，这个小倒三角形相当于一个从小到大的有序数组，这个梯形相当于一个从大到小的有序数组。

中位数就可以通过小倒三角和梯形顶部的元素算出来对吧？嗯，你联想到什么了没有？它们能不能用优先级队列表示？

**小倒三角不就是个大顶堆嘛，梯形不就是个小顶堆嘛，中位数可以通过它们的堆顶元素算出来**：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679057345022-b5216f86-e7fc-4dea-920b-7e43258b0525-20240407151225-zxqoll9.png)

梯形虽然是小顶堆，但其中的元素是较大的，我们称其为 large，倒三角虽然是大顶堆，但是其中元素较小，我们称其为 small。

当然，这两个堆需要算法逻辑正确维护，才能保证堆顶元素是可以算出正确的中位数，**我们很容易看出来，两个堆中的元素之差不能超过 1**。

因为我们要求中位数嘛，假设元素总数是 n，如果 n 是偶数，我们希望两个堆的元素个数是一样的，这样把两个堆的堆顶元素拿出来求个平均数就是中位数；如果 n 是奇数，那么我们希望两个堆的元素个数分别是 n/2 + 1 和 n/2，这样元素多的那个堆的堆顶元素就是中位数。

根据这个逻辑，我们可以直接写出 findMedian 函数的代码：

```java
class MedianFinder {

    private PriorityQueue<Integer> large;
    private PriorityQueue<Integer> small;

    public MedianFinder() {
        // 小顶堆
        large = new PriorityQueue<>();
        // 大顶堆
        small = new PriorityQueue<>((a, b) -> {
            return b - a;
        });
    }

    public double findMedian() {    



        // 如果元素不一样多，多的那个堆的堆顶元素就是中位数
        if (large.size() < small.size()) {
            return small.peek();
        } else if (large.size() > small.size()) {
            return large.peek();
        }
        // 如果元素一样多，两个堆堆顶元素的平均数是中位数
        return (large.peek() + small.peek()) / 2.0;    



    }

    public void addNum(int num) {
        // 后文实现
    }
}
```

现在的问题是，如何实现 addNum 方法，维护「两个堆中的元素之差不能超过 1」这个条件呢？

这样行不行？每次调用 addNum 函数的时候，我们比较一下 large 和 small 的元素个数，谁的元素少我们就加到谁那里，如果它们的元素一样多，我们默认加到 large 里面：

```java
// 有缺陷的代码实现
public void addNum(int num) {
    if (small.size() >= large.size()) {
        large.offer(num);
    } else {
        small.offer(num);
    }
}
```

看起来好像没问题，但是跑一下就发现问题了，比如说我们这样调用：

addNum(1)，现在两个堆元素数量相同，都是 0，所以默认把 1 添加进 large 堆。

addNum(2)，现在 large 的元素比 small 的元素多，所以把 2 添加进 small 堆中。

addNum(3)，现在两个堆都有一个元素，所以默认把 3 添加进 large 中。

调用 findMedian，预期的结果应该是 2，但是实际得到的结果是 1。

问题很容易发现，看下当前两个堆中的数据：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679057409312-a1b4591d-b2a3-4f38-b9f3-af37e5292b8a-20240407151225-rs4zsse.png)

抽象点说，我们的梯形和小倒三角都是由原始的大倒三角从中间切开得到的，那么梯形中的最小宽度要大于等于小倒三角的最大宽度，这样它俩才能拼成一个大的倒三角对吧？

**也就是说，不仅要维护 large 和 small 的元素个数之差不超过 1，还要维护 large 堆的堆顶元素要大于等于 small 堆的堆顶元素**。

维护 large 堆的元素大小整体大于 small 堆的元素是本题的难点，不是一两个 if 语句能够正确维护的，而是需要如下技巧：

```java
// 正确的代码实现
public void addNum(int num) {
    if (small.size() >= large.size()) {
        small.offer(num);
        large.offer(small.poll());
    } else {
        large.offer(num);
        small.offer(large.poll());
    }
}
```

**简单说，想要往 large 里添加元素，不能直接添加，而是要先往 small 里添加，然后再把 small 的堆顶元素加到 large 中；向 small 中添加元素同理**。

为什么呢，稍加思考可以想明白，假设我们准备向 large 中插入元素：

如果插入的 num 小于 small 的堆顶元素，那么 num 就会留在 small 堆里，为了保证两个堆的元素数量之差不大于 1，作为交换，把 small 堆顶部的元素再插到 large 堆里。

如果插入的 num 大于 small 的堆顶元素，那么 num 就会成为 samll 的堆顶元素，最后还是会被插入 large 堆中。

反之，向 small 中插入元素是一个道理，这样就巧妙地保证了 large 堆整体大于 small 堆，且两个堆的元素之差不超过 1，那么中位数就可以通过两个堆的堆顶元素快速计算了。

至此，整个算法就结束了，addNum 方法时间复杂度 O(logN)，findMedian 方法时间复杂度 O(1)。

## 栈设计类

### LCR 147. 「[最小栈](https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/description/)」

> 请你设计一个 **最小栈** 。它提供 `push`​ ，`pop`​ ，`top`​ 操作，并能在常数时间内检索到最小元素的栈。
>
> **示例:**
>
> MinStack minStack = new MinStack();  
> minStack.push(-2);  
> minStack.push(0);  
> minStack.push(-3);  
> minStack.min();   --> 返回 -3.  
> minStack.pop();  
> minStack.top();   --> 返回 0.  
> minStack.min();   --> 返回 -2.

> 普通栈的 push() 和 pop() 函数的复杂度为 O(1) ；而获取栈最小值 min() 函数需要遍历整个栈，复杂度为 O(N) 。

- 本题难点： 将 min() 函数复杂度降为 O(1)，可通过建立辅助栈实现；

    - 数据栈 A ： 栈 A 用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。
    - 辅助栈 B ： 栈 B 中存储栈 A 中所有 非严格降序 的元素，则栈 A 中的最小元素始终对应栈 B 的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可。
- 因此，只需设法维护好 栈 B 的元素，使其保持非严格降序，即可实现 min() 函数的 O(1) 复杂度。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678435482068-efc9cc43-c65d-40b8-a9b1-4a20e8be0875-20240407152535-g1px55e.png)

函数设计：

- push(x) 函数： 重点为保持栈 B 的元素是 非严格降序 的。

    - 将 x 压入栈 A （即 A.add(x) ）；
    - 若 ① 栈 B 为空 或 ② x 小于等于 栈 B 的栈顶元素，则将 x 压入栈 B （即 B.add(x) ）。
- pop() 函数： 重点为保持栈 A,B 的 元素一致性 。

    - 执行栈 A 出栈（即 A.pop() ），将出栈元素记为 y ；
    - 若 y 等于栈 B 的栈顶元素，则执行栈 B 出栈（即 B.pop() ）。
- top() 函数： 直接返回栈 A 的栈顶元素即可，即返回 A.peek() 。
- min() 函数： 直接返回栈 B 的栈顶元素即可，即返回 B.peek() 。

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678435794299-3665b136-3052-42a9-89f3-5fcc72a55656-20240407152535-lxvzb9f.gif)

```java
class MinStack {
    Stack<Integer> A, B;
    public MinStack() {
        A = new Stack<>();
        B = new Stack<>(); // 栈 A 中的最小元素始终对应栈 B 的栈顶元素
    }
    public void push(int x) {
        A.add(x);
        if(B.empty() || B.peek() >= x)
            B.add(x);
    }
    public void pop() {
        if(A.pop().equals(B.peek()))
            B.pop();
    }
    public int top() {
        return A.peek();
    }
    public int min() {
        return B.peek();
    }
}
```

复杂度分析：

- 时间复杂度 O(1)： push(), pop(), top(), min() 四个函数的时间复杂度均为常数级别。
- 空间复杂度 O(N)： 当共有 N 个待入栈元素时，辅助栈 B 最差情况下存储 N 个元素，使用 O(N) 额外空间。

## 阻塞队列

### 加锁方式

这里我们先说明一下，在java中，可以有两种方式加锁

1. synocized关键字加锁
2. ReentrantLock类创建可重入锁对象,该对象还可以创建出条件对象，来执行阻塞和唤醒操作

### 代码实现

```java
/**
 * 基于数组实现阻塞队列
 * @param <E>
 */
public class ArrayBlockQueue<E> {
 
 
    private final E[] array;
	private final ReentrantLock lock;
    private final Condition notEmpty;
    private final Condition notFull;

    private int head;
    private int tail;
    private int size;
 
    @SuppressWarnings("all")
    public ArrayBlockQueue(int capacity){
        array = (E[]) new Object[capacity];
		lock = new ReentrantLock();
        notEmpty = lock.newCondition();
        notFull = lock.newCondition();
    }

 
    /**
     * 向队尾添加元素，如果队列为满，则阻塞当前线程
     * @param e 要添加元素
     * @throws InterruptedException
     */
    @Override
    public void offer(E e) throws InterruptedException {
       //先加锁
        lock.lock();
        try{
            //判断队列是否为满，这里要用while循环来判断，防止虚假唤醒
            while (isFull()){
                //如果是满的，就让当前线程阻塞
                notFull.await();  //因为是向队尾添加元素，所以用tailWaits
            }
            //当队列不满时，可以进行添加
            array[tail] = e;
            //先判断tail是否越界
            tail = (tail + 1) % array.length;
            //让size+1
            size++;
            //这时要通知poll，因为放入了一个元素，所以队列肯定不为空，通知poll线程可以取元素了
            notEmpty.signal(); //唤醒poll线程
        }finally {
            //释放锁
            lock.unlock();
        }
    }
 
    /**
     * 向队尾添加元素，加入超时时间，如果队满，并且过了超时时间，返回false
     * @param e 要添加的元素
     * @param timeout 超时时间
     * @return 是否添加成功
     * @throws InterruptedException
     */
    @Override
    public boolean offer(E e, long timeout) throws InterruptedException {
        //先加锁
        lock.lock();
 
        try{
            //将传入的时间转换为纳秒
            long t = TimeUnit.MILLISECONDS.toNanos(timeout);
            //判断队列是否为满，这里要用while循环来判断，防止虚假唤醒
            while (isFull()){
                /**
                 *  如果是满的，就让当前线程阻塞
                 *  我们用加入时间的方法来阻塞
                 *  注意这里我们每次阻塞完唤醒后，就更新等待时间
                 *  如果要等待的时间是5s,那么如果等待了1s发现队列有空，那么唤醒之后，
                 *  如果是虚假唤醒，就要再次等待，那么下次等待时间就是4s
                 *  如果等待时间 t<=0了，说明等待超时，直接返回false，不要在等了
                 **/
                if(t <= 0){
                    return false;
                }
                t = notFull.awaitNanos(t);
            }
            //当队列不满时，可以进行添加
            array[tail] = e;
            //先判断tail是否越界
            tail = (tail + 1) % array.length;
            //让size+1
            size++;
            //这时要通知poll，因为放入了一个元素，所以队列肯定不为空，通知poll线程可以取元素了
            notEmpty.signal(); //唤醒poll线程
            /**
             * 到这里就说明添加成功，返回true
             */
            return true;
        } finally {
            //释放锁
            lock.unlock();
        }
    }
 
    /**
     * 移除队头元素，如果队列为空，则阻塞当前线程
     * @return 队头元素
     * @throws InterruptedException
     */
    @Override
    public E poll() throws InterruptedException {
        //先加锁
        lock.lock();
 
        try {
          //先循环判断队列是否为空
            while (isEmpty()){
                //如果队列为空，让当前线程阻塞
                notEmpty.await();
            }
            //如果队列不为空，可以取了
            E e = array[head];
            array[head] = null; //help GC
            //判断head是否越界
            head = (head + 1) % array.length;
            //让size-1
            size--;
            //这时队列因为取出了一个元素，所以肯定不为满，通知offer线程可以添加元素了
            notFull.signal(); //唤醒offer线程
            return e;
        }finally {
            //释放锁
            lock.unlock();
        }
    }
 
    /**
     * 移除队头元素，加入超时时间，如果队空，并且超过等待时间，返回null
     * @param timeout 超时时间
     * @return 队头元素
     * @throws InterruptedException
     */
    @Override
    public E poll(long timeout) throws InterruptedException {
        //先加锁
        lock.lock();
 
        try {
            long t = TimeUnit.MILLISECONDS.toNanos(timeout);
            //先循环判断队列是否为空
            while (isEmpty()){
                //如果队列为空，让当前线程阻塞
                if(t <= 0){
                    return null;
                }
                 t = notEmpty.awaitNanos(t);
            }
            //如果队列不为空，可以取了
            E e = array[head];
            array[head] = null; //help GC
            //判断head是否越界
            head = (head + 1) % array.length;
            //让size-1
            size--;
            //这时队列因为取出了一个元素，所以肯定不为满，通知offer线程可以添加元素了
            notFull.signal(); //唤醒offer线程
            return e;
        }finally {
            //释放锁
            lock.unlock();
        }
    }
 
    @Override
    public boolean isFull() {
        return size == array.length;
    }
 
    @Override
    public boolean isEmpty() {
        return size == 0;
    }
 
 
    @Override
    public String toString() {
        return Arrays.toString(array);
    }
}
```

### 解释说明

注释中也都写了，我在这里再次解释一下:

(1).offer添加元素

当我们执行offer方法向队列中添加元素时:

1. 我们需要先加锁，
2. 我们判断队列是否为满，
3. 如果满了，我们需要让当前线程阻塞

注意:这里使用的是while循环，为什么不用if呢?我们想，如果用if，那么它只会判断一次，如果当某个时刻，队列从满变为不满，这

时我们阻塞的offer线程被唤醒，将要去添加元素，但就在此时，另一个offer1线程可能在offer线程添加之前抢先往队列中添加了元

素，那么offer线程再去添加就会报错，也就是虚假唤醒（spurious wakeups），使用while循环判断队列是否为满，可以在阻塞线

程被唤醒后重新判断队列是否满足条件。如果队列仍然满，线程会继续被阻塞，直到队列有空闲位置。这样可以预防虚假唤醒的问

题，确保线程只有在满足条件的情况下才会执行添加元素的操作。

4. 当while条件不成立时，也就是队列有空为，并且此时没有其他线程来争抢，那么就可以往队列中添加元素了 ， queue[tail] = e;

5. 判断++tail是否达到了数组末尾位置，如果到了，那么重新调整为0，相当于一个圆圈

6. 让size++

7. 当offer线程向队列中添加元素后，此时队列肯定不为空，我们应该向poll线程发出信号，可以唤醒，相当于操作系统中的信号量机制

（2）poll取出元素

1. 先加锁
2. 判断队列是否为空，同理使用while循环判断
3. 当队列不为空时，取出队头元素
4. 判断++head是否到数组末尾位置，如果到了，重新置为0
5. 让size--;
6. 当poll线程从队列中取出元素后，队列肯定不为满，我们应该向offer线程发出信号，唤醒offer线程

### timeout超时时间

我们可以为offer和poll设置超时时间,当超过了等待时间，将直接返回，不在执行

看一下offer方法设置timeout

```
/**
             *  如果是满的，就让当前线程阻塞
             *  我们用加入时间的方法来阻塞
             *  注意这里我们每次阻塞完唤醒后，就更新等待时间
             *  如果要等待的时间是5s,那么如果等待了1s发现队列有空，那么唤醒之后，
             *  如果是虚假唤醒，就要再次等待，那么下次等待时间就是4s
             *  如果等待时间 t<=0了，说明等待超时，直接返回false，不要在等了
             **/
```

poll方法同理...

## 手撸 LRU 算法

### 一、LRU 算法描述

#### 146.「 [LRU缓存机制](https://leetcode.cn/problems/lru-cache/)」

> 请你设计并实现一个满足  [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。
>
> 实现 LRUCache 类：
>
> - LRUCache(int capacity) 以 **正整数** 作为容量 capacity 初始化 LRU 缓存
> - int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
> - void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 **逐出** 最久未使用的关键字。
>
> 函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
>
> **示例：**
>
> 输入
>
> ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
>
> 输出
>
> [null, null, null, 1, null, -1, null, -1, 3, 4]
>
> 解释
>
> LRUCache lRUCache = new LRUCache(2);  
> lRUCache.put(1, 1); // 缓存是 {1=1}  
> lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}  
> lRUCache.get(1);    // 返回 1  
> lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}  
> lRUCache.get(2);    // 返回 -1 (未找到)  
> lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}  
> lRUCache.get(1);    // 返回 -1 (未找到)  
> lRUCache.get(3);    // 返回 3  
> lRUCache.get(4);    // 返回 4

首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 put(key, val) 方法存入键值对，另一个是 get(key) 方法获取 key 对应的 val，如果 key 不存在则返回 -1。

注意哦，get 和 put 方法必须都是 O(1) 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。

```java
/* 缓存容量为 2 */
LRUCache cache = new LRUCache(2);
// 你可以把 cache 理解成一个队列
// 假设左边是队头，右边是队尾
// 最近使用的排在队头，久未使用的排在队尾
// 圆括号表示键值对 (key, val)

cache.put(1, 1);
// cache = [(1, 1)]

cache.put(2, 2);
// cache = [(2, 2), (1, 1)]

cache.get(1);       // 返回 1
// cache = [(1, 1), (2, 2)]
// 解释：因为最近访问了键 1，所以提前至队头
// 返回键 1 对应的值 1

cache.put(3, 3);
// cache = [(3, 3), (1, 1)]
// 解释：缓存容量已满，需要删除内容空出位置
// 优先删除久未使用的数据，也就是队尾的数据
// 然后把新的数据插入队头

cache.get(2);       // 返回 -1 (未找到)
// cache = [(3, 3), (1, 1)]
// 解释：cache 中不存在键为 2 的数据

cache.put(1, 4);  
// cache = [(1, 4), (3, 3)]
// 解释：键 1 已存在，把原始值 1 覆盖为 4
// 不要忘了也要将键值对提前到队头
```

### 二、LRU 算法设计

分析上面的操作过程，要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：

1、显然 cache 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。

2、我们要在 cache 中快速找某个 key 是否已存在并得到对应的 val；

3、每次访问 cache 中的某个 key，需要将这个元素变为最近使用的，也就是说 cache 要支持在任意位置快速插入和删除元素。

那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表 LinkedHashMap。

LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686636130721-204eb281-4d29-4a15-b75c-27009fe58dc1-20240407163154-iw6k8gi.png)

借助这个结构，我们来逐一分析上面的 3 个条件：

1、如果我们每次默认从链表尾部添加元素，那么显然越靠尾部的元素就是最近使用的，越靠头部的元素就是最久未使用的。

2、对于某一个 key，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 val。

3、链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 key 快速映射到任意一个链表节点，然后进行插入和删除。

**也许读者会问，为什么要是双向链表，单链表行不行？另外，既然哈希表中已经存了 key，为什么链表中还要存 key 和 val 呢，只存 val 不就行了**？

想的时候都是问题，只有做的时候才有答案。这样设计的原因，必须等我们亲自实现 LRU 算法之后才能理解，所以我们开始看代码吧～

### 三、代码实现

很多编程语言都有内置的哈希链表或者类似 LRU 功能的库函数，但是为了帮大家理解算法的细节，我们先自己造轮子实现一遍 LRU 算法，然后再使用 Java 内置的 LinkedHashMap 来实现一遍。

首先，我们把双链表的节点类写出来，为了简化，key 和 val 都认为是 int 类型：

```java
class Node {
    public int key, val;
    public Node next, prev;
    public Node(int k, int v) {
        this.key = k;
        this.val = v;
    }
}
```

然后依靠我们的 Node 类型构建一个双链表，实现几个 LRU 算法必须的 API：

```java
class DoubleList {  
    // 头尾虚节点
    private Node head, tail;  
    // 链表元素数
    private int size;
  
    public DoubleList() {
        // 初始化双向链表的数据
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
        size = 0;
    }

    // 在链表尾部添加节点 x，时间 O(1)
    public void addLast(Node x) {
        x.prev = tail.prev;
        x.next = tail;
        tail.prev.next = x;
        tail.prev = x;
        size++;
    }

    // 删除链表中的 x 节点（x 一定存在）
    // 由于是双链表且给的是目标 Node 节点，时间 O(1)
    public void remove(Node x) {
        x.prev.next = x.next;
        x.next.prev = x.prev;
        size--;
    }
  
    // 删除链表中第一个节点，并返回该节点，时间 O(1)
    public Node removeFirst() {
        if (head.next == tail)
            return null;
        Node first = head.next;
        remove(first);
        return first;
    }

    // 返回链表长度，时间 O(1)
    public int size() { return size; }

}
```

到这里就能回答刚才「为什么必须要用双向链表」的问题了，因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。

**注意我们实现的双链表 API 只能从尾部插入，也就是说靠尾部的数据是最近使用的，靠头部的数据是最久未使用的**。

有了双向链表的实现，我们只需要在 LRU 算法中把它和哈希表结合起来即可，先搭出代码框架：

```java
class LRUCache {
    // key -> Node(key, val)
    private HashMap<Integer, Node> map;
    // Node(k1, v1) <-> Node(k2, v2)...
    private DoubleList cache;
    // 最大容量
    private int cap;
  
    public LRUCache(int capacity) {
        this.cap = capacity;
        map = new HashMap<>();
        cache = new DoubleList();
    }
}
```

先不慌去实现 LRU 算法的 get 和 put 方法。由于我们要同时维护一个双链表 cache 和一个哈希表 map，很容易漏掉一些操作，比如说删除某个 key 时，在 cache 中删除了对应的 Node，但是却忘记在 map 中删除 key。

**解决这种问题的有效方法是：在这两种数据结构之上提供一层抽象 API**。

说的有点玄幻，实际上很简单，就是尽量让 LRU 的主方法 get 和 put 避免直接操作 map 和 cache 的细节。我们可以先实现下面几个函数：

```java
class LRUCache {
    // 为了节约篇幅，省略上文给出的代码部分...

    /* 将某个 key 提升为最近使用的 */
    private void makeRecently(int key) {
        Node x = map.get(key);
        // 先从链表中删除这个节点
        cache.remove(x);
        // 重新插到队尾
        cache.addLast(x);
    }

    /* 添加最近使用的元素 */
    private void addRecently(int key, int val) {
        Node x = new Node(key, val);
        // 链表尾部就是最近使用的元素
        cache.addLast(x);
        // 别忘了在 map 中添加 key 的映射
        map.put(key, x);
    }

    /* 删除某一个 key */
    private void deleteKey(int key) {
        Node x = map.get(key);
        // 从链表中删除
        cache.remove(x);
        // 从 map 中删除
        map.remove(key);
    }

    /* 删除最久未使用的元素 */
    private void removeLeastRecently() {
        // 链表头部的第一个元素就是最久未使用的
        Node deletedNode = cache.removeFirst();
        // 同时别忘了从 map 中删除它的 key
        int deletedKey = deletedNode.key;
        map.remove(deletedKey);
    }
}
```

这里就能回答之前的问答题「为什么要在链表中同时存储 key 和 val，而不是只存储 val」，注意 removeLeastRecently 函数中，我们需要用 deletedNode 得到 deletedKey。

也就是说，当缓存容量已满，我们不仅仅要删除最后一个 Node 节点，还要把 map 中映射到该节点的 key 同时删除，而这个 key 只能由 Node 得到。如果 Node 结构中只存储 val，那么我们就无法得知 key 是什么，就无法删除 map 中的键，造成错误。

上述方法就是简单的操作封装，调用这些函数可以避免直接操作 cache 链表和 map 哈希表，下面我先来实现 LRU 算法的 get 方法：

```java
class LRUCache {
    // 为了节约篇幅，省略上文给出的代码部分...

    public int get(int key) {
        if (!map.containsKey(key)) {
            return -1;
        }
        // 将该数据提升为最近使用的
        makeRecently(key);
        return map.get(key).val;
    }
}
```

put 方法稍微复杂一些，我们先来画个图搞清楚它的逻辑：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686636257079-344b650f-fd33-4473-b88e-622f914e3e80-20240407163155-zb4ntla.png)

这样我们可以轻松写出 put 方法的代码：

```java
class LRUCache {
    // 为了节约篇幅，省略上文给出的代码部分...
  
    public void put(int key, int val) {
        if (map.containsKey(key)) {
            // 删除旧的数据
            deleteKey(key);
            // 新插入的数据为最近使用的数据
            addRecently(key, val);
            return;
        }
    
        if (cap == cache.size()) {
            // 删除最久未使用的元素
            removeLeastRecently();
        }
        // 添加为最近使用的元素
        addRecently(key, val);
    }
}
```

至此，你应该已经完全掌握 LRU 算法的原理和实现了，我们最后用 Java 的内置类型 LinkedHashMap 来实现 LRU 算法，逻辑和之前完全一致，我就不过多解释了：

```java
class LRUCache {
    int cap;
    LinkedHashMap<Integer, Integer> cache = new LinkedHashMap<>();
    public LRUCache(int capacity) { 
        this.cap = capacity;
    }
  
    public int get(int key) {
        if (!cache.containsKey(key)) {
            return -1;
        }
        // 将 key 变为最近使用
        makeRecently(key);
        return cache.get(key);
    }
  
    public void put(int key, int val) {
        if (cache.containsKey(key)) {
            // 修改 key 的值
            cache.put(key, val);
            // 将 key 变为最近使用
            makeRecently(key);
            return;
        }
    
        if (cache.size() >= this.cap) {
            // 链表头部就是最久未使用的 key
            int oldestKey = cache.keySet().iterator().next();
            cache.remove(oldestKey);
        }
        // 将新的 key 添加链表尾部
        cache.put(key, val);
    }
  
    private void makeRecently(int key) {
        int val = cache.get(key);
        // 删除 key，重新插入到队尾
        cache.remove(key);
        cache.put(key, val);
    }
}
```

## 手撸 LFU 算法

LRU 算法的淘汰策略是 Least Recently Used，也就是每次淘汰那些最久没被使用的数据；而 LFU 算法的淘汰策略是 Least Frequently Used，也就是每次淘汰那些使用次数最少的数据。

LRU 算法的核心数据结构是使用哈希链表 LinkedHashMap，首先借助链表的有序性使得链表元素维持插入顺序，同时借助哈希映射的快速访问能力使得我们可以在 O(1) 时间访问链表的任意元素。

从实现难度上来说，LFU 算法的难度大于 LRU 算法，因为 LRU 算法相当于把数据按照时间排序，这个需求借助链表很自然就能实现，你一直从链表头部加入元素的话，越靠近头部的元素就是新的数据，越靠近尾部的元素就是旧的数据，我们进行缓存淘汰的时候只要简单地将尾部的元素淘汰掉就行了。

而 LFU 算法相当于是把数据按照访问频次进行排序，这个需求恐怕没有那么简单，而且还有一种情况，如果多个数据拥有相同的访问频次，我们就得删除最早插入的那个数据。也就是说 LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。

所以说 LFU 算法是要复杂很多的，而且经常出现在面试中，因为 LFU 缓存淘汰算法在工程实践中经常使用，也有可能是因为 LRU 算法太简单了。**不过话说回来，这种著名的算法的套路都是固定的，关键是由于逻辑较复杂，不容易写出漂亮且没有 bug 的代码**。

那么本文我就带你拆解 LFU 算法，自顶向下，逐步求精，就是解决复杂问题的不二法门。

### 一、算法描述

要求你写一个类，接受一个 capacity 参数，实现 get 和 put 方法：

```java
class LFUCache {
    // 构造容量为 capacity 的缓存
    public LFUCache(int capacity) {}
    // 在缓存中查询 key
    public int get(int key) {}
    // 将 key 和 val 存入缓存
    public void put(int key, int val) {}
}
```

get(key) 方法会去缓存中查询键 key，如果 key 存在，则返回 key 对应的 val，否则返回 -1。

put(key, value) 方法插入或修改缓存。如果 key 已存在，则将它对应的值改为 val；如果 key 不存在，则插入键值对 (key, val)。

当缓存达到容量 capacity 时，则应该在插入新的键值对之前，删除使用频次（后文用 freq 表示）最低的键值对。如果 freq 最低的键值对有多个，则删除其中最旧的那个。

```java
// 构造一个容量为 2 的 LFU 缓存
LFUCache cache = new LFUCache(2);

// 插入两对 (key, val)，对应的 freq 为 1
cache.put(1, 10);
cache.put(2, 20);

// 查询 key 为 1 对应的 val
// 返回 10，同时键 1 对应的 freq 变为 2
cache.get(1);

// 容量已满，淘汰 freq 最小的键 2
// 插入键值对 (3, 30)，对应的 freq 为 1
cache.put(3, 30);   

// 键 2 已经被淘汰删除，返回 -1
cache.get(2);
```

### 二、思路分析

一定先从最简单的开始，根据 LFU 算法的逻辑，我们先列举出算法执行过程中的几个显而易见的事实：

1、调用 get(key) 方法时，要返回该 key 对应的 val。

2、只要用 get 或者 put 方法访问一次某个 key，该 key 的 freq 就要加一。

3、如果在容量满了的时候进行插入，则需要将 freq 最小的 key 删除，如果最小的 freq 对应多个 key，则删除其中最旧的那一个。

好的，我们希望能够在 O(1) 的时间内解决这些需求，可以使用基本数据结构来逐个击破：

1、使用一个 HashMap 存储 key 到 val 的映射，就可以快速计算 get(key)。

```java
HashMap<Integer, Integer> keyToVal;
```

2、使用一个 HashMap 存储 key 到 freq 的映射，就可以快速操作 key 对应的 freq。

```java
HashMap<Integer, Integer> keyToFreq;
```

3、这个需求应该是 LFU 算法的核心，所以我们分开说：

3.1、首先，肯定是需要 freq 到 key 的映射，用来找到 freq 最小的 key。

3.2、将 freq 最小的 key 删除，那你就得快速得到当前所有 key 最小的 freq 是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量 minFreq 来记录当前最小的 freq 吧。

3.3、可能有多个 key 拥有相同的 freq，所以 **freq 对 key 是一对多的关系**，即一个 freq 对应一个 key 的列表。

3.4、希望 freq 对应的 key 的列表是**存在时序**的，便于快速查找并删除最旧的 key。

3.5、希望**能够快速删除 key 列表中的任何一个 key**，因为如果频次为 freq 的某个 key 被访问，那么它的频次就会变成 freq+1，就应该从 freq 对应的 key 列表中删除，加到 freq+1 对应的 key 的列表中。

```java
HashMap<Integer, LinkedHashSet<Integer>> freqToKeys;
int minFreq = 0;
```

介绍一下这个 LinkedHashSet，它满足我们 3.3，3.4，3.5 这几个要求。你会发现普通的链表 LinkedList 能够满足 3.3，3.4 这两个要求，但是由于普通链表不能快速访问链表中的某一个节点，所以无法满足 3.5 的要求。

LinkedHashSet 顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。

那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，又可以保持插入的时序，高效实现 3.5 这个需求。

综上，我们可以写出 LFU 算法的基本数据结构：

```java
class LFUCache {
    // key 到 val 的映射，我们后文称为 KV 表
    HashMap<Integer, Integer> keyToVal;
    // key 到 freq 的映射，我们后文称为 KF 表
    HashMap<Integer, Integer> keyToFreq;
    // freq 到 key 列表的映射，我们后文称为 FK 表
    HashMap<Integer, LinkedHashSet<Integer>> freqToKeys;
    // 记录最小的频次
    int minFreq;
    // 记录 LFU 缓存的最大容量
    int cap;

    public LFUCache(int capacity) {
        keyToVal = new HashMap<>();
        keyToFreq = new HashMap<>();
        freqToKeys = new HashMap<>();
        this.cap = capacity;
        this.minFreq = 0;
    }

    public int get(int key) {}

    public void put(int key, int val) {}

}
```

### 三、代码框架

LFU 的逻辑不难理解，但是写代码实现并不容易，因为你看我们要维护 KV 表，KF 表，FK 表三个映射，特别容易出错。对于这种情况，我教你三个技巧：

1、不要企图上来就实现算法的所有细节，而应该自顶向下，逐步求精，先写清楚主函数的逻辑框架，然后再一步步实现细节。

2、搞清楚映射关系，如果我们更新了某个 key 对应的 freq，那么就要同步修改 KF 表和 FK 表，这样才不会出问题。

3、画图，画图，画图，重要的话说三遍，把逻辑比较复杂的部分用流程图画出来，然后根据图来写代码，可以极大减少出错的概率。

下面我们先来实现 get(key) 方法，逻辑很简单，返回 key 对应的 val，然后增加 key 对应的 freq：

```java
class LFUCache {
    // 为了节约篇幅，省略上文给出的代码部分...

    public int get(int key) {
        if (!keyToVal.containsKey(key)) {
            return -1;
        }
        // 增加 key 对应的 freq
        increaseFreq(key);
        return keyToVal.get(key);
    }
}
```

增加 key 对应的 freq 是 LFU 算法的核心，所以我们干脆直接抽象成一个函数 increaseFreq，这样 get 方法看起来就简洁清晰了对吧。

下面来实现 put(key, val) 方法，逻辑略微复杂，我们直接画个图来看：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686637916027-515cc8ad-1f27-469c-9e92-31bf89e97e5d-20240407164314-434nin4.png)

这图就是随手画的，不是什么正规的程序流程图，但是算法逻辑一目了然，看图可以直接写出 put 方法的逻辑：

```java
class LFUCache {
    // 为了节约篇幅，省略上文给出的代码部分...

    public void put(int key, int val) {
        if (this.cap <= 0) return;

        /* 若 key 已存在，修改对应的 val 即可 */
        if (keyToVal.containsKey(key)) {
            keyToVal.put(key, val);
            // key 对应的 freq 加一
            increaseFreq(key);
            return;
        }

        /* key 不存在，需要插入 */
        /* 容量已满的话需要淘汰一个 freq 最小的 key */
        if (this.cap <= keyToVal.size()) {
            removeMinFreqKey();
        }

        /* 插入 key 和 val，对应的 freq 为 1 */
        // 插入 KV 表
        keyToVal.put(key, val);
        // 插入 KF 表
        keyToFreq.put(key, 1);
        // 插入 FK 表
        freqToKeys.putIfAbsent(1, new LinkedHashSet<>());
        freqToKeys.get(1).add(key);
        // 插入新 key 后最小的 freq 肯定是 1
        this.minFreq = 1;
    }
}
```

increaseFreq 和 removeMinFreqKey 方法是 LFU 算法的核心，我们下面来看看怎么借助 KV 表，KF 表，FK 表这三个映射巧妙完成这两个函数。

### 四、LFU 核心逻辑

首先来实现 removeMinFreqKey 函数：

```java
class LFUCache {
    // 为了节约篇幅，省略上文给出的代码部分...

    private void removeMinFreqKey() {
        // freq 最小的 key 列表
        LinkedHashSet<Integer> keyList = freqToKeys.get(this.minFreq);
        // 其中最先被插入的那个 key 就是该被淘汰的 key
        int deletedKey = keyList.iterator().next();
        /* 更新 FK 表 */
        keyList.remove(deletedKey);
        if (keyList.isEmpty()) {
            freqToKeys.remove(this.minFreq);
            // 问：这里需要更新 minFreq 的值吗？
        }
        /* 更新 KV 表 */
        keyToVal.remove(deletedKey);
        /* 更新 KF 表 */
        keyToFreq.remove(deletedKey);
    }
}
```

删除某个键 key 肯定是要同时修改三个映射表的，借助 minFreq 参数可以从 FK 表中找到 freq 最小的 keyList，根据时序，其中第一个元素就是要被淘汰的 deletedKey，操作三个映射表删除这个 key 即可。

但是有个细节问题，如果 keyList 中只有一个元素，那么删除之后 minFreq 对应的 key 列表就为空了，也就是 minFreq 变量需要被更新。如何计算当前的 minFreq 是多少呢？

实际上没办法快速计算 minFreq，只能线性遍历 FK 表或者 KF 表来计算，这样肯定不能保证 O(1) 的时间复杂度。

**但是，其实这里没必要更新 minFreq 变量**，因为你想想 removeMinFreqKey 这个函数是在什么时候调用？在 put 方法中插入新 key 时可能调用。而你回头看 put 的代码，插入新 key 时一定会把 minFreq 更新成 1，所以说即便这里 minFreq 变了，我们也不需要管它。

下面来实现 increaseFreq 函数：

```java
class LFUCache {
    // 为了节约篇幅，省略上文给出的代码部分...

    private void increaseFreq(int key) {
        int freq = keyToFreq.get(key);
        /* 更新 KF 表 */
        keyToFreq.put(key, freq + 1);
        /* 更新 FK 表 */
        // 将 key 从 freq 对应的列表中删除
        freqToKeys.get(freq).remove(key);
        // 将 key 加入 freq + 1 对应的列表中
        freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet<>());
        freqToKeys.get(freq + 1).add(key);
        // 如果 freq 对应的列表空了，移除这个 freq
        if (freqToKeys.get(freq).isEmpty()) {
            freqToKeys.remove(freq);
            // 如果这个 freq 恰好是 minFreq，更新 minFreq
            if (freq == this.minFreq) {
                this.minFreq++;
            }
        }
    }
}
```

更新某个 key 的 freq 肯定会涉及 FK 表和 KF 表，所以我们分别更新这两个表就行了。

和之前类似，当 FK 表中 freq 对应的列表被删空后，需要删除 FK 表中 freq 这个映射。如果这个 freq 恰好是 minFreq，说明 minFreq 变量需要更新。

能不能快速找到当前的 minFreq 呢？这里是可以的，因为之前修改的那个 key 依然是目前出现频率最小的 key，所以 minFreq 也加 1 就行了。

至此，经过层层拆解，LFU 算法就完成了。

```java
class LFUCache {

	// key 到 val 的映射，我们后文称为 KV 表
    HashMap<Integer, Integer> keyToVal;
    // key 到 freq 的映射，我们后文称为 KF 表
    HashMap<Integer, Integer> keyToFreq;
    // freq 到 key 列表的映射，我们后文称为 FK 表
    HashMap<Integer, LinkedHashSet<Integer>> freqToKeys;
    // 记录最小的频次
    int minFreq;
    // 记录 LFU 缓存的最大容量
    int cap;

    public LFUCache(int capacity) {
        keyToVal = new HashMap<>();
        keyToFreq = new HashMap<>();
        freqToKeys = new HashMap<>();
        this.cap = capacity;
        this.minFreq = 0;
    }

	public int get(int key) {
        if (!keyToVal.containsKey(key)) {
            return -1;
        }
        // 增加 key 对应的 freq
        increaseFreq(key);
        return keyToVal.get(key);
    }

	public void put(int key, int val) {
        if (this.cap <= 0) return;

        /* 若 key 已存在，修改对应的 val 即可 */
        if (keyToVal.containsKey(key)) {
            keyToVal.put(key, val);
            // key 对应的 freq 加一
            increaseFreq(key);
            return;
        }

        /* key 不存在，需要插入 */
        /* 容量已满的话需要淘汰一个 freq 最小的 key */
        if (this.cap <= keyToVal.size()) {
            removeMinFreqKey();
        }

        /* 插入 key 和 val，对应的 freq 为 1 */
        // 插入 KV 表
        keyToVal.put(key, val);
        // 插入 KF 表
        keyToFreq.put(key, 1);
        // 插入 FK 表
        freqToKeys.putIfAbsent(1, new LinkedHashSet<>());
        freqToKeys.get(1).add(key);
        // 插入新 key 后最小的 freq 肯定是 1
        this.minFreq = 1;
    }
  
	private void removeMinFreqKey() {
        // freq 最小的 key 列表
        LinkedHashSet<Integer> keyList = freqToKeys.get(this.minFreq);
        // 其中最先被插入的那个 key 就是该被淘汰的 key
        int deletedKey = keyList.iterator().next();
        /* 更新 FK 表 */
        keyList.remove(deletedKey);
        if (keyList.isEmpty()) {
            freqToKeys.remove(this.minFreq);
            // 问：这里需要更新 minFreq 的值吗？
        }
        /* 更新 KV 表 */
        keyToVal.remove(deletedKey);
        /* 更新 KF 表 */
        keyToFreq.remove(deletedKey);
    }

    private void increaseFreq(int key) {
        int freq = keyToFreq.get(key);
        /* 更新 KF 表 */
        keyToFreq.put(key, freq + 1);
        /* 更新 FK 表 */
        // 将 key 从 freq 对应的列表中删除
        freqToKeys.get(freq).remove(key);
        // 将 key 加入 freq + 1 对应的列表中
        freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet<>());
        freqToKeys.get(freq + 1).add(key);
        // 如果 freq 对应的列表空了，移除这个 freq
        if (freqToKeys.get(freq).isEmpty()) {
            freqToKeys.remove(freq);
            // 如果这个 freq 恰好是 minFreq，更新 minFreq
            if (freq == this.minFreq) {
                this.minFreq++;
            }
        }
    }
}
```

## 设计朋友圈时间线功能

### 355.「[设计推特](https://leetcode.cn/problems/design-twitter/)」

> 设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近 10 条推文。
>
> 实现 Twitter 类：
>
> - Twitter() 初始化简易版推特对象
> - void postTweet(int userId, int tweetId) 根据给定的 tweetId 和 userId 创建一条新推文。每次调用此函数都会使用一个不同的 tweetId 。
> - List<Integer> getNewsFeed(int userId) 检索当前用户新闻推送中最近  10 条推文的 ID 。新闻推送中的每一项都必须是由用户关注的人或者是用户自己发布的推文。推文必须 **按照时间顺序由最近到最远排序** 。
> - void follow(int followerId, int followeeId) ID 为 followerId 的用户开始关注 ID 为 followeeId 的用户。
> - void unfollow(int followerId, int followeeId) ID 为 followerId 的用户不再关注 ID 为 followeeId 的用户。
>
> **示例：**
>
> 输入 ["Twitter", "postTweet", "getNewsFeed", "follow", "postTweet", "getNewsFeed", "unfollow", "getNewsFeed"] [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]
>
> 输出 [null, null, [5], null, null, [6, 5], null, [5]]
>
> 解释  
> Twitter twitter = new Twitter();  
> twitter.postTweet(1, 5); // 用户 1 发送了一条新推文 (用户 id = 1, 推文 id = 5)  
> twitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含一个 id 为 5 的推文  
> twitter.follow(1, 2);    // 用户 1 关注了用户 2  
> twitter.postTweet(2, 6); // 用户 2 发送了一个新推文 (推文 id = 6)  
> twitter.getNewsFeed(1);  // 用户 1 的获取推文应当返回一个列表，其中包含两个推文，id 分别为 -> [6, 5] 。推文 id 6 应当在推文 id 5 之前，因为它是在 5 之后发送的  
> twitter.unfollow(1, 2);  // 用户 1 取消关注了用户 2  
> twitter.getNewsFeed(1);  // 用户 1 获取推文应当返回一个列表，其中包含一个 id 为 5 的推文。因为用户 1 已经不再关注用户 2

Twitter 和微博功能差不多，我们主要要实现这样几个 API：

```java
class Twitter {

    /** user 发表一条 tweet 动态 */
    public void postTweet(int userId, int tweetId) {}

    /** 返回该 user 关注的人（包括他自己）最近的动态 id，
    最多 10 条，而且这些动态必须按从新到旧的时间线顺序排列。*/
    public List<Integer> getNewsFeed(int userId) {}

    /** follower 关注 followee，如果 Id 不存在则新建 */
    public void follow(int followerId, int followeeId) {}

    /** follower 取关 followee，如果 Id 不存在则什么都不做 */
    public void unfollow(int followerId, int followeeId) {}
}
```

举个具体的例子，方便大家理解 API 的具体用法：

```java
Twitter twitter = new Twitter();

twitter.postTweet(1, 5);
// 用户 1 发送了一条新推文 5

twitter.getNewsFeed(1);
// return [5]，因为自己是关注自己的

twitter.follow(1, 2);
// 用户 1 关注了用户 2

twitter.postTweet(2, 6);
// 用户2发送了一个新推文 (id = 6)

twitter.getNewsFeed(1);
// return [6, 5]
// 解释：用户 1 关注了自己和用户 2，所以返回他们的最近推文
// 而且 6 必须在 5 之前，因为 6 是最近发送的

twitter.unfollow(1, 2);
// 用户 1 取消关注了用户 2

twitter.getNewsFeed(1);
// return [5]
```

这个场景在我们的现实生活中非常常见。拿朋友圈举例，比如我刚加到女神的微信，然后我去刷新一下我的朋友圈动态，那么女神的动态就会出现在我的动态列表，而且会和其他动态按时间排好序。只不过 Twitter 是单向关注，微信好友相当于双向关注。除非，被屏蔽…

这几个 API 中大部分都很好实现，最核心的功能难点应该是 getNewsFeed，因为返回的结果必须在时间上有序，但问题是用户的关注是动态变化的，怎么办？

**这里就涉及到算法了**：如果我们把每个用户各自的推文存储在链表里，每个链表节点存储文章 id 和一个时间戳 time（记录发帖时间以便比较），而且这个链表是按 time 有序的，那么如果某个用户关注了 k 个用户，我们就可以用合并 k 个有序链表的算法合并出有序的推文列表，正确地 getNewsFeed 了！

具体的算法等会讲解。不过，就算我们掌握了算法，应该如何编程表示用户 user 和推文动态 tweet 才能把算法流畅地用出来呢？

**这就涉及简单的面向对象设计了**，下面我们来由浅入深，一步一步进行设计。

#### 二、面向对象设计

根据刚才的分析，我们需要一个 User 类，储存 user 信息，还需要一个 Tweet 类，储存推文信息，并且要作为链表的节点。所以我们先搭建一下整体的框架：

```java
class Twitter {
    private static int timestamp = 0;
    private static class Tweet {}
    private static class User {}

    /* 还有那几个 API 方法 */
    public void postTweet(int userId, int tweetId) {}
    public List<Integer> getNewsFeed(int userId) {}
    public void follow(int followerId, int followeeId) {}
    public void unfollow(int followerId, int followeeId) {}
}
```

之所以要把 Tweet 和 User 类放到 Twitter 类里面，是因为 Tweet 类必须要用到一个全局时间戳 timestamp，而 User 类又需要用到 Tweet 类记录用户发送的推文，所以它们都作为内部类。不过为了清晰和简洁，下文会把每个内部类和 API 方法单独拿出来实现。

**1、Tweet 类的实现**

根据前面的分析，Tweet 类很容易实现：每个 Tweet 实例需要记录自己的 tweetId 和发表时间 time，而且作为链表节点，要有一个指向下一个节点的 next 指针。

```java
class Tweet {
    private int id;
    private int time;
    private Tweet next;

    // 需要传入推文内容（id）和发文时间
    public Tweet(int id, int time) {
        this.id = id;
        this.time = time;
        this.next = null;
    }
}
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686972878457-437e508f-68ba-48b6-8830-769f55b0c7e5-20240407165030-bbank1l.png)

**2、User 类的实现**

我们根据实际场景想一想，一个用户需要存储的信息有 userId，关注列表，以及该用户发过的推文列表。其中关注列表应该用集合（Hash Set）这种数据结构来存，因为不能重复，而且需要快速查找；推文列表应该由链表这种数据结构储存，以便于进行有序合并的操作。画个图理解一下：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686972880524-3a4db482-52a2-4fab-9a71-45b361546dc9-20240407165032-m0my4tb.png)

除此之外，根据面向对象的设计原则，「关注」「取关」和「发文」应该是 User 的行为，况且关注列表和推文列表也存储在 User 类中，所以我们也应该给 User 添加 follow，unfollow 和 post 这几个方法：

```java
// static int timestamp = 0
class User {
    private int id;
    public Set<Integer> followed;
    // 用户发表的推文链表头结点
    public Tweet head;

    public User(int userId) {
        followed = new HashSet<>();
        this.id = userId;
        this.head = null;
        // 关注一下自己
        follow(id);
    }

    public void follow(int userId) {
        followed.add(userId);
    }

    public void unfollow(int userId) {
        // 不可以取关自己
        if (userId != this.id)
            followed.remove(userId);
    }

    public void post(int tweetId) {
        Tweet twt = new Tweet(tweetId, timestamp);
        timestamp++;
        // 将新建的推文插入链表头
        // 越靠前的推文 time 值越大
        twt.next = head;
        head = twt;
    }
}
```

**3、几个 API 方法的实现**

```java
class Twitter {
    private static int timestamp = 0;
    private static class Tweet {...}
    private static class User {...}

    // 我们需要一个映射将 userId 和 User 对象对应起来
    private HashMap<Integer, User> userMap = new HashMap<>();

    /** user 发表一条 tweet 动态 */
    public void postTweet(int userId, int tweetId) {
        // 若 userId 不存在，则新建
        if (!userMap.containsKey(userId))
            userMap.put(userId, new User(userId));
        User u = userMap.get(userId);
        u.post(tweetId);
    }

    /** follower 关注 followee */
    public void follow(int followerId, int followeeId) {
        // 若 follower 不存在，则新建
        if(!userMap.containsKey(followerId)){
            User u = new User(followerId);
            userMap.put(followerId, u);
        }
        // 若 followee 不存在，则新建
        if(!userMap.containsKey(followeeId)){
            User u = new User(followeeId);
            userMap.put(followeeId, u);
        }
        userMap.get(followerId).follow(followeeId);
    }

    /** follower 取关 followee，如果 Id 不存在则什么都不做 */
    public void unfollow(int followerId, int followeeId) {
        if (userMap.containsKey(followerId)) {
            User flwer = userMap.get(followerId);
            flwer.unfollow(followeeId);
        }
    }

    /** 返回该 user 关注的人（包括他自己）最近的动态 id，
    最多 10 条，而且这些动态必须按从新到旧的时间线顺序排列。*/
    public List<Integer> getNewsFeed(int userId) {
        // 需要理解算法，见下文
    }
}
```

#### 三、算法设计

实现合并 k 个有序链表的算法需要用到优先级队列（Priority Queue），这种数据结构是「二叉堆」最重要的应用，你可以理解为它可以对插入的元素自动排序。乱序的元素插入其中就被放到了正确的位置，可以按照从小到大（或从大到小）有序地取出元素。

```java
PriorityQueue pq
// 乱序插入
for i in {2,4,1,9,6}:
pq.add(i)
while pq not empty:
// 每次取出第一个（最小）元素
print(pq.pop())

// 输出有序：1,2,4,6,9
```

借助这种牛逼的数据结构支持，我们就很容易实现这个核心功能了。注意我们把优先级队列设为按 time 属性**从大到小降序排列**，因为 time 越大意味着时间越近，应该排在前面：

```java
class Twitter {
    // 为了节约篇幅，省略上文给出的代码部分...

    public List<Integer> getNewsFeed(int userId) {
        List<Integer> res = new ArrayList<>();
        if (!userMap.containsKey(userId)) return res;
        // 关注列表的用户 Id
        Set<Integer> users = userMap.get(userId).followed;
        // 自动通过 time 属性从大到小排序，容量为 users 的大小
        PriorityQueue<Tweet> pq = 
        new PriorityQueue<>(users.size(), (a, b)->(b.time - a.time));

        // 先将所有链表头节点插入优先级队列
        for (int id : users) {
            Tweet twt = userMap.get(id).head;
            if (twt == null) continue;
            pq.add(twt);
        }

        while (!pq.isEmpty()) {
            // 最多返回 10 条就够了
            if (res.size() == 10) break;
            // 弹出 time 值最大的（最近发表的）
            Tweet twt = pq.poll();
            res.add(twt.id);
            // 将下一篇 Tweet 插入进行排序
            if (twt.next != null) 
                pq.add(twt.next);
        }
        return res;
    }
}
```

这个过程是这样的，下面是我制作的一个 GIF 图描述合并链表的过程。假设有三个 Tweet 链表按 time 属性降序排列，我们把他们降序合并添加到 res 中。注意图中链表节点中的数字是 time 属性，不是 id 属性：

![1686972877396-b017372c-2254-4950-aad1-aef5867b313f](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686972877396-b017372c-2254-4950-aad1-aef5867b313f-20240407165032-0bul753.gif)

至此，这道一个极其简化的 Twitter 时间线功能就设计完毕了。

```java
class Twitter {

    private int timestamp = 0;

    private final Map<Integer, User> userMap = new HashMap<>();

    class Tweet {
        private int id; // 记录发表推文的id
        private int time; // 发送推文的时间
        private Tweet next; // 指向下一个推文

        public Tweet(int id, int time) {
            this.id = id;
            this.time = time;
        }
    }

    class User {
        private final int id; // 记录用户id
        private final Set<Integer> followed = new HashSet<>(); // 关注的用户集合
        private Tweet head; // 最新的推文

        public User(int userId) {
            this.id = userId;
            follow(userId); // 自己关注自己
        }

        public void follow(int followeeId) {
            followed.add(followeeId);
        }

        public void unfollow(int followeeId) {
            if (followeeId != this.id) { // 不可以取关自己
                followed.remove(followeeId);
            }
        }

        public void postTweet(int tweetId) {
            Tweet tw = new Tweet(tweetId, timestamp);
            ++timestamp;
            tw.next = head; // 将新建的推文插入链表头, 越靠前的推文 time 值越大
            head = tw;
        }

    }

    public Twitter() {

    }

    public void postTweet(int userId, int tweetId) {
        User user = userMap.computeIfAbsent(userId, k -> new User(userId));
        user.postTweet(tweetId);
    }

    public List<Integer> getNewsFeed(int userId) {
        List<Integer> res = new ArrayList<>(10);
        if (!userMap.containsKey(userId)) {
            return res;
        }
        Set<Integer> followed = userMap.get(userId).followed; // 关注列表
        PriorityQueue<Tweet> queue = new PriorityQueue<>((a, b) -> b.time - a.time); // 根据时间倒排
        for (int followedId : followed) {
            Tweet head = userMap.get(followedId).head; // 关注人的最新推文
            if (head != null) {
                queue.offer(head);
            }
        }
        while (!queue.isEmpty()) {
            if (res.size() == 10) return res;
            Tweet tw = queue.poll();
            res.add(tw.id);
            if (tw.next != null) {
                queue.offer(tw.next);
            }
        }
        return res;
    }

    public void follow(int followerId, int followeeId) {
        User follower = userMap.computeIfAbsent(followerId, k -> new User(followerId));
        userMap.computeIfAbsent(followeeId, k -> new User(followeeId));
        follower.follow(followeeId);
    }

    public void unfollow(int followerId, int followeeId) {
        if (userMap.containsKey(followerId)) {
            userMap.get(followerId).unfollow(followeeId);
        }
    }
}
```

‍
