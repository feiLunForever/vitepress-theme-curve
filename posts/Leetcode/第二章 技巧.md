# 技巧

## 排序

### 归并排序

#### 提纲

你看归并排序的代码框架：

```java
// 定义：排序 nums[lo..hi]
void sort(int[] nums, int lo, int hi) {
    if (lo == hi) {
        return;
    }
    int mid = (lo + hi) / 2;
    // 利用定义，排序 nums[lo..mid]
    sort(nums, lo, mid);
    // 利用定义，排序 nums[mid+1..hi]
    sort(nums, mid + 1, hi);

    /****** 后序位置 ******/
    // 此时两部分子数组已经被排好序
    // 合并两个有序数组，使 nums[lo..hi] 有序
    merge(nums, lo, mid, hi);
    /*********************/
}

// 将有序数组 nums[lo..mid] 和有序数组 nums[mid+1..hi]
// 合并为有序数组 nums[lo..hi]
void merge(int[] nums, int lo, int mid, int hi);
```

**归并排序的过程可以在逻辑上抽象成一棵二叉树，树上的每个节点的值可以认为是 nums[lo..hi]，叶子节点的值就是数组中的单个元素**：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679581044173-4f2b5162-cbf8-4247-9c70-3f91966eeb7b-20240329101331-6azzo6d.png" alt="image.png" style="zoom:50%;" />

然后，在每个节点的后序位置（左右子节点已经被排好序）的时候执行 merge 函数，合并两个子节点上的子数组：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679581043631-1bf59d38-5e37-4c50-9d0a-26be9b960bdf-20240329101331-4l4ux93.png" alt="image.png" style="zoom:50%;" />  
这个 merge 操作会在二叉树的每个节点上都执行一遍，执行顺序是二叉树后序遍历的顺序。

后序遍历二叉树大家应该已经烂熟于心了，就是下图这个遍历顺序：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679581044271-3b9bed62-d31d-4121-80f5-f7def2d5ba94-20240329101331-4yaikut.png" alt="image.png" style="zoom:50%;" />

结合上述基本分析，我们把 nums[lo..hi] 理解成二叉树的节点，sort 函数理解成二叉树的遍历函数，整个归并排序的执行过程就是以下 GIF 描述的这样：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679581041254-dbdcb77b-4b6e-46c5-9d14-aeeb159871c5-20240329101331-mu6byd0.gif" alt="1679581041254-dbdcb77b-4b6e-46c5-9d14-aeeb159871c5" style="zoom:50%;" />

这样，归并排序的核心思路就分析完了，接下来只要把思路翻译成代码就行。

```java
class Merge {

    // 用于辅助合并有序数组
    private static int[] temp;

    public static void sort(int[] nums) {
        // 先给辅助数组开辟内存空间
        temp = new int[nums.length];
        // 排序整个数组（原地修改）
        sort(nums, 0, nums.length - 1);
    }

    // 定义：将子数组 nums[lo..hi] 进行排序
    private static void sort(int[] nums, int lo, int hi) {
        if (lo == hi) {
            // 单个元素不用排序
            return;
        }
        // 这样写是为了防止溢出，效果等同于 (hi + lo) / 2
        int mid = lo + (hi - lo) / 2;
        // 先对左半部分数组 nums[lo..mid] 排序
        sort(nums, lo, mid);
        // 再对右半部分数组 nums[mid+1..hi] 排序
        sort(nums, mid + 1, hi);
        // 将两部分有序数组合并成一个有序数组
        merge(nums, lo, mid, hi);
    }

    // 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组
    private static void merge(int[] nums, int lo, int mid, int hi) {
        // 先把 nums[lo..hi] 复制到辅助数组中
        // 以便合并后的结果能够直接存入 nums
        for (int i = lo; i <= hi; i++) {
            temp[i] = nums[i];
        }

        // 数组双指针技巧，合并两个有序数组
        int i = lo, j = mid + 1;
        for (int p = lo; p <= hi; p++) {
            if (i == mid + 1) {
                // 左半边数组已全部被合并
                nums[p] = temp[j++];
            } else if (j == hi + 1) {
                // 右半边数组已全部被合并
                nums[p] = temp[i++];
            } else if (temp[i] > temp[j]) {
                nums[p] = temp[j++];
            } else {
                nums[p] = temp[i++];
            }
        }
    }
}
```

有了之前的铺垫，这里只需要着重讲一下这个 merge 函数。

sort 函数对 nums[lo..mid] 和 nums[mid+1..hi] 递归排序完成之后，我们没有办法原地把它俩合并，所以需要 copy 到 temp 数组里面，然后通过类似于前文 [单链表的六大技巧](https://labuladong.github.io/algo/di-ling-zh-bfe1b/shuang-zhi-0f7cc/) 中合并有序链表的双指针技巧将 nums[lo..hi] 合并成一个有序数组。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684914781539-e8f40848-2e1b-4aad-9cc7-de1f42e56571-20240329101332-6vf82ok.png" alt="image.png" style="zoom:50%;" />

注意我们不是在 merge 函数执行的时候 new 辅助数组，而是提前把 temp 辅助数组 new 出来了，这样就避免了在递归中频繁分配和释放内存可能产生的性能问题。

再说一下归并排序的时间复杂度，虽然大伙儿应该都知道是 O(NlogN)，但不见得所有人都知道这个复杂度怎么算出来的。

前文 [动态规划详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/) 说过递归算法的复杂度计算，就是子问题个数 x 解决一个子问题的复杂度。对于归并排序来说，时间复杂度显然集中在 merge 函数遍历 nums[lo..hi] 的过程，但每次 merge 输入的 lo 和 hi 都不同，所以不容易直观地看出时间复杂度。

merge 函数到底执行了多少次？每次执行的时间复杂度是多少？总的时间复杂度是多少？这就要结合之前画的这幅图来看：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679581169319-4a3d50c5-f3fe-4fa1-b3e1-34ab1d8160c4-20240329101332-019j4s1.png" alt="image.png" style="zoom:50%;" />

**执行的次数是二叉树节点的个数，每次执行的复杂度就是每个节点代表的子数组的长度，所以总的时间复杂度就是整棵树中「数组元素」的个数**。

所以从整体上看，这个二叉树的高度是 logN，其中每一层的元素个数就是原数组的长度 N，所以总的时间复杂度就是 O(NlogN)。

#### 练习题

##### **912.「**​[排序数组](https://leetcode.cn/problems/sort-an-array/)」

> 给你一个整数数组 nums，请你将该数组升序排列。
>
> **示例 1：**   
> 输入：nums = [5,2,3,1]  
> 输出：[1,2,3,5]

可以直接套用归并排序代码模板：

```java
class Solution {
    private int[] temp;

    public int[] sortArray(int[] nums) {
        temp = new int[nums.length];
        sort(nums, 0, nums.length - 1);
        return nums;
    }

    private void sort(int[] nums, int l, int r) {
        if (l == r) return;
        int mid = l + (r - l) / 2;
        sort(nums, l, mid);
        sort(nums, mid + 1, r);
        merge(nums, l, mid, r);
    }

    private void merge(int[] nums, int l, int mid, int r) {
        for (int i = l; i <= r; i++) {
            temp[i] = nums[i];
        }
        int i = l, j = mid + 1;
        for (int k = l; k <= r; k++) {
            if (i == mid + 1) { // 左边数组全部merge完了
                nums[k] = temp[j++];
            } else if (j == r + 1) { // 右边数组全部merge完了
                nums[k] = temp[i++];
            } else if (temp[i] < temp[j]) {
                nums[k] = temp[i++];
            } else {
                nums[k] = temp[j++];
            }
        }
    }
}
```

##### 315.「 [计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)」

> 给你一个整数数组 `nums`​ ，按要求返回一个新数组 `counts`​ 。数组 `counts`​ 有该性质： `counts[i]`​ 的值是  `nums[i]`​ 右侧小于 `nums[i]`​ 的元素的数量。
>
> **示例 1：**   
> 输入：nums = [5,2,6,1]  
> 输出：[2,1,1,0]  
> 解释：  
> 5 的右侧有 2 个更小的元素 (2 和 1)  
> 2 的右侧仅有 1 个更小的元素 (1)  
> 6 的右侧有 1 个更小的元素 (1)  
> 1 的右侧有 0 个更小的元素

拍脑袋的暴力解法就不说了，嵌套 for 循环，平方级别的复杂度。

这题和归并排序什么关系呢，主要在 merge 函数，**我们在使用 merge 函数合并两个有序数组的时候，其实是可以知道一个元素 nums[i] 后边有多少个元素比 nums[i] 小的**。

具体来说，比如这个场景：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684920798683-ed807ffc-2099-4dae-91ba-1ab270dc1936-20240329101332-pyhbxv4.png" alt="image.png" style="zoom:50%;" />

这时候我们应该把 temp[i] 放到 nums[p] 上，因为 temp[i] < temp[j]。

但就在这个场景下，我们还可以知道一个信息：5 后面比 5 小的元素个数就是 左闭右开区间 [mid + 1, j) 中的元素个数，即 2 和 4 这两个元素：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684920816888-3d676e4e-844d-4bb7-acb4-1002c8711576-20240329101332-h2klcdy.png" alt="image.png" style="zoom:50%;" />

**换句话说，在对 nums[lo..hi] 合并的过程中，每当执行 nums[p] = temp[i] 时，就可以确定 temp[i] 这个元素后面比它小的元素个数为 j - mid - 1**。

当然，nums[lo..hi] 本身也只是一个子数组，这个子数组之后还会被执行 merge，其中元素的位置还是会改变。但这是其他递归节点需要考虑的问题，我们只要在 merge 函数中做一些手脚，叠加每次 merge 时记录的结果即可。

发现了这个规律后，我们只要在 merge 中添加两行代码即可解决这个问题，看解法代码：

```java
class Solution {
    private class Pair {
        int val, id;
        Pair(int val, int id) {
            // 记录数组的元素值
            this.val = val;
            // 记录元素在数组中的原始索引
            this.id = id;
        }
    }
  
    // 归并排序所用的辅助数组
    private Pair[] temp;
    // 记录每个元素后面比自己小的元素个数
    private int[] count;
  
    // 主函数
    public List<Integer> countSmaller(int[] nums) {
        int n = nums.length;
        count = new int[n];
        temp = new Pair[n];
        Pair[] arr = new Pair[n];
        // 记录元素原始的索引位置，以便在 count 数组中更新结果
        for (int i = 0; i < n; i++)
            arr[i] = new Pair(nums[i], i);
    
        // 执行归并排序，本题结果被记录在 count 数组中
        sort(arr, 0, n - 1);
    
        List<Integer> res = new LinkedList<>();
        for (int c : count) res.add(c);
        return res;
    }
  
    // 归并排序
    private void sort(Pair[] arr, int lo, int hi) {
        if (lo == hi) return;
        int mid = lo + (hi - lo) / 2;
        sort(arr, lo, mid);
        sort(arr, mid + 1, hi);
        merge(arr, lo, mid, hi);
    }
  
    // 合并两个有序数组
    private void merge(Pair[] arr, int lo, int mid, int hi) {
        for (int i = lo; i <= hi; i++) {
            temp[i] = arr[i];
        }
    
        int i = lo, j = mid + 1;
        for (int p = lo; p <= hi; p++) {
            if (i == mid + 1) {
                arr[p] = temp[j++];
            } else if (j == hi + 1) {
                arr[p] = temp[i++];
                // 更新 count 数组
                count[arr[p].id] += j - mid - 1;
            } else if (temp[i].val > temp[j].val) {
                arr[p] = temp[j++];
            } else {
                arr[p] = temp[i++];
                // 更新 count 数组
                count[arr[p].id] += j - mid - 1;
            }
        }
    }
}
```

因为在排序过程中，每个元素的索引位置会不断改变，所以我们用一个 Pair 类封装每个元素及其在原始数组 nums 中的索引，以便 count 数组记录每个元素之后小于它的元素个数。

##### 493.「 [翻转对](https://leetcode.cn/problems/reverse-pairs/)」

> 给定一个数组 `nums`​ ，如果 `i < j`​ 且 `nums[i] > 2*nums[j]`​ 我们就将 `(i, j)`​ 称作一个***重要翻转对***。
>
> 你需要返回给定数组中的重要翻转对的数量。
>
> **示例 1:**   
> 输入: [1,3,2,3,1]  
> 输出: 2

你看，这样说其实和题目是一个意思，而且和上一道题非常类似，只不过上一题求的是 nums[i] > nums[j]，这里求的是 nums[i] > 2*nums[j] 罢了。

所以解题的思路当然还是要在 merge 函数中做点手脚，当 nums[lo..mid] 和 nums[mid+1..hi] 两个子数组完成排序后，对于 nums[lo..mid] 中的每个元素 nums[i]，去 nums[mid+1..hi] 中寻找符合条件的 nums[j] 就行了。

看一下我们对 merge 函数的改造：

```java
// 记录「翻转对」的个数
int count = 0;

// 将 nums[lo..mid] 和 nums[mid+1..hi] 这两个有序数组合并成一个有序数组
private void merge(int[] nums, int lo, int mid, int hi) {
    for (int i = lo; i <= hi; i++) {
        temp[i] = nums[i];
    }
  
    // 在合并有序数组之前，加点私货
    for (int i = lo; i <= mid; i++) {
        // 对于左半边的每个 nums[i]，都去右半边寻找符合条件的元素
        for (int j = mid + 1; j <= hi; j++) {
            // nums 中的元素可能较大，乘 2 可能溢出，所以转化成 long
            if ((long)nums[i] > (long)nums[j] * 2) {
                count++;
            }
        }
    }
  
    // 数组双指针技巧，合并两个有序数组
    int i = lo, j = mid + 1;
    for (int p = lo; p <= hi; p++) {
        if (i == mid + 1) {
            nums[p] = temp[j++];
        } else if (j == hi + 1) {
            nums[p] = temp[i++];
        } else if (temp[i] > temp[j]) {
            nums[p] = temp[j++];
        } else {
            nums[p] = temp[i++];
        }
    }
}
```

不过呢，这段代码提交会超时，毕竟额外添加了一个嵌套 for 循环。怎么进行优化呢，注意子数组 nums[lo..mid] 是排好序的，也就是 nums[i] <= nums[i+1]。

所以，对于 nums[i], lo <= i <= mid，我们在找到的符合 nums[i] > 2*nums[j] 的 nums[j], mid+1 &lt;= j &lt;= hi，也必然也符合 nums[i+1] &gt; 2*nums[j]。

**换句话说，我们不用每次都傻乎乎地去遍历整个 nums[mid+1..hi]，只要维护一个开区间边界 end，维护 nums[mid+1..end-1] 是符合条件的元素即可**。

看最终的解法代码：

```java
class Solution {
    public int reversePairs(int[] nums) {
        // 执行归并排序
        sort(nums);
        return count;
    }

    private int[] temp;

    public void sort(int[] nums) {
        temp = new int[nums.length];
        sort(nums, 0, nums.length - 1);
    }

    // 归并排序
    private void sort(int[] nums, int lo, int hi) {
        if (lo == hi) {
            return;
        }
        int mid = lo + (hi - lo) / 2;
        sort(nums, lo, mid);
        sort(nums, mid + 1, hi);
        merge(nums, lo, mid, hi);
    }

    // 记录「翻转对」的个数
    private int count = 0;

    private void merge(int[] nums, int lo, int mid, int hi) {
        for (int i = lo; i <= hi; i++) {
            temp[i] = nums[i];
        }
    
        // 进行效率优化，维护左闭右开区间 [mid+1, end) 中的元素乘 2 小于 nums[i]
        // 为什么 end 是开区间？因为这样的话可以保证初始区间 [mid+1, mid+1) 是一个空区间
        int end = mid + 1;
        for (int i = lo; i <= mid; i++) {
            // nums 中的元素可能较大，乘 2 可能溢出，所以转化成 long
            while (end <= hi && (long)nums[i] > (long)nums[end] * 2) {
                end++;
            }
            count += end - (mid + 1);
        }

        // 数组双指针技巧，合并两个有序数组
        int i = lo, j = mid + 1;
        for (int p = lo; p <= hi; p++) {
            if (i == mid + 1) {
                nums[p] = temp[j++];
            } else if (j == hi + 1) {
                nums[p] = temp[i++];
            } else if (temp[i] > temp[j]) {
                nums[p] = temp[j++];
            } else {
                nums[p] = temp[i++];
            }
        }
    }
}
```

##### 327.「 [区间和的个数](https://leetcode.cn/problems/count-of-range-sum/)」

> 给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的 **区间和的个数** 。
>
> **区间和** S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。
>
> **示例 1：**   
> 输入：nums = [-2,5,-1], lower = -2, upper = 2  
> 输出：3  
> 解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。

简单说，题目让你计算元素和落在 [lower, upper] 中的所有子数组的个数。

拍脑袋的暴力解法我就不说了，依然是嵌套 for 循环，这里还是说利用归并排序实现的高效算法。

首先，解决这道题需要快速计算子数组的和，所以你需要阅读前文 [前缀和数组技巧](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/xiao-er-me-03265/)，创建一个前缀和数组 preSum 来辅助我们迅速计算区间和。

我继续用比较数学的语言来表述下这道题，题目让你通过 preSum 数组求一个 count 数组，使得：

```java
count[i] = COUNT(j) where lower <= preSum[j] - preSum[i] <= upper
```

然后请你求出这个 count 数组中所有元素的和。

你看，这是不是和题目描述一样？preSum 中的两个元素之差其实就是区间和。

有了之前两道题的铺垫，我直接给出这道题的解法代码吧，思路见注释：

```java
class Solution {
    private int lower, upper;

    public int countRangeSum(int[] nums, int lower, int upper) {
    this.lower = lower;
        this.upper = upper;
        // 构建前缀和数组，注意 int 可能溢出，用 long 存储
        long[] preSum = new long[nums.length + 1];
        for (int i = 0; i < nums.length; i++) {
            preSum[i + 1] = (long)nums[i] + preSum[i];
        }
        // 对前缀和数组进行归并排序
        sort(preSum);
        return count;
    }

    private long[] temp;

    public void sort(long[] nums) {
        temp = new long[nums.length];
        sort(nums, 0, nums.length - 1);
    }

    private void sort(long[] nums, int lo, int hi) {
        if (lo == hi) {
            return;
        }
        int mid = lo + (hi - lo) / 2;
        sort(nums, lo, mid);
        sort(nums, mid + 1, hi);
        merge(nums, lo, mid, hi);
    }

    private int count = 0;

    private void merge(long[] nums, int lo, int mid, int hi) {
        for (int i = lo; i <= hi; i++) {
            temp[i] = nums[i];
        }
    
        // 在合并有序数组之前加点私货（这段代码会超时）
        // for (int i = lo; i <= mid; i++) {
        //     for (int j = mid + 1; j <= hi; k++) {
        //         // 寻找符合条件的 nums[j]
        //         long delta = nums[j] - nums[i];
        //         if (delta <= upper && delta >= lower) {
        //             count++;
        //         }
        //     }
        // }
    
        // 进行效率优化
        // 维护左闭右开区间 [start, end) 中的元素和 nums[i] 的差在 [lower, upper] 中
        int start = mid + 1, end = mid + 1;
        for (int i = lo; i <= mid; i++) {
            // 如果 nums[i] 对应的区间是 [start, end)，
            // 那么 nums[i+1] 对应的区间一定会整体右移，类似滑动窗口
            while (start <= hi && nums[start] - nums[i] < lower) {
                start++;
            }
            while (end <= hi && nums[end] - nums[i] <= upper) {
                end++;
            }
            count += end - start;
        }

        // 数组双指针技巧，合并两个有序数组
        int i = lo, j = mid + 1;
        for (int p = lo; p <= hi; p++) {
            if (i == mid + 1) {
                nums[p] = temp[j++];
            } else if (j == hi + 1) {
                nums[p] = temp[i++];
            } else if (temp[i] > temp[j]) {
                nums[p] = temp[j++];
            } else {
                nums[p] = temp[i++];
            }
        }
    }
}
```

我们依然在 merge 函数合并有序数组之前加了一些逻辑，如果看过前文 [滑动窗口核心框架](https://labuladong.github.io/algo/di-ling-zh-bfe1b/wo-xie-le--f02cd/)，这个效率优化有点类似维护一个滑动窗口，让窗口中的元素和 nums[i] 的差落在 [lower, upper] 中。

归并排序相关的题目到这里就讲完了，你现在回头体会下我在本文开头说那句话：

**所有递归的算法，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码。你要写递归算法，本质上就是要告诉每个节点需要做什么**。

比如本文讲的归并排序算法，递归的 sort 函数就是二叉树的遍历函数，而 merge 函数就是在每个节点上做的事情，有没有品出点味道？

##### LCR 170.「**[交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)**」

> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。
>
> **示例 1:**
>
> 输入: [7,5,6,4]  
> 输出: 5

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679581504327-94c11635-cda8-45d1-848d-b448f1f30564-20240329101333-qtj8tf8.gif)

**复杂度分析：**

- 时间复杂度 O(Nlog⁡N) ： 其中 N 为数组长度；归并排序使用 O(Nlog⁡N) 时间；
- 空间复杂度 O(N) ： 辅助数组 tmp 占用 O(N) 大小的额外空间；

```java
class Solution {
    private int count = 0;

    public int reversePairs(int[] nums) {
        int n = nums.length;
        int[] temp = new int[n];
        sort(nums, temp, 0, n - 1);
        return count;
    }

    private void sort(int[] nums, int[] temp, int l, int r) {
        if (l >= r) return; // 单个元素不用排序
        int mid = l + (r - l) / 2;
        sort(nums, temp, l, mid); // 先对左半部分数组 nums[l..mid] 排序
        sort(nums, temp, mid + 1, r); // 再对右半部分数组 nums[mid+1..r] 排序
        merge(nums, temp, l, mid, r); // 将两部分有序数组合并成一个有序数组
    }

    /**
         * 将 nums[l..mid] 和 nums[mid+1,r] 合并成有序数组
         *
         * @param nums
         * @param temp
         * @param l
         * @param mid
         * @param r
         */
    private void merge(int[] nums, int[] temp, int l, int mid, int r) {
        for (int i = l; i <= r; i++) { // 先把 nums[l..r] 复制到辅助数组中, 以便合并后的结果能够直接存入 nums
            temp[i] = nums[i];
        }
        int i = l, j = mid + 1; // i,j 分别代表 两个数组的下标
        for (int k = l; k <= r; k++) {
            if (i == mid + 1) { // 左半边数组已全部被合并
                nums[k] = temp[j++];
            } else if (j == r + 1) { // 右半边数组已全部被合并
                nums[k] = temp[i++];
            } else if (temp[i] <= temp[j]) {
                nums[k] = temp[i++];
            } else { //当左边数组的大与右边数组的元素时，就对当前元素以及后面的元素的个数进行统计
                count += (mid + 1 - i);
                nums[k] = temp[j++];
            }
        }
    }
}
```

### 快排

#### 提纲

首先我们看一下快速排序的代码框架：

```java
void sort(int[] nums, int lo, int hi) {
    if (lo >= hi) {
        return;
    }
    // 对 nums[lo..hi] 进行切分
    // 使得 nums[lo..p-1] <= nums[p] < nums[p+1..hi]
    int p = partition(nums, lo, hi);
    // 去左右子数组进行切分
    sort(nums, lo, p - 1);
    sort(nums, p + 1, hi);
}
```

其实你对比之后可以发现，快速排序就是一个二叉树的前序遍历：

```java
/* 二叉树遍历框架 */
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    /****** 前序位置 ******/
    print(root.val);
    /*********************/
    traverse(root.left);
    traverse(root.right);
}
```

为什么这么说呢，且听我慢慢道来。

快速排序的核心无疑是 partition 函数， partition 函数的作用是在 nums[lo..hi] 中寻找一个切分点 p，通过交换元素使得 nums[lo..p-1] 都小于等于 nums[p]，且 nums[p+1..hi] 都大于 nums[p]：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685086966631-4e34a55a-a7ae-4982-add2-97bfbefbbbc7-20240329101333-gl492gb.png" alt="image.png" style="zoom:50%;" />

一个元素左边的元素都比它小，右边的元素都比它大，啥意思？不就是它自己已经被放到正确的位置上了吗？

所以 partition 函数干的事情，其实就是把 nums[p] 这个元素排好序了。

一个元素被排好序了，然后呢？你再把剩下的元素排好序不就得了。

剩下的元素有哪些？左边一坨，右边一坨，去吧，对子数组进行递归，用 partition 函数把剩下的元素也排好序。

**从二叉树的视角，我们可以把子数组 nums[lo..hi] 理解成二叉树节点上的值，sort 函数理解成二叉树的遍历函数**。

参照二叉树的前序遍历顺序，快速排序的运行过程如下 GIF：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685086964130-bab6550a-b771-42ff-9688-69bc6529cd02-20240329101333-0w6gl1w.gif" alt="1685086964130-bab6550a-b771-42ff-9688-69bc6529cd02" style="zoom:50%;" />

你注意最后形成的这棵二叉树是什么？是一棵二叉搜索树：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685086966760-d7ce424d-cacb-4e67-aca0-03e8c179e7fc-20240329101333-291396r.png" alt="image.png" style="zoom:50%;" />

这应该不难理解吧，因为 partition 函数每次都将数组切分成左小右大两部分，恰好和二叉搜索树左小右大的特性吻合。

**你甚至可以这样理解：快速排序的过程是一个构造二叉搜索树的过程**。

但谈到二叉搜索树的构造，那就不得不说二叉搜索树不平衡的极端情况，极端情况下二叉搜索树会退化成一个链表，导致操作效率大幅降低。

快速排序的过程中也有类似的情况，比如我画的图中每次 partition 函数选出的切分点都能把 nums[lo..hi] 平分成两半，但现实中你不见得运气这么好。

如果你每次运气都特别背，有一边的元素特别少的话，这样会导致二叉树生长不平衡：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685086966685-de367774-fd2a-4df6-ab76-45e4fa2158a2-20240329101334-qqyod5t.png" alt="image.png" style="zoom:50%;" />

这样的话，时间复杂度会大幅上升，后面分析时间复杂度的时候再细说。

**我们为了避免出现这种极端情况，需要引入随机性**。

常见的方式是在进行排序之前对整个数组执行 [洗牌算法](https://labuladong.github.io/article/fname.html?fname=%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95) 进行打乱，或者在 partition 函数中随机选择数组元素作为切分点，本文会使用前者。

```java
public class QuickSort {

    public static void main(String[] args) {
        int[] nums = new int[]{2, 5, 7, 4};
        int[] nums1 = new int[]{3, 2, 1, 5, 6, 4};
        int[] nums2 = new int[]{3, 2, 3, 1, 2, 4, 5, 5, 6};
        int[] nums3 = new int[]{0,0,2,3,2,1,1,2,0,4};
        int[] nums4 = new int[]{0,0,1,2,4,2,2,3,1,4};
//        sort(nums);
//        sort(nums1);
//        sort(nums2);
//        System.out.println(Arrays.toString(nums));
//        System.out.println(Arrays.toString(nums1));
//        System.out.println(Arrays.toString(nums2));
//        System.out.println(Arrays.toString(topKFrequent(nums2, 6)));
//        System.out.println(Arrays.toString(topKFrequent(nums3, 10)));
        System.out.println(Arrays.toString(topKFrequent(nums4, 8)));
//        System.out.println(findKthLargest(new int[]{1}, 1));
    }

    public static int[] topKFrequent(int[] nums, int k) {
        if (nums.length == 0 || k == 0)
            return new int[0];
        quickSortK(nums, 0, nums.length - 1, k);
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = nums[i];
        }
        return res;
    }

    public static int findKthLargest(int[] nums, int k) {
        int lo = 0, hi = nums.length - 1;
        k = nums.length - k; // 转化成「排名第 k 的元素」
        while (lo <= hi) {
            int p = partition(nums, lo, hi);
            if (p < k) {
                lo = p + 1;
            } else if (p > k) {
                hi = p - 1;
            } else {
                return nums[p];
            }
        }
        return -1;
    }

    public static void sort(int[] nums) {
        // 为了避免出现耗时的极端情况，先随机打乱
        shuffle(nums);
        // 排序整个数组（原地修改）
        quickSort(nums, 0, nums.length - 1);
    }

    private static void quickSort(int[] nums, int lo, int hi) {
        if (lo >= hi) {
            return;
        }
        // 对 nums[lo..hi] 进行切分
        // 使得 nums[lo..p-1] <= nums[p] < nums[p+1..hi]
        int p = partition(nums, lo, hi);

        if (p != -1) {
            quickSort(nums, lo, p - 1);
            quickSort(nums, p + 1, hi);
        }
    }

    private static void quickSortK(int[] nums, int lo, int hi, int k) {
        if (lo >= hi) {
            return;
        }
        // 对 nums[lo..hi] 进行切分
        // 使得 nums[lo..p-1] <= nums[p] < nums[p+1..hi]
        int p = partition(nums, lo, hi);

        if (p < k) {
            quickSortK(nums, p + 1, hi, k);
        } else if (p > k) {
            quickSortK(nums, lo,p - 1, k);
        }
    }

    // 对 nums[lo..hi] 进行切分
    private static int partition(int[] arr, int lo, int hi) {
        // 子数组长度为 1 时终止递归
        if (lo > hi) return -1;
        int target = arr[lo]; // 以起点作为基准
        int i = lo;
        int j = hi;
        while (i < j) {
            while (i < j && arr[j] >= target) // 从后往前找 比基准值 小
                --j;
            while (i < j && arr[i] <= target) // 从前往后找 比基准值 大
                ++i;
            swap(arr, i, j); // 交换位置
        }
        // 此时，i和j是一样的
        swap(arr, lo, i); // 最后将 target 放到合适的位置，即 target 左边元素较小，右边元素较大
        return i;
    }


    // 洗牌算法，将输入的数组随机打乱
    private static void shuffle(int[] nums) {
        Random rand = new Random();
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            // 生成 [i, n - 1] 的随机数
            int r = i + rand.nextInt(n - i);
            swap(nums, i, r);
        }
    }

    // 原地交换数组中的两个元素
    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

}
```

#### 快速排序代码实现

‍

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1701421181308-75ed9730-e1e1-4a5b-9359-76facce90fdc-20240329101334-9odmyaj.png)

明白了上述概念，直接看快速排序的代码实现：

```java
class Quick {

    public static void sort(int[] nums) {
        // 为了避免出现耗时的极端情况，先随机打乱
        shuffle(nums);
        // 排序整个数组（原地修改）
        quickSort(nums, 0, nums.length - 1);
    }

    private static void quickSort(int[] nums, int lo, int hi) {
        if (lo >= hi) {
            return;
        }
        // 对 nums[lo..hi] 进行切分
        // 使得 nums[lo..p-1] <= nums[p] < nums[p+1..hi]
        int p = partition(nums, lo, hi);

        if (p != -1) {
            quickSort(nums, lo, p - 1);
            quickSort(nums, p + 1, hi);
        }
    }

    // 对 nums[lo..hi] 进行切分
    private static int partition(int[] arr, int l, int r) {
        // 子数组长度为 0 时终止递归
        if (l > r) return -1;
        int target = arr[l]; // 以起点作为基准
        int i = l;
        int j = r;
        while (i < j) {
            while (i < j && arr[j] >= target) // 找到比基准值小的值为止
                --j;
            while (i < j && arr[i] <= target) // 找到比基准值大的值为止
                ++i;
            swap(arr, i, j); // 交换位置
        }
        // 此时，i和j是一样的
        swap(arr, l, i); // 最后将 target 放到合适的位置，即 target 左边元素较小，右边元素较大
        return i;
    }

    // 洗牌算法，将输入的数组随机打乱
    private static void shuffle(int[] nums) {
        Random rand = new Random();
        int n = nums.length;
        for (int i = 0 ; i < n; i++) {
            // 生成 [i, n - 1] 的随机数
            int r = i + rand.nextInt(n - i);
            swap(nums, i, r);
        }
    }

    // 原地交换数组中的两个元素
    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

**注意 while 循环的顺序不能颠倒，应该先从后往前找比基准小的，再从前往后找比基准大的**

> 因为 nums[i] = target，所以 i 最开始是一定等于基准的，无论如何也会 +1，后面从后往前找比基准小的时候，j 就取不到 i 最开始的索引了。

参照

**示例 1：**

输入：stock = [2,5,7,4], cnt = 1 输出：[2]

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1701424073961-ec368c59-b2fc-4350-9e39-7cde3f70f9fb-20240329101334-i5f1zm1.png" alt="image.png" style="zoom:50%;" />

这个时候，i，j 都为 1，lo 为 0，跳出 while 循环时，就会调换 lo 和 i 的数值，那就排序错了。

接下来分析一下快速排序的时间复杂度。

显然，快速排序的时间复杂度主要消耗在 partition 函数上，因为这个函数中存在循环。

所以 partition 函数到底执行了多少次？每次执行的时间复杂度是多少？总的时间复杂度是多少？

和归并排序类似，需要结合之前画的这幅图来从整体上分析：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685090153212-0ad65f5f-a818-4c1d-a5f1-32709ef09c8a-20240329101334-tpsh5mf.png" alt="image.png" style="zoom:50%;" />

**partition 执行的次数是二叉树节点的个数，每次执行的复杂度就是每个节点代表的子数组 nums[lo..hi] 的长度，所以总的时间复杂度就是整棵树中「数组元素」的个数**。

假设数组元素个数为 N，那么二叉树每一层的元素个数之和就是 O(N)；切分点 p 每次都落在数组正中间的理想情况下，树的层数为 O(logN)，所以理想的总时间复杂度为 O(NlogN)。

由于快速排序没有使用任何辅助数组，所以空间复杂度就是递归堆栈的深度，也就是树高 O(logN)。

当然，我们之前说过快速排序的效率存在一定随机性，如果每次 partition 切分的结果都极不均匀：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685090167768-e8156ebe-90e0-49fd-81ca-75981d35064e-20240329101334-1ivle14.png" alt="image.png" style="zoom:50%;" />

快速排序就退化成选择排序了，树高为 O(N)，每层节点的元素个数从 N 开始递减，总的时间复杂度为：

> N + (N - 1) + (N - 2) + ... + 1 = O(N^2)

所以我们说，快速排序理想情况的时间复杂度是 O(NlogN)，空间复杂度 O(logN)，极端情况下的最坏时间复杂度是 O(N^2)，空间复杂度是 O(N)。

不过大家放心，经过随机化的 partition 函数很难出现极端情况，所以快速排序的效率还是非常高的。

**还有一点需要注意的是，快速排序是「不稳定排序」，与之相对的，前文讲的** **[归并排序](https://labuladong.github.io/article/fname.html?fname=%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)** **是「稳定排序」** 。

对于序列中的相同元素，如果排序之后它们的相对位置没有发生改变，则称该排序算法为「稳定排序」，反之则为「不稳定排序」。

如果单单排序 int 数组，那么稳定性没有什么意义。但如果排序一些结构比较复杂的数据，那么稳定性排序就有更大的优势了。

比如说你有若干订单数据，已经按照订单号排好序了，现在你想对订单的交易日期再进行排序：

如果用稳定排序算法（比如归并排序），那么这些订单不仅按照交易日期排好了序，而且相同交易日期的订单的订单号依然是有序的。

但如果你用不稳定排序算法（比如快速排序），那么虽然排序结果会按照交易日期排好序，但相同交易日期的订单的订单号会丧失有序性。

**在实际工程中我们经常会将一个复杂对象的某一个字段作为排序的 key，所以应该关注编程语言提供的 API 底层使用的到底是什么排序算法，是稳定的还是不稳定的，这很可能影响到代码执行的效率甚至正确性**。

#### 快速选择算法

不仅快速排序算法本身很有意思，而且它还有一些有趣的变体，最有名的就是快速选择算法（Quick Select）。

假如我们寻找**第 k 个最大的元素**，稍微有点绕，意思是去寻找 nums 数组降序排列后排名第 k 的那个元素。

比如输入 nums = [2,1,5,4], k = 2，算法应该返回 4，因为 4 是 nums 中第 2 个**最大**的元素。

这种问题有两种解法，一种是二叉堆（优先队列）的解法，另一种就是快速选择算法，我们分别来看。

**二叉堆的解法比较简单，但时间复杂度稍高**，直接看代码好了：

```java
int findKthLargest(int[] nums, int k) {
    // 小顶堆，堆顶是最小元素
    PriorityQueue<Integer>  pq = new PriorityQueue<>();
    for (int e : nums) {
        // 每个元素都要过一遍二叉堆
        pq.offer(e);
        // 堆中元素多于 k 个时，删除堆顶元素
        if (pq.size() > k) {
            pq.poll();
        }
    }
    // pq 中剩下的是 nums 中 k 个最大元素，
    // 堆顶是最小的那个，即第 k 个最大元素
    return pq.peek();
}
```

二叉堆（优先队列）是一种能够自动排序的数据结构，我们前文 [手把手实现二叉堆数据结构](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_633faa07e4b0a51fef24c4e9/1) 实现过这种结构，我就默认大家熟悉它的特性了。

核心思路就是把小顶堆 pq 理解成一个筛子，较大的元素会沉淀下去，较小的元素会浮上来；当堆大小超过 k 的时候，我们就删掉堆顶的元素，因为这些元素比较小，而我们想要的是前 k 个最大元素嘛。

当 nums 中的所有元素都过了一遍之后，筛子里面留下的就是最大的 k 个元素，而堆顶元素是堆中最小的元素，也就是「第 k 个最大的元素」。

思路很简单吧，唯一注意的是，Java 的 PriorityQueue 默认实现是小顶堆，有的语言的优先队列可能默认是大顶堆，可能需要做一些调整。

二叉堆插入和删除的时间复杂度和堆中的元素个数有关，在这里我们堆的大小不会超过 k，所以插入和删除元素的复杂度是 O(logk)，再套一层 for 循环，假设数组元素总数为 N，总的时间复杂度就是 O(Nlogk)。

这个解法的空间复杂度很显然就是二叉堆的大小，为 O(k)。

**快速选择算法是快速排序的变体，效率更高**，面试中如果能够写出快速选择算法，肯定是加分项。

首先，题目问「第 k 个最大的元素」，相当于数组升序排序后「排名第 n - k 的元素」，为了方便表述，后文另 k' = n - k。

如何知道「排名第 k' 的元素」呢？其实在快速排序算法 partition 函数执行的过程中就可以略见一二。

我们刚说了，partition 函数会将 nums[p] 排到正确的位置，使得 nums[lo..p-1] < nums[p] < nums[p+1..hi]：

这时候，虽然还没有把整个数组排好序，但我们已经让 nums[p] 左边的元素都比 nums[p] 小了，也就知道 nums[p] 的排名了。

**那么我们可以把 p 和 k' 进行比较，如果 p &lt; k' 说明第 k' 大的元素在 nums[p+1..hi] 中，如果 p &gt; k' 说明第 k' 大的元素在 nums[lo..p-1] 中**。

进一步，去 nums[p+1..hi] 或者 nums[lo..p-1] 这两个子数组中执行 partition 函数，就可以进一步缩小排在第 k' 的元素的范围，最终找到目标元素。

这样就可以写出解法代码：

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        shuffle(nums);
        int lo = 0, hi = nums.length - 1;
        k = nums.length - k;
        while (lo <= hi) {
            int p = partition(nums, lo, hi);
            if (p < k) {
                lo = p + 1;
            } else if (p > k) {
                hi = p - 1;
            } else {
                return nums[p];
            }
        }
        return -1;
    }

    public int partition(int[] nums, int lo, int hi) {
        if (lo > hi)
            return -1;
        int target = nums[lo];
        int i = lo, j = hi;
        while (i < j) {
            while (i < j && nums[j] >= target) {
                --j;
            }
            while (i < j && nums[i] <= target) {
                ++i;
            }
            swap(nums, i, j);
        }
        swap(nums, lo, i);
        return i;
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public void shuffle (int[] nums) {
        Random random = new Random();
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            int j = i + random.nextInt(n - i);
            swap(nums, i, j);
        }
    }
}
```

这个代码框架其实非常像我们前文 [二分搜索框架](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_627cce93e4b0812e17989cfa/1) 的代码，这也是这个算法高效的原因，但是时间复杂度为什么是 O(N) 呢？

显然，这个算法的时间复杂度也主要集中在 partition 函数上，我们需要估算 partition 函数执行了多少次，每次执行的时间复杂度是多少。

最好情况下，每次 partition 函数切分出的 p 都恰好是正中间索引 (lo + hi) / 2（二分），且每次切分之后会到左边或者右边的子数组继续进行切分，那么 partition 函数执行的次数是 logN，每次输入的数组大小缩短一半。

所以总的时间复杂度为：

> 等比数列
>
> N + N/2 + N/4 + N/8 + ... + 1 = 2N = O(N)

当然，类似快速排序，快速选择算法中的 partition 函数也可能出现极端情况，最坏情况下 p 一直都是 lo + 1 或者一直都是 hi - 1，这样的话时间复杂度就退化为 O(N^2) 了：

> N + (N - 1) + (N - 2) + ... + 1 = O(N^2)

这也是我们在代码中使用 shuffle 函数的原因，通过引入随机性来避免极端情况的出现，让算法的效率保持在比较高的水平。随机化之后的快速选择算法的复杂度可以认为是 O(N)。

到这里，快速排序算法和快速选择算法就讲完了，从二叉树的视角来理解思路应该是不难的，但 partition 函数对细节的把控需要你多花心思去理解和记忆。

#### 练习题

##### 215.「[数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)」

> 给定整数数组 nums 和整数 k，请返回数组中第 **k** 个最大的元素。
>
> 请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。
>
> 你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。
>
> **示例 1:**   
> 输入: [3,2,1,5,6,4], k = 2  
> 输出: 5

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        shuffle(nums);
        int lo = 0, hi = nums.length - 1;
        k = nums.length - k;
        while (lo <= hi) {
            int p = partition(nums, lo, hi);
            if (p < k) {
                lo = p + 1;
            } else if (p > k) {
                hi = p - 1;
            } else {
                return nums[p];
            }
        }
        return -1;
    }

    public int partition(int[] nums, int lo, int hi) {
        if (lo > hi)
            return -1;
        int target = nums[lo];
        int i = lo, j = hi;
        while (i < j) {
            while (i < j && nums[j] >= target) {
                --j;
            }
            while (i < j && nums[i] <= target) {
                ++i;
            }
            swap(nums, i, j);
        }
        swap(nums, lo, i);
        return i;
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public void shuffle (int[] nums) {
        Random random = new Random();
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            int j = i + random.nextInt(n - i);
            swap(nums, i, j);
        }
    }
}
```

##### LCR 159.「[库存管理 III](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/description/)」

> 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
>
> **示例 1：**   
> 输入：arr = [3,2,1], k = 2  
> 输出：[1,2] 或者 [2,1]

**基于快速排序的数组划分**

题目只要求返回最小的 k 个数，对这 k 个数的顺序并没有要求。因此，只需要将数组划分为 最小的 k 个数 和 其他数字 两部分即可，而快速排序的哨兵划分可完成此目标。

根据快速排序原理，如果某次哨兵划分后 基准数正好是第 k+1 小的数字 ，那么此时基准数左边的所有数字便是题目所求的 最小的 k 个数 。

根据此思路，考虑在每次哨兵划分后，判断基准数在数组中的索引是否等于 k ，若 truet 则直接返回此时数组的前 k 个数字即可。

**复杂度分析：**

- 时间复杂度 O(N) ： 其中 N 为数组元素数量；对于长度为 N 的数组执行哨兵划分操作的时间复杂度为 O(N) ；每轮哨兵划分后根据 k 和 i 的大小关系选择递归，由于 i 分布的随机性，则向下递归子数组的平均长度为 n / 2；因此平均情况下，哨兵划分操作一共有<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679047141887-e1ca39ff-0941-45e4-b9e4-9968669c92b0-20240329101335-8ha4ep1.png" alt="image.png" style="zoom:70%;" />（等比数列求和），即总体时间复杂度为 O(N)
- **空间复杂度 O(log⁡N)：**  划分函数的平均递归深度为 **O(log⁡N)**  。

```java
class Solution {
    public int[] inventoryManagement(int[] stock, int cnt) {
        if (stock.length == 0 || cnt == 0)
            return new int[0];
        quickSortK(stock, 0, stock.length - 1, cnt);
        int[] res = new int[cnt];
        for (int i = 0; i < cnt; i++) {
            res[i] = stock[i];
        }
        return res;
    }
    private void quickSortK(int[] nums, int lo, int hi, int k) {
        if (lo >= hi) {
            return;
        }
        // 对 nums[lo..hi] 进行切分
        // 使得 nums[lo..p-1] <= nums[p] < nums[p+1..hi]
        int p = partition(nums, lo, hi);

        if (p < k) {
            quickSortK(nums, p + 1, hi, k);
        } else if (p > k) {
            quickSortK(nums, lo,p - 1, k);
        }
    }
    // 对 nums[lo..hi] 进行切分
    private int partition(int[] arr, int lo, int hi) {
        // 子数组长度为 1 时终止递归
        if (lo > hi) return -1;
        int target = arr[lo]; // 以起点作为基准
        int i = lo;
        int j = hi;
        while (i < j) {
            while (i < j && arr[j] >= target) // 从后往前找 比基准值 小
                --j;
            while (i < j && arr[i] <= target) // 从前往后找 比基准值 大
                ++i;
            swap(arr, i, j); // 交换位置
        }
        // 此时，i和j是一样的
        swap(arr, lo, i); // 最后将 target 放到合适的位置，即 target 左边元素较小，右边元素较大
        return i;
    }
    public void swap (int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

## 位运算

### 练习题

#### **LCR 177.「**​[撞色搭配](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)」

> 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
>
> 示例 1：  
> 输入：nums = [4,1,4,6]  
> 输出：[1,6] 或 [6,1]

题解思路：

已知：两数相等异或结果为0，一个数与0异或结果就等于其本身。所以如果数组中只有一个出现一次的数，那么就只需要对所有的数进行异或就可以得到这个只出现一次的数，而本题中出现一次的数有两个。所以所有数异或的结果就是那两个只出现一次的数异或的结果。所以根据这个特性，我们就可以采用分组的方法解决此问题。

分组要满足两个条件：

- 两个相同的数必须出现在同一组。
- 那两个只出现一次的数必须分配在不同的组。

这样我们分别对这两组数进行异或，就可以得到两个出现一次的数。那么，究竟应该怎么分组呢？

例如【4,1,4,6】:全部异或的结果就是1和6异或的结果。就是0001和0110异或的结果0111。其实我们不难发现。将该两个相同的数分配在一组是很容易实现的。我们只需要固定一个二进制位，若这两个数在这个二进制位上的数是相同的。我们就把他分在同一组。但是难点还是在如何实现将两个子出现一次的数分配在不同的组里面。

往下分析，1和6异或结果就是0111，0111这个二进制数中是1的二进制位暗含了什么个意思呢？分析不难知道，二进制位是1，就表示1和6在这个二进制位上的数是不同的。所以，这就是我们划分两个数到不同组的依据。因为0111有三个二进制位都是1，分别是第一位、第二位、第三位。这就表示了1和6的二进制数在第一、二、三位上的数是不同的。我们假设就以第一个二进制位为划分标准。当数组中的数的第一个二进制位是1的就分为第一组。数组中的数第一个二进制位是0的就划分为第二组。这样就成功的将1和6分到了不同的组别中，而相同的数例如4，因为4和4的第一个二进制位是必然相等的，这样也就实现了将两个相同的数划分到同一组。最后只需要分别将这两个组进行异或，就可以得到我们要求的答案。

> - 第一轮整体遍历，求出a^b（因为相同的数字异或为0，0异或任何数字为数字自身）
> - 然后结合a^b以及原来数组求出这两个数字
    >
    >   - 原理：用一个只有一位为1的数字来遍历异或整个数组，把这个数组分成两个子数组（异或结果相同的数字在同一个子数组），如果是两个相同的数字，它们一定在同一个子数组里（保证子数组异或时为0），现在只需要把两个只出现一次的数字分到不同的子数组，那么子数组分别遍历异或得到的两个数字就是这两个数字。
>   - 怎么把两个只出现一次的数字分到不同地子数组？
      >
      >     - 找到a^b第一个为1的位置，异或结果为1说明a和b在这一位上不同，那用只有这一位为1的数字m去分别异或a和b，得到的结果一定不同，也就把a和b分到了不同的子数组。结合上一点得出结果。

```java
class Solution {
    public int[] singleNumbers(int[] nums) {
        int ret = 0;
        for(int num:nums){
            ret ^= num;//ret最终答案就是那两个只出现一次的的数异或的结果
        }
        //找到ret二进制数中第几位是1
        int target = 1;//初始位0001
        while((target & ret)==0){//如果target第一个二进制位不为1，就将target左移一位位0010，然后与相与，判断ret第二位是否为一.按此循环，知道找到ret的第一个为1的二进制位
            target = target<<1;
        }
        int a = 0, b = 0;
        for(int num:nums){
            if((num & target)==0){//第一组
                a ^= num;
            }else{//第二组
                b ^= num;
            }
        }
        return new int[]{a,b};
    }
}
```

#### **LCR 178.「**​[训练计划 VI](https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)」

> 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
>
> 示例 1：  
> 输入：nums = [3,4,3,3]  
> 输出：4

值得注意的是：如果某个数字出现3次，那么这个3个数字的和肯定能被3整除，则其对应二进制位的每一位的和也能被3整除  
统计数组中每个数字的二进制中每一位的和，判断该和是否能被3整除。

若可以，则只出现一次的数字的二进制数中那一位为0，否则为1

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for (int i = 0; i < 32; i++) { // int最大32位，统计每一位
            int cnt = 0;
            int index = 1 << i; // 第几位
            for (int num : nums) {
                if((num & index) != 0) ++cnt;
            }
            if(cnt % 3 != 0){ // 说明这一位为1
                res ^= index; // 该位设为1
            }
        }
        return res;
    }
}
```

#### LCR 190.「**[加密运算](https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)**」

> 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。
>
> **示例:**   
> 输入: a = 1, b = 1  
> 输出: 2

如果是十进制的话，我们是如何完成加法计算的？

15 + 12 = ？

1. 个位数和十位数的数字分别相加先不管进位的问题，

> 2 + 5 = 7；  
> 1 + 1 = 2；
>
> 所以得到结果 27。

2. 计算产生进位的数字 这里有进位吗？没有，那么就是0
3. 把上面两步的结果进行相加：27 + 0 = 27；

99 + 111 = ？

1. 个、十、百位 的数字分别相加先不管进位的问题：

> 个位：9 + 1 = 0  
> 十位：9 + 1 = 0  
> 百位：0 + 1 = 1
>
> 得到临时结果：100

2. 计算进位的数字：

> 1 + 9 = 10;  
> 10 + 90 = 100;  
> 得到进位结果：110

3. 相加得到结果

> 100 + 110 = 210

如何用二进制完成以上的步骤？

问题1： 二进制的加法利用以上的步骤可以得到正确的结果吗？

12 二进制：1100  
15 二进制：1111

1. 各位置上的数字分别相加先不管进位的问题：

> 1100 + 1111 = 0011
>
> 得到临时二进制结果：0011

2. 计算进位的数字：

> 0100 + 0100 = 1000
>
> 1000 + 1000= 10000
>
> 得到进位结果：11000

3. 相加得到结果

> 0011 + 11000 = 11011（十进制：27）

就目前来看，是可以的。

问题2：第一步骤不用加法如何得到相同结果？异或

异或：相同为0，相异为1

> 1100 ^ 1111 = 0011

问题3：第二步骤不用加法如何得到相同结果？相与，左移一位

如果一个位置上的数字相遇能得到1 ，那么表示，位置上的数字都是1，然后在往左移动一位，就是步骤二 进位得到的结果

> (1100 & 1111) << 1 = 11000

问题4：第三步骤不用加法如何得到相同结果？其实这是个套娃

第三步不用加法实现最难，因为第三步是前两步的和，还是个加法；如果不用加法，就只能不断调用前两步的步骤。

我想用下面的一张图来说明：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1701684386663-55ef3773-c693-407d-8d29-cc2d117eb32a-20240329162422-nnjzj9m.png)

```java
public int add(int a, int b) {
    if (b==0) return a;
    if (a==0) return b;
    int plus1 = (a ^ b); // 求和（不计进位）. 相同位置0，相反位置1
    int plus2 = ((a & b) << 1); // 计算进位. 先保留同为1的位，都为1的位要向左进位，因此左移1位
    return add(plus1, plus2);
}
```

## 回溯

### 回溯算法大纲

### 排列-组合-子集问题

#### 纲领

无论是排列、组合还是子集问题，简单说无非就是让你从序列 nums 中以给定规则取若干元素，主要有以下几种变体：

- **形式一、元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式**。

    - 以组合为例，如果输入 nums = [2,3,6,7]，和为 7 的组合应该只有 [7]。
- **形式二、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次**。

    - 以组合为例，如果输入 nums = [2,5,2,1,2]，和为 7 的组合应该有两种 [2,2,2,1] 和 [5,2]。
- **形式三、元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次**。

    - 以组合为例，如果输入 nums = [2,3,6,7]，和为 7 的组合应该有两种 [2,2,3] 和 [7]。
- 当然，也可以说有第四种形式，即元素可重可复选。但既然元素可复选，那又何必存在重复元素呢？元素去重之后就等同于形式三，所以这种情况不用考虑。

上面用组合问题举的例子，但排列、组合、子集问题都可以有这三种基本形式，所以共有 9 种变化。

除此之外，题目也可以再添加各种限制条件，比如让你求和为 target 且元素个数为 k 的组合，那这么一来又可以衍生出一堆变体，怪不得面试笔试中经常考到排列组合这种基本题型。

**但无论形式怎么变化，其本质就是穷举所有解，而这些解呈现树形结构，所以合理使用回溯算法框架，稍改代码框架即可把这些问题一网打尽**。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676616934528-c826c0ec-b13f-4de7-9c0d-8420871bfcf4-20240329163842-s842l2d.png" alt="image.png" style="zoom:50%;" />

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676616934834-fa76fa64-3aca-4a4c-b588-6440d300f82e-20240329163843-czo92fa.png" alt="image.png" style="zoom:50%;" />

为什么只要记住这两种树形结构就能解决所有相关问题呢？

**首先，组合问题和子集问题其实是等价的，这个后面会讲；至于之前说的三种变化形式，无非是在这两棵树上剪掉或者增加一些树枝罢了**。

#### 练习题

##### 元素无重不可复选

###### 子集

###### 78.「 [子集](https://leetcode.cn/problems/subsets/)」

> 给你一个整数数组 nums ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。
>
> 解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。
>
> **示例 1：**   
> 输入：nums = [1,2,3]  
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]

好，我们暂时不考虑如何用代码实现，先回忆一下我们的高中知识，如何手推所有子集？

首先，生成元素个数为 0 的子集，即空集 []，为了方便表示，我称之为 S_0。

然后，在 S_0 的基础上生成元素个数为 1 的所有子集，我称为 S_1：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676617128900-be4e9220-4d93-424d-92e8-4335f1c890c0-20240329163844-sikzu3u.png" alt="image.png" style="zoom:50%;" />

接下来，我们可以在 S_1 的基础上推导出 S_2，即元素个数为 2 的所有子集：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676617145625-f40e688d-169b-424f-a7f2-edb198b31722-20240329163844-722gsbi.png" alt="image.png" style="zoom:50%;" />

为什么集合 [2] 只需要添加 3，而不添加前面的 1 呢？

因为集合中的元素不用考虑顺序， [1,2,3] 中 2 后面只有 3，如果你向前考虑 1，那么 [2,1] 会和之前已经生成的子集 [1,2] 重复。

**换句话说，我们通过保证元素之间的相对顺序不变来防止出现重复的子集**。

接着，我们可以通过 S_2 推出 S_3，实际上 S_3 中只有一个集合 [1,2,3]，它是通过 [1,2] 推出的。

整个推导过程就是这样一棵树：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676617137195-8b98e37c-9c7f-4762-82c4-3ef3960608ce-20240329163845-734ibx4.png" alt="image.png" style="zoom:50%;" />

注意这棵树的特性：

**如果把根节点作为第 0 层，将每个节点和根节点之间树枝上的元素作为该节点的值，那么第 n 层的所有节点就是大小为 n 的所有子集**。

你比如大小为 2 的子集就是这一层节点的值：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676617152538-78537c5d-8e58-4922-a3d0-518dfb57f785-20240329163846-028y6tq.png" alt="image.png" style="zoom:50%;" />

**PS：注意，本文之后所说「节点的值」都是指节点和根节点之间树枝上的元素，且将根节点认为是第 0 层**。

那么再进一步，如果想计算所有子集，那只要遍历这棵多叉树，把所有节点的值收集起来不就行了？

直接看代码：

```java
List<List<Integer>> res = new LinkedList<>();
// 记录回溯算法的递归路径
LinkedList<Integer> track = new LinkedList<>();

// 主函数
public List<List<Integer>> subsets(int[] nums) {
    backtrack(nums, 0);
    return res;
}

// 回溯算法核心函数，遍历子集问题的回溯树
void backtrack(int[] nums, int start) {

    // 前序位置，每个节点的值都是一个子集
    res.add(new LinkedList<>(track));
  
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 通过 start 参数控制树枝的遍历，避免产生重复的子集
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}
```

我们使用 start 参数控制树枝的生长避免产生重复的子集，用 track 记录根节点到每个节点的路径的值，同时在前序位置把每个节点的路径值收集起来，完成回溯树的遍历就收集了所有子集：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676617808959-7398b704-51ac-4c7d-924c-e5750c04fcd2-20240329163847-p2ogzkn.png" alt="image.png" style="zoom:50%;" />

最后，backtrack 函数开头看似没有 base case，会不会进入无限递归？

其实不会的，当 start == nums.length 时，叶子节点的值会被装入 res，但 for 循环不会执行，也就结束了递归。

###### 组合

###### 77.「 [组合](https://leetcode.cn/problems/combinations/)」

> 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。
>
> 你可以按 **任何顺序** 返回答案。
>
> **示例 1：**   
> 输入：n = 4, k = 2  
> 输出：[
> [2,4],
> [3,4],
> [2,3],
> [1,2],
> [1,3],
> [1,4]  
> ]

还是以 nums = [1,2,3] 为例，刚才让你求所有子集，就是把所有节点的值都收集起来；**现在你只需要把第 2 层（根节点视为第 0 层）的节点收集起来，就是大小为 2 的所有组合**：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676617994193-a9aed597-fedf-400b-9266-3bdcbee3b25b-20240329163848-c9twlry.png" alt="image.png" style="zoom:50%;" />

反映到代码上，只需要稍改 base case，控制算法仅仅收集第 k 层节点的值即可：

```java
List<List<Integer>> res = new LinkedList<>();
// 记录回溯算法的递归路径
LinkedList<Integer> track = new LinkedList<>();

// 主函数
public List<List<Integer>> combine(int n, int k) {
    backtrack(1, n, k);
    return res;
}

void backtrack(int start, int n, int k) {
    // base case
    if (k == track.size()) {
        // 遍历到了第 k 层，收集当前节点的值
        res.add(new LinkedList<>(track));
        return;
    }
  
    // 回溯算法标准框架
    for (int i = start; i <= n; i++) {
        // 选择
        track.addLast(i);
        // 通过 start 参数控制树枝的遍历，避免产生重复的子集
        backtrack(i + 1, n, k);
        // 撤销选择
        track.removeLast();
    }
}
```

这样，标准的子集问题也解决了。

###### 排列

###### 46.「 [全排列](https://leetcode.cn/problems/permutations/)」

> 给定一个不含重复数字的数组 nums ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。
>
> **示例 1：**   
> 输入：nums = [1,2,3]  
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

刚才讲的组合/子集问题使用 start 变量保证元素 nums[start] 之后只会出现 nums[start+1..] 中的元素，通过固定元素的相对位置保证不出现重复的子集。

**但排列问题本身就是让你穷举元素的位置，nums[i] 之后也可以出现 nums[i] 左边的元素，所以之前的那一套玩不转了，需要额外使用 used 数组来标记哪些元素还可以被选择**。

标准全排列可以抽象成如下这棵多叉树：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676618580025-e475214d-d76b-4de1-ab75-79f43944468f-20240329163848-q8pp5e8.png" alt="image.png" style="zoom:50%;" />

我们用 used 数组标记已经在路径上的元素避免重复选择，然后收集所有叶子节点上的值，就是所有全排列的结果：

下面，直接看全排列代码：

```java
List<List<Integer>> res = new LinkedList<>();

/* 主函数，输入一组不重复的数字，返回它们的全排列 */
List<List<Integer>> permute(int[] nums) {
    // 记录「路径」
    LinkedList<Integer> track = new LinkedList<>();
    // 「路径」中的元素会被标记为 true，避免重复使用
    boolean[] used = new boolean[nums.length];
  
    backtrack(nums, track, used);
    return res;
}

// 路径：记录在 track 中
// 选择列表：nums 中不存在于 track 的那些元素（used[i] 为 false）
// 结束条件：nums 中的元素全都在 track 中出现
void backtrack(int[] nums, LinkedList<Integer> track, boolean[] used) {
    // 触发结束条件
    if (track.size() == nums.length) {
        res.add(new LinkedList(track));
        return;
    }
  
    for (int i = 0; i < nums.length; i++) {
        // 排除不合法的选择
        if (used[i]) {
            // nums[i] 已经在 track 中，跳过
            continue;
        }
        // 做选择
        track.add(nums[i]);
        used[i] = true;
        // 进入下一层决策树
        backtrack(nums, track, used);
        // 取消选择
        track.removeLast();
        used[i] = false;
    }
}
```

我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 used 数组排除已经存在 track 中的元素，从而推导出当前的选择列表：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676451402767-74b4f4f5-742e-4947-b4a9-24f4c63a0ad1-20240329163849-l7pm214.png" alt="image.png" style="zoom:50%;" />

至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是最高效的，你可能看到有的解法连 used 数组都不使用，通过交换元素达到目的。但是那种解法稍微难理解一些，这里就不写了，有兴趣可以自行搜索一下。

但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。

**这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高**。

##### 元素可重不可复选

###### 子集

###### 90.「 [子集 II](https://leetcode.cn/problems/subsets-ii/)」

> 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
>
> 解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。
>
> **示例 1：**   
> 输入：nums = [1,2,2]  
> 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]

当然，按道理说「集合」不应该包含重复元素的，但既然题目这样问了，我们就忽略这个细节吧，仔细思考一下这道题怎么做才是正事。

就以 nums = [1,2,2] 为例，为了区别两个 2 是不同元素，后面我们写作 nums = [1,2,2']。

按照之前的思路画出子集的树形结构，显然，两条值相同的相邻树枝会产生重复：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676619352684-5198e53f-04d4-46a5-b9ce-9391f2ea696f-20240329163850-pbtxqbd.png" alt="image.png" style="zoom:50%;" />

‍

```java
[ 
    [],
    [1],[2],[2'],
    [1,2],[1,2'],[2,2'],
    [1,2,2']
]
```

所以我们需要进行剪枝，如果一个节点有多条值相同的树枝相邻，则只遍历第一条，剩下的都剪掉，不要去遍历：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676619346463-bda6650e-bd06-4a19-9010-ff1312ac3165-20240329163850-3ms9ked.png" alt="image.png" style="zoom:50%;" />

**体现在代码上，需要先进行排序，让相同的元素靠在一起，如果发现 nums[i] == nums[i-1]，则跳过**：

```java
List<List<Integer>> res = new LinkedList<>();
LinkedList<Integer> track = new LinkedList<>();

public List<List<Integer>> subsetsWithDup(int[] nums) {
    // 先排序，让相同的元素靠在一起
    Arrays.sort(nums);
    backtrack(nums, 0);
    return res;
}

void backtrack(int[] nums, int start) {
    // 前序位置，每个节点的值都是一个子集
    res.add(new LinkedList<>(track));
  
    for (int i = start; i < nums.length; i++) {
        // 剪枝逻辑，值相同的相邻树枝，只遍历第一条
        if (i > start && nums[i] == nums[i - 1]) {
            continue;
        }
        track.addLast(nums[i]);
        backtrack(nums, i + 1);
        track.removeLast();
    }
}
```

这段代码和之前标准的子集问题的代码几乎相同，就是添加了排序和剪枝的逻辑。

至于为什么要这样剪枝，结合前面的图应该也很容易理解，这样带重复元素的子集问题也解决了。

###### 组合

###### 40.「 [组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)」

> 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
>
> candidates 中的每个数字在每个组合中只能使用 **一次** 。
>
> **注意：** 解集不能包含重复的组合。
>
> **示例 1:**   
> 输入: candidates = [10,1,2,7,6,1,5], target = 8,  
> 输出:  
> [ [1,1,6], [1,2,5], [1,7], [2,6] ]

对比子集问题的解法，只要将 target 变量减去回溯路径上的元素和，然后将 base case 改一改即可解决这道题：

```java
public List < List < Integer >> combinationSum2(int[] candidates, int target) {
  LinkedList < Integer > trace = new LinkedList < > ();
  List < List < Integer >> res = new ArrayList < > ();
  Arrays.sort(candidates);
  backTrack(candidates, 0, target, trace, res);
  return res;
}

private void backTrack(int[] candidates, int start, int target, LinkedList < Integer > trace, List < List < Integer >> res) {
  if (target == 0) {
    res.add(new ArrayList < > (trace));
    return;
  }
  if (target < 0) return;
  for (int i = start; i < candidates.length; i++) {
    if (i > start && candidates[i] == candidates[i - 1]) continue;
    trace.add(candidates[i]);
    backTrack(candidates, i + 1, target - candidates[i], trace, res);
    trace.removeLast();
  }
}
```

###### 排列

###### 47.「 [全排列 II](https://leetcode.cn/problems/permutations-ii/)」

> 给定一个可包含重复数字的序列 `nums`​ ，***按任意顺序*** 返回所有不重复的全排列。
>
> **示例 1：**   
> 输入：nums = [1,1,2]  
> 输出：[[1,1,2],  [1,2,1],  [2,1,1]]

先看解法代码：

```java
List<List<Integer>> res = new LinkedList<>();
LinkedList<Integer> track = new LinkedList<>();
boolean[] used;

public List<List<Integer>> permuteUnique(int[] nums) {
    // 先排序，让相同的元素靠在一起
    Arrays.sort(nums);
    used = new boolean[nums.length];
    backtrack(nums);
    return res;
}

void backtrack(int[] nums) {
    if (track.size() == nums.length) {
        res.add(new LinkedList(track));
        return;
    }

    for (int i = 0; i < nums.length; i++) {
        if (used[i]) {
            continue;
        }
        // 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
            continue;
        }
        track.add(nums[i]);
        used[i] = true;
        backtrack(nums);
        track.removeLast();
        used[i] = false;
    }
}
```

你对比一下之前的标准全排列解法代码，这段解法代码只有两处不同：

1、对 nums 进行了排序。

2、添加了一句额外的剪枝逻辑。

类比输入包含重复元素的子集/组合问题，你大概应该理解这么做是为了防止出现重复结果。

但是注意排列问题的剪枝逻辑，和子集/组合问题的剪枝逻辑略有不同：新增了 !used[i - 1] 的逻辑判断。

这个地方理解起来就需要一些技巧性了，且听我慢慢到来。为了方便研究，依然把相同的元素用上标 ' 以示区别。

假设输入为 nums = [1,2,2']，标准的全排列算法会得出如下答案：

```java
[
    [1,2,2'],[1,2',2],
    [2,1,2'],[2,2',1],
    [2',1,2],[2',2,1]
]
```

显然，这个结果存在重复，比如 [1,2,2'] 和 [1,2',2] 应该只被算作同一个排列，但被算作了两个不同的排列。

所以现在的关键在于，如何设计剪枝逻辑，把这种重复去除掉？

**答案是，保证相同元素在排列中的相对位置保持不变**。

比如说 nums = [1,2,2'] 这个例子，我保持排列中 2 一直在 2' 前面。

这样的话，你从上面 6 个排列中只能挑出 3 个排列符合这个条件：

```java
[ [1,2,2'],[2,1,2'],[2,2',1] ]
```

这也就是正确答案。

进一步，如果 nums = [1,2,2',2'']，我只要保证重复元素 2 的相对位置固定，比如说 2 -> 2' -> 2''，也可以得到无重复的全排列结果。

仔细思考，应该很容易明白其中的原理：

**标准全排列算法之所以出现重复，是因为把相同元素形成的排列序列视为不同的序列，但实际上它们应该是相同的；而如果固定相同元素形成的序列顺序，当然就避免了重复**。

那么反映到代码上，你注意看这个剪枝逻辑：

```java
// 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
    // 如果前面的相邻相等元素没有用过，则跳过
    continue;
}
// 选择 nums[i]
```

**当出现重复元素时，比如输入 nums = [1,2,2',2'']，2' 只有在 2 已经被使用的情况下才会被选择，同理，2'' 只有在 2' 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定**。

这里拓展一下，如果你把上述剪枝逻辑中的 !used[i - 1] 改成 used[i - 1]，其实也可以通过所有测试用例，但效率会有所下降，这是为什么呢？

之所以这样修改不会产生错误，是因为这种写法相当于维护了 2'' -> 2' -> 2 的相对顺序，最终也可以实现去重的效果。

但为什么这样写效率会下降呢？因为这个写法剪掉的树枝不够多。

比如输入 nums = [2,2',2'']，产生的回溯树如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676621632397-9b9f9c2b-65f4-468f-9123-60434a28fe62-20240329163851-hxyx8y3.png" alt="image.png" style="zoom:50%;" />

如果用绿色树枝代表 backtrack 函数遍历过的路径，红色树枝代表剪枝逻辑的触发，那么 !used[i - 1] 这种剪枝逻辑得到的回溯树长这样：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676621623699-d918bc02-7950-4130-81e6-dd509fdf1aa2-20240329163851-c8c8ci3.png" alt="image.png" style="zoom:50%;" />

而 used[i - 1] 这种剪枝逻辑得到的回溯树如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676621641866-3b40c663-e58d-4418-93ae-4ff206b5c9b6-20240329163852-z5ypuz5.png" alt="image.png" style="zoom:50%;" />

可以看到，!used[i - 1] 这种剪枝逻辑剪得干净利落，而 used[i - 1] 这种剪枝逻辑虽然也能得到无重结果，但它剪掉的树枝较少，存在的无效计算较多，所以效率会差一些。

###### **LCR 157.「**​[套餐内商品的排列顺序](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/)」

> 某店铺将用于组成套餐的商品记作字符串 `goods`​，其中 `goods[i]`​ 表示对应商品。请返回该套餐内所含商品的 **全部排列方式** 。
>
> 返回结果 **无顺序要求**，但不能含有重复的元素。
>
> **示例:**   
> 输入：goods = "abc"  
> 输出：["abc","acb","bac","bca","cab","cba"]

```java
class Solution {
    public String[] permutation(String s) {
        if (s == null) return null;
        List<String> res = new LinkedList<>();
        boolean[] used = new boolean[s.length()];
        StringBuilder trace = new StringBuilder();
        char[] array = s.toCharArray();
        Arrays.sort(array);
        permutation(array, used, trace, res);
        return res.toArray(new String[0]);
    }

    private void permutation(char[] array, boolean[] used, StringBuilder trace, List<String> res) {
        if (trace.length() == array.length) {
            res.add(trace.toString());
        }
        for (int i = 0; i < array.length; i++) {
            if (used[i]) continue;
            if (i > 0 && array[i] == array[i - 1] && !used[i - 1]) continue;
            trace.append(array[i]);
            used[i] = true;
            permutation(array, used, trace, res);
            trace.deleteCharAt(trace.length() - 1);
            used[i] = false;
        }
    }
}
```

##### 元素无重可复选

###### 组合

###### 39.「 [组合总和](https://leetcode.cn/problems/combination-sum/)」

> 给你一个 **无重复元素** 的整数数组 `candidates`​ 和一个目标整数 `target`​ ，找出 `candidates`​ 中可以使数字和为目标数 `target`​ 的 所有  **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。
>
> `candidates`​ 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。
>
> 对于给定的输入，保证和为 `target`​ 的不同组合数少于 `150`​ 个。
>
> **示例 1：**   
> 输入：candidates = [2,3,6,7], target = 7  
> 输出：[[2,2,3],[7]]  
> 解释： 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。 7 也是一个候选， 7 = 7 。 仅有这两种组合。

想解决这种类型的问题，也得回到回溯树上，**我们不妨先思考思考，标准的子集/组合问题是如何保证不重复使用元素的**？

答案在于 backtrack 递归时输入的参数 start：

```java
// 无重组合的回溯算法框架
void backtrack(int[] nums, int start) {
    for (int i = start; i < nums.length; i++) {
        // ...
        // 递归遍历下一层回溯树，注意参数
        backtrack(nums, i + 1);
        // ...
    }
}
```

这个 i 从 start 开始，那么下一层回溯树就是从 start + 1 开始，从而保证 nums[start] 这个元素不会被重复使用：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676624086723-ee75e3ba-00a8-44f5-99a8-fc925bbfce2f-20240329163852-iblrv3l.png" alt="image.png" style="zoom:50%;" />

那么反过来，如果我想让每个元素被重复使用，我只要把 i + 1 改成 i 即可：

```java
// 可重组合的回溯算法框架
void backtrack(int[] nums, int start) {
    for (int i = start; i < nums.length; i++) {
        // ...
        // 递归遍历下一层回溯树，注意参数
        backtrack(nums, i);
        // ...
    }
}
```

这相当于给之前的回溯树添加了一条树枝，在遍历这棵树的过程中，一个元素可以被无限次使用：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676624132838-7875d47a-70bc-41ec-a9b3-2f99d02959d5-20240329163853-ovw88rx.png" alt="image.png" style="zoom:50%;" />

当然，这样这棵回溯树会永远生长下去，所以我们的递归函数需要设置合适的 base case 以结束算法，即路径和大于 target 时就没必要再遍历下去了。

这道题的解法代码如下：

```java
public List < List < Integer >> combinationSum(int[] candidates, int target) {
  LinkedList < Integer > trace = new LinkedList < > ();
  List < List < Integer >> res = new ArrayList < > ();
  backTrack(candidates, 0, target, trace, res);
  return res;
}

private void backTrack(int[] candidates, int start, int target, LinkedList < Integer > trace, List < List < Integer >> res) {
  if (target == 0) {
    res.add(new ArrayList < > (trace));
    return;
  }
  if (target < 0) return;
  for (int i = start; i < candidates.length; i++) {
    trace.add(candidates[i]);
    backTrack(candidates, i, target - candidates[i], trace, res);
    trace.removeLast();
  }
}
```

###### 排列

力扣上没有类似的题目，我们不妨先想一下，nums 数组中的元素无重复且可复选的情况下，会有哪些排列？

比如输入 nums = [1,2,3]，那么这种条件下的全排列共有 3^3 = 27 种：

```java
[
  [1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],
  [2,1,1],[2,1,2],[2,1,3],[2,2,1],[2,2,2],[2,2,3],[2,3,1],[2,3,2],[2,3,3],
  [3,1,1],[3,1,2],[3,1,3],[3,2,1],[3,2,2],[3,2,3],[3,3,1],[3,3,2],[3,3,3]
]
```

**标准的全排列算法利用 used 数组进行剪枝，避免重复使用同一个元素。如果允许重复使用元素的话，直接放飞自我，去除所有 used 数组的剪枝逻辑就行了**。

那这个问题就简单了，代码如下：

```java
List<List<Integer>> res = new LinkedList<>();
LinkedList<Integer> track = new LinkedList<>();

public List<List<Integer>> permuteRepeat(int[] nums) {
    backtrack(nums);
    return res;
}

// 回溯算法核心函数
void backtrack(int[] nums) {
    // base case，到达叶子节点
    if (track.size() == nums.length) {
        // 收集叶子节点上的值
        res.add(new LinkedList(track));
        return;
    }

    // 回溯算法标准框架
    for (int i = 0; i < nums.length; i++) {
        // 做选择
        track.add(nums[i]);
        // 进入下一层回溯树
        backtrack(nums);
        // 取消选择
        track.removeLast();
    }
}
```

#### 总结

来回顾一下排列/组合/子集问题的三种形式在代码上的区别。

由于子集问题和组合问题本质上是一样的，无非就是 base case 有一些区别，所以把这两个问题放在一起看。

**形式一、元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次**，backtrack 核心代码如下：

```java
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}

/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 撤销选择
        track.removeLast();
        used[i] = false;
    }
}
```

**形式二、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次**，其关键在于排序和剪枝，backtrack 核心代码如下：

```java
Arrays.sort(nums);
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 剪枝逻辑，跳过值相同的相邻树枝
        if (i > start && nums[i] == nums[i - 1]) {
            continue;
        }
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}


Arrays.sort(nums);
/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 剪枝逻辑，固定相同的元素在排列中的相对位置
        if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 撤销选择
        track.removeLast();
        used[i] = false;
    }
}
```

**形式三、元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次**，只要删掉去重逻辑即可，backtrack 核心代码如下：

```java
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i);
        // 撤销选择
        track.removeLast();
    }
}


/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        backtrack(nums);
        // 撤销选择
        track.removeLast();
    }
}
```

### 回溯算法之集合划分问题

#### 698.「[划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)」

> 给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。
>
> **示例 1：**   
> 输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4  
> 输出： True  
> 说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。

我们之前 [背包问题之子集划分](https://labuladong.github.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--43be3/) 写过一次子集划分问题，不过那道题只需要我们把集合划分成两个相等的集合，可以转化成背包问题用动态规划技巧解决。

> **Info**
>
> 思考题：为什么划分成两个相等的子集可以转化成背包问题用动态规划思路解决，而划分成 k 个相等的子集就不可以转化成背包问题，只能用回溯算法暴力穷举？请先尝试自己思考，我会在文末给出答案。

但是如果划分成多个相等的集合，解法一般只能通过暴力穷举，时间复杂度爆表，是练习回溯算法和递归思维的好机会。

这道算法题让我们求子集划分，子集问题和排列组合问题有所区别，但我们可以借鉴「球盒模型」的抽象，用两种不同的视角来解决这道子集划分问题。

把装有 n 个数字的数组 nums 分成 k 个和相同的集合，你可以想象将 n 个数字分配到 k 个「桶」里，最后这 k 个「桶」里的数字之和要相同。

前文 [回溯算法框架套路](https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 说过，回溯算法的关键在哪里？

关键是要知道怎么「做选择」，这样才能利用递归函数进行穷举。

那么模仿排列公式的推导思路，将 n 个数字分配到 k 个桶里，我们也可以有两种视角：

**视角一，如果我们切换到这 n 个数字的视角，每个数字都要选择进入到 k 个桶中的某一个**。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687585215704-ac4a245b-5357-4d5d-a953-35f362f19d5f-20240329195002-an75it7.png" alt="image.png" style="zoom:50%;" />

**视角二，如果我们切换到这 k 个桶的视角，对于每个桶，都要遍历 nums 中的 n 个数字，然后选择是否将当前遍历到的数字装进自己这个桶里**。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687585215467-12b1a768-5b84-43cc-82f3-04643e70ba2a-20240329195003-hmk35yk.png" alt="image.png" style="zoom:50%;" />

你可能问，这两种视角有什么不同？

**用不同的视角进行穷举，虽然结果相同，但是解法代码的逻辑完全不同，进而算法的效率也会不同；对比不同的穷举视角，可以帮你更深刻地理解回溯算法，我们慢慢道来**。

##### 以数字的视角

用 for 循环迭代遍历 nums 数组大家肯定都会：

```java
for (int index = 0; index < nums.length; index++) {
    System.out.println(nums[index]);
}
```

递归遍历数组你会不会？其实也很简单：

```java
void traverse(int[] nums, int index) {
    if (index == nums.length) {
        return;
    }
    System.out.println(nums[index]);
    traverse(nums, index + 1);
}
```

只要调用 traverse(nums, 0)，和 for 循环的效果是完全一样的。

那么回到这道题，以数字的视角，选择 k 个桶，用 for 循环写出来是下面这样：

```java
// k 个桶（集合），记录每个桶装的数字之和
int[] bucket = new int[k];

// 穷举 nums 中的每个数字
for (int index = 0; index < nums.length; index++) {
    // 穷举每个桶
    for (int i = 0; i < k; i++) {
        // nums[index] 选择是否要进入第 i 个桶
        // ...
    }
}
```

如果改成递归的形式，就是下面这段代码逻辑：

```java
// k 个桶（集合），记录每个桶装的数字之和
int[] bucket = new int[k];

// 穷举 nums 中的每个数字
void backtrack(int[] nums, int index) {
    // base case
    if (index == nums.length) {
        return;
    }
    // 穷举每个桶
    for (int i = 0; i < bucket.length; i++) {
        // 选择装进第 i 个桶
        bucket[i] += nums[index];
        // 递归穷举下一个数字的选择
        backtrack(nums, index + 1);
        // 撤销选择
        bucket[i] -= nums[index];
    }
}
```

虽然上述代码仅仅是穷举逻辑，还不能解决我们的问题，但是只要略加完善即可：

```java
// 主函数
boolean canPartitionKSubsets(int[] nums, int k) {
    // 排除一些基本情况
    if (k > nums.length) return false;
    int sum = 0;
    for (int v : nums) sum += v;
    if (sum % k != 0) return false;

    // k 个桶（集合），记录每个桶装的数字之和
    int[] bucket = new int[k];
    // 理论上每个桶（集合）中数字的和
    int target = sum / k;
    // 穷举，看看 nums 是否能划分成 k 个和为 target 的子集
    return backtrack(nums, 0, bucket, target);
}

// 递归穷举 nums 中的每个数字
boolean backtrack(
    int[] nums, int index, int[] bucket, int target) {

    if (index == nums.length) {
        // 检查所有桶的数字之和是否都是 target
        for (int i = 0; i < bucket.length; i++) {
            if (bucket[i] != target) {
                return false;
            }
        }
        // nums 成功平分成 k 个子集
        return true;
    }
  
    // 穷举 nums[index] 可能装入的桶
    for (int i = 0; i < bucket.length; i++) {
        // 剪枝，桶装装满了
        if (bucket[i] + nums[index] > target) {
            continue;
        }
        // 将 nums[index] 装入 bucket[i]
        bucket[i] += nums[index];
        // 递归穷举下一个数字的选择
        if (backtrack(nums, index + 1, bucket, target)) {
            return true;
        }
        // 撤销选择
        bucket[i] -= nums[index];
    }

    // nums[index] 装入哪个桶都不行
    return false;
}
```

有之前的铺垫，相信这段代码是比较容易理解的，其实我们可以再做一个优化。

主要看 backtrack 函数的递归部分：

```java
for (int i = 0; i < bucket.length; i++) {
    // 剪枝
    if (bucket[i] + nums[index] > target) {
        continue;
    }

    if (backtrack(nums, index + 1, bucket, target)) {
        return true;
    }
}
```

**如果我们让尽可能多的情况命中剪枝的那个 if 分支，就可以减少递归调用的次数，一定程度上减少时间复杂度**。

如何尽可能多的命中这个 if 分支呢？要知道我们的 index 参数是从 0 开始递增的，也就是递归地从 0 开始遍历 nums 数组。

如果我们提前对 nums 数组排序，把大的数字排在前面，那么大的数字会先被分配到 bucket 中，对于之后的数字，bucket[i] + nums[index] 会更大，更容易触发剪枝的 if 条件。

所以可以在之前的代码中再添加一些代码：

```java
boolean canPartitionKSubsets(int[] nums, int k) {
    // 其他代码不变
    // ...
    /* 降序排序 nums 数组 */
    Arrays.sort(nums);
    for (i = 0, j = nums.length - 1; i < j; i++, j--) {
        // 交换 nums[i] 和 nums[j]
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    /*******************/
    return backtrack(nums, 0, bucket, target);
}
```

由于 Java 的语言特性，这段代码通过先升序排序再反转，达到降序排列的目的。

这个解法可以得到正确答案，但耗时比较多，已经无法通过所有测试用例了，接下来看看另一种视角的解法。

##### 以桶的视角

文章开头说了，**以桶的视角进行穷举，每个桶需要遍历 nums 中的所有数字，决定是否把当前数字装进桶中；当装满一个桶之后，还要装下一个桶，直到所有桶都装满为止**。

这个思路可以用下面这段代码表示出来：

```java
// 装满所有桶为止
while (k > 0) {
    // 记录当前桶中的数字之和
    int bucket = 0;
    for (int i = 0; i < nums.length; i++) {
        // 决定是否将 nums[i] 放入当前桶中
        if (canAdd(bucket, num[i])) {
            bucket += nums[i];
        }
        if (bucket == target) {
            // 装满了一个桶，装下一个桶
            k--;
            break;
        }
    }
}
```

那么我们也可以把这个 while 循环改写成递归函数，不过比刚才略微复杂一些，首先写一个 backtrack 递归函数出来：

```java
boolean backtrack(int k, int bucket, int[] nums, int start, boolean[] used, int target);
```

不要被这么多参数吓到，我会一个个解释这些参数。**如果你能够透彻理解本文，也能得心应手地写出这样的回溯函数**。  
这个 backtrack 函数的参数可以这样解释：

现在 k 号桶正在思考是否应该把 nums[start] 这个元素装进来；目前 k 号桶里面已经装的数字之和为 bucket；used 标志某一个元素是否已经被装到桶中；target 是每个桶需要达成的目标和。

根据这个函数定义，可以这样调用 backtrack 函数：

```java
boolean canPartitionKSubsets(int[] nums, int k) {
    // 排除一些基本情况
    if (k > nums.length) return false;
    int sum = 0;
    for (int v : nums) sum += v;
    if (sum % k != 0) return false;
  
    boolean[] used = new boolean[nums.length];
    int target = sum / k;
    // k 号桶初始什么都没装，从 nums[0] 开始做选择
    return backtrack(k, 0, nums, 0, used, target);
}
```

实现 backtrack 函数的逻辑之前，再重复一遍，从桶的视角：

1、需要遍历 nums 中所有数字，决定哪些数字需要装到当前桶中。

2、如果当前桶装满了（桶内数字和达到 target），则让下一个桶开始执行第 1 步。

下面的代码就实现了这个逻辑：

```java
boolean backtrack(int k, int bucket, 
    int[] nums, int start, boolean[] used, int target) {
    // base case
    if (k == 0) {
        // 所有桶都被装满了，而且 nums 一定全部用完了
        // 因为 target == sum / k
        return true;
    }
    if (bucket == target) {
        // 装满了当前桶，递归穷举下一个桶的选择
        // 让下一个桶从 nums[0] 开始选数字
        return backtrack(k - 1, 0 ,nums, 0, used, target);
    }

    // 从 start 开始向后探查有效的 nums[i] 装入当前桶
    for (int i = start; i < nums.length; i++) {
        // 剪枝
        if (used[i]) {
            // nums[i] 已经被装入别的桶中
            continue;
        }
        if (nums[i] + bucket > target) {
            // 当前桶装不下 nums[i]
            continue;
        }
        // 做选择，将 nums[i] 装入当前桶中
        used[i] = true;
        bucket += nums[i];
        // 递归穷举下一个数字是否装入当前桶
        if (backtrack(k, bucket, nums, i + 1, used, target)) {
            return true;
        }
        // 撤销选择
        used[i] = false;
        bucket -= nums[i];
    }
    // 穷举了所有数字，都无法装满当前桶
    return false;
}
```

**这段代码是可以得出正确答案的，但是效率很低，我们可以思考一下是否还有优化的空间**。

首先，在这个解法中每个桶都可以认为是没有差异的，但是我们的回溯算法却会对它们区别对待，这里就会出现重复计算的情况。  
什么意思呢？我们的回溯算法，说到底就是穷举所有可能的组合，然后看是否能找出和为 target 的 k 个桶（子集）。

那么，比如下面这种情况，target = 5，算法会在第一个桶里面装 1, 4：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687585974851-8bbe1a2c-181e-4822-8e2b-4f4c418d7526-20240329195003-0yjbjc1.png" alt="image.png" style="zoom:30%;" />

现在第一个桶装满了，就开始装第二个桶，算法会装入 2, 3：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687585975128-8850e082-acfc-4665-a8f7-32d2ae7137cb-20240329195004-c4j1odp.png" alt="image.png" style="zoom:30%;" />

然后以此类推，对后面的元素进行穷举，凑出若干个和为 5 的桶（子集）。

但问题是，如果最后发现无法凑出和为 target 的 k 个子集，算法会怎么做？

回溯算法会回溯到第一个桶，重新开始穷举，现在它知道第一个桶里装 1, 4 是不可行的，它会尝试把 2, 3 装到第一个桶里：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687585975210-e6143acd-a695-4a53-bd33-e81c1a03a2c6-20240329195004-veac7sk.png" alt="image.png" style="zoom:30%;" />

现在第一个桶装满了，就开始装第二个桶，算法会装入 1, 4：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687585975219-716cd26a-8bac-4056-b2c3-661edcb08652-20240329195004-f1fjae1.png" alt="image.png" style="zoom:30%;" />

好，到这里你应该看出来问题了，这种情况其实和之前的那种情况是一样的。也就是说，到这里你其实已经知道不需要再穷举了，必然凑不出来和为 target 的 k 个子集。

但我们的算法还是会傻乎乎地继续穷举，因为在她看来，第一个桶和第二个桶里面装的元素不一样，那这就是两种不一样的情况呀。

那么我们怎么让算法的智商提高，识别出这种情况，避免冗余计算呢？

你注意这两种情况的 used 数组肯定长得一样，所以 used 数组可以认为是回溯过程中的「状态」。

**所以，我们可以用一个 memo 备忘录，在装满一个桶时记录当前 used 的状态，如果当前 used 的状态是曾经出现过的，那就不用再继续穷举，从而起到剪枝避免冗余计算的作用**。

有读者肯定会问，used 是一个布尔数组，怎么作为键进行存储呢？这其实是小问题，比如我们可以把数组转化成字符串，这样就可以作为哈希表的键进行存储了。

看下代码实现，只要稍微改一下 backtrack 函数即可：

```java
// 备忘录，存储 used 数组的状态
HashMap<String, Boolean> memo = new HashMap<>();

boolean backtrack(int k, int bucket, int[] nums, int start, boolean[] used, int target) {    
    // base case
    if (k == 0) {
        return true;
    }
    // 将 used 的状态转化成形如 [true, false, ...] 的字符串
    // 便于存入 HashMap
    String state = Arrays.toString(used);

    if (bucket == target) {
        // 装满了当前桶，递归穷举下一个桶的选择
        boolean res = backtrack(k - 1, 0, nums, 0, used, target);
        // 将当前状态和结果存入备忘录
        memo.put(state, res);
        return res;
    }
  
    if (memo.containsKey(state)) {
        // 如果当前状态曾今计算过，就直接返回，不要再递归穷举了
        return memo.get(state);
    }

    // 其他逻辑不变...
}
```

这样提交解法，发现执行效率依然比较低，这次不是因为算法逻辑上的冗余计算，而是代码实现上的问题。

**因为每次递归都要把 used 数组转化成字符串，这对于编程语言来说也是一个不小的消耗，所以我们还可以进一步优化**。

注意题目给的数据规模 nums.length <= 16，也就是说 used 数组最多也不会超过 16，那么我们完全可以用「位图」的技巧，用一个 int 类型的 used 变量来替代 used 数组。

具体来说，我们可以用整数 used 的第 i 位（(used >> i) & 1）的 1/0 来表示 used[i] 的 true/false。

这样一来，不仅节约了空间，而且整数 used 也可以直接作为键存入 HashMap，省去数组转字符串的消耗。

看下最终的解法代码：

```java
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
        // 排除一些基本情况
        if (k > nums.length) return false;
        int sum = 0;
        for (int v : nums) sum += v;
        if (sum % k != 0) return false;
    
        int used = 0; // 使用位图技巧
        int target = sum / k;
        // k 号桶初始什么都没装，从 nums[0] 开始做选择
        return backtrack(k, 0, nums, 0, used, target);
    }

    HashMap<Integer, Boolean> memo = new HashMap<>();

    boolean backtrack(int k, int bucket,
                    int[] nums, int start, int used, int target) {    
        // base case
        if (k == 0) {
            // 所有桶都被装满了，而且 nums 一定全部用完了
            return true;
        }
        if (bucket == target) {
            // 装满了当前桶，递归穷举下一个桶的选择
            // 让下一个桶从 nums[0] 开始选数字
            boolean res = backtrack(k - 1, 0, nums, 0, used, target);
            // 缓存结果
            memo.put(used, res);
            return res;
        }
    
        if (memo.containsKey(used)) {
            // 避免冗余计算
            return memo.get(used);
        }

        for (int i = start; i < nums.length; i++) {
            // 剪枝
            if (((used >> i) & 1) == 1) { // 判断第 i 位是否是 1
                // nums[i] 已经被装入别的桶中
                continue;
            }
            if (nums[i] + bucket > target) {
                continue;
            }
            // 做选择
            used |= 1 << i; // 将第 i 位置为 1
            bucket += nums[i];
            // 递归穷举下一个数字是否装入当前桶
            if (backtrack(k, bucket, nums, i + 1, used, target)) {
                return true;
            }
            // 撤销选择
            used ^= 1 << i; // 使用异或运算将第 i 位恢复 0
            bucket -= nums[i];
        }

        return false;
    }
}
```

至此，这道题的第二种思路也完成了。

本文写的这两种思路都可以算出正确答案，不过第一种解法即便经过了排序优化，也明显比第二种解法慢很多，这是为什么呢？  
我们来分析一下这两个算法的时间复杂度，假设 nums 中的元素个数为 n。

先说第一个解法，也就是从数字的角度进行穷举，n 个数字，每个数字有 k 个桶可供选择，所以组合出的结果个数为 k<sup>n，时间复杂度也就是 O(k</sup>n)。

第二个解法，每个桶要遍历 n 个数字，对每个数字有「装入」或「不装入」两种选择，所以组合的结果有 2<sup>n 种；而我们有 k 个桶，所以总的时间复杂度为 O(k*2</sup>n)。

**当然，这是对最坏复杂度上界的粗略估算，实际的复杂度肯定要好很多，毕竟我们添加了这么多剪枝逻辑**。不过，从复杂度的上界已经可以看出第一种思路要慢很多了。

所以，谁说回溯算法没有技巧性的？虽然回溯算法就是暴力穷举，但穷举也分聪明的穷举方式和低效的穷举方式，关键看你以谁的「视角」进行穷举。

通俗来说，我们应该尽量「少量多次」，就是说宁可多做几次选择（乘法关系），也不要给太大的选择空间（指数关系）；做 n 次「k 选一」仅重复一次（O(k<sup>n)），比 n 次「二选一」重复 k 次（O(k*2</sup>n)）效率低很多。

好了，这道题我们从两种视角进行穷举，虽然代码量看起来多，但核心逻辑都是类似的，相信你通过本文能够更深刻地理解回溯算法。

> **Info**
>
> 文中思考题答案：为什么划分两个相等的子集可以转化成背包问题？
>
> [0-1 背包问题](https://labuladong.github.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--28f3c/) 的场景中，有一个背包和若干物品，每个物品有**两个选择**，分别是「装进背包」和「不装进背包」。把原集合 S 划分成两个相等子集 S_1, S_2 的场景下，S 中的每个元素也有**两个选择**，分别是「装进 S_1」和「不装进 S_1（装进 S_2）」，这时候的穷举思路其实和背包问题相同。
>
> 但如果你想把 S 划分成 k 个相等的子集，相当于 S 中的每个元素有 **k 个选择**，这和标准背包问题的场景有本质区别，是无法套用背包问题的解题思路的。

### 回溯算法之解数独

#### 37.「[解数独](https://leetcode.cn/problems/sudoku-solver/)」

> 编写一个程序，通过填充空格来解决数独问题。  
> 数独的解法需 **遵循如下规则**：
>
> 1. 数字 1-9 在每一行只能出现一次。
> 2. 数字 1-9 在每一列只能出现一次。
> 3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
>
> 数独部分空格内已填入了数字，空白格用 '.' 表示。
>
> **示例 1：**
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687594966626-3d64b05c-6713-4b28-9ad7-3184a0294b8b-20240331142231-ul0hlnh.png)
>
> 输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
>
> 输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
>
> 解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687595045419-dae8c429-f292-46ff-9b6e-05d79f33fa29-20240331142231-zplp4lx.png)

输入是一个9x9的棋盘，空白格子用点号字符 . 表示，算法需要在原地修改棋盘，将空白格子填上数字，得到一个可行解。

至于数独的要求，大家想必都很熟悉了，每行，每列以及每一个 3×3 的小方格都不能有相同的数字出现。那么，现在我们直接套回溯框架即可求解。

**前文 **​**[回溯算法详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/)**​ **，已经写过了回溯算法的套路框架，如果还没看过那篇文章的，建议先看看**。

回忆刚才的 GIF 图片，我们求解数独的思路很简单粗暴，就是对每一个格子所有可能的数字进行穷举。对于每个位置，应该如何穷举，有几个选择呢？

**很简单啊，从 1 到 9 就是选择，全部试一遍不就行了**：

```java
// 对 board[i][j] 进行穷举尝试
void backtrack(char[][] board, int i, int j) {
    int m = 9, n = 9;
    for (char ch = '1'; ch <= '9'; ch++) {
        // 做选择
        board[i][j] = ch;
        // 继续穷举下一个
        backtrack(board, i, j + 1);
        // 撤销选择
        board[i][j] = '.';
    }
}
```

emmm，再继续细化，并不是 1 到 9 都可以取到的，有的数字不是不满足数独的合法条件吗？而且现在只是给 j 加一，那如果 j 加到最后一列了，怎么办？

**很简单，当 j 到达超过每一行的最后一个索引时，转为增加 i 开始穷举下一行，并且在穷举之前添加一个判断，跳过不满足条件的数字**：

```java
void backtrack(char[][] board, int i, int j) {
    int m = 9, n = 9;
    if (j == n) {
        // 穷举到最后一列的话就换到下一行重新开始。
        backtrack(board, i + 1, 0);
        return;
    }
  
    // 如果该位置是预设的数字，不用我们操心
    if (board[i][j] != '.') {
        backtrack(board, i, j + 1);
        return;
    } 

    for (char ch = '1'; ch <= '9'; ch++) {
        // 如果遇到不合法的数字，就跳过
        if (!isValid(board, i, j, ch))
            continue;
    
        board[i][j] = ch;
        backtrack(board, i, j + 1);
        board[i][j] = '.';
    }
}

// 判断 board[i][j] 是否可以填入 n
boolean isValid(char[][] board, int r, int c, char n) {
    for (int i = 0; i < 9; i++) {
        // 判断行是否存在重复
        if (board[r][i] == n) return false;
        // 判断列是否存在重复
        if (board[i][c] == n) return false;
        // 判断 3 x 3 方框是否存在重复
        if (board[(r/3)*3 + i/3][(c/3)*3 + i%3] == n)
            return false;
    }
    return true;
}
```

emmm，现在基本上差不多了，还剩最后一个问题：这个算法没有 base case，永远不会停止递归。这个好办，什么时候结束递归？**显然 r == m 的时候就说明穷举完了最后一行，完成了所有的穷举，就是 base case**。

另外，前文也提到过，为了减少复杂度，我们可以让 backtrack 函数返回值为 boolean，如果找到一个可行解就返回 true，这样就可以阻止后续的递归。只找一个可行解，也是题目的本意。

最终代码修改如下：

```java
boolean backtrack(char[][] board, int i, int j) {
    int m = 9, n = 9;
    if (j == n) {
        // 穷举到最后一列的话就换到下一行重新开始。
        return backtrack(board, i + 1, 0);
    }
    if (i == m) {
        // 找到一个可行解，触发 base case
        return true;
    }

    if (board[i][j] != '.') {
        // 如果有预设数字，不用我们穷举
        return backtrack(board, i, j + 1);
    } 

    for (char ch = '1'; ch <= '9'; ch++) {
        // 如果遇到不合法的数字，就跳过
        if (!isValid(board, i, j, ch))
            continue;
  
        board[i][j] = ch;
        // 如果找到一个可行解，立即结束
        if (backtrack(board, i, j + 1)) {
            return true;
        }
        board[i][j] = '.';
    }
    // 穷举完 1~9，依然没有找到可行解，此路不通
    return false;
}

boolean isValid(char[][] board, int r, int c, char n) {
    for (int k = 0; k < 9; k++) {
    	if (board[i][k] == ch) return false; // 判断行是否重复
        if (board[k][j] == ch) return false; // 判断列是否重复
        for (int m = i / 3 * 3; m < i / 3 * 3 + 3; m++) { // 判断3*3方框中是否重复
       		for (int n = j / 3 * 3; n < j / 3 * 3 + 3; n++) {
            	if (board[m][n] == ch) return false;
            }
        }
    }
    return true;
}
```

**现在可以回答一下之前的问题，为什么有时候算法执行的次数多，有时候少？为什么对于计算机而言，确定的数字越少，反而算出答案的速度越快**？

我们已经实现了一遍算法，掌握了其原理，回溯就是从 1 开始对每个格子穷举，最后只要试出一个可行解，就会立即停止后续的递归穷举。所以暴力试出答案的次数和随机生成的棋盘关系很大，这个是说不准的。

那么你可能问，**既然运行次数说不准，那么这个算法的时间复杂度是多少呢**？

**对于这种时间复杂度的计算，我们只能给出一个最坏情况，也就是 O(9^M)，其中** **M** **是棋盘中空着的格子数量。你想嘛，对每个空格子穷举 9 个数，结果就是指数级的。**

**这个复杂度非常高，但稍作思考就能发现，实际上我们并没有真的对每个空格都穷举 9 次，有的数字会跳过，有的数字根本就没有穷举，因为当我们找到一个可行解的时候就立即结束了，后续的递归都没有展开。**

**这个 O(9^M) 的复杂度实际上是完全穷举，或者说是找到所有**可行解的时间复杂度。

如果给定的数字越少，相当于给出的约束条件越少，对于计算机这种穷举策略来说，是更容易进行下去，而不容易走回头路进行回溯的，所以说**如果仅仅找出一个可行解**，这种情况下穷举的速度反而比较快。

至此，回溯算法就完成了。

### 回溯算法之括号生成

括号问题可以简单分成两类，一类是前文写过的 [括号的合法性判断](https://labuladong.gitee.io/algo/di-san-zha-24031/jing-dian--a94a0/ru-he-jie--306f6/) ，一类是合法括号的生成。对于括号合法性的判断，主要是借助「栈」这种数据结构，而对于括号的生成，一般都要利用回溯递归的思想。  
关于回溯算法，我们前文写过一篇 [回溯算法套路框架详解](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 反响非常好，读本文前应该读过那篇文章，这样你就能够进一步了解回溯算法的框架使用方法了。

#### 22.「[括号生成](https://leetcode.cn/problems/generate-parentheses/)」

> 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的 ** 括号组合。
>
> **示例 1：**   
> 输入：n = 3  
> 输出：["((()))","(()())","(())()","()(())","()()()"]

有关括号问题，你只要记住以下性质，思路就很容易想出来：

**1、一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解**。

**2、对于一个「合法」的括号字符串组合 p，必然对于任何 0 &lt;= i &lt; len(p) 都有：子串 p[0..i] 中左括号的数量都大于或等于右括号的数量**。

如果不跟你说这个性质，可能不太容易发现，但是稍微想一下，其实很容易理解，因为从左往右算的话，肯定是左括号多嘛，到最后左右括号数量相等，说明这个括号组合是合法的。

反之，比如这个括号组合 ))((，前几个子串都是右括号多于左括号，显然不是合法的括号组合。

下面就来手把手实践一下回溯算法框架。

明白了合法括号的性质，如何把这道题和回溯算法扯上关系呢？

算法输入一个整数 n，让你计算 **n 对儿括号**能组成几种合法的括号组合，可以改写成如下问题：

**现在有 2n 个位置，每个位置可以放置字符 ( 或者 )，组成的所有括号组合中，有多少个是合法的**？

这个命题和题目的意思完全是一样的对吧，那么我们先想想如何得到全部 2^(2n) 种组合，然后再根据我们刚才总结出的合法括号组合的性质筛选出合法的组合，不就完事儿了？

如何得到所有的组合呢？这就是标准的暴力穷举回溯框架啊，我们前文 [回溯算法套路框架详解](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 都总结过了：

```java
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
  
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

那么对于我们的需求，如何打印所有括号组合呢？套一下框架就出来了，伪码如下：

```java
void backtrack(int n, int i, string& track) {
    // i 代表当前的位置，共 2n 个位置
    // 穷举到最后一个位置了，得到一个长度为 2n 组合
    if (i == 2 * n) {
        print(track);
        return;
    }

    // 对于每个位置可以是左括号或者右括号两种选择
    for choice in ['(', ')'] {
        track.push(choice); // 做选择
        // 穷举下一个位置
        backtrack(n, i + 1, track);
        track.pop(choice); // 撤销选择
    }
}
```

那么，现在能够打印所有括号组合了，如何从它们中筛选出合法的括号组合呢？很简单，加几个条件进行「剪枝」就行了。

对于 2n 个位置，必然有 n 个左括号，n 个右括号，所以我们不是简单的记录穷举位置 i，而是**用 left 记录还可以使用多少个左括号，用 right 记录还可以使用多少个右括号**，这样就可以通过刚才总结的合法括号规律进行筛选了：

```java
// 注意：java 代码由 chatGPT🤖 根据我的 cpp 代码翻译，旨在帮助不同背景的读者理解算法逻辑。
// 本代码还未经过力扣测试，仅供参考，如有疑惑，可以参照我写的 cpp 代码对比查看。

public List<String> generateParenthesis(int n) {
    if (n == 0) return new ArrayList<>();
    // 记录所有合法的括号组合
    List<String> res = new ArrayList<>();
    // 回溯过程中的路径
    StringBuilder track = new StringBuilder();
    // 可用的左括号和右括号数量初始化为 n
    backtrack(n, n, track, res);
    return res;
}

// 可用的左括号数量为 left 个，可用的右括号数量为 rgiht 个
void backtrack(int left, int right, 
            StringBuilder track, List<String> res) {
    // 若左括号剩下的多，说明不合法
    if (right < left) return;
    // 数量小于 0 肯定是不合法的
    if (left < 0 || right < 0) return;
    // 当所有括号都恰好用完时，得到一个合法的括号组合
    if (left == 0 && right == 0) {
        res.add(track.toString());
        return;
    }
  
    // 尝试放一个左括号
    track.append('('); // 选择
    backtrack(left - 1, right, track, res);
    track.deleteCharAt(track.length() - 1); // 撤消选择

    // 尝试放一个右括号
    track.append(')'); // 选择
    backtrack(left, right - 1, track, res);
    track.deleteCharAt(track.length() - 1); // 撤消选择
}
```

这样，我们的算法就完成了，算法的复杂度是多少呢？这个比较难分析，**对于递归相关的算法，时间复杂度这样计算（递归次数）*（递归函数本身的时间复杂度）** 。

backtrack 就是我们的递归函数，其中没有任何 for 循环代码，所以递归函数本身的时间复杂度是 O(1)，但关键是这个函数的递归次数是多少？换句话说，给定一个 n，backtrack 函数递归被调用了多少次？

我们前面怎么分析动态规划算法的递归次数的？主要是看「状态」的个数对吧。其实回溯算法和动态规划的本质都是穷举，只不过动态规划存在「重叠子问题」可以优化，而回溯算法不存在而已。

所以说这里也可以用「状态」这个概念，**对于 backtrack 函数，状态有三个，分别是 left, right, track**，这三个变量的所有组合个数就是 backtrack 函数的状态个数（调用次数）。

**left** **和** **right** **的组合好办，他俩取值就是 0~n 嘛，组合起来也就** **n^2** **种而已；这个** **track** **的长度虽然取在 0~2n，但对于每一个长度，它还有指数级的括号组合，这个是不好算的。**

说了这么多，就是想让大家知道这个算法的复杂度是指数级，而且不好算，这里就不具体展开了，是 4^n / sqrt(n)，有兴趣的读者可以搜索一下「卡特兰数」相关的知识了解一下这个复杂度是怎么算的。

## 动态规划

### 动态规划框架

### 动态规划和回溯算法的思维转换

之前 [手把手带你刷二叉树（纲领篇）](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-ge-da-334dd/) 把递归穷举划分为「遍历」和「分解问题」两种思路，其中「遍历」的思路扩展延伸一下就是回溯算法，「分解问题」的思路可以扩展成动态规划算法。

我在 [手把手带你刷二叉树（思路篇）](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-cbce8/) 对一些二叉树问题进行举例，同时给出「遍历」和「分解问题」两种思路的解法，帮大家借助二叉树理解更高级的算法设计思想。

当然，这种思维转换不止局限于二叉树相关的算法，本文就跳出二叉树类型问题，来看看实际算法题中如何把问题抽象成树形结构，从而进行「遍历」和「分解问题」的思维转换，从 [回溯算法](https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 顺滑地切换到 [动态规划算法](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/)。

先说句题外话，前文 [动态规划核心框架详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/) 说，**标准的动态规划问题一定是求最值的**，因为动态规划类型问题有一个性质叫做「最优子结构」，即从子问题的最优解推导出原问题的最优解。

但在我们平常的语境中，就算不是求最值的题目，只要看见使用备忘录消除重叠子问题，我们一般都称它为动态规划算法。严格来讲这是不符合动态规划问题的定义的，说这种解法叫做「带备忘录的 DFS 算法」可能更准确些。不过咱也不用太纠结这种名词层面的细节，既然大家叫的顺口，就叫它动态规划也无妨。

本文讲解的两道题目也不是求最值的，但依然会把他们的解法称为动态规划解法，这里提前跟大家说下这里面的细节，免得细心的读者疑惑。其他不多说了，直接看题目吧。

#### 练习题

##### 139.「 [单词拆分](https://leetcode.cn/problems/word-break/)」

> 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。
>
> **注意：** 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。
>
> **示例 1：**   
> 输入: s = "leetcode", wordDict = ["leet", "code"]  
> 输出: true  
> 解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

这是一道非常高频的面试题，我们来思考下如何通过「遍历」和「分解问题」的思路来解决它。

**先说说「遍历」的思路，也就是用回溯算法解决本题**。回溯算法最经典的应用就是排列组合相关的问题了，不难发现这道题换个说法也可以变成一个排列问题：

现在给你一个不包含重复单词的单词列表 wordDict 和一个字符串 s，请你判断是否可以从 wordDict 中选出若干单词的排列（可以重复挑选）构成字符串 s。

这就是前文 [回溯算法秒杀排列组合问题的九种变体](https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-56e11/) 中讲到的最后一种变体：元素无重可复选的排列问题，前文我写了一个 permuteRepeat 函数，代码如下：

```java
class Solution {
    List<List<Integer>> res = new LinkedList<>();
    LinkedList<Integer> track = new LinkedList<>();

    // 元素无重可复选的全排列
    public List<List<Integer>> permuteRepeat(int[] nums) {
        backtrack(nums);
        return res;
    }

    // 回溯算法核心函数
    void backtrack(int[] nums) {
        // base case，到达叶子节点
        if (track.size() == nums.length) {
            // 收集根到叶子节点路径上的值
            res.add(new LinkedList(track));
            return;
        }

        // 回溯算法标准框架
        for (int i = 0; i < nums.length; i++) {
            // 做选择
            track.add(nums[i]);
            // 进入下一层回溯树
            backtrack(nums);
            // 取消选择
            track.removeLast();
        }
    }
}
```

给这个函数输入 nums = [1,2,3]，输出是 3^3 = 27 种可能的组合：

```java
[
  [1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],
  [2,1,1],[2,1,2],[2,1,3],[2,2,1],[2,2,2],[2,2,3],[2,3,1],[2,3,2],[2,3,3],
  [3,1,1],[3,1,2],[3,1,3],[3,2,1],[3,2,2],[3,2,3],[3,3,1],[3,3,2],[3,3,3]
]
```

这段代码实际上就是遍历一棵高度为 N + 1 的满 N 叉树（N 为 nums 的长度），其中根到叶子的每条路径上的元素就是一个排列结果：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686986340346-93668281-a9cf-423f-b073-f2cf915d695d-20240331144419-lumb2ds.png" alt="image.png" style="zoom:50%;" />

类比一下，本文讲的这道题也有异曲同工之妙，假设 wordDict = ["a", "aa", "ab"], s = "aaab"，想用 wordDict 中的单词拼出 s，其实也面对着类似的一棵 M 叉树，M 为 wordDict 中单词的个数，**你需要做的就是站在回溯树的每个节点上，看看哪个单词能够匹配 s[i..] 的前缀，从而判断应该往哪条树枝上走**：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686986354972-d514297f-8cf2-4eb7-a5d6-d3c071615e4b-20240331144419-62zlcf6.png" alt="image.png" style="zoom:50%;" />

然后，按照前文 [回溯算法框架详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 所说，你把 backtrack 函数理解成在回溯树上游走的一个指针，维护每个节点上的变量 i，即可遍历整棵回溯树，寻找出匹配 s 的组合。

回溯算法解法代码如下：

```java
class Solution {
    List<String> wordDict;
    // 记录是否找到一个合法的答案
    boolean found = false;
    // 记录回溯算法的路径
    LinkedList<String> track = new LinkedList<>();

    // 主函数
    public boolean wordBreak(String s, List<String> wordDict) {
        this.wordDict = wordDict;
        // 执行回溯算法穷举所有可能的组合
        backtrack(s, 0);
        return found;
    }

    // 回溯算法框架
    void backtrack(String s, int i) {
        // base case
        if (found) {
            // 如果已经找到答案，就不要再递归搜索了
            return;
        }
        if (i == s.length()) {
            // 整个 s 都被匹配完成，找到一个合法答案
            found = true;
            return;
        }

        // 回溯算法框架
        for (String word : wordDict) {
            // 看看哪个单词能够匹配 s[i..] 的前缀
            int len = word.length();
            if (i + len <= s.length()
                && s.substring(i, i + len).equals(word)) {
                // 找到一个单词匹配 s[i..i+len)
                // 做选择
                track.addLast(word);
                // 进入回溯树的下一层，继续匹配 s[i+len..]
                backtrack(s, i + len);
                // 撤销选择
                track.removeLast();
            }
        }
    }
}
```

这段代码就是严格按照回溯算法框架写出来的，应该不难理解，但这段代码无法通过所有测试用例，我们按照之前 [算法时空复杂度使用指南](https://labuladong.github.io/algo/di-ling-zh-bfe1b/suan-fa-sh-05f25/) 中讲到的方法来分析一下它的时间复杂度。

递归函数的时间复杂度的粗略估算方法就是用递归函数调用次数（递归树的节点数） x 递归函数本身的复杂度。对于这道题来说，递归树的每个节点其实就是对 s 进行的一次切割，那么最坏情况下 s 能有多少种切割呢？长度为 N 的字符串 s 中共有 N - 1 个「缝隙」可供切割，每个缝隙可以选择「切」或者「不切」，**所以** **s** **最多有** **O(2^N)**  **种切割方式，即递归树上最多有** **O(2^N)**  **个节点。**

当然，实际情况可定会好一些，毕竟存在剪枝逻辑，但从最坏复杂度的角度来看，递归树的节点个数确实是指数级别的。

那么 backtrack 函数本身的时间复杂度是多少呢？主要的时间消耗是遍历 wordDict 寻找匹配 s[i..] 的前缀的单词：

```java
// 遍历 wordDict 的所有单词
for (String word : wordDict) {
    // 看看哪个单词能够匹配 s[i..] 的前缀
    int len = word.length();
    if (i + len <= s.length()
        && s.substring(i, i + len).equals(word)) {
        // 找到一个单词匹配 s[i..i+len)
        // ...
    }
}
```

设 wordDict 的长度为 M，字符串 s 的长度为 N，那么这段代码的最坏时间复杂度是 O(MN)（for 循环 O(M)，Java 的 substring 方法 O(N)），所以总的时间复杂度是 O(2^N * MN)。

这里顺便说一个细节优化，其实你也可以反过来，通过穷举 s[i..] 的前缀去判断 wordDict 中是否有对应的单词：

```java
// 注意，要转化成哈希集合，提高 contains 方法的效率
HashSet<String> wordDict = new HashSet<>(wordDict);

// 遍历 s[i..] 的所有前缀
for (int len = 1; i + len <= s.length(); len++) {
    // 看看 wordDict 中是否有单词能匹配 s[i..] 的前缀
    String prefix = s.substring(i, i + len);
    if (wordDict.contains(prefix)) {
        // 找到一个单词匹配 s[i..i+len)
        // ...
    }
}
```

这段代码和刚才那段代码的结果是一样的，**但这段代码的时间复杂度变成了** **O(N^2)** ，和刚才的代码不同。

**到底哪样子好呢？这要看题目给的数据范围。本题说了** **1 &lt;= s.length &lt;= 300, 1 &lt;= wordDict.length &lt;= 1000**，所以**O(N^2)** 的结果较小，这段代码的实际运行效率应该稍微高一些，这个是一个细节的优化，你可以自己做一下，我就不写了。

不过即便你优化这段代码，总的时间复杂度依然是指数级的 O(2^N * N^2)，是无法通过所有测试用例的，那么问题出在哪里呢？

比如输入 wordDict = ["a", "aa"], s = "aaab"，算法无法找到一个可行的组合，所以一定会遍历整棵回溯树，但你注意这里面会存在重复的情况：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686986441436-b1e0b04b-aa76-484c-91d5-065ed965615d-20240331144420-4b7c0f4.png" alt="image.png" style="zoom:50%;" />

图中标红的这两部分，虽然经历了不同的切分，但是切分得出的结果是相同的，所以这两个节点下面的子树也是重复的，即存在冗余计算，极端情况下会消耗大量时间。

**如何消除冗余计算呢？这就要稍微转变一下思维模式，用「分解问题」的思维模式来考虑这道题**。

我们刚才以排列组合的视角思考这个问题，现在我们换一种视角，思考一下是否能够把原问题分解成规模更小，结构相同的子问题，然后通过子问题的结果计算原问题的结果。

对于输入的字符串 s，如果我能够从单词列表 wordDict 中找到一个单词匹配 s 的前缀 s[0..k]，那么只要我能拼出 s[k+1..]，就一定能拼出整个 s。换句话说，我把规模较大的原问题 wordBreak(s[0..]) 分解成了规模较小的子问题 wordBreak(s[k+1..])，然后通过子问题的解反推出原问题的解。

有了这个思路就可以定义一个 dp 函数，并给出该函数的定义：

```java
// 定义：返回 s[i..] 是否能够被拼出
int dp(String s, int i);

// 计算整个 s 是否能被拼出，调用 dp(s, 0)
```

有了这个函数定义，就可以把刚才的逻辑大致翻译成伪码：

```java
List<String> wordDict;

// 定义：返回 s[i..] 是否能够被拼出
int dp(String s, int i) {
    // base case，s[i..] 是空串
    if (i == s.length()) {
        return true;
    }
    // 遍历 wordDict，看看哪些单词是 s[i..] 的前缀
    for (Strnig word : wordDict) {
        if word 是 s[i..] 的前缀 {
            int len = word.length();
            // 只要 s[i+len..] 可以被拼出，s[i..] 就能被拼出
            if (dp(s, i + len) == true) {
                return true;
            }
        }
    }
    // 所有单词都尝试过，无法拼出整个 s
    return false;
}
```

类似之前讲的回溯算法，dp 函数中的 for 循环也可以优化一下：

```java
// 注意，用哈希集合快速判断元素是否存在
HashSet<String> wordDict;

// 定义：返回 s[i..] 是否能够被拼出
int dp(String s, int i) {
    // base case，s[i..] 是空串
    if (i == s.length()) {
        return true;
    }
  
    // 遍历 s[i..] 的所有前缀，看看哪些前缀存在 wordDict 中
    for (int len = 1; i + len <= s.length(); len++) {
        if wordDict 中存在 s[i..len) {
            // 只要 s[i+len..] 可以被拼出，s[i..] 就能被拼出
            if (dp(s, i + len) == true) {
                return true;
            }
        }
    }
    // 所有单词都尝试过，无法拼出整个 s
    return false;
}
```

对于这个 dp 函数，指针 i 的位置就是「状态」，所以我们可以通过添加备忘录的方式优化效率，避免对相同的子问题进行冗余计算。最终的解法代码如下：

```java
class Solution {
    // 用哈希集合方便快速判断是否存在
    HashSet<String> wordDict;
    // 备忘录，-1 代表未计算，0 代表无法凑出，1 代表可以凑出
    int[] memo;

    // 主函数
    public boolean wordBreak(String s, List<String> wordDict) {
        // 转化为哈希集合，快速判断元素是否存在
        this.wordDict = new HashSet<>(wordDict);
        // 备忘录初始化为 -1
        this.memo = new int[s.length()];
        Arrays.fill(memo, -1);
        return dp(s, 0);
    }

    // 定义：s[i..] 是否能够被拼出
    boolean dp(String s, int i) {
        // base case
        if (i == s.length()) {
            return true;
        }
        // 防止冗余计算
        if (memo[i] != -1) {
            return memo[i] == 0 ? false : true;
        }

        // 遍历 s[i..] 的所有前缀
        for (int len = 1; i + len <= s.length(); len++) {
            // 看看哪些前缀存在 wordDict 中
            String prefix = s.substring(i, i + len);
            if (wordDict.contains(prefix)) {
                // 找到一个单词匹配 s[i..i+len)
                // 只要 s[i+len..] 可以被拼出，s[i..] 就能被拼出
                boolean subProblem = dp(s, i + len);
                if (subProblem == true) {
                    memo[i] = 1;
                    return true;
                }
            }
        }
        // s[i..] 无法被拼出
        memo[i] = 0;
        return false;
    }
}
```

这个解法能够通过所有测试用例，我们根据 [算法时空复杂度使用指南](https://labuladong.github.io/algo/di-ling-zh-bfe1b/suan-fa-sh-05f25/) 来算一下它的时间复杂度：

**因为有备忘录的辅助，消除了递归树上的重复节点，使得递归函数的调用次数从指数级别降低为状态的个数** **O(N)** ，函数本身的复杂度还是**O(N^2)** ，所以总的时间复杂度是**O(N^3)** ，相较回溯算法的效率有大幅提升。

##### 140.「 [单词拆分 II](https://leetcode.cn/problems/word-break-ii/)」

> 给定一个字符串 s 和一个字符串字典 wordDict ，在字符串 s 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。**以任意顺序** 返回所有这些可能的句子。  
> **注意：** 词典中的同一个单词可能在分段中被重复使用多次。
>
> **示例 1：**   
> 输入:s = "catsanddog", wordDict = ["cat","cats","and","sand","dog"]  
> 输出:["cats and dog","cat sand dog"]

相较上一题，这道题不是单单问你 s 是否能被拼出，还要问你是怎么拼的，其实只要把之前的解法稍微改一改就可以解决这道题。

上一道题的回溯算法维护一个 found 变量，只要找到一种拼接方案就提前结束遍历回溯树，那么在这道题中我们不要提前结束遍历，并把所有可行的拼接方案收集起来就能得到答案：

```java
class Solution {
    public List<String> wordBreak(String s, List<String> wordDict) {
        Set<String> words = new HashSet<>();
        for (String it : wordDict) {
            words.add(it);
        }
        List<String> res = new LinkedList<>();
        LinkedList<String> trace = new LinkedList<>();
        backTrace(s, 0, words, trace, res);
        return res;
    }
    public void backTrace (String s, int i, Set<String> wordDict, LinkedList<String> trace, List<String> res) {
        int n = s.length();
        if (i == n) {
            res.add(String.join(" ", trace));
            return;
        }
        // 看看哪个单词能够匹配 s[i..] 的前缀
        for (int len = 1; i + len <= n; len++) {
            String prefix = s.substring(i, i + len); 
            if (wordDict.contains(prefix)) { // 找到一个单词匹配 s[i..i+len)
                trace.addLast(prefix); // 做选择
                // 进入回溯树的下一层，继续匹配 s[i+len..]
                backTrace(s, i + len, wordDict, trace, res);
                trace.removeLast(); // 撤销选择
            }
        }
    }
}
```

这个解法的时间复杂度和前一道题类似，依然是 O(2^N * MN)，但由于这道题给的数据规模较小，所以可以通过所有测试用例。

类似的，这个问题也可以用分解问题的思维解决，把上一道题的 dp 函数稍作修改即可：

```java
class Solution {
    HashSet<String> wordDict;
    // 备忘录
    List<String>[] memo;

    public List<String> wordBreak(String s, List<String> wordDict) {
        this.wordDict = new HashSet<>(wordDict);
        memo = new List[s.length()];
        return dp(s, 0);
    }



    // 定义：返回用 wordDict 构成 s[i..] 的所有可能
    List<String> dp(String s, int i) {
        List<String> res = new LinkedList<>();
        if (i == s.length()) {
            res.add("");
            return res;
        }
        // 防止冗余计算
        if (memo[i] != null) {
            return memo[i];
        }
    
        // 遍历 s[i..] 的所有前缀
        for (int len = 1; i + len <= s.length(); len++) {
            // 看看哪些前缀存在 wordDict 中
            String prefix = s.substring(i, i + len);
            if (wordDict.contains(prefix)) {
                // 找到一个单词匹配 s[i..i+len)
                List<String> subProblem = dp(s, i + len);
                // 构成 s[i+len..] 的所有组合加上 prefix 
                // 就是构成构成 s[i] 的所有组合
                for (String sub : subProblem) {
                    if (sub.isEmpty()) {
                        // 防止多余的空格
                        res.add(prefix);
                    } else {
                        res.add(prefix + " " + sub);
                    }
                }
            }
        }
        // 存入备忘录
        memo[i] = res;
    
        return res;
    }
}
```

这个解法依然用备忘录消除了重叠子问题，所以 dp 函数递归调用的次数减少为 O(N)，但 dp 函数本身的时间复杂度上升了，因为 subProblem 是一个子集列表，它的长度是指数级的。再加上 Java 中用 + 拼接字符串的效率并不高，且还要消耗备忘录去存储所有子问题的结果，所以这个算法的时间复杂度并不比回溯算法低，依然是指数级别。

综上，我们处理排列组合问题时一般使用回溯算法去「遍历」回溯树，而不用「分解问题」的思路去处理，因为存储子问题的结果就需要大量的时间和空间，除非重叠子问题的数量较多的极端情况，否则得不偿失。

### 动态规划和回溯算法关系

我们前文经常说回溯算法和递归算法有点类似，有的问题如果实在想不出状态转移方程，尝试用回溯算法暴力解决也是一个聪明的策略，总比写不出来解法强。

那么，回溯算法和动态规划到底是啥关系？它俩都涉及递归，算法模板看起来还挺像的，都涉及做「选择」，真的酷似父与子。  
那么，它俩具体有啥区别呢？回溯算法和动态规划之间，是否可能互相转化呢？

今天就用力扣一个题来详细对比一下回溯算法和动态规划。

#### 练习题

##### 494.「[目标和](https://leetcode.cn/problems/target-sum/)」

> 给你一个整数数组 nums 和一个整数 target 。
>
> 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 **表达式** ：
>
> - 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
>
> 返回可以通过上述方法构造的、运算结果等于 target 的不同 **表达式** 的数目。
>
> **示例 1：**   
> 输入：nums = [1,1,1,1,1], target = 3  
> 输出：5
>
> 解释：一共有 5 种方法让最终目标和为 3 。  
> -1 + 1 + 1 + 1 + 1 = 3  
> +1 - 1 + 1 + 1 + 1 = 3  
> +1 + 1 - 1 + 1 + 1 = 3  
> +1 + 1 + 1 - 1 + 1 = 3  
> +1 + 1 + 1 + 1 - 1 = 3

###### 回溯思路

其实我第一眼看到这个题目，花了两分钟就写出了一个回溯解法。

任何算法的核心都是穷举，回溯算法就是一个暴力穷举算法，前文 [回溯算法解题框架](https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 就写了回溯算法框架：

```java
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
  
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

关键就是搞清楚什么是「选择」，而对于这道题，「选择」不是明摆着的吗？**对于每个数字 nums[i]，我们可以选择给一个正号 + 或者一个负号 -** ，然后利用回溯模板穷举出来所有可能的结果，数一数到底有几种组合能够凑出 target 不就行了嘛？

伪码思路如下：

```java
def backtrack(nums, i):
    if i == len(nums):
        if 达到 target:
            result += 1
        return
  
    for op in { +1, -1 }:
        选择 op * nums[i]
        # 穷举 nums[i + 1] 的选择
        backtrack(nums, i + 1)
        撤销选择
```

如果看过我们之前的几篇回溯算法文章，这个代码可以说是比较简单的了：

```java
class Solution {
    int result = 0;

    /* 主函数 */
    public int findTargetSumWays(int[] nums, int target) {
        if (nums.length == 0) return 0;
        backtrack(nums, 0, target);
        return result;
    }

    /* 回溯算法模板 */
    void backtrack(int[] nums, int i, int remain) {
        // base case
        if (i == nums.length) {
            if (remain == 0) {
                // 说明恰好凑出 target
                result++;
            }
            return;
        }
        // 给 nums[i] 选择 - 号
        remain += nums[i];
        // 穷举 nums[i + 1]
        backtrack(nums, i + 1, remain);
        // 撤销选择
        remain -= nums[i]; 
    
        // 给 nums[i] 选择 + 号
        remain -= nums[i];
        // 穷举 nums[i + 1]
        backtrack(nums, i + 1, remain);
        // 撤销选择
        remain += nums[i];
    }
}
```

有的读者可能问，选择 - 的时候，为什么是 remain += nums[i]，选择 + 的时候，为什么是 remain -= nums[i] 呢，是不是写反了？  
不是的，「如何凑出 target」和「如何把 target 减到 0」其实是一样的。我们这里选择后者，因为前者必须给 backtrack 函数多加一个参数，我觉得不美观：

```java
void backtrack(int[] nums, int i, int sum, int target) {
    // base case
    if (i == nums.length) {
        if (sum == target) {
            result++;
        }
        return;
    }
    // ...
}
```

因此，如果我们给 nums[i] 选择 + 号，就要让 remain - nums[i]，反之亦然。

以上回溯算法可以解决这个问题，时间复杂度为 O(2^N)，N 为 nums 的大小。这个复杂度怎么算的？回忆前文 [学习数据结构和算法的框架思维](https://labuladong.github.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/)，发现这个回溯算法就是个二叉树的遍历问题：

```java
void backtrack(int[] nums, int i, int remain) {
    if (i == nums.length) {
        return;
    }
    backtrack(nums, i + 1, remain - nums[i]);
    backtrack(nums, i + 1, remain + nums[i]);
}
```

树的高度就是 nums 的长度嘛，所以说时间复杂度就是这棵二叉树的节点数，为 O(2^N)，其实是非常低效的。

那么，这个问题如何用动态规划思想进行优化呢？

###### 消除重叠子问题

动态规划之所以比暴力算法快，是因为动态规划技巧消除了重叠子问题。  
如何发现重叠子问题？看是否可能出现重复的「状态」。对于递归函数来说，函数参数中会变的参数就是「状态」，对于 backtrack 函数来说，会变的参数为 i 和 remain。  
前文 [动态规划之编辑距离](https://labuladong.github.io/algo/di-er-zhan-a01c6/zi-xu-lie--6bc09/jing-dian--e5f5e/) 说了一种一眼看出重叠子问题的方法，先抽象出递归框架：

```java
void backtrack(int i, int remain) {
    backtrack(i + 1, remain - nums[i]);
    backtrack(i + 1, remain + nums[i]);
}
```

举个简单的例子，如果 nums[i] = 0，会发生什么？

```java
void backtrack(int i, int remain) {
    backtrack(i + 1, remain);
    backtrack(i + 1, remain);
}
```

你看，这样就出现了两个「状态」完全相同的递归函数，无疑这样的递归计算就是重复的。**这就是重叠子问题，而且只要我们能够找到一个重叠子问题，那一定还存在很多的重叠子问题**。

因此，状态 (i, remain) 是可以用备忘录技巧进行优化的：

```java
class Solution {
    int findTargetSumWays(int[] nums, int target) {
        if (nums.length == 0) return 0;
        return dp(nums, 0, target);
    }

    // 备忘录
    HashMap<String, Integer> memo = new HashMap<>();
    int dp(int[] nums, int i, int remain) {
        // base case
        if (i == nums.length) {
            if (remain == 0) return 1;
            return 0;
        }
        // 把它俩转成字符串才能作为哈希表的键
        String key = i + "," + remain;
        // 避免重复计算
        if (memo.containsKey(key)) {
            return memo.get(key);
        }
        // 还是穷举
        int result = dp(nums, i + 1, remain - nums[i]) + dp(nums, i + 1, remain + nums[i]);
        // 记入备忘录
        memo.put(key, result);
        return result;
    }
}
```

这个解法通过备忘录消除了很多重叠子问题，效率有一定的提升，但是这就结束了吗？

###### 动态规划

其实，这个问题可以转化为一个子集划分问题，而子集划分问题又是一个典型的背包问题。动态规划总是这么玄学，让人摸不着头脑……

首先，如果我们把 nums 划分成两个子集 A 和 B，分别代表分配 + 的数和分配 - 的数，那么他们和 target 存在如下关系：

```java
sum(A) - sum(B) = target
sum(A) = target + sum(B)
sum(A) + sum(A) = target + sum(B) + sum(A)
2 * sum(A) = target + sum(nums)
```

综上，可以推出 sum(A) = (target + sum(nums)) / 2，也就是把原问题转化成：**nums 中存在几个子集 A，使得 A 中元素的和为 (target + sum(nums)) / 2**？  
类似的子集划分问题我们前文 [经典背包问题：子集划分](https://labuladong.github.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--43be3/) 讲过，现在实现这么一个函数：

```java
/* 计算 nums 中有几个子集的和为 sum */
int subsets(int[] nums, int sum) {}
```

然后，可以这样调用这个函数：

```java
int findTargetSumWays(int[] nums, int target) {
    int sum = 0;
    for (int n : nums) sum += n;
    // 这两种情况，不可能存在合法的子集划分
    if (sum < Math.abs(target) || (sum + target) % 2 == 1) {
        return 0;
    }
    return subsets(nums, (sum + target) / 2);
}
```

好的，变成背包问题的标准形式：

**有一个背包，容量为 sum，现在给你 N 个物品，第 i 个物品的重量为 nums[i - 1]（注意 1 &lt;= i &lt;= N），每个物品只有一个，请问你有几种不同的方法能够恰好装满这个背包**？  
现在，这就是一个正宗的动态规划问题了，下面按照我们一直强调的动态规划套路走流程：

**第一步要明确两点，「状态」和「选择」** 。

对于背包问题，这个都是一样的，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。

**第二步要明确 dp 数组的定义**。

按照背包问题的套路，可以给出如下定义：

dp[i][j] = x 表示，若只在前 i 个物品中选择，若当前背包的容量为 j，则最多有 x 种方法可以恰好装满背包。

翻译成我们探讨的子集问题就是，若只在 nums 的前 i 个元素中选择，若目标和为 j，则最多有 x 种方法划分子集。

根据这个定义，显然 dp[0][..] = 0，因为没有物品的话，根本没办法装背包；但是 dp[0][0] 应该是个例外，因为如果背包的最大载重为 0，「什么都不装」也算是一种装法，即 dp[0][0] = 1。

> **Note**
>
> 可能有些看过前文 [0-1 背包问题](https://labuladong.github.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--28f3c/) 和 [完全背包问题](https://labuladong.github.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--70de0/) 这两篇背包问题的文章之后会有疑问，为什么 base case 不是 dp[..][0] = 1 呢？即背包容量为 0 时，只有「什么都不装」这一种装法。这里不能这样初始化，是因为本题 nums 数组中的元素是可能为 0 的，那么背包容量为 0 时，「什么都不装」可能就不是唯一的装法了，而需要在状态转移的过程中具体去计算。

我们所求的答案就是 dp[N][sum]，即使用所有 N 个物品，有几种方法可以装满容量为 sum 的背包。

**第三步，根据「选择」，思考状态转移的逻辑**。

回想刚才的 dp 数组含义，可以根据「选择」对 dp[i][j] 得到以下状态转移：

如果不把 nums[i] 算入子集，**或者说你不把这第 i 个物品装入背包**，那么恰好装满背包的方法数就取决于上一个状态 dp[i-1][j]，继承之前的结果。

如果把 nums[i] 算入子集，**或者说你把这第 i 个物品装入了背包**，那么只要看前 i - 1 个物品有几种方法可以装满 j - nums[i-1] 的重量就行了，所以取决于状态 dp[i-1][j-nums[i-1]]。

> **Note**
>
> 注意我们说的 i 是从 1 开始算的，而数组 nums 的索引时从 0 开始算的，所以 nums[i-1] 代表的是第 i 个物品的重量，j - nums[i-1] 就是背包装入物品 i 之后还剩下的容量。

**由于 dp[i][j] 为装满背包的总方法数，所以应该以上两种选择的结果求和，得到状态转移方程**：

```java
dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];
```

然后，根据状态转移方程写出动态规划算法：

```java
/* 计算 nums 中有几个子集的和为 sum */
int subsets(int[] nums, int sum) {
    int n = nums.length;
    int[][] dp = new int[n + 1][sum + 1]; // 前 i 个物品中选择，当前背包的容量为 j，则最多有 x 种方法可以恰好装满背包
    // base case
    dp[0][0] = 1;
  
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= sum; j++) {
            if (j >= nums[i-1]) {
                // 两种选择的结果之和
				// 注意我们说的 i 是从 1 开始算的，而数组 nums 的索引时从 0 开始算的，
				// 所以 nums[i-1] 代表的是第 i 个物品的重量，j - nums[i-1] 就是背包装入物品 i 之后还剩下的容量。
                dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];
            } else {
                // 背包的空间不足，只能选择不装物品 i
                dp[i][j] = dp[i-1][j];
            }
        }
    }
    return dp[n][sum];
}
```

然后，发现这个 dp[i][j] 只和前一行 dp[i-1][..] 有关，那么肯定可以优化成一维 dp：

```java
/* 计算 nums 中有几个子集的和为 sum */
int subsets(int[] nums, int sum) {
    int n = nums.length;
    int[] dp = new int[sum + 1];
    // base case
    dp[0] = 1;
  
    for (int i = 1; i <= n; i++) {
        // j 要从后往前遍历
        for (int j = sum; j >= 0; j--) {
            // 状态转移方程
            if (j >= nums[i-1]) {
                dp[j] = dp[j] + dp[j-nums[i-1]];
            } else {
                dp[j] = dp[j];
            }
        }
    }
    return dp[sum];
}
```

**对照二维 dp，只要把 dp 数组的第一个维度全都去掉就行了，唯一的区别就是这里的 j 要从后往前遍历，原因如下**：

因为二维压缩到一维的根本原理是，dp[j] 和 dp[j-nums[i-1]] 还没被新结果覆盖的时候，相当于二维 dp 中的 dp[i-1][j] 和 dp[i-1][j-nums[i-1]]。

那么，我们就要做到：**在计算新的 dp[j] 的时候，dp[j] 和 dp[j-nums[i-1]] 还是上一轮外层 for 循环的结果**。

如果你从前往后遍历一维 dp 数组，dp[j] 显然是没问题的，但是 dp[j-nums[i-1]] 已经不是上一轮外层 for 循环的结果了，这里就会使用错误的状态，当然得不到正确的答案。

现在，这道题算是彻底解决了。

总结一下，回溯算法虽好，但是复杂度高，即便消除一些冗余计算，也只是「剪枝」，没有本质的改进。而动态规划就比较玄学了，经过各种改造，从一个加减法问题变成子集问题，又变成背包问题，经过各种套路写出解法，又搞出空间压缩，还得反向遍历。

现在我都搞不清楚自己是来干嘛的了。嗯，这也许就是动态规划的魅力吧。

### 股票买卖问题

#### 穷举框架

以【188.「 [买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)」】为例讲解

> 给你一个整数数组 `prices`​ 和一个整数 `k`​ ，其中 `prices[i]`​ 是某支给定的股票在第 `i`​ 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k`​ 笔交易。也就是说，你最多可以买 `k`​ 次，卖 `k`​ 次。
>
> **注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> **示例 1：**   
> 输入：k = 2, prices = [2,4,1]  
> 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

[动态规划核心套路](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/) 说过，动态规划算法本质上就是穷举「状态」，然后在「选择」中选择最优解。

那么对于这道题，我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。

比如说这个问题，**每天都有三种「选择」** ：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。

但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k > 0 的前提下操作。

很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。

**这个问题的「状态」有三个**，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：

```java
dp[i][k][0 or 1]
0 <= i <= n - 1, 1 <= k <= K
n 为天数，大 K 为交易数的上限，0 和 1 代表是否持有股票。
此问题共 n × K × 2 种状态，全部穷举就能搞定。

for 0 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)
```

而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？

我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。

读者可能问为什么不是 dp[n - 1][K][1]？因为 dp[n - 1][K][1] 代表到最后一天手上还持有股票，dp[n - 1][K][0] 表示最后一天手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。

记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。

#### 状态转移框架

现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。

只看「持有状态」，可以画个状态转移图：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677335284636-eea63907-0ad9-4329-beb4-887d11dc5c53-20240331172957-yszi1ln.png" alt="image.png" style="zoom:50%;" />

通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：

```java
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) // max(今天选择 rest,今天选择 sell)
```

解释：今天我没有持有股票，有两种可能，我从这两种可能中求最大利润：

1、我昨天就没有持有，且截至昨天最大交易次数限制为 k；然后我今天选择 rest，所以我今天还是没有持有，最大交易次数限制依然为 k。

2、我昨天持有股票，且截至昨天最大交易次数限制为 k；但是今天我 sell 了，所以我今天没有持有股票了，最大交易次数限制依然为 k。

```java
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) // max(今天选择 rest,今天选择 buy)
```

解释：今天我持有着股票，最大交易次数限制为 k，那么对于昨天来说，有两种可能，我从这两种可能中求最大利润：

1、我昨天就持有着股票，且截至昨天最大交易次数限制为 k；然后今天选择 rest，所以我今天还持有着股票，最大交易次数限制依然为 k。

2、我昨天本没有持有，且截至昨天最大交易次数限制为 k - 1；但今天我选择 buy，所以今天我就持有股票了，最大交易次数限制为 k。

> 这里着重提醒一下，**时刻牢记「状态」的定义**，状态 k 的定义并不是「已进行的交易次数」，而是「最大交易次数的上限限制」。如果确定今天进行一次交易，且要保证截至今天最大交易次数上限为 k，那么昨天的最大交易次数上限必须是 k - 1。

这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。

注意 k 的限制，在选择 buy 的时候相当于开启了一次交易，那么对于昨天来说，交易次数的上限 k 应该减小 1。

现在，我们已经完成了动态规划中最困难的一步：状态转移方程。**如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了**。不过还差最后一点点，就是定义 base case，即最简单的情况。

```java
dp[-1][...][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。

dp[-1][...][1] = -infinity
解释：还没开始的时候，是不可能持有股票的。
因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。

dp[...][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。

dp[...][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的。
因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
```

把上面的状态转移方程总结一下：

```java
base case：
dp[-1][...][0] = dp[...][0][0] = 0
dp[-1][...][1] = dp[...][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

#### 练习题

##### **121.「**  **[买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)**​ **」**

> 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
>
> 你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。
>
> 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。
>
> **示例 1：**
>
> 输入：[7,1,5,3,6,4]  
> 输出：5  
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
> 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

**相当于 k = 1 的情况**：

直接套状态转移方程，根据 base case，可以做一些化简：

```java
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) 
            = max(dp[i-1][1][1], -prices[i])

解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。

现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
可以进行进一步化简去掉所有 k：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])
```

直接写出代码：

```java
int n = prices.length;
int[][] dp = new int[n][2];
for (int i = 0; i < n; i++) {
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
}
return dp[n - 1][0];
```

显然 i = 0 时 i - 1 是不合法的索引，这是因为我们没有对 i 的 base case 进行处理，可以这样给一个特化处理：

```java
if (i - 1 == -1) {
    dp[i][0] = 0;
    // 根据状态转移方程可得：
    //   dp[i][0] 
    // = max(dp[-1][0], dp[-1][1] + prices[i])
    // = max(0, -infinity + prices[i]) = 0

    dp[i][1] = -prices[i];
    // 根据状态转移方程可得：
    //   dp[i][1] 
    // = max(dp[-1][1], dp[-1][0] - prices[i])
    // = max(-infinity, 0 - prices[i]) 
    // = -prices[i]
    continue;
}
```

第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，所以可以用后文 [动态规划的降维打击：空间压缩技巧](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dui-dong-t-8e7bf/)，不需要用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):

```java
// 原始版本
int maxProfit_k_1(int[] prices) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for (int i = 1; i < n; i++) {
         dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); // 今天没有持有  = Math.max(昨天也没有持有, 昨天持有但今天卖了)
         dp[i][1] = Math.max(dp[i - 1][1], -prices[i]); // 今天持有  = Math.max(昨天也持有, 昨天没持有但今天买了)
    }
    return dp[n - 1][0];
}

// 空间复杂度优化版本
int maxProfit_k_1(int[] prices) {
    int n = prices.length;
    // base case: dp[-1][0] = 0, dp[-1][1] = -infinity
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        // dp[i][1] = max(dp[i-1][1], -prices[i])
        dp_i_1 = Math.max(dp_i_1, -prices[i]);
    }
    return dp_i_0;
}
```

##### **122.「**  **[买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)**​ **」**

> 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
>
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。
>
> 返回 *你能获得的* ***最大*** *利润* 。
>
> **示例 1：**   
> 输入：prices = [7,1,5,3,6,4]  
> 输出：7  
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。  
> 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
> 总利润为 4 + 3 = 7 。

**相当于 k 为正无穷的情况**：

这道题的特点在于没有给出交易总数 k 的限制，也就相当于 k 为正无穷。

如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：

```java
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])

我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
```

直接翻译成代码：

```java
public int maxProfit1(int[] prices) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for (int i = 1; i < n; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); // 当前没有持有 = Math.max(昨天也没有持有, 昨天持有但是今天卖了)
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); // 当前持有 = Math.max(昨天也持有, 昨天没有持有但是今天买了)
    }
    return dp[n - 1][0];
}
```

##### **309.「**  **[最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)**」

> 给定一个整数数组`prices`​，其中第   `prices[i]`​ 表示第 `i`​ 天的股票价格 。
>
> 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:
>
> - 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
>
> **注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> **示例 1:**   
> 输入: prices = [1,2,3,0,2]  
> 输出: 3
> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

**相当于是 k 为正无穷，但含有交易冷冻期的情况：**

和上一道题一样的，只不过每次 sell 之后要等一天才能继续交易，只要把这个特点融入上一题的状态转移方程即可：

```java
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。
```

翻译成代码：

```java
public int maxProfit(int[] prices) {
    if (prices.length == 1) return 0;
    int n = prices.length;
    int[][] dp = new int[n][2];
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    dp[1][0] = Math.max(0, prices[1] - prices[0]);
    dp[1][1] = Math.max(-prices[0], -prices[1]); // 要么昨天持有，要么今天持有
    for (int i = 2; i < n; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]); // 今天没有持有 = Math.max(昨天也没有持有, 昨天持有但今天卖了);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]); // 今天持有 = Math.max(昨天也持有, 前天没持有但今天买了（冷冻期一天）);
    }
    return dp[n - 1][0];
}
```

##### **714.「**  **[买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)**​ **」**

> 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。
>
> 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。
>
> 返回获得利润的最大值。
>
> **注意：** 这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。
>
> **示例 1：**   
> 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2  
> 输出：8
>
> 解释：
>
> 在此处买入 prices[0] = 1  
> 在此处卖出 prices[3] = 8  
> 在此处买入 prices[4] = 4  
> 在此处卖出 prices[5] = 9  
> 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8

**相当于k 为正无穷且考虑交易手续费的情况：**   
每次交易要支付手续费，只要把手续费从利润中减去即可，改写方程：

```java
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
解释：相当于买入股票的价格升高了。
在第一个式子里减也是一样的，相当于卖出股票的价格减小了。
```

> 如果直接把 fee 放在第一个式子里减，会有一些测试用例无法通过，错误原因是整型溢出而不是思路问题。一种解决方案是把代码中的 int 类型都改成 long 类型，避免 int 的整型溢出。

直接翻译成代码，注意状态转移方程改变后 base case 也要做出对应改变：

```java
public int maxProfit(int[] prices, int fee) {
    int n = prices.length;
    int[][] dp = new int[n][2];
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for (int i = 1; i < n; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - fee + prices[i]); // 今天没有持有 = Math.max(昨天也没有持有, 昨天持有但今天卖了);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]); // 今天持有 = Math.max(昨天也持有, 昨天没有持有但今天买了);
    }
    return dp[n - 1][0];
}
```

##### **123.「**  **[买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)**」

> 给定一个数组，它的第 `i`​ 个元素是一支给定的股票在第 `i`​ 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔**交易。
>
> **注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> **示例 1:**   
> 输入：prices = [3,3,5,0,0,3,1,4]  
> 输出：6  
> 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。  
> 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

**相当于 k = 2 的情况**：

k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大：要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。

这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了，我们直接写代码，边写边分析原因。

```java
原始的状态转移方程，没有可化简的地方
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```

按照之前的代码，我们可能想当然这样写代码（错误的）：

```java
int k = 2;
int[][][] dp = new int[n][k + 1][2];
for (int i = 0; i < n; i++) {
    if (i - 1 == -1) {
        // 处理 base case
        dp[i][k][0] = 0;
        dp[i][k][1] = -prices[i];
        continue;
    }
    dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
    dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
}
return dp[n - 1][k][0];
```

为什么错误？我这不是照着状态转移方程写的吗？

还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。  
比如说第一题，k = 1 时的代码框架：

```java
int n = prices.length;
int[][] dp = new int[n][2];
for (int i = 0; i < n; i++) {
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
}
return dp[n - 1][0];
```

但当 k = 2 时，由于没有消掉 k 的影响，所以必须要对 k 进行穷举：

```java
// 原始版本
int maxProfit_k_2(int[] prices) {
    int max_k = 2, n = prices.length;
    int[][][] dp = new int[n][max_k + 1][2];
    for (int i = 0; i < n; i++) {
        for (int k = max_k; k >= 1; k--) {
            if (i - 1 == -1) {
                // 处理 base case
                dp[i][k][0] = 0;
                dp[i][k][1] = -prices[i];
                continue;
            }
            dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
            dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
        }
    }
    // 穷举了 n × max_k × 2 个状态，正确。
    return dp[n - 1][max_k][0];
}
```

> **PS：这里肯定会有读者疑惑，k 的 base case 是 0，按理说应该从 k = 1, k++ 这样穷举状态 k 才对？而且如果你真的这样从小到大遍历 k，提交发现也是可以的**。

这个疑问很正确，因为我们后文 [动态规划答疑篇](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/zui-you-zi-fbef6/) 有介绍 dp 数组的遍历顺序是怎么确定的，主要是根据 base case，以 base case 为起点，逐步向结果靠近。

但为什么我从大到小遍历 k 也可以正确提交呢？因为你注意看，dp[i][k][..] 不会依赖 dp[i][k - 1][..]，而是依赖 dp[i - 1][k - 1][..]，而 dp[i - 1][..][..]，都是已经计算出来的，所以不管你是 k = max_k, k--，还是 k = 1, k++，都是可以得出正确答案的。

那为什么我使用 k = max_k, k-- 的方式呢？因为这样符合语义：

你买股票，初始的「状态」是什么？应该是从第 0 天开始，而且还没有进行过买卖，所以最大交易次数限制 k 应该是 max_k；而随着「状态」的推移，你会进行交易，那么交易次数上限 k 应该不断减少，这样一想，k = max_k, k-- 的方式是比较合乎实际场景的。

##### **188.「**  **[买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)**​ **」**

> 给定一个数组，它的第 `i`​ 个元素是一支给定的股票在第 `i`​ 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 **k** 笔交易。
>
> **注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>
> **示例 1：**   
> 输入：k = 2, prices = [2,4,1]  
> 输出：2  
> 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别，你把上一题的 k = 2 换成题目输入的 k 就行了。

```java
public int maxProfit(int k, int[] prices) {
    int n = prices.length;
    int[][][] dp = new int[n][k + 1][2];
    for (int i = k; i >= 1; i--) {
        dp[0][i][0] = 0;
        dp[0][i][1] = -prices[0];
    }
    for (int i = 1; i < n; i++) {
        for (int j = k; j >= 1; j--) {
            dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
            dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
        }
    }
	return dp[n - 1][k][0];
}
```

### 打家劫舍问题

#### 练习题

##### 198.「 [打家劫舍](https://leetcode.cn/problems/house-robber/)」

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下 **，一夜之内能够偷窃到的最高金额。
>
> **示例 1：**   
> 输入：[1,2,3,1]  
> 输出：4  
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。  
> 偷窃到的最高金额 = 1 + 3 = 4 。

**解决动态规划问题就是找「状态」和「选择」，仅此而已**。

假想你就是这个专业强盗，从左到右走过这一排房子，在每间房子前都有两种**选择**：抢或者不抢。

如果你抢了这间房子，那么你 **肯定** 不能抢相邻的下一间房子了，只能从下下间房子开始做选择。

如果你不抢这件房子，那么你可以走到下一间房子前，继续做选择。

当你走过了最后一间房子后，你就没得抢了，能抢到的钱显然是 0（**base case**）。

以上的逻辑很简单吧，其实已经明确了「状态」和「选择」：**你面前房子的索引就是状态，抢和不抢就是选择**。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677487899272-91d46905-06be-4971-9f54-67563eeda5d7-20240331212050-ho390rh.png" alt="image.png" style="zoom:50%;" />

在两个选择中，每次都选更大的结果，最后得到的就是最多能抢到的 money：

```java
// 主函数
public int rob(int[] nums) {
    return dp(nums, 0);
}
// 返回 nums[start..] 能抢到的最大值
private int dp(int[] nums, int start) {
    if (start >= nums.length) {
        return 0;
    }

    int res = Math.max(
            // 不抢，去下家
            dp(nums, start + 1), 
            // 抢，去下下家
            nums[start] + dp(nums, start + 2)
        );
    return res;
}
```

明确了状态转移，就可以发现对于同一 start 位置，是存在重叠子问题的，比如下图：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677487944846-f23d5cc1-72b8-414a-a0be-16f8ba9e4030-20240331212051-y1zscz2.png" alt="image.png" style="zoom:50%;" />

盗贼有多种选择可以走到这个位置，如果每次到这都进入递归，岂不是浪费时间？所以说存在重叠子问题，可以用备忘录进行优化：

```java
private int[] memo;
// 主函数
public int rob(int[] nums) {
    // 初始化备忘录
    memo = new int[nums.length];
    Arrays.fill(memo, -1);
    // 强盗从第 0 间房子开始抢劫
    return dp(nums, 0);
}

// 返回 dp[start..] 能抢到的最大值
private int dp(int[] nums, int start) {
    if (start >= nums.length) {
        return 0;
    }
    // 避免重复计算
    if (memo[start] != -1) return memo[start];

    int res = Math.max(
        dp(nums, start + 1), 
        dp(nums, start + 2) + nums[start]
    );
    // 记入备忘录
    memo[start] = res;
    return res;
}
```

这就是自顶向下的动态规划解法，我们也可以略作修改，写出**自底向上**的解法：

```java
int rob(int[] nums) {
    int n = nums.length;
    // dp[i] = x 表示：
    // 从第 i 间房子开始抢劫，最多能抢到的钱为 x
    // base case: dp[n] = 0
    int[] dp = new int[n + 2];
    for (int i = n - 1; i >= 0; i--) {
        dp[i] = Math.max(dp[i + 1], nums[i] + dp[i + 2]);
    }
    return dp[0];
}
```

我们又发现状态转移只和 dp[i] 最近的两个状态有关，所以可以进一步优化，将空间复杂度降低到 O(1)。

```java
int rob(int[] nums) {
    int n = nums.length;
    // 记录 dp[i+1] 和 dp[i+2]
    int dp_i_1 = 0, dp_i_2 = 0;
    // 记录 dp[i]
    int dp_i = 0; 
    for (int i = n - 1; i >= 0; i--) {
        dp_i = Math.max(dp_i_1, nums[i] + dp_i_2);
        dp_i_2 = dp_i_1;
        dp_i_1 = dp_i;
    }
    return dp_i;
}
```

##### 213.「[打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)」

> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。
>
> **示例 1：**   
> 输入：nums = [2,3,2]  
> 输出：3  
> 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

也就是说，现在第一间房子和最后一间房子也相当于是相邻的，不能同时抢。比如说输入数组 nums=[2,3,2]，算法返回的结果应该是 3 而不是 4，因为开头和结尾不能同时被抢。

这个约束条件看起来应该不难解决，我们前文 [单调栈问题汇总](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_627cd21ce4b01a4851fe126d/1) 说过一种解决环形数组的方案，那么在这个问题上怎么处理呢？

首先，首尾房间不能同时被抢，那么只可能有三种不同情况：要么都不被抢；要么第一间房子被抢最后一间不抢；要么最后一间房子被抢第一间不抢。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677488814625-b40f73dd-5ab8-41b9-a1fa-6563a31b394d-20240331212051-aq6jbap.png" alt="image.png" style="zoom:30%;" />

那就简单了啊，这三种情况，哪种的结果最大，就是最终答案呗！不过，其实我们不需要比较三种情况，只要比较情况二和情况三就行了，**因为这两种情况对于房子的选择余地比情况一大呀，房子里的钱数都是非负数，所以选择余地大，最优决策结果肯定不会小**。

所以只需对之前的解法稍作修改即可：

```java
public int rob(int[] nums) {
    if (nums.length == 1) return nums[0];
    return Math.max(dp(nums, 0, nums.length - 2), dp(nums, 1, nums.length - 1));
}

private int dp(int[] nums, int start, int end) {
    int n = nums.length;
    int[] dp = new int[n + 2];

    for (int i = end; i >= start; i--) {
        dp[i] = Math.max(dp[i + 1], dp[i + 2] + nums[i]);
    }
    return dp[start];
}
```

##### 337.「[打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)」

> 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。
>
> 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。
>
> 给定二叉树的 root 。返回 ***在不触动警报的情况下***  *，小偷能够盗取的最高金额* 。
>
> **示例 1:**
>
> ![1677489361451-8d2160d6-7355-4a25-ae36-8e30e6290199](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677489361451-8d2160d6-7355-4a25-ae36-8e30e6290199-20240331212051-jykpzhz.jpeg)​
>
> 输入: root = [3,2,3,null,3,null,1]  
> 输出: 7
> 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7

如果输入为下图这棵二叉树：

```
     3
    / \
   4   5
  / \   \ 
 1   3   1
```

那么算法应该返回 9，如果抢劫第二层的房子可以获得最高金额 4 + 5 = 9。

整体的思路完全没变，还是做抢或者不抢的选择，去收益较大的选择。甚至我们可以直接按这个套路写出代码：

```java
int rob(TreeNode root) {
    int[] res = dp(root); // res[0]代表不抢root, res[1]代表抢root
    return Math.max(res[0], res[1]);
}


int[] dp(TreeNode root) {
    if (root == null) return new int[]{0, 0};
    // 后序遍历，拿到左右子树的结果
    int[] left = dp(root.left);
    int[] right = dp(root.right);
    // 抢，下家就不能抢了
    int rob = root.val + left[0] + right[0];
    // 不抢，下家可抢可不抢，取决于收益大小
    int not_rob = Math.max(left[0], left[1])
                + Math.max(right[0], right[1]);

    return new int[]{not_rob, rob};
}
```

### 子序列

#### 动态规划之子序列问题解题模板

子序列问题是常见的算法问题，而且并不好解决。

首先，子序列问题本身就相对子串、子数组更困难一些，因为前者是不连续的序列，而后两者是连续的，就算穷举你都不一定会，更别说求解相关的算法问题了。

而且，子序列问题很可能涉及到两个字符串，比如前文 [最长公共子序列](https://labuladong.github.io/algo/di-er-zhan-a01c6/zi-xu-lie--6bc09/jing-dian--93b6b/)，如果没有一定的处理经验，真的不容易想出来。所以本文就来扒一扒子序列问题的套路，其实就有两种模板，相关问题只要往这两种思路上想，十拿九稳。

一般来说，这类问题都是让你求一个**最长子序列**，因为最短子序列就是一个字符嘛，没啥可问的。一旦涉及到子序列和最值，那几乎可以肯定，**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)** 。

原因很简单，你想想一个字符串，它的子序列有多少种可能？起码是指数级的吧，这种情况下，不用动态规划技巧，还想怎么着？

既然要用动态规划，那就要定义 dp 数组，找状态转移关系。我们说的两种思路模板，就是 dp 数组的定义思路。不同的问题可能需要不同的 dp 数组定义来解决。

##### 一、两种思路

**1、第一种思路模板是一个一维的 dp 数组**：

```java
int n = array.length;
int[] dp = new int[n];

for (int i = 1; i < n; i++) {
    for (int j = 0; j < i; j++) {
        dp[i] = 最值(dp[i], dp[j] + ...)
    }
}
```

比如我们写过的 [最长递增子序列](https://labuladong.gitee.io/article/fname.html?fname=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97) 和 [最大子数组和](https://labuladong.gitee.io/article/fname.html?fname=%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84) 都是这个思路。

在这个思路中 dp 数组的定义是：

**在子数组 arr[0..i] 中，以 arr[i] 结尾的子序列的长度是 dp[i]** 。

为啥最长递增子序列需要这种思路呢？前文说得很清楚了，因为这样符合归纳法，可以找到状态转移的关系，这里就不具体展开了。

**2、第二种思路模板是一个二维的 dp 数组**：

```java
int n = arr.length;
int[][] dp = new dp[n][n];

for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        if (arr[i] == arr[j]) 
            dp[i][j] = dp[i][j] + ...
        else
            dp[i][j] = 最值(...)
    }
}
```

这种思路运用相对更多一些，尤其是涉及两个字符串/数组的子序列时，比如前文讲的 [最长公共子序列](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_6298793ae4b09dda12708be8/1) 和 [编辑距离](https://labuladong.gitee.io/article/fname.html?fname=%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB)；这种思路也可以用于只涉及一个字符串/数组的情景，比如本文讲的回文子序列问题。

**2.1 涉及两个字符串/数组的场景**，dp 数组的定义如下：

**在子数组 arr1[0..i] 和子数组 arr2[0..j] 中，我们要求的子序列长度为 dp[i][j]** 。

**2.2 只涉及一个字符串/数组的场景**，dp 数组的定义如下：

**在子数组 array[i..j] 中，我们要求的子序列的长度为 dp[i][j]** 。

下面就看看最长回文子序列问题，详解一下第二种情况下如何使用动态规划。

##### 二、最长回文子序列

###### 516.「[最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)」

> 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。
>
> 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
>
> **示例 1：**   
> 输入：s = "bbbab"  
> 输出：4  
> 解释：一个可能的最长回文子序列为 "bbbb" 。

我们对 dp 数组的定义是：**在子串 s[i..j] 中，最长回文子序列的长度为 dp[i][j]** 。一定要记住这个定义才能理解算法。

为啥这个问题要这样定义二维的 dp 数组呢？我在 [最长递增子序列](https://labuladong.gitee.io/article/fname.html?fname=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97) 提到，找状态转移需要归纳思维，说白了就是如何从已知的结果推出未知的部分。而这样定义能够进行归纳，容易发现状态转移关系。

具体来说，如果我们想求 dp[i][j]，假设你知道了子问题 dp[i+1][j-1] 的结果（s[i+1..j-1] 中最长回文子序列的长度），你是否能想办法算出 dp[i][j] 的值（s[i..j] 中，最长回文子序列的长度）呢？

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687068693108-960477ef-5579-4654-822c-b4941c8a021a-20240331215918-a6to4ar.png" alt="image.png" style="zoom:40%;" />

可以！这取决于 s[i] 和 s[j] 的字符：

**如果它俩相等**，那么它俩加上 s[i+1..j-1] 中的最长回文子序列就是 s[i..j] 的最长回文子序列：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687068722056-021c13ca-8c4d-4fff-b5e6-3f47602e3196-20240331215918-j931hyv.png" alt="image.png" style="zoom:40%;" />

**如果它俩不相等**，说明它俩**不可能同时**出现在 s[i..j] 的最长回文子序列中，那么把它俩**分别**加入 s[i+1..j-1] 中，看看哪个子串产生的回文子序列更长即可：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687068748939-ff26ce14-e8ee-40ad-b3ef-6088ffba19a2-20240331215919-y5d2oo2.png" alt="image.png" style="zoom:50%;" />

以上两种情况写成代码就是这样：

```java
if (s[i] == s[j])
    // 它俩一定在最长回文子序列中
    dp[i][j] = dp[i + 1][j - 1] + 2;
else
    // s[i+1..j] 和 s[i..j-1] 谁的回文子序列更长？
    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
```

至此，状态转移方程就写出来了，根据 dp 数组的定义，我们要求的就是 dp[0][n - 1]，也就是整个 s 的最长回文子序列的长度。

##### 三、代码实现

首先明确一下 base case，如果只有一个字符，显然最长回文子序列长度是 1，也就是 dp[i][j] = 1 (i == j)。

因为 i 肯定小于等于 j，所以对于那些 i > j 的位置，根本不存在什么子序列，应该初始化为 0。

另外，看看刚才写的状态转移方程，想求 dp[i][j] 需要知道 dp[i+1][j-1]，dp[i+1][j]，dp[i][j-1] 这三个位置；再看看我们确定的 base case，填入 dp 数组之后是这样：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687068868236-3b54b8c7-f296-481f-b547-a0dd04073f24-20240331215919-a33ljrj.png" alt="image.png" style="zoom:50%;" />

**为了保证每次计算 dp[i][j]，左下右方向的位置已经被计算出来，只能斜着遍历或者反着遍历**：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687069016209-4a36fda6-b442-429a-8a2e-69ada1fba92e-20240331215919-brlawbr.png" alt="image.png" style="zoom:50%;" />

> tip：关于 dp 数组的遍历方向，详情见 [动态规划答疑篇](https://labuladong.gitee.io/article/fname.html?fname=%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84)。

我选择反着遍历，代码如下：

```java
int longestPalindromeSubseq(String s) {
    int n = s.length();
    // dp 数组全部初始化为 0
    int[][] dp = new int[n][n];
    // base case
    for (int i = 0; i < n; i++) {
        dp[i][i] = 1;
    }
    // 反着遍历保证正确的状态转移
    for (int i = n - 1; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            // 状态转移方程
            if (s.charAt(i) == s.charAt(j)) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    // 整个 s 的最长回文子串长度
    return dp[0][n - 1];
}
```

至此，最长回文子序列的问题就解决了。

当然，也可以用dfs方式去解，不过，需要注意的是，使用纯DFS解这个问题会有较高的时间复杂度，因为它没有利用到动态规划（DP）中的重叠子问题优化。对于长字符串，这种方法可能会导致性能问题，因为它的时间复杂度接近于O(2\^n)，其中n是字符串的长度。

```java
public class Solution {
    public int longestPalindromeSubseq(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        return dfs(s, 0, s.length() - 1, new Integer[s.length()][s.length()]);
    }

    private int dfs(String s, int left, int right, Integer[][] memo) {
        // 如果左右指针相遇或交错，说明找到了一个回文序列
        if (left > right) {
            return 0;
        }
        // 如果只有一个字符，那么它自己就是一个长度为1的回文序列
        if (left == right) {
            return 1;
        }
        // 如果已经计算过这个子问题，则直接返回记忆化的结果
        if (memo[left][right] != null) {
            return memo[left][right];
        }
        // 如果左右字符相同，它们可以构成回文序列的一部分
        if (s.charAt(left) == s.charAt(right)) {
            memo[left][right] = 2 + dfs(s, left + 1, right - 1, memo);
        } else {
            // 如果左右字符不同，尝试去掉左边或右边的字符，递归地寻找最长回文序列
            memo[left][right] = Math.max(dfs(s, left + 1, right, memo), dfs(s, left, right - 1, memo));
        }
        return memo[left][right];
    }
}
```

#### 经典动态规划：编辑距离

##### 72.「 [编辑距离](https://leetcode.cn/problems/edit-distance/)」

> 给你两个单词 word1 和 word2， *请返回将 word1 转换成 word2 所使用的最少操作数*  。
>
> 你可以对一个单词进行如下三种操作：
>
> - 插入一个字符
> - 删除一个字符
> - 替换一个字符
>
> **示例 1：**   
> 输入：word1 = "horse", word2 = "ros"  
> 输出：3  
> 解释： horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e')

###### 一、思路

编辑距离问题就是给我们两个字符串 s1 和 s2，只能用三种操作，让我们把 s1 变成 s2，求最少的操作数。需要明确的是，不管是把 s1 变成 s2 还是反过来，结果都是一样的，所以后文就以 s1 变成 s2 举例。

后文 [最长公共子序列](https://labuladong.github.io/algo/di-er-zhan-a01c6/zi-xu-lie--6bc09/jing-dian--93b6b/) 说过，**解决两个字符串的动态规划问题，一般都是用两个指针 i, j 分别指向两个字符串的最后，然后一步步往前移动，缩小问题的规模**。

> 其实让 i, j 从前往后移动也可以，改一下 dp 函数/数组的定义即可，思路是完全一样的。

设两个字符串分别为 "rad" 和 "apple"，为了把 s1 变成 s2，算法会这样进行：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686994515841-ce44a8dd-31fd-42e4-bc09-fc603a0be95b-20240331222527-s7yldo6.gif" alt="1.gif" style="zoom:50%;" /><img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686994532359-19fa2156-8aa3-4461-8518-2e16e0c51faf-20240331222528-vbn633s.png" alt="image.png" style="zoom:50%;" />

请记住这个 GIF 过程，这样就能算出编辑距离。关键在于如何做出正确的操作，稍后会讲。

根据上面的 GIF，可以发现操作不只有三个，其实还有第四个操作，就是什么都不要做（skip）。比如这个情况：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686994578871-494c562c-8ed9-43e5-9657-5032ad810dcf-20240331222528-49n50q4.png" alt="image.png" style="zoom:50%;" />

因为这两个字符本来就相同，为了使编辑距离最小，显然不应该对它们有任何操作，直接往前移动 i, j 即可。

还有一个很容易处理的情况，就是 j 走完 s2 时，如果 i 还没走完 s1，那么只能用删除操作把 s1 缩短为 s2。比如这个情况：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686994597734-3e070518-715d-481a-b3b6-fe2bf7ffddbf-20240331222528-4l3pjm6.png" alt="image.png" style="zoom:50%;" />

类似的，如果 i 走完 s1 时 j 还没走完了 s2，那就只能用插入操作把 s2 剩下的字符全部插入 s1。等会会看到，这两种情况就是算法的 **base case**。

下面详解一下如何将思路转换成代码，坐稳，要发车了。

###### 二、代码详解

先梳理一下之前的思路：

base case 是 i 走完 s1 或 j 走完 s2，可以直接返回另一个字符串剩下的长度。

对于每对儿字符 s1[i] 和 s2[j]，可以有四种操作：

```java
if s1[i] == s2[j]:
    啥都别做（skip）
    i, j 同时向前移动
else:
    三选一：
        插入（insert）
        删除（delete）
        替换（replace）
```

有这个框架，问题就已经解决了。读者也许会问，这个「三选一」到底该怎么选择呢？很简单，全试一遍，哪个操作最后得到的编辑距离最小，就选谁。这里需要递归技巧，先看下暴力解法代码：

```java
int minDistance(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    // i，j 初始化指向最后一个索引
    return dp(s1, m - 1, s2, n - 1);
}

// 定义：返回 s1[0..i] 和 s2[0..j] 的最小编辑距离
int dp(String s1, int i, String s2, int j) {
    // base case
    if (i == -1) return j + 1;
    if (j == -1) return i + 1;

    if (s1.charAt(i) == s2.charAt(j)) {
        return dp(s1, i - 1, s2, j - 1); // 啥都不做
    }
    return min(
        dp(s1, i, s2, j - 1) + 1,    // 插入
        dp(s1, i - 1, s2, j) + 1,    // 删除
        dp(s1, i - 1, s2, j - 1) + 1 // 替换
    );
}

int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}
```

下面来详细解释一下这段递归代码，base case 应该不用解释了，主要解释一下递归部分。

都说递归代码的可解释性很好，这是有道理的，只要理解函数的定义，就能很清楚地理解算法的逻辑。我们这里 dp 函数的定义是这样的：

```java
// 定义：返回 s1[0..i] 和 s2[0..j] 的最小编辑距离
int dp(String s1, int i, String s2, int j) {}
```

**记住这个定义**之后，先来看这段代码：

```java
if s1[i] == s2[j]:
    return dp(s1, i - 1, s2, j - 1); // 啥都不做
// 解释：
// 本来就相等，不需要任何操作
// s1[0..i] 和 s2[0..j] 的最小编辑距离等于
// s1[0..i-1] 和 s2[0..j-1] 的最小编辑距离
// 也就是说 dp(i, j) 等于 dp(i-1, j-1)
```

如果 s1[i] != s2[j]，就要对三个操作递归了，稍微需要点思考：

```java
dp(s1, i, s2, j - 1) + 1,    // 插入
// 解释：
// 我直接在 s1[i] 插入一个和 s2[j] 一样的字符
// 那么 s2[j] 就被匹配了，前移 j，继续跟 i 对比
// 别忘了操作数加一
```

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686994934104-e97afb22-7299-490e-89bc-0f0a8711730a-20240331222528-8gfnqs1.gif" alt="1.gif" style="zoom:50%;" />

```java
dp(s1, i - 1, s2, j) + 1,    // 删除
// 解释：
// 我直接把 s[i] 这个字符删掉
// 前移 i，继续跟 j 对比
// 操作数加一
```

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686995028869-44ca8e2c-0c2a-4831-865c-39bfaa3edcf6-20240331222528-yyiu7ty.gif" alt="1.gif" style="zoom:50%;" />

```java
dp(s1, i - 1, s2, j - 1) + 1 // 替换
// 解释：
// 我直接把 s1[i] 替换成 s2[j]，这样它俩就匹配了
// 同时前移 i，j 继续对比
// 操作数加一
```

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686995073627-cde7c4cf-db93-41a4-8282-8ac0a1c979bf-20240331222529-jcay1gd.gif" alt="1.gif" style="zoom:50%;" />  
现在，你应该完全理解这段短小精悍的代码了。还有点小问题就是，这个解法是暴力解法，存在重叠子问题，需要用动态规划技巧来优化。

**怎么能一眼看出存在重叠子问题呢**？后文 [动态规划之正则表达式](https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/jing-dian--8d516/) 有提过，这里再简单提一下，需要抽象出本文算法的递归框架：

```java
int dp(i, j) {
    dp(i - 1, j - 1); // #1
    dp(i, j - 1);     // #2
    dp(i - 1, j);     // #3
}
```

对于子问题 dp(i-1, j-1)，如何通过原问题 dp(i, j) 得到呢？有不止一条路径，比如 dp(i, j) -> #1 和 dp(i, j) -> #2 -> #3。一旦发现一条重复路径，就说明存在巨量重复路径，也就是重叠子问题。

###### 三、动态规划优化

对于重叠子问题呢，前文 [动态规划详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/) 详细介绍过，优化方法无非是备忘录或者 DP table。

备忘录很好加，原来的代码稍加修改即可：

```java
class Solution {
    // 备忘录
    int[][] memo;
    
    public int minDistance(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // 备忘录初始化为特殊值，代表还未计算
        memo = new int[m][n];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }
        return dp(s1, m - 1, s2, n - 1);
    }

    int dp(String s1, int i, String s2, int j) {
        if (i == -1) return j + 1;
        if (j == -1) return i + 1;
        // 查备忘录，避免重叠子问题
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // 状态转移，结果存入备忘录
        if (s1.charAt(i) == s2.charAt(j)) {
            memo[i][j] = dp(s1, i - 1, s2, j - 1);
        } else {
            memo[i][j] =  min(
                dp(s1, i, s2, j - 1) + 1,
                dp(s1, i - 1, s2, j) + 1,
                dp(s1, i - 1, s2, j - 1) + 1
            );
        }
        return memo[i][j];
    }

    int min(int a, int b, int c) {
        return Math.min(a, Math.min(b, c));
    }
}
```

**主要说下 DP table 的解法**：

首先明确 dp 数组的含义，dp 数组是一个二维数组，长这样：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686995171657-cc285e33-3854-4c76-97ca-5cca71244809-20240331222529-ijpz0bv.png" alt="image.png" style="zoom:40%;" />

有了之前递归解法的铺垫，应该很容易理解。dp[..][0] 和 dp[0][..] 对应 base case，dp[i][j] 的含义和之前的 dp 函数类似：

```java
int dp(String s1, int i, String s2, int j)
// 返回 s1[0..i] 和 s2[0..j] 的最小编辑距离

dp[i-1][j-1]
// 存储 s1[0..i] 和 s2[0..j] 的最小编辑距离
```

dp 函数的 base case 是 i, j 等于 -1，而数组索引至少是 0，所以 dp 数组会偏移一位。

既然 dp 数组和递归 dp 函数含义一样，也就可以直接套用之前的思路写代码，**唯一不同的是，DP table 是自底向上求解，递归解法是自顶向下求解**：

```java
int minDistance(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    // 定义：s1[0..i] 和 s2[0..j] 的最小编辑距离是 dp[i+1][j+1]
    int[][] dp = new int[m + 1][n + 1];
    // base case 
    for (int i = 1; i <= m; i++)
        dp[i][0] = i;
    for (int j = 1; j <= n; j++)
        dp[0][j] = j;
    // 自底向上求解
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1.charAt(i-1) == s2.charAt(j-1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = min(
                    dp[i - 1][j] + 1,
                    dp[i][j - 1] + 1,
                    dp[i - 1][j - 1] + 1
                );
            }
        }
    }
    // 储存着整个 s1 和 s2 的最小编辑距离
    return dp[m][n];
}

int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}
```

###### 三、扩展延伸

一般来说，处理两个字符串的动态规划问题，都是按本文的思路处理，建立 DP table。为什么呢，因为易于找出状态转移的关系，比如编辑距离的 DP table：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686995294060-02763c9a-3c31-4315-918b-fc4135d86ca3-20240331222529-3silay9.png" alt="image.png" style="zoom:50%;" />

还有一个细节，既然每个 dp[i][j] 只和它附近的三个状态有关，空间复杂度是可以压缩成 O(min(M, N)) 的（M，N 是两个字符串的长度）。不难，但是可解释性大大降低，读者可以自己尝试优化一下。

你可能还会问，**这里只求出了最小的编辑距离，那具体的操作是什么**？你之前举的修改公众号文章的例子，只有一个最小编辑距离肯定不够，还得知道具体怎么修改才行。

这个其实很简单，代码稍加修改，给 dp 数组增加额外的信息即可：

```java
// int[][] dp;
Node[][] dp;

class Node {
    int val;
    int choice;
    // 0 代表啥都不做
    // 1 代表插入
    // 2 代表删除
    // 3 代表替换
}
```

val 属性就是之前的 dp 数组的数值，choice 属性代表操作。在做最优选择时，顺便把操作记录下来，然后就从结果反推具体操作。

我们的最终结果不是 dp[m][n] 吗，这里的 val 存着最小编辑距离，choice 存着最后一个操作，比如说是插入操作，那么就可以左移一格：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686995327930-7de5f565-4bbe-4468-b20d-40512c624c63-20240331222529-7btkk38.png" alt="image.png" style="zoom:50%;" />

重复此过程，可以一步步回到起点 dp[0][0]，形成一条路径，按这条路径上的操作进行编辑，就是最佳方案。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686995343002-c62da9d1-a424-4160-880f-96402a983d85-20240331222530-fhkg6wj.png" alt="image.png" style="zoom:50%;" />

#### 最长递增子序列

也许有读者看了前文 [动态规划详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/)，学会了动态规划的套路：找到了问题的「状态」，明确了 dp 数组/函数的含义，定义了 base case；但是不知道如何确定「选择」，也就是找不到状态转移的关系，依然写不出动态规划解法，怎么办？

不要担心，动态规划的难点本来就在于寻找正确的状态转移方程，本文就借助经典的「最长递增子序列问题」来讲一讲设计动态规划的通用技巧：**数学归纳思想**。

最长递增子序列（Longest Increasing Subsequence，简写 LIS）是非常经典的一个算法问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何找状态转移方程，如何写出动态规划解法。比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。

##### 300.「 [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)」

> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
>
> **子序列**是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
>
> **示例 1：**   
> 输入：nums = [10,9,2,5,3,7,101,18]  
> 输出：4  
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

> 注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。

下面先来设计动态规划算法解决这个问题。

###### 动态规划解法

动态规划的核心设计思想是数学归纳法。

相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么**我们先假设这个结论在 k &lt; n 时成立，然后根据这个假设，想办法推导证明出 k = n 的时候此结论也成立**。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。

类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 dp[0...i-1] 都已经被算出来了，然后问自己：怎么通过这些结果算出 dp[i]？

直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 dp[i] 的值到底代表着什么？

**我们的定义是这样的：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度**。

根据这个定义，我们就可以推出 base case：dp[i] 初始值为 1，因为以 nums[i] 结尾的最长递增子序列起码要包含它自己。

举两个例子：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686980171197-0c83933f-f598-4f08-b755-6d0a7a868363-20240331224416-w1oif28.png" alt="image.png" style="zoom:50%;" />

这个 GIF 展示了算法演进的过程：

![1.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686980430061-297940e4-c7b3-413e-ba86-7bfaf304b407-20240331224416-frsmj28.gif)

根据这个定义，我们的最终结果（子序列的最大长度)应该是 dp 数组中的最大值。

```java
int res = 0;
for (int i = 0; i < dp.length; i++) {
    res = Math.max(res, dp[i]);
}
return res;
```

读者也许会问，刚才的算法演进过程中每个 dp[i] 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 dp[i] 呢？

这就是动态规划的重头戏，如何设计算法逻辑进行状态转移，才能正确运行呢？这里需要使用数学归纳的思想：

**假设我们已经知道了 dp[0..4] 的所有结果，我们如何通过这些已知结果推出 dp[5] 呢**？

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686980461105-c607841a-4e4d-4557-9929-1d7c92c0beaa-20240331224416-5exih2d.png" alt="image.png" style="zoom:50%;" />

根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。

**nums[5] = 3，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到这些子序列末尾，就可以形成一个新的递增子序列，而且这个新的子序列长度加一**。

nums[5] 前面有哪些元素小于 nums[5]？这个好算，用 for 循环比较一波就能把这些元素找出来。

以这些元素为结尾的最长递增子序列的长度是多少？回顾一下我们对 dp 数组的定义，它记录的正是以每个元素为末尾的最长递增子序列的长度。

以我们举的例子来说，nums[0] 和 nums[4] 都是小于 nums[5] 的，然后对比 dp[0] 和 dp[4] 的值，我们让 nums[5] 和更长的递增子序列结合，得出 dp[5] = 3：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686980548805-1fa4e532-5f0d-4f1f-a11b-cef2b7b415ad-20240331224416-kok58v1.png" alt="image.png" style="zoom:50%;" />

```java
for (int j = 0; j < i; j++) {
    if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
    }
}
```

当 i = 5 时，这段代码的逻辑就可以算出 dp[5]。其实到这里，这道算法题我们就基本做完了。

读者也许会问，我们刚才只是算了 dp[5] 呀，dp[4], dp[3] 这些怎么算呢？类似数学归纳法，你已经可以算出 dp[5] 了，其他的就都可以算出来：

```java
for (int i = 0; i < nums.length; i++) {
    for (int j = 0; j < i; j++) {
        // 寻找 nums[0..j-1] 中比 nums[i] 小的元素
        if (nums[i] > nums[j]) {
            // 把 nums[i] 接在后面，即可形成长度为 dp[j] + 1，
            // 且以 nums[i] 为结尾的递增子序列
            dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
}
```

结合我们刚才说的 base case，下面我们看一下完整代码：

```java
int lengthOfLIS(int[] nums) {
    // 定义：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度
    int[] dp = new int[nums.length];
    // base case：dp 数组全都初始化为 1，因为以 nums[i] 结尾的最长递增子序列起码要包含它自己
    Arrays.fill(dp, 1);
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) 
                dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
  
    int res = 0;
    for (int i = 0; i < dp.length; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}
```

至此，这道题就解决了，时间复杂度 O(N^2)。总结一下如何找到动态规划的状态转移关系：

1、明确 dp 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

2、根据 dp 数组的定义，运用数学归纳法的思想，假设 dp[0...i-1] 都已知，想办法求出 dp[i]，一旦这一步完成，整个题目基本就解决了。

但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。

目前的解法是标准的动态规划，但对最长递增子序列问题来说，这个解法不是最优的，可能无法通过所有测试用例了，下面讲讲更高效的解法。

###### 二分查找解法

这个解法的时间复杂度为 O(NlogN)，但是说实话，正常人基本想不到这种解法（也许玩过某些纸牌游戏的人可以想出来）。所以大家了解一下就好，正常情况下能够给出动态规划解法就已经很不错了。

根据题目的意思，我都很难想象这个问题竟然能和二分查找扯上关系。其实最长递增子序列和一种叫做 patience game 的纸牌游戏有关，甚至有一种排序方法就叫做 patience sorting（耐心排序）。

为了简单起见，后文跳过所有数学证明，通过一个简化的例子来理解一下算法思路。

首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686980808727-1bfcf87b-3889-4d7d-8ace-906dcab28992-20240331224416-ixznvz1.png" alt="image.png" style="zoom:80%;" />

**处理这些扑克牌要遵循以下规则**：

只能把点数小的牌压到点数比它大的牌上；如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去；如果当前牌有多个堆可供选择，则选择最左边的那一堆放置。

比如说上述的扑克牌最终会被分成这样 5 堆（我们认为纸牌 A 的牌面是最大的，纸牌 2 的牌面是最小的）。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686980831222-a03f3106-ddc7-4ae2-910a-c161e64dbb35-20240331224416-6vaerp4.png" alt="image.png" style="zoom:50%;" />

为什么遇到多个可选择堆的时候要放到最左边的堆上呢？因为这样可以保证牌堆顶的牌有序（2, 4, 7, 8, Q），证明略。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686980934600-be22b3f0-eb3a-416b-905b-6ab4fd470c9e-20240331224416-tef9hvo.png" alt="image.png" style="zoom:70%;" />

按照上述规则执行，可以算出最长递增子序列，牌的堆数就是最长递增子序列的长度，证明略。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686980960340-950f851d-9935-420d-94cf-f47684a5bcff-20240331224417-5txhsu4.png" alt="image.png" style="zoom:70%;" />

我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是**有序**吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置。

```java
int lengthOfLIS(int[] nums) {
    int[] top = new int[nums.length];
    // 牌堆数初始化为 0
    int piles = 0;
    for (int i = 0; i < nums.length; i++) {
        // 要处理的扑克牌
        int poker = nums[i];

        /***** 搜索左侧边界的二分查找 *****/
        int left = 0, right = piles;
        while (left < right) {
            int mid = (left + right) / 2;
            if (top[mid] > poker) {
                right = mid;
            } else if (top[mid] < poker) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        /*********************************/
    
        // 没找到合适的牌堆，新建一堆
        if (left == piles) piles++;
        // 把这张牌放到牌堆顶
        top[left] = poker;
    }
    // 牌堆数就是 LIS 长度
    return piles;
}
```

至此，二分查找的解法也讲解完毕。

这个解法确实很难想到。首先涉及数学证明，谁能想到按照这些规则执行，就能得到最长递增子序列呢？其次还有二分查找的运用，要是对二分查找的细节不清楚，给了思路也很难写对。

所以，这个方法作为思维拓展好了。但动态规划的设计方法应该完全理解：假设之前的答案已知，利用数学归纳的思想正确进行状态的推演转移，最终得到答案。

#### 动态规划设计：最大子数组

##### 53.「 [最大子序和](https://leetcode.cn/problems/maximum-subarray/)」

> 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **子数组** 是数组中的一个连续部分。
>
> **示例 1：**   
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]  
> 输出：6  
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

解决这个问题还可以用动态规划技巧解决，但是 dp 数组的定义比较特殊。按照我们常规的动态规划思路，一般是这样定义 dp 数组：

**nums[0..i] 中的「最大的子数组和」为 dp[i]** 。

如果这样定义的话，整个 nums 数组的「最大子数组和」就是 dp[n-1]。如何找状态转移方程呢？按照数学归纳法，假设我们知道了 dp[i-1]，如何推导出 dp[i] 呢？

如下图，按照我们刚才对 dp 数组的定义，dp[i] = 5 ，也就是等于 nums[0..i] 中的最大子数组和：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686997438383-c38dbb7c-273d-4a78-ba3c-ea403ce6a5fe-20240401105034-f47ic3c.png" alt="image.png" style="zoom:40%;" />

那么在上图这种情况中，利用数学归纳法，你能用 dp[i] 推出 dp[i+1] 吗？

**实际上是不行的，因为子数组一定是连续的，按照我们当前 dp 数组定义，并不能保证 nums[0..i] 中的最大子数组与 nums[i+1] 是相邻的**，也就没办法从 dp[i] 推导出 dp[i+1]。

所以说我们这样定义 dp 数组是不正确的，无法得到合适的状态转移方程。对于这类子数组问题，我们就要重新定义 dp 数组的含义：

**以 nums[i] 为结尾的「最大子数组和」为 dp[i]** 。

这种定义之下，想得到整个 nums 数组的「最大子数组和」，不能直接返回 dp[n-1]，而需要遍历整个 dp 数组：

```java
int res = Integer.MIN_VALUE;
for (int i = 0; i < n; i++) {
    res = Math.max(res, dp[i]);
}
return res;
```

依然使用数学归纳法来找状态转移关系：假设我们已经算出了 dp[i-1]，如何推导出 dp[i] 呢？

可以做到，dp[i] 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。

如何选择？既然要求「最大子数组和」，当然选择结果更大的那个啦：

```java
// 要么自成一派，要么和前面的子数组合并
dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
```

综上，我们已经写出了状态转移方程，就可以直接写出解法了：

```java
int maxSubArray(int[] nums) {
    int n = nums.length;
    if (n == 0) return 0;
    // 定义：dp[i] 记录以 nums[i] 为结尾的「最大子数组和」
    int[] dp = new int[n];
    // base case
    // 第一个元素前面没有子数组
    dp[0] = nums[0];
    // 状态转移方程
    for (int i = 1; i < n; i++) {
        dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
    }
    // 得到 nums 的最大子数组
    int res = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        res = Math.max(res, dp[i]);
    }
    return res;
}
```

以上解法时间复杂度是 O(N)，空间复杂度也是 O(N)，较暴力解法已经很优秀了，不过**注意到 dp[i] 仅仅和 dp[i-1] 的状态有关**，那么我们可以施展前文 [动态规划的降维打击：空间压缩技巧](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dui-dong-t-8e7bf/) 讲的技巧进行进一步优化，将空间复杂度降低：

```java
int maxSubArray(int[] nums) {
    int n = nums.length;
    if (n == 0) return 0;
    // base case
    int dp_0 = nums[0];
    int dp_1 = 0, res = dp_0;

    for (int i = 1; i < n; i++) {
        // dp[i] = max(nums[i], nums[i] + dp[i-1])
        dp_1 = Math.max(nums[i], nums[i] + dp_0);
        dp_0 = dp_1;
        // 顺便计算最大的结果
        res = Math.max(res, dp_1);
    }
  
    return res;
}
```

#### 经典动态规划：最长公共子序列

##### 1143.「 [最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)」

> 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。
>
> 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
>
> 例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
>
> 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。
>
> 示例 1：  
> 输入：text1 = "abcde", text2 = "ace"  
> 输出：3
> 解释：最长公共子序列是 "ace" ，它的长度为 3 。

如果没有做过这道题，一个最简单的暴力算法就是，把 s1 和 s2 的所有子序列都穷举出来，然后看看有没有公共的，然后在所有公共子序列里面再寻找一个长度最大的。

显然，这种思路的复杂度非常高，你要穷举出所有子序列，这个复杂度就是指数级的，肯定不实际。

正确的思路是不要考虑整个字符串，而是细化到 s1 和 s2 的每个字符。前文 [子序列解题模板](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_62987943e4b01c509ab8b6aa/1) 中总结的一个规律：

**对于两个字符串求子序列的问题，都是用两个指针 i 和 j 分别在两个字符串上移动，大概率是动态规划思路**。

最长公共子序列的问题也可以遵循这个规律，我们可以先写一个 dp 函数：

```java
// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度
int dp(String s1, int i, String s2, int j)
```

这个 dp 函数的定义是：**dp(s1, i, s2, j) 计算 s1[i..] 和 s2[j..] 的最长公共子序列长度**。

根据这个定义，那么我们想要的答案就是 dp(s1, 0, s2, 0)，且 base case 就是 i == len(s1) 或 j == len(s2) 时，因为这时候 s1[i..] 或 s2[j..] 就相当于空串了，最长公共子序列的长度显然是 0：

```java
int longestCommonSubsequence(String s1, String s2) {
    return dp(s1, 0, s2, 0);
}

/* 主函数 */
int dp(String s1, int i, String s2, int j) {
    // base case
    if (i == s1.length() || j == s2.length()) {
        return 0;
    }
    // ...
```

**接下来，咱不要看 s1 和 s2 两个字符串，而是要具体到每一个字符，思考每个字符该做什么**。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687052896989-1f8beee5-9ef1-4e07-9c2f-4dd76a40ce1b-20240401112204-ui0cjqe.png" alt="image.png" style="zoom:50%;" />

我们只看 s1[i] 和 s2[j]，**如果 s1[i] == s2[j]，说明这个字符一定在 lcs 中**：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687052923377-0848479a-7b43-4ea6-bf6d-fc5219bd6282-20240401112204-5vusy80.png" alt="image.png" style="zoom:50%;" />

这样，就找到了一个 lcs 中的字符，根据 dp 函数的定义，我们可以完善一下代码：

```java
// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度
int dp(String s1, int i, String s2, int j) {
    if (s1.charAt(i) == s2.charAt(j)) {
        // s1[i] 和 s2[j] 必然在 lcs 中，
        // 加上 s1[i+1..] 和 s2[j+1..] 中的 lcs 长度，就是答案
        return 1 + dp(s1, i + 1, s2, j + 1)
    } else {
        // ...
    }
}
```

刚才说的 s1[i] == s2[j] 的情况，但如果 s1[i] != s2[j]，应该怎么办呢？

**s1[i] != s2[j] 意味着，s1[i] 和 s2[j] 中至少有一个字符不在 lcs 中**：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687052955090-59dd0e5e-c445-4f10-8381-4da364eae19b-20240401112204-92e530e.png" alt="image.png" style="zoom:50%;" />

如上图，总共可能有三种情况，我怎么知道具体是那种情况呢？

其实我们也不知道，那就把这三种情况的答案都算出来，取其中结果最大的那个呗，因为题目让我们算「最长」公共子序列的长度嘛。

这三种情况的答案怎么算？回想一下我们的 dp 函数定义，不就是专门为了计算它们而设计的嘛！

代码可以再进一步：

```java
// 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度
int dp(String s1, int i, String s2, int j) {
    if (s1.charAt(i) == s2.charAt(j)) {
        return 1 + dp(s1, i + 1, s2, j + 1)
    } else {
        // s1[i] 和 s2[j] 中至少有一个字符不在 lcs 中，
        // 穷举三种情况的结果，取其中的最大结果
        return max(        
            // 情况一、s1[i] 不在 lcs 中
            dp(s1, i + 1, s2, j),
            // 情况二、s2[j] 不在 lcs 中
            dp(s1, i, s2, j + 1),
            // 情况三、都不在 lcs 中
            dp(s1, i + 1, s2, j + 1)
        );
    }
}
```

这里就已经非常接近我们的最终答案了，**还有一个小的优化，情况三「s1[i] 和 s2[j] 都不在 lcs 中」其实可以直接忽略**。

因为我们在求最大值嘛，情况三在计算 s1[i+1..] 和 s2[j+1..] 的 lcs 长度，这个长度肯定是小于等于情况二 s1[i..] 和 s2[j+1..] 中的 lcs 长度的，因为 s1[i+1..] 比 s1[i..] 短嘛，那从这里面算出的 lcs 当然也不可能更长嘛。

同理，情况三的结果肯定也小于等于情况一。**说白了，情况三被情况一和情况二包含了**，所以我们可以直接忽略掉情况三，完整代码如下：

```java
class Solution {
    // 备忘录，消除重叠子问题
    int[][] memo;

    /* 主函数 */
    public int longestCommonSubsequence(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // 备忘录值为 -1 代表未曾计算
        memo = new int[m][n];
        for (int[] row : memo) 
            Arrays.fill(row, -1);
        // 计算 s1[0..] 和 s2[0..] 的 lcs 长度
        return dp(s1, 0, s2, 0);
    }

    // 定义：计算 s1[i..] 和 s2[j..] 的最长公共子序列长度
    int dp(String s1, int i, String s2, int j) {
        // base case
        if (i == s1.length() || j == s2.length()) {
            return 0;
        }
        // 如果之前计算过，则直接返回备忘录中的答案
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // 根据 s1[i] 和 s2[j] 的情况做选择
        if (s1.charAt(i) == s2.charAt(j)) {
            // s1[i] 和 s2[j] 必然在 lcs 中
            memo[i][j] = 1 + dp(s1, i + 1, s2, j + 1);
        } else {
            // s1[i] 和 s2[j] 至少有一个不在 lcs 中
            memo[i][j] = Math.max(
                dp(s1, i + 1, s2, j),
                dp(s1, i, s2, j + 1)
            );
        }
        return memo[i][j];
    }
}
```

以上思路完全就是按照我们之前的爆文 [动态规划套路框架](https://labuladong.gitee.io/article/fname.html?fname=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6) 来的，应该是很容易理解的。至于为什么要加 memo 备忘录，我们之前写过很多次，为了照顾新来的读者，这里再简单重复一下，首先抽象出我们核心 dp 函数的递归框架：

```java
int dp(int i, int j) {
    dp(i + 1, j + 1); // #1
    dp(i, j + 1);     // #2
    dp(i + 1, j);     // #3
}
```

你看，假设我想从 dp(i, j) 转移到 dp(i+1, j+1)，有不止一种方式，可以直接走 #1，也可以走 #2 -> #3，也可以走 #3 -> #2。

这就是重叠子问题，如果我们不用 memo 备忘录消除子问题，那么 dp(i+1, j+1) 就会被多次计算，这是没有必要的。

至此，最长公共子序列问题就完全解决了，用的是自顶向下带备忘录的动态规划思路，我们当然也可以使用自底向上的迭代的动态规划思路，和我们的递归思路一样，关键是如何定义 dp 数组，我这里也写一下自底向上的解法吧：

```java
class Solution {
    public int longestCommonSubsequence(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        int[][] dp = new int[m + 1][n + 1];
        // 定义：s1[0..i-1] 和 s2[0..j-1] 的 lcs 长度为 dp[i][j]
        // 目标：s1[0..m-1] 和 s2[0..n-1] 的 lcs 长度，即 dp[m][n]
        // base case: dp[0][..] = dp[..][0] = 0

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 现在 i 和 j 从 1 开始，所以要减一
                if (s1.charAt(i - 1) == s2.charAt(j - 1)) {
                    // s1[i-1] 和 s2[j-1] 必然在 lcs 中
                    dp[i][j] = 1 + dp[i - 1][j - 1];
                } else {
                    // s1[i-1] 和 s2[j-1] 至少有一个不在 lcs 中
                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);
                }
            }
        }

        return dp[m][n];
    }
}
```

自底向上的解法中 dp 数组定义的方式和我们的递归解法有一点差异，而且由于数组索引从 0 开始，有索引偏移，不过思路和我们的递归解法完全相同，如果你看懂了递归解法，这个解法应该不难理解。

另外，自底向上的解法可以通过我们前文讲过的 [动态规划空间压缩技巧](https://labuladong.gitee.io/article/fname.html?fname=%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E6%8A%80%E5%B7%A7) 来进行优化，把空间复杂度压缩为 O(N)，这里由于篇幅所限，就不展开了。

##### 583.「[两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)」

> 给定两个单词 `word1`​ 和 `word2`​ ，返回使得 `word1`​ 和  `word2`​  **相同**所需的**最小步数**。
>
> **每步** 可以删除任意一个字符串中的一个字符。
>
> **示例 1：**   
> 输入: word1 = "sea", word2 = "eat"  
> 输出: 2  
> 解释: 第一步将 "sea" 变为 "ea" ，第二步将 "eat "变为 "ea"

比如输入 s1 = "sea" s2 = "eat"，算法返回 2，第一步将 "sea" 变为 "ea" ，第二步将 "eat" 变为 "ea"。

题目让我们计算将两个字符串变得相同的最少删除次数，那我们可以思考一下，最后这两个字符串会被删成什么样子？

删除的结果不就是它俩的最长公共子序列嘛！

那么，要计算删除的次数，就可以通过最长公共子序列的长度推导出来：

```java
int minDistance(String s1, String s2) {
    int m = s1.length(), n = s2.length();
    // 复用前文计算 lcs 长度的函数
    int lcs = longestCommonSubsequence(s1, s2);
    return m - lcs + n - lcs;
}
```

这道题就解决了！

##### 712.「[两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/)」

> 给定两个字符串`s1`​ 和 `s2`​，返回 *使两个字符串相等所需删除字符的* ***ASCII*** *值的最小和* 。
>
> **示例 1:**   
> 输入: s1 = "sea", s2 = "eat"  
> 输出: 231  
> 解释: 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。 在 "eat" 中删除 "t" 并将 116 加入总和。 结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。

比如输入 s1 = "sea", s2 = "eat"，算法返回 231。

因为在 "sea" 中删除 "s"，在 "eat" 中删除 "t"，可使得两个字符串相等，且删掉字符的 ASCII 码之和最小，即 s(115) + t(116) = 231。

**这道题不能直接复用计算最长公共子序列的函数，但是可以依照之前的思路，稍微修改 base case 和状态转移部分即可直接写出解法代码**：

```java
class Solution {
    // 备忘录
    int memo[][];
    /* 主函数 */  
    public int minimumDeleteSum(String s1, String s2) {
        int m = s1.length(), n = s2.length();
        // 备忘录值为 -1 代表未曾计算
        memo = new int[m][n];
        for (int[] row : memo) 
            Arrays.fill(row, -1);

        return dp(s1, 0, s2, 0);
    }

    // 定义：将 s1[i..] 和 s2[j..] 删除成相同字符串，
    // 最小的 ASCII 码之和为 dp(s1, i, s2, j)。
    int dp(String s1, int i, String s2, int j) {
        int res = 0;
        // base case
        if (i == s1.length()) {
            // 如果 s1 到头了，那么 s2 剩下的都得删除
            for (; j < s2.length(); j++)
                res += s2.charAt(j);
            return res;
        }
        if (j == s2.length()) {
            // 如果 s2 到头了，那么 s1 剩下的都得删除
            for (; i < s1.length(); i++)
                res += s1.charAt(i);
            return res;
        }

        if (memo[i][j] != -1) {
            return memo[i][j];
        }

        if (s1.charAt(i) == s2.charAt(j)) {
            // s1[i] 和 s2[j] 都是在 lcs 中的，不用删除
            memo[i][j] = dp(s1, i + 1, s2, j + 1);
        } else {
            // s1[i] 和 s2[j] 至少有一个不在 lcs 中，删一个
            memo[i][j] = Math.min(
                s1.charAt(i) + dp(s1, i + 1, s2, j),
                s2.charAt(j) + dp(s1, i, s2, j + 1)
            );
        }
        return memo[i][j];
    }
}
```

base case 有一定区别，计算 lcs 长度时，如果一个字符串为空，那么 lcs 长度必然是 0；但是这道题如果一个字符串为空，另一个字符串必然要被全部删除，所以需要计算另一个字符串所有字符的 ASCII 码之和。

关于状态转移，当 s1[i] 和 s2[j] 相同时不需要删除，不同时需要删除，所以可以利用 dp 函数计算两种情况，得出最优的结果。其他的大同小异，就不具体展开了。

### 背包类型

#### 经典动态规划：0-1 背包问题

今天就来说一下背包问题吧，就讨论最常说的 0-1 背包问题。描述：

给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687154997794-ba0bd3ee-5adc-40a9-989b-64c73fa31b9a-20240401150024-z64ns5e.png)

举个简单的例子，输入如下：

```python
N = 3, W = 4
wt = [2, 1, 3]
val = [4, 2, 3]
```

算法返回 6，选择前两件物品装进背包，总重量 3 小于 W，可以获得最大价值 6。

题目就是这么简单，一个典型的动态规划问题。这个题目中的物品不可以分割，要么装进包里，要么不装，不能说切成两块装一半。这就是 0-1 背包这个名词的来历。

解决这个问题没有什么排序之类巧妙的方法，只能穷举所有可能，根据我们 [动态规划详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/) 中的套路，直接走流程就行了。

##### 动规标准套路

看来每篇动态规划文章都得重复一遍套路，历史文章中的动态规划问题都是按照下面的套路来的。

**第一步要明确两点，「状态」和「选择」** 。

先说状态，如何才能描述一个问题局面？只要给几个物品和一个背包的容量限制，就形成了一个背包问题呀。**所以状态有两个，就是「背包的容量」和「可选择的物品」** 。

再说选择，也很容易想到啊，对于每件物品，你能选择什么？**选择就是「装进背包」或者「不装进背包」嘛**。

明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：

```python
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```

**第二步要明确 dp 数组的定义**。

首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维 dp 数组。

dp[i][w] 的定义如下：对于前 i 个物品，当前背包的容量为 w，这种情况下可以装的最大价值是 dp[i][w]。

比如说，如果 dp[3][5] = 6，其含义为：对于给定的一系列物品中，若只对前 3 个物品进行选择，当背包容量为 5 时，最多可以装下的价值为 6。

> **Info**
>
> 为什么要这么定义？便于状态转移，或者说这就是套路，记下来就行了。建议看一下我们的动态规划系列文章，几种套路都被扒得清清楚楚了。

根据这个定义，我们想求的最终答案就是 dp[N][W]。base case 就是 dp[0][..] = dp[..][0] = 0，因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。

细化上面的框架：

```python
int[][] dp[N+1][W+1]
dp[0][..] = 0
dp[..][0] = 0

for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            把物品 i 装进背包,
            不把物品 i 装进背包
        )
return dp[N][W]
```

**第三步，根据「选择」，思考状态转移的逻辑**。

简单说就是，上面伪码中「把物品 i 装进背包」和「不把物品 i 装进背包」怎么用代码体现出来呢？

这就要结合对 dp 数组的定义，看看这两种选择会对状态产生什么影响：

先重申一下刚才我们的 dp 数组的定义：

dp[i][w] 表示：对于前 i 个物品（从 1 开始计数），当前背包的容量为 w 时，这种情况下可以装下的最大价值是 dp[i][w]。

**如果你没有把这第 i 个物品装入背包**，那么很显然，最大价值 dp[i][w] 应该等于 dp[i-1][w]，继承之前的结果。

**如果你把这第 i 个物品装入了背包**，那么 dp[i][w] 应该等于 val[i-1] + dp[i-1][w - wt[i-1]]。

首先，由于数组索引从 0 开始，而我们定义中的 i 是从 1 开始计数的，所以 val[i-1] 和 wt[i-1] 表示第 i 个物品的价值和重量。

你如果选择将第 i 个物品装进背包，那么第 i 个物品的价值 val[i-1] 肯定就到手了，接下来你就要在剩余容量 w - wt[i-1] 的限制下，在前 i - 1 个物品中挑选，求最大价值，即 dp[i-1][w - wt[i-1]]。

综上就是两种选择，我们都已经分析完毕，也就是写出来了状态转移方程，可以进一步细化代码：

```python
for i in [1..N]:
    for w in [1..W]:
        dp[i][w] = max(
            dp[i-1][w],
            dp[i-1][w - wt[i-1]] + val[i-1]
        )
return dp[N][W]
```

**最后一步，把伪码翻译成代码，处理一些边界情况**。

我用 Java 写的代码，把上面的思路完全翻译了一遍，并且处理了 w - wt[i-1] 可能小于 0 导致数组索引越界的问题：

```java
int knapsack(int W, int N, int[] wt, int[] val) {
    assert N == wt.length;
    // base case 已初始化
    int[][] dp = new int[N + 1][W + 1];
    for (int i = 1; i <= N; i++) {
        for (int w = 1; w <= W; w++) {
            if (w - wt[i - 1] < 0) {
                // 这种情况下只能选择不装入背包
                dp[i][w] = dp[i - 1][w];
            } else {
                // 装入或者不装入背包，择优
                dp[i][w] = Math.max(
                    dp[i - 1][w - wt[i-1]] + val[i-1], 
                    dp[i - 1][w]
                );
            }
        }
    }
  
    return dp[N][W];
}
```

> **Note**
>
> 其实函数签名中的物品数量 N 就是 wt 数组的长度，所以实际上这个参数 N 是多此一举的。但为了体现原汁原味的 0-1 背包问题，我就带上这个参数 N 了，你自己写的话可以省略。

至此，背包问题就解决了，相比而言，我觉得这是比较简单的动态规划问题，因为状态转移的推导比较自然，基本上你明确了 dp 数组的定义，就可以理所当然地确定状态转移了。

##### 练习题

###### 416.「[分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)」

> 给你一个 **只包含正整数** 的 **非空** 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
>
> **示例 1：**   
> 输入：nums = [1,5,11,5]  
> 输出：true  
> 解释：数组可以分割成 [1, 5, 5] 和 [11] 。

###### 问题分析

比如说输入 nums = [1,5,11,5]，算法返回 true，因为 nums 可以分割成 [1,5,5] 和 [11] 这两个子集。

如果说输入 nums = [1,3,2,5]，算法返回 false，因为 nums 无论如何都不能分割成两个和相等的子集。

对于这个问题，看起来和背包没有任何关系，为什么说它是背包问题呢？

首先回忆一下背包问题大致的描述是什么：

给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？

那么对于这个问题，我们可以先对集合求和，得出 sum，把问题转化为背包问题：

**给一个可装载重量为 sum / 2 的背包和 N 个物品，每个物品的重量为 nums[i]。现在让你装物品，是否存在一种装法，能够恰好将背包装满**？

你看，这就是背包问题的模型，甚至比我们之前的经典背包问题还要简单一些，**下面我们就直接转换成背包问题**，开始套前文讲过的背包问题框架即可。

###### 解法分析

**第一步要明确两点，「状态」和「选择」** 。

这个前文 [经典动态规划：背包问题](https://labuladong.github.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--28f3c/) 已经详细解释过了，状态就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」。

**第二步要明确 dp 数组的定义**。

按照背包问题的套路，可以给出如下定义：

**dp[i][j] = x 表示，对于前 i 个物品（i 从 1 开始计数），当前背包的容量为 j 时，若 x 为 true，则说明可以恰好将背包装满，若 x 为 false，则说明不能恰好将背包装满**。

比如说，如果 dp[4][9] = true，其含义为：对于容量为 9 的背包，若只是在前 4 个物品中进行选择，可以有一种方法把背包恰好装满。

或者说对于本题，含义是对于给定的集合中，若只在前 4 个数字中进行选择，存在一个子集的和可以恰好凑出 9。

根据这个定义，我们想求的最终答案就是 dp[N][sum/2]，base case 就是 dp[..][0] = true 和 dp[0][..] = false，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。

**第三步，根据「选择」，思考状态转移的逻辑**。

回想刚才的 dp 数组含义，可以根据「选择」对 dp[i][j] 得到以下状态转移：

如果不把 nums[i] 算入子集，**或者说你不把这第 i 个物品装入背包**，那么是否能够恰好装满背包，取决于上一个状态 dp[i-1][j]，继承之前的结果。

如果把 nums[i] 算入子集，**或者说你把这第 i 个物品装入了背包**，那么是否能够恰好装满背包，取决于状态 dp[i-1][j-nums[i-1]]。

> **Info**
>
> 由于 dp 数组定义中的 i 是从 1 开始计数，而数组索引是从 0 开始的，所以第 i 个物品的重量应该是 nums[i-1]，这一点不要搞混。

dp[i - 1][j-nums[i-1]] 也很好理解：你如果装了第 i 个物品，就要看背包的剩余重量 j - nums[i-1] 限制下是否能够被恰好装满。

换句话说，如果 j - nums[i-1] 的重量可以被恰好装满，那么只要把第 i 个物品装进去，也可恰好装满 j 的重量；否则的话，重量 j 肯定是装不满的。

**最后一步，把伪码翻译成代码，处理一些边界情况**。

以下是我的 Java 代码，完全翻译了之前的思路，并处理了一些边界情况：

```java
boolean canPartition(int[] nums) {
    int sum = 0;
    for (int num : nums) sum += num;
    // 和为奇数时，不可能划分成两个和相等的集合
    if (sum % 2 != 0) return false;
    int n = nums.length;
    sum = sum / 2;
    boolean[][] dp = new boolean[n + 1][sum + 1];
    // base case
    for (int i = 0; i <= n; i++)
        dp[i][0] = true;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= sum; j++) {
            if (j - nums[i - 1] < 0) {
                // 背包容量不足，不能装入第 i 个物品
                dp[i][j] = dp[i - 1][j];
            } else {
                // 装入或不装入背包
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];
            }
        }
    }
    return dp[n][sum];
}
```

###### 进一步优化

再进一步，是否可以优化这个代码呢？**注意到 dp[i][j] 都是通过上一行 dp[i-1][..] 转移过来的**，之前的数据都不会再使用了。

所以，我们可以参照前文 [对动态规划进行降维打击](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dui-dong-t-8e7bf/)，将二维 dp 数组压缩为一维，节约空间复杂度：

```java
boolean canPartition(int[] nums) {
    int sum = 0;
    for (int num : nums) sum += num;
    // 和为奇数时，不可能划分成两个和相等的集合
    if (sum % 2 != 0) return false;
    int n = nums.length;
    sum = sum / 2;
    boolean[] dp = new boolean[sum + 1];
  
    // base case
    dp[0] = true;

    for (int i = 0; i < n; i++) {
        for (int j = sum; j >= 0; j--) {
            if (j - nums[i] >= 0) {
                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
    }
    return dp[sum];
}
```

其实这段代码和之前的解法思路完全相同，只在一行 dp 数组上操作，i 每进行一轮迭代，dp[j] 其实就相当于 dp[i-1][j]，所以只需要一维数组就够用了。

**唯一需要注意的是 j 应该从后往前反向遍历，因为每个物品（或者说数字）只能用一次，以免之前的结果影响其他的结果**。

至此，子集切割的问题就完全解决了，时间复杂度 O(n\*sum)，空间复杂度 O(sum)。

#### 经典动态规划：完全背包问题

##### 练习题

###### 第 518 题「[零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)」

> 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
>
> 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
>
> 假设每一种面额的硬币有无限个。
>
> 题目数据保证结果符合 32 位带符号整数。
>
> **示例 1：**   
> 输入：amount = 5, coins = [1, 2, 5]  
> 输出：4
>
> 解释：  
> 有四种方式可以凑成总金额：  
> 5=5  
> 5=2+2+1  
> 5=2+1+1+1  
> 5=1+1+1+1+1

**我们可以把这个问题转化为背包问题的描述形式**：

有一个背包，最大容量为 amount，有一系列物品 coins，每个物品的重量为 coins[i]，**每个物品的数量无限**。请问有多少种方法，能够把背包恰好装满？

这个问题和我们前面讲过的两个背包问题，有一个最大的区别就是，每个物品的数量是无限的，这也就是传说中的「**完全背包问题**」，没啥高大上的，无非就是状态转移方程有一点变化而已。

下面就以背包问题的描述形式，继续按照流程来分析。

###### 解题思路

**第一步要明确两点，「状态」和「选择」** 。

状态有两个，就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」嘛，背包问题的套路都是这样。

明白了状态和选择，动态规划问题基本上就解决了，只要往这个框架套就完事儿了：

```java
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 计算(选择1，选择2...)
```

**第二步要明确 dp 数组的定义**。

首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维 dp 数组。

dp[i][j] 的定义如下：

若只使用前 i 个物品（可以重复使用），当背包容量为 j 时，有 dp[i][j] 种方法可以装满背包。

换句话说，翻译回我们题目的意思就是：

**若只使用 coins 中的前 i 个（i 从 1 开始计数）硬币的面值，若想凑出金额 j，有 dp[i][j] 种凑法**。

经过以上的定义，可以得到：

base case 为 dp[0][..] = 0, dp[..][0] = 1。i = 0 代表不使用任何硬币面值，这种情况下显然无法凑出任何金额；j = 0 代表需要凑出的目标金额为 0，那么什么都不做就是唯一的一种凑法。

我们最终想得到的答案就是 dp[N][amount]，其中 N 为 coins 数组的大小。

大致的伪码思路如下：

```java
int dp[N+1][amount+1]
dp[0][..] = 0
dp[..][0] = 1

for i in [1..N]:
    for j in [1..amount]:
        把物品 i 装进背包,
        不把物品 i 装进背包
return dp[N][amount]
```

**第三步，根据「选择」，思考状态转移的逻辑**。

注意，我们这个问题的特殊点在于物品的数量是无限的，所以这里和之前写的 [0-1 背包问题](https://labuladong.github.io/algo/di-er-zhan-a01c6/bei-bao-le-34bd4/jing-dian--28f3c/) 文章有所不同。

**如果你不把这第 i 个物品装入背包**，也就是说你不使用 coins[i-1] 这个面值的硬币，那么凑出面额 j 的方法数 dp[i][j] 应该等于 dp[i-1][j]，继承之前的结果。

**如果你把这第 i 个物品装入了背包**，也就是说你使用 coins[i-1] 这个面值的硬币，那么 dp[i][j] 应该等于 dp[i][j-coins[i-1]]。

> **Note**
>
> 由于定义中的 i 是从 1 开始计数的，所以 coins 的索引是 i-1 时表示第 i 个硬币的面值。

dp[i][j-coins[i-1]] 也不难理解，如果你决定使用这个面值的硬币，那么就应该关注如何凑出金额 j - coins[i-1]。

比如说，你想用面值为 2 的硬币凑出金额 5，那么如果你知道了凑出金额 3 的方法，再加上一枚面额为 2 的硬币，不就可以凑出 5 了嘛。

**综上就是两种选择，而我们想求的 dp[i][j] 是「共有多少种凑法」，所以 dp[i][j] 的值应该是以上两种选择的结果之和**：

```java
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= amount; j++) {
        if (j - coins[i-1] >= 0)
            dp[i][j] = dp[i - 1][j] 
                     + dp[i][j-coins[i-1]];
return dp[N][W]
```

> **Note**
>
> 有的读者在这里可能会有疑问，不是说可以重复使用硬币吗？那么如果我确定「使用第 i 个面值的硬币」，我怎么确定这个面值的硬币被使用了多少枚？简单的一个 dp[i][j-coins[i-1]] 可以包含重复使用第 i 个硬币的情况吗？

对于这个问题，建议你再仔回头细阅读一下我们对 dp 数组的定义，然后把这个定义代入 dp[i][j-coins[i-1]] 看看：

若只使用前 i 个物品（可以重复使用），当背包容量为 j-coins[i-1] 时，有 dp[i][j-coins[i-1]] 种方法可以装满背包。

看到了吗，dp[i][j-coins[i-1]] 也是允许你使用第 i 个硬币的，所以说已经包含了重复使用硬币的情况，你一百个放心。

**最后一步，把伪码翻译成代码，处理一些边界情况**。

我用 Java 写的代码，把上面的思路完全翻译了一遍，并且处理了一些边界问题：

```java
int change(int amount, int[] coins) {
    int n = coins.length;
    int[][] dp = int[n + 1][amount + 1];
    // base case
    for (int i = 0; i <= n; i++) 
        dp[i][0] = 1;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= amount; j++)
            if (j - coins[i-1] >= 0)
                dp[i][j] = dp[i - 1][j] 
                         + dp[i][j - coins[i-1]];
            else 
                dp[i][j] = dp[i - 1][j];
    }
    return dp[n][amount];
}
```

而且，我们通过观察可以发现，dp 数组的转移只和 dp[i][..] 和 dp[i-1][..] 有关，所以可以使用前文讲的 [动态规划空间压缩技巧](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dui-dong-t-8e7bf/)，进一步降低算法的空间复杂度：

```java
int change(int amount, int[] coins) {
    int n = coins.length;
    int[] dp = new int[amount + 1];
    dp[0] = 1; // base case
    for (int i = 0; i < n; i++)
        for (int j = 1; j <= amount; j++)
            if (j - coins[i] >= 0)
                dp[j] = dp[j] + dp[j-coins[i]];
  
    return dp[amount];
}
```

这个解法和之前的思路完全相同，将二维 dp 数组压缩为一维，时间复杂度 O(N*amount)，空间复杂度 O(amount)。

至此，这道零钱兑换问题也通过背包问题的框架解决了。

### 用动规玩游戏

#### 动态规划之最小路径和

###### 64.「[最小路径和](https://leetcode.cn/problems/minimum-path-sum/)」

> 给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
>
> **说明：** 每次只能向下或者向右移动一步。
>
> **示例 1：**
>
> ![1687245118131-ccee4144-25e5-4b0e-9eb9-be2cba4fd037](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687245118131-ccee4144-25e5-4b0e-9eb9-be2cba4fd037-20240401154420-yujvpqo.jpeg)​
>
> 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]  
> 输出：7  
> 解释：因为路径 1→3→1→1→1 的总和最小。

**一般来说，让你在二维矩阵中求最优化问题（最大值或者最小值），肯定需要递归 + 备忘录，也就是动态规划技巧**。

就拿题目举的例子来说，我给图中的几个格子编个号方便描述：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687245148712-ce7be77d-8e72-49b7-bb31-af431537e142-20240401154420-x34k5vc.png)

我们想计算从起点 D 到达 B 的最小路径和，那你说怎么才能到达 B 呢？

题目说了只能向右或者向下走，所以只有从 A 或者 C 走到 B。

那么算法怎么知道从 A 走到 B 才能使路径和最小，而不是从 C 走到 B 呢？

难道是因为位置 A 的元素大小是 1，位置 C 的元素是 2，1 小于 2，所以一定要从 A 走到 B 才能使路径和最小吗？

其实不是的，**真正的原因是，从 D 走到 A 的最小路径和是 6，而从 D 走到 C 的最小路径和是 8，6 小于 8，所以一定要从 A 走到 B 才能使路径和最小**。

换句话说，我们把「从 D 走到 B 的最小路径和」这个问题转化成了「从 D 走到 A 的最小路径和」和 「从 D 走到 C 的最小路径和」这两个问题。

理解了上面的分析，这不就是状态转移方程吗？所以这个问题肯定会用到动态规划技巧来解决。

比如我们定义如下一个 dp 函数：

```java
int dp(int[][] grid, int i, int j);
```

这个 dp 函数的定义如下：

**从左上角位置 (0, 0) 走到位置 (i, j) 的最小路径和为 dp(grid, i, j)** 。

根据这个定义，我们想求的最小路径和就可以通过调用这个 dp 函数计算出来：

```java
int minPathSum(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    // 计算从左上角走到右下角的最小路径和
    return dp(grid, m - 1, n - 1);
}
```

再根据刚才的分析，很容易发现，dp(grid, i, j) 的值取决于 dp(grid, i - 1, j) 和 dp(grid, i, j - 1) 返回的值。

我们可以直接写代码了：

```java
int dp(int[][] grid, int i, int j) {
    // base case
    if (i == 0 && j == 0) {
        return grid[0][0];
    }
    // 如果索引出界，返回一个很大的值，
    // 保证在取 min 的时候不会被取到
    if (i < 0 || j < 0) {
        return Integer.MAX_VALUE;
    }

    // 左边和上面的最小路径和加上 grid[i][j]
    // 就是到达 (i, j) 的最小路径和
    return Math.min(
            dp(grid, i - 1, j), 
            dp(grid, i, j - 1)
        ) + grid[i][j];
}
```

上述代码逻辑已经完整了，接下来就分析一下，这个递归算法是否存在重叠子问题？是否需要用备忘录优化一下执行效率？

**前文多次说过判断重叠子问题的技巧，首先抽象出上述代码的递归框架**：

```java
int dp(int i, int j) {
    dp(i - 1, j); // #1
    dp(i, j - 1); // #2
}
```

如果我想从 dp(i, j) 递归到 dp(i-1, j-1)，有几种不同的递归调用路径？

可以是 dp(i, j) -> #1 -> #2 或者 dp(i, j) -> #2 -> #1，不止一种，说明 dp(i-1, j-1) 会被多次计算，所以一定存在重叠子问题。

那么我们可以使用备忘录技巧进行优化：

```java
class Solution {
    // 备忘录
    int[][] memo;

    int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        // 构造备忘录，初始值全部设为 -1
        memo = new int[m][n];
        for (int[] row : memo)
            Arrays.fill(row, -1);
    
        return dp(grid, m - 1, n - 1);
    }

    int dp(int[][] grid, int i, int j) {
        // base case
        if (i == 0 && j == 0) {
            return grid[0][0];
        }
        if (i < 0 || j < 0) {
            return Integer.MAX_VALUE;
        }
        // 避免重复计算
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // 将计算结果记入备忘录
        memo[i][j] = Math.min(
            dp(grid, i - 1, j),
            dp(grid, i, j - 1)
        ) + grid[i][j];

        return memo[i][j];
    }
}
```

至此，本题就算是解决了，时间复杂度和空间复杂度都是 O(MN)，标准的自顶向下动态规划解法。

有的读者可能问，能不能用自底向上的迭代解法来做这道题呢？完全可以的。

首先，类似刚才的 dp 函数，我们需要一个二维 dp 数组，定义如下：

**从左上角位置 (0, 0) 走到位置 (i, j) 的最小路径和为 dp[i][j]** 。

状态转移方程当然不会变的，dp[i][j] 依然取决于 dp[i-1][j] 和 dp[i][j-1]，直接看代码吧：

```java
int minPathSum(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    int[][] dp = new int[m][n];

    /** base case **/
    dp[0][0] = grid[0][0];

    for (int i = 1; i < m; i++)
        dp[i][0] = dp[i - 1][0] + grid[i][0];
  
    for (int j = 1; j < n; j++)
        dp[0][j] = dp[0][j - 1] + grid[0][j];    
    /*******************/
  
    // 状态转移
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = Math.min(
                dp[i - 1][j],
                dp[i][j - 1]
            ) + grid[i][j];
        }
    }

    return dp[m - 1][n - 1];
}
```

**这个解法的 base case 看起来和递归解法略有不同，但实际上是一样的**。

因为状态转移为下面这段代码：

```java
dp[i][j] = Math.min(
    dp[i - 1][j],
    dp[i][j - 1]
) + grid[i][j];
```

那如果 i 或者 j 等于 0 的时候，就会出现索引越界的错误。

所以我们需要提前计算出 dp[0][..] 和 dp[..][0]，然后让 i 和 j 的值从 1 开始迭代。

dp[0][..] 和 dp[..][0] 的值怎么算呢？其实很简单，第一行和第一列的路径和只有下面这一种情况嘛：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687245237770-ab97a0fe-aee8-4852-b272-72752791c81a-20240401154421-1jiil79.png)

那么按照 dp 数组的定义，dp[i][0] = sum(grid[0..i][0]), dp[0][j] = sum(grid[0][0..j])，也就是如下代码：

```java
/** base case **/
dp[0][0] = grid[0][0];

for (int i = 1; i < m; i++)
    dp[i][0] = dp[i - 1][0] + grid[i][0];

for (int j = 1; j < n; j++)
    dp[0][j] = dp[0][j - 1] + grid[0][j];    
/*******************/
```

到这里，自底向上的迭代解法也搞定了，那有的读者可能又要问了，能不能优化一下算法的空间复杂度呢？

前文 [动态规划的降维打击：空间压缩](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/dui-dong-t-8e7bf/) 说过降低 dp 数组的技巧，这里也是适用的，不过略微复杂些，本文由于篇幅所限就不写了，有兴趣的读者可以自己尝试一下。

#### 动态规划之地下城游戏

##### 174.「[地下城游戏](https://leetcode.cn/problems/dungeon-game/)」

> 恶魔们抓住了公主并将她关在了地下城 `dungeon`​ 的 **右下角** 。地下城是由 `m x n`​ 个房间组成的二维网格。我们英勇的骑士最初被安置在 **左上角** 的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
>
> 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
>
> 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为*负整数*，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 *0*），要么包含增加骑士健康点数的魔法球（若房间里的值为*正整数*，则表示骑士将增加健康点数）。
>
> 为了尽快解救公主，骑士决定每次只 **向右** 或 **向下** 移动一步。
>
> 返回确保骑士能够拯救到公主所需的最低初始健康点数。
>
> **注意：** 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。
>
> **示例 1：**
>
> ![1687246554183-dd42f955-80ae-4e77-bdf3-46bbd4019c7c](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687246554183-dd42f955-80ae-4e77-bdf3-46bbd4019c7c-20240401155702-ote76fn.jpeg)
>
> 输入：  
> dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]  
> 输出：  
> 7
>
> 解释：  
> 如果骑士遵循最佳路径：右 -> 右 -> 下 -> 下 ，则骑士的初始健康点数至少为 7 。

比如题目给我们举的例子，输入如下一个二维数组 grid，用 K 表示骑士，用 P 表示公主：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687246603225-34f42f2e-0d1b-4d92-9bfe-d0fe808fdf8a-20240401155702-4e8n27w.png)

算法应该返回 7，也就是说骑士的初始生命值**至少**为 7 时才能成功救出公主，行进路线如图中的箭头所示。

上篇文章 [最小路径和](https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/dong-tai-g-52f34/) 写过类似的问题，问你从左上角到右下角的最小路径和是多少。

我们做算法题一定要尝试举一反三，感觉今天这道题和最小路径和有点关系对吧？

想要最小化骑士的初始生命值，是不是意味着要最大化骑士行进路线上的血瓶？是不是相当于求「最大路径和」？是不是可以直接套用计算「最小路径和」的思路？

但是稍加思考，发现这个推论并不成立，吃到最多的血瓶，并不一定就能获得最小的初始生命值。

比如如下这种情况，如果想要吃到最多的血瓶获得「最大路径和」，应该按照下图箭头所示的路径，初始生命值需要 11：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687246603514-ef4ef1c0-0830-4740-bbb4-444e2f923565-20240401155703-fcx5x66.png)

但也很容易看到，正确的答案应该是下图箭头所示的路径，初始生命值只需要 1：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687246603557-413bf770-82b0-40fa-bba1-353ef9cba223-20240401155703-s7gp9nb.png)

**所以，关键不在于吃最多的血瓶，而是在于如何损失最少的生命值**。

这类求最值的问题，肯定要借助动态规划技巧，要合理设计 dp 数组/函数的定义。类比前文 [最小路径和问题](https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/dong-tai-g-52f34/)，dp 函数签名肯定长这样：

```java
int dp(int[][] grid, int i, int j);
```

但是这道题对 dp 函数的定义比较有意思，按照常理，这个 dp 函数的定义应该是：

**从左上角（grid[0][0]）走到 grid[i][j] 至少需要 dp(grid, i, j) 的生命值**。

这样定义的话，base case 就是 i, j 都等于 0 的时候，我们可以这样写代码：

```java
int calculateMinimumHP(int[][] grid) {
    int m = grid.length;
    int n = grid[0].length;
    // 我们想计算左上角到右下角所需的最小生命值
    return dp(grid, m - 1, n - 1);
}

int dp(int[][] grid, int i, int j) {
    // base case
    if (i == 0 && j == 0) {
        // 保证骑士落地不死就行了
        return gird[i][j] > 0 ? 1 : -grid[i][j] + 1;
    }
    ...
}
```

接下来我们需要找状态转移了，还记得如何找状态转移方程吗？我们这样定义 dp 函数能否正确进行状态转移呢？

我们希望 dp(i, j) 能够通过 dp(i-1, j) 和 dp(i, j-1) 推导出来，这样就能不断逼近 base case，也就能够正确进行状态转移。

具体来说，「到达 A 的最小生命值」应该能够由「到达 B 的最小生命值」和「到达 C 的最小生命值」推导出来：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687246654056-38dd90b7-154f-43f2-ab50-413e535fa10a-20240401155703-yerhvs6.png)

**但问题是，能推出来么？实际上是不能的**。

因为按照 dp 函数的定义，你只知道「能够从左上角到达 B 的最小生命值」，但并不知道「到达 B 时的生命值」。

「到达 B 时的生命值」是进行状态转移的必要参考，我给你举个例子你就明白了，假设下图这种情况：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687246654051-e6a1176f-3da3-4995-a48e-fa3787225542-20240401155703-04xchf7.png)

你说这种情况下，骑士救公主的最优路线是什么？

显然是按照图中蓝色的线走到 B，最后走到 A 对吧，这样初始血量只需要 1 就可以；如果走黄色箭头这条路，先走到 C 然后走到 A，初始血量至少需要 6。

为什么会这样呢？骑士走到 B 和 C 的最少初始血量都是 1，为什么最后是从 B 走到 A，而不是从 C 走到 A 呢？

因为骑士走到 B 的时候生命值为 11，而走到 C 的时候生命值依然是 1。

如果骑士执意要通过 C 走到 A，那么初始血量必须加到 6 点才行；而如果通过 B 走到 A，初始血量为 1 就够了，因为路上吃到血瓶了，生命值足够抗 A 上面怪物的伤害。

这下应该说的很清楚了，再回顾我们对 dp 函数的定义，上图的情况，算法只知道 dp(1, 2) = dp(2, 1) = 1，都是一样的，怎么做出正确的决策，计算出 dp(2, 2) 呢？

**所以说，我们之前对 dp 数组的定义是错误的，信息量不足，算法无法做出正确的状态转移**。

正确的做法需要反向思考，依然是如下的 dp 函数：

```java
int dp(int[][] grid, int i, int j);
```

但是我们要修改 dp 函数的定义：

**从 grid[i][j] 到达终点（右下角）所需的最少生命值是 dp(grid, i, j)** 。

那么可以这样写代码：

```java
int calculateMinimumHP(int[][] grid) {
    // 我们想计算左上角到右下角所需的最小生命值
    return dp(grid, 0, 0);
}

int dp(int[][] grid, int i, int j) {
    int m = grid.length;
    int n = grid[0].length;
    // base case
    if (i == m - 1 && j == n - 1) {
        return grid[i][j] >= 0 ? 1 : -grid[i][j] + 1;
    }
    ...
}
```

根据新的 dp 函数定义和 base case，我们想求 dp(0, 0)，那就应该试图通过 dp(i, j+1) 和 dp(i+1, j) 推导出 dp(i, j)，这样才能不断逼近 base case，正确进行状态转移。

具体来说，「从 A 到达右下角的最少生命值」应该由「从 B 到达右下角的最少生命值」和「从 C 到达右下角的最少生命值」推导出来：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687246692805-baa5c9a3-87b4-4134-9d05-446be5e1daee-20240401155703-qvmq7a4.png)

能不能推导出来呢？这次是可以的，假设 dp(0, 1) = 5, dp(1, 0) = 4，那么可以肯定要从 A 走向 C，因为 4 小于 5 嘛。  
那么怎么推出 dp(0, 0) 是多少呢？

假设 A 的值为 1，既然知道下一步要往 C 走，且 dp(1, 0) = 4 意味着走到 grid[1][0] 的时候至少要有 4 点生命值，那么就可以确定骑士出现在 A 点时需要 4 - 1 = 3 点初始生命值，对吧。

那如果 A 的值为 10，落地就能捡到一个大血瓶，超出了后续需求，4 - 10 = -6 意味着骑士的初始生命值为负数，这显然不可以，骑士的生命值小于 1 就挂了，所以这种情况下骑士的初始生命值应该是 1。

综上，状态转移方程已经推出来了：

```java
int res = min(
    dp(i + 1, j),
    dp(i, j + 1)
) - grid[i][j];

dp(i, j) = res <= 0 ? 1 : res;
```

根据这个核心逻辑，加一个备忘录消除重叠子问题，就可以直接写出最终的代码了：

```java
class Solution {
    /* 主函数 */
    public int calculateMinimumHP(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        // 备忘录中都初始化为 -1
        memo = new int[m][n];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }

        return dp(grid, 0, 0);
    }

    // 备忘录，消除重叠子问题
    int[][] memo;

    /* 定义：从 (i, j) 到达右下角，需要的初始血量至少是多少 */
    int dp(int[][] grid, int i, int j) {
        int m = grid.length;
        int n = grid[0].length;
        // base case
        if (i == m - 1 && j == n - 1) {
            return grid[i][j] >= 0 ? 1 : -grid[i][j] + 1;
        }
        if (i == m || j == n) {
            return Integer.MAX_VALUE;
        }
        // 避免重复计算
        if (memo[i][j] != -1) {
            return memo[i][j];
        }
        // 状态转移逻辑
        int res = Math.min(
                dp(grid, i, j + 1),
                dp(grid, i + 1, j)
            ) - grid[i][j];
        // 骑士的生命值至少为 1
        memo[i][j] = res <= 0 ? 1 : res;

        return memo[i][j];
    }
}
```

这就是自顶向下带备忘录的动态规划解法，参考前文 [动态规划套路详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/) 很容易就可以改写成 dp 数组的迭代解法，这里就不写了，读者可以尝试自己写一写。

这道题的核心是定义 dp 函数，找到正确的状态转移方程，从而计算出正确的答案。

#### 动态规划之自由之路

##### 514.「[自由之路](https://leetcode.cn/problems/freedom-trail/)」

> 电子游戏“辐射4”中，任务  **“通向自由”**  要求玩家到达名为 “**Freedom Trail Ring”**  的金属表盘，并使用表盘拼写特定关键词才能开门。
>
> 给定一个字符串 ring ，表示刻在外环上的编码；给定另一个字符串 key ，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的**最少**步数。
>
> 最初，**ring** 的第一个字符与 12:00 方向对齐。您需要顺时针或逆时针旋转 ring 以使 **key** 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 **key** **中的所有字符。旋转 ring拼出 key 字符 key[i]**  的阶段中：
>
> 1. 您可以将 **ring** 顺时针或逆时针旋转 **一个位置** ，计为1步。旋转的最终目的是将字符串 **ring** 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 **key[i] 。**
> 2. 如果字符 **key[i]**  已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 **1 步**。按完之后，您可以开始拼写 **key** 的下一个字符（下一阶段）, 直至完成所有拼写。
>
> **示例 1：**   
> 输入: ring = "godding", key = "gd"  
> 输出: 4
>
> 解释:  对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。
> 对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring "godding" 2步使它变成 "ddinggo"。
> 当然, 我们还需要1步进行拼写。
> 因此最终的输出是 4。

题目给你输入一个字符串 ring 代表圆盘上的字符（指针位置在 12 点钟方向，初始指向 ring[0]），再输入一个字符串 key 代表你需要拨动圆盘输入的字符串，你的算法需要返回输入这个 key 至少进行多少次操作（拨动一格圆盘和按下圆盘中间的按钮都算是一次操作）。

比如题目举的例子，输入 ring = "godding", key = "gd"，对应的圆盘如下（大写只是为了清晰，实际上输入的字符串都是小写字母）：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687328255170-5cd2cb41-dedd-4f0f-a6b5-3d7b45249e7c-20240401171953-p48v9b1.png)

我们需要输入 key = "gd"，算法返回 4。

因为现在指针指的字母就是字母 "g"，所以可以直接按下中间的按钮，然后再将圆盘逆时针拨动两格，让指针指向字母 "d"，然后再按一次中间的按钮。

上述过程，按了两次按钮，拨了两格转盘，总共操作了 4 次，是最少的操作次数，所以算法应该返回 4。

我们这里可以首先给题目做一个等价，转动圆盘是不是就等于拨动指针？

**原题可以转化为：圆盘固定，我们可以拨动指针；现在需要我们拨动指针并按下按钮，以最少的操作次数输入 key 对应的字符串**。

那么，这个问题如何使用动态规划的技巧解决呢？或者说，这道题的「状态」和「选择」是什么呢？

**「状态」就是「当前需要输入的字符」和「当前圆盘指针的位置」** 。

再具体点，「状态」就是 i 和 j 两个变量。我们可以用 i 表示当前圆盘上指针指向的字符（也就是 ring[i]）；用 j 表示需要输入的字符（也就是 key[j])。

这样我们可以写这样一个 dp 函数：

```java
int dp(String ring, int i, String key, int j);
```

这个 dp 函数的定义如下：

**当圆盘指针指向 ring[i] 时，输入字符串 key[j..] 至少需要 dp(ring, i, key, j) 次操作**。

根据这个定义，题目其实就是想计算 dp(ring, 0, key, 0) 的值，而且我们可以把 dp 函数的 base case 写出来：

```java
int dp(String ring, int i, String key, int j) {
    // base case，完成输入
    if (j == key.length()) return 0;
    // ...
}
```

接下来，思考一下如何根据状态做选择，如何进行状态转移？

**「选择」就是「如何拨动指针得到待输入的字符」** 。

再具体点就是，对于现在想输入的字符 key[j]，我们可以如何拨动圆盘，得到这个字符？

比如说输入 ring = "gdonidg"，现在圆盘的状态如下图：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687328305139-ef0c6544-e40d-42f9-b7c4-37faf2dff1bc-20240401171953-ysph2gu.png)

假设我想输入的字符 key[j] = "d"，圆盘中有两个字母 "d"，而且我可以顺时针也可以逆时针拨动指针，所以总共有四种「选择」输入字符 "d"，我们需要选择操作次数最少的那个拨法。

大致的代码逻辑如下：

```java
int dp(String ring, int i, String key, int j) {
    // base case 完成输入
    if (j == key.length()) return 0;
  
    // 做选择
    int res = Integer.MAX_VALUE;
    for (int k : [字符 key[j] 在 ring 中的所有索引]) {
        res = min(
            把 i 顺时针转到 k 的代价,
            把 i 逆时针转到 k 的代价
        );
    }
  
    return res;
}
```

至于到底是顺时针还是逆时针，其实非常好判断，怎么近就怎么来；但是对于圆盘中的两个字符 "d"，还能是怎么近怎么来吗？  
不能，因为这和 key[i] 之后需要输入的字符有关，还是上面的例子：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687328337489-6f9a6da5-44f0-4203-b080-4e578956012e-20240401171954-kupshgy.png)

如果输入的是 key = "di"，那么即便右边的 "d" 离得近，也应该去左边的 "d"，因为左边的 "d" 旁边就是 "i"，「整体」的操作数最少。  
那么，应该如何判断呢？其实就是穷举，递归调用 dp 函数，把两种选择的「整体」代价算出来，然后再做比较就行了。

讲到这就差不多了，直接看代码吧：

```java
class Solution {
    // 字符 -> 索引列表
    HashMap<Character, List<Integer>> charToIndex = new HashMap<>();
    // 备忘录
    int[][] memo;

    /* 主函数 */
    public int findRotateSteps(String ring, String key) {
        int m = ring.length();
        int n = key.length();
        // 备忘录全部初始化为 0
        memo = new int[m][n];
        // 记录圆环上字符到索引的映射
        for (int i = 0; i < ring.length(); i++) {
            char c = ring.charAt(i);
            if (!charToIndex.containsKey(c)) {
                charToIndex.put(c, new LinkedList<>());
            }
            charToIndex.get(c).add(i);
        }
        // 圆盘指针最初指向 12 点钟方向，
        // 从第一个字符开始输入 key
        return dp(ring, 0, key, 0);
    }

    // 计算圆盘指针在 ring[i]，输入 key[j..] 的最少操作数
    int dp(String ring, int i, String key, int j) {
        // base case 完成输入
        if (j == key.length()) return 0;
        // 查找备忘录，避免重叠子问题
        if (memo[i][j] != 0) return memo[i][j];
    
        int n = ring.length();
        // 做选择
        int res = Integer.MAX_VALUE;
        // ring 上可能有多个字符 key[j]
        for (int k : charToIndex.get(key.charAt(j))) {
            // 拨动指针的次数
            int delta = Math.abs(k - i);
            // 选择顺时针还是逆时针
            delta = Math.min(delta, n - delta);
            // 将指针拨到 ring[k]，继续输入 key[j+1..]
            int subProblem = dp(ring, k, key, j + 1);
            // 选择「整体」操作次数最少的
            // 加一是因为按动按钮也是一次操作
            res = Math.min(res, 1 + delta + subProblem);
        }
        // 将结果存入备忘录
        memo[i][j] = res;
        return res;
    }
}
```

#### 动态规划之加权最短路径

##### 787.「[K 站中转内最便宜的航班](https://leetcode.cn/problems/cheapest-flights-within-k-stops/)」

> 有 n 个城市通过一些航班连接。给你一个数组 flights ，其中 flights[i] = [fromi, toi, pricei] ，表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。
>
> 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线，使得从 src 到 dst 的 **价格最便宜** ，并返回该价格。 如果不存在这样的路线，则输出 -1。
>
> **示例 1：**   
> 输入:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1  
> 输出: 200  
> 解释:  城市航班图如下
>
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687328497331-f4367f56-16af-42d9-94c4-17c33895b1c6-20240401174708-uwuvn40.png)
>
> 从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。

现在有 n 个城市，分别用 0, 1..., n - 1 这些序号表示，城市之间的航线用三元组 [from, to, price] 来表示，比如说三元组 [0,1,100] 就表示，从城市 0 到城市 1 之间的机票价格是 100 元。

题目会给你输入若干参数：正整数 n 代表城市个数，数组 flights 装着若干三元组代表城市间的航线及价格，城市编号 src 代表你所在的城市，城市编号 dst 代表你要去的目标城市，整数 K 代表你最多经过的中转站个数。

请你的算法计算，在 K 次中转之内，从 src 到 dst 所需的最小花费是多少钱，如果无法到达，则返回 -1。

比方说题目给的例子：

n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, K = 1

航线就是如下这张图所示，有向边代表航向的方向，边上的数字代表航线的机票价格：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687328532845-3651d3d8-aecb-4586-80ab-bf9caaf7f011-20240401174708-8z7ijme.png)

出发点是 0，到达点是 2，允许的最大中转次数 K 为 1，所以最小的开销就是图中红色的两条边，从 0 出发，经过中转城市 1 到达目标城市 2，所以算法的返回值应该是 200。

注意这个中转次数的上限 K 是比较棘手的，如果上述题目将 K 改为 0，也就是不允许中转，那么我们的算法只能返回 500 了，也就是直接从 0 飞到 2。

**很明显，这题就是个加权有向图中求最短路径的问题**。

说白了，就是给你一幅加权有向图，让你求 src 到 dst 权重最小的一条路径，同时要满足，**这条路径最多不能超过 K + 1 条边**（经过 K 个节点相当于经过 K + 1 条边)。

我们来分析下求最短路径相关的算法。

###### BFS 算法思路

我们前文 [BFS 算法框架详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/bfs-suan-f-463fd/) 中说到，求最短路径，肯定可以用 BFS 算法来解决。

因为 BFS 算法相当于从起始点开始，一步一步向外扩散，那当然是离起点越近的节点越先被遍历到，如果 BFS 遍历的过程中遇到终点，那么走的肯定是最短路径。

不过呢，我们在 [BFS 算法框架详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/bfs-suan-f-463fd/) 用的是普通的队列 Queue 来遍历多叉树，而对于加权图的最短路径来说，普通的队列不管用了，得用优先级队列 PriorityQueue。

为什么呢？也好理解，在多叉树（或者扩展到无权图）的遍历中，与其说边没有权重，不如说每条边的权重都是 1，起点与终点之间的路径权重就是它们之间「边」的条数。

这样，按照 BFS 算法一步步向四周扩散的逻辑，先遍历到的节点和起点之间的「边」更少，累计的权重当然少。

换言之，先进入 Queue 的节点就是离起点近的，路径权重小的节点。

但对于加权图，路径中边的条数和路径的权重并不是正相关的关系了，有的路径可能边的条数很少，但每条边的权重都很大，那显然这条路径权重也会很大，很难成为最短路径。

比如题目给的这个例子：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687328587064-f5f84d08-9439-424c-92c6-339a8e01deb6-20240401174708-7s7isov.png)

你是可以一步从 0 走到 2，但路径权重不见得是最小的。

所以，对于加权图的场景，我们需要优先级队列「自动排序」的特性，将路径权重较小的节点排在队列前面，以此为基础施展 BFS 算法，也就变成了 [Dijkstra 算法](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/dijkstra-s-6d0b2/)。

```java
public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
    List<int[]>[] graph = new LinkedList[n];
    for (int i = 0; i < n; i++) {
        graph[i] = new LinkedList<>();
    }
    for (int[] edge : flights) {
        int from = edge[0];
        int to = edge[1];
        int price = edge[2];
        graph[from].add(new int[]{to, price});
    }

    // 启动 dijkstra 算法
    // 计算以 src 为起点在 k 次中转到达 dst 的最短路径
    K++;
    return dijkstra(graph, src, K, dst);
}

class State {
    // 图节点的 id
    int id;
    // 从 src 节点到当前节点的花费
    int costFromSrc;
    // 从 src 节点到当前节点经过的节点个数
    int nodeNumFromSrc;

    State(int id, int costFromSrc, int nodeNumFromSrc) {
        this.id = id;
        this.costFromSrc = costFromSrc;
        this.nodeNumFromSrc = nodeNumFromSrc;
    }
}

// 输入一个起点 src，计算从 src 到其他节点的最短距离
int dijkstra(List<int[]>[] graph, int src, int k, int dst) {
    // 定义：从起点 src 到达节点 i 的最短路径权重为 distTo[i]
    int[] distTo = new int[graph.length];
    // 定义：从起点 src 到达节点 i 的最小权重路径至少要经过 nodeNumTo[i] 个节点
    int[] nodeNumTo = new int[graph.length];
    Arrays.fill(distTo, Integer.MAX_VALUE);
    Arrays.fill(nodeNumTo, Integer.MAX_VALUE);
    // base case
    distTo[src] = 0;
    nodeNumTo[src] = 0;

    // 优先级队列，costFromSrc 较小的排在前面
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
        return a.costFromSrc - b.costFromSrc;
    });
    // 从起点 src 开始进行 BFS
    pq.offer(new State(src, 0, 0));

    while (!pq.isEmpty()) {
        State curState = pq.poll();
        int curNodeID = curState.id;
        int costFromSrc = curState.costFromSrc;
        int curNodeNumFromSrc = curState.nodeNumFromSrc;
    
        if (curNodeID == dst) {
            // 找到最短路径
            return costFromSrc;
        }
        if (curNodeNumFromSrc == k) {
            // 中转次数耗尽
            continue;
        }

        // 将 curNode 的相邻节点装入队列
        for (int[] neighbor : graph[curNodeID]) {
            int nextNodeID = neighbor[0];
            int costToNextNode = costFromSrc + neighbor[1];
            // 中转次数消耗 1
            int nextNodeNumFromSrc = curNodeNumFromSrc + 1;

            // 更新 dp table
            if (distTo[nextNodeID] > costToNextNode) {
                distTo[nextNodeID] = costToNextNode;
                nodeNumTo[nextNodeID] = nextNodeNumFromSrc;
            }
            // 剪枝，如果中转次数更多，花费还更大，那必然不会是最短路径
            if (costToNextNode > distTo[nextNodeID]
                && nextNodeNumFromSrc > nodeNumTo[nextNodeID]) {
                continue;
            }
        
            pq.offer(new State(nextNodeID, costToNextNode, nextNodeNumFromSrc));
        }
    }
    return -1;
}
```

错误答案：

```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        List<int[]>[] graph = new LinkedList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : flights) {
            int from = edge[0];
            int to = edge[1];
            int price = edge[2];
            graph[from].add(new int[]{to, price});
        }
        // 三元组[src, cost, stops]，其中stops表示中转站的数量
        Queue<int[]> q = new PriorityQueue<>((o1, o2) -> {
            return o1[1] - o2[1];
        });

        int[] disTo = new int[n]; // 从起点 src 到达节点 i 的最短路径权重为 distTo[i]
        Arrays.fill(disTo, Integer.MAX_VALUE);
        disTo[src] = 0;

        q.offer(new int[]{src, 0, 0}); // 初始时，从src出发，花费为0，中转站数量为0

        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int curId = cur[0], disToCur = cur[1], curStops = cur[2];

            if (curId == dst) {
                return disToCur;
            }

            if (curStops > k) continue; // 如果中转站数量已经超过k，不再考虑

            for (int[] neighbor : graph[curId]) {
                int nextId = neighbor[0];
                int disToNext = disToCur + neighbor[1];
                int nextStops = curStops + 1;
                if (disToNext < disTo[nextId]) { // 如果找到更便宜的路线，则更新并加入队列
                    disTo[nextId] = disToNext;
                    q.offer(new int[]{nextId, disTo[nextId], nextStops});
                }
            }
        }
        return disTo[dst] == Integer.MAX_VALUE ? -1 : disTo[dst];
    }
}
```

![image-20240905164453-vxubdkm](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240905164453-vxubdkm.png)​

0 -> 1 虽然是5，但是没有中转，而0 ->3 -> 1虽然是2+2=4，但是中转了一次。

所以 0 -> 1 -> 4 -> 2 才是最优解（7），而不是0 -> 3 -> 1 -> 2（9）

那如果去解决这个问题呢？

**需要一个数组记录 src -&gt; i 中转次数，花费金额少或者中转次数少的时候，放入 queue 中**

```java
class Solution {
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        List<int[]>[] graph = new LinkedList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : flights) {
            int from = edge[0];
            int to = edge[1];
            int price = edge[2];
            graph[from].add(new int[]{to, price});
        }
        // 三元组[src, cost, stops]，其中stops表示中转站的数量
        Queue<int[]> q = new PriorityQueue<>((o1, o2) -> {
            return o1[1] - o2[1];
        });

        int[] disTo = new int[n]; // 从起点 src 到达节点 i 的最短路径权重为 distTo[i]
        int[] stopTo = new int[n]; // 对应中转次数
        Arrays.fill(disTo, Integer.MAX_VALUE);
        Arrays.fill(stopTo, Integer.MAX_VALUE);

        disTo[src] = 0;
        stopTo[src] = 0;

        q.offer(new int[]{src, 0, 0}); // 初始时，从src出发，花费为0，中转站数量为0

        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int curId = cur[0], disToCur = cur[1], curStops = cur[2];

            if (curId == dst) {
                return disToCur;
            }

            if (curStops > k) continue; // 如果中转站数量已经超过k，不再考虑

            for (int[] neighbor : graph[curId]) {
                int nextId = neighbor[0];
                int disToNext = disToCur + neighbor[1];
                int nextStops = curStops + 1;
                if (disToNext < disTo[nextId]) { // 如果找到更便宜的路线
                    disTo[nextId] = disToNext;
                    stopTo[nextId] = nextStops;
                }
              
                // 剪枝，如果中转次数更多，花费还更大，那必然不会是最短路径
                if (disToNext > disTo[nextId] && nextStops > stopTo[nextId]) { 
                    continue;
                }
                q.offer(new int[]{nextId, disToNext, nextStops});
            }
        }
        return disTo[dst] == Integer.MAX_VALUE ? -1 : disTo[dst];
    }
}
```

###### 动态规划思路

我们前文 [动态规划核心套路详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/) 中说过，求最值的问题，很多都可能使用动态规划来求解。

加权最短路径问题，再加个 K 的限制也无妨，不也是个求最值的问题嘛，动态规划统统拿下。

我们先不管 K 的限制，但就「加权最短路径」这个问题来看看，它怎么就是个动态规划问题了呢？

比方说，现在我想计算 src 到 dst 的最短路径：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687328641638-aac9c496-73d0-4b54-a4eb-ae19a718cc5d-20240401174708-f2ogc8d.png)

最小权重是多少？我不知道。

但我可以把问题进行分解：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687328644403-3cfddcac-6111-4991-b129-7e990f961bea-20240401174708-g6xrtcw.png)

s1, s2 是指向 dst 的相邻节点，它们之间的权重我是知道的，分别是 w1, w2。

只要我知道了从 src 到 s1, s2 的最短路径，我不就知道 src 到 dst 的最短路径了吗！

```java
minPath(src, dst) = min(
    minPath(src, s1) + w1, 
    minPath(src, s2) + w2
)
```

这其实就是递归关系了，就是这么简单。

**不过别忘了，题目对我们的最短路径还有个「路径上不能超过 K + 1 条边」的限制**。

那么我们不妨定义这样一个 dp 函数：

```java
int dp(int s, int k);
```

函数的定义如下：

**从起点 src 出发，k 步之内（一步就是一条边）到达节点 s 的最小路径权重为 dp(s, k)** 。

那么，dp 函数的 base case 就显而易见了：

```java
// 定义：从 src 出发，k 步之内到达 s 的最小成本
int dp(int s, int k) {
    // 从 src 到 src，一步都不用走
    if (s == src) {
        return 0;
    }
    // 如果步数用尽，就无解了
    if (k == 0) {
        return -1;
    }

    // ...
}
```

题目想求的最小机票开销就可以用 dp(dst, K+1) 来表示：

```java
int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
    // 将中转站个数转化成边的条数
    K++;
    //...
    return dp(dst, K);
```

添加了一个 K 条边的限制，状态转移方程怎么写呢？其实和刚才是一样的：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687328741430-25f7a3a7-ca2b-4734-a392-b3eca2d24780-20240401174708-y01q0q0.png)

K 步之内从 src 到 dst 的最小路径权重是多少？我不知道。

但我可以把问题分解：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687328747117-fa9f524f-e4d1-47f0-9eb3-9a07f11b26c2-20240401174709-6ur7uig.png)

s1, s2 是指向 dst 的相邻节点，我只要知道 K - 1 步之内从 src 到达 s1, s2，那我就可以在 K 步之内从 src 到达 dst。

也就是如下关系式：

```java
dp(dst, k) = min(
    dp(s1, k - 1) + w1, 
    dp(s2, k - 1) + w2
)
```

这就是新的状态转移方程，如果你能看懂这个算式，就已经可以解决这道题了。

根据上述思路，我怎么知道 s1, s2 是指向 dst 的相邻节点，他们之间的权重是 w1, w2？

我希望给一个节点，就能知道有谁指向这个节点，还知道它们之间的权重，对吧。

专业点说，得用一个数据结构记录每个节点的「入度」indegree：

```java
// 哈希表记录每个点的入度
// to -> [from, price]
HashMap<Integer, List<int[]>> indegree;
int src, dst;

public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
    // 将中转站个数转化成边的条数
    K++;
    this.src = src;
    this.dst = dst;
  
    indegree = new HashMap<>();
    for (int[] f : flights) {
        int from = f[0];
        int to = f[1];
        int price = f[2];
        // 记录谁指向该节点，以及之间的权重
        indegree.putIfAbsent(to, new LinkedList<>());
        indegree.get(to).add(new int[] {from, price});
    }
  
    return dp(dst, K);
}
```

有了 indegree 存储入度，那么就可以具体实现 dp 函数了：

```java
// 定义：从 src 出发，k 步之内到达 s 的最短路径权重
int dp(int s, int k) {
    // base case
    if (s == src) {
        return 0;
    }
    if (k == 0) {
        return -1;
    }
    // 初始化为最大值，方便等会取最小值
    int res = Integer.MAX_VALUE;
    if (indegree.containsKey(s)) {
        // 当 s 有入度节点时，分解为子问题
        for (int[] v : indegree.get(s)) {
            int from = v[0];
            int price = v[1];
            // 从 src 到达相邻的入度节点所需的最短路径权重
            int subProblem = dp(from, k - 1);
            // 跳过无解的情况
            if (subProblem != -1) {
                res = Math.min(res, subProblem + price);
            }
        }
    }
    // 如果还是初始值，说明此节点不可达
    return res == Integer.MAX_VALUE ? -1 : res;
}
```

有之前的铺垫，这段解法逻辑应该是很清晰的。当然，对于动态规划问题，肯定要消除重叠子问题。

为什么有重叠子问题？很简单，如果某个节点同时指向两个其他节点，那么这两个节点就有相同的一个入度节点，就会产生重复的递归计算。

怎么消除重叠子问题？找问题的「状态」。

状态是什么？在问题分解（状态转移）的过程中变化的，就是状态。

**谁在变化？显然就是 dp 函数的参数 s 和 k，每次递归调用，目标点 s 和步数约束 k 在变化**。

所以，本题的状态有两个，应该算是二维动态规划，我们可以用一个 memo 二维数组或者哈希表作为备忘录，减少重复计算。

我们选用二维数组做备忘录吧，注意 K 是从 1 开始算的，所以备忘录初始大小要再加一：

```java
int src, dst;
HashMap<Integer, List<int[]>> indegree;
// 备忘录
int[][] memo;

public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) {
    K++;
    this.src = src;
    this.dst = dst;
    // 初始化备忘录，全部填一个特殊值
    memo = new int[n][K + 1];
    for (int[] row : memo) {
        Arrays.fill(row, -888);
    }
  
    // 其他不变
    // ...
  
    return dp(dst, K);
}

// 定义：从 src 出发，k 步之内到达 s 的最小成本
int dp(int s, int k) {
    // base case
    if (s == src) {
        return 0;
    }
    if (k == 0) {
        return -1;
    }
    // 查备忘录，防止冗余计算
    if (memo[s][k] != -888) {
        return memo[s][k];
    }
  
    // 状态转移不变
    // ...
  
    // 存入备忘录
    memo[s][k] = res == Integer.MAX_VALUE ? -1 : res;
    return memo[s][k];
}
```

备忘录初始值为啥初始为 -888？前文 [base case 和备忘录的初始值怎么定](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/basecase-h-de925/) 说过，随便初始化一个无意义的值就行。

至此，这道题就通过自顶向下的递归方式解决了。当然，完全可以按照这个解法衍生出自底向上迭代的动态规划解法，但由于篇幅所限，我就不写了，反正本质上都是一样的。

其实，大家如果把我们号之前的所有动态规划文章都看一遍，就会发现我们一直在套用 [动态规划核心套路](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/)，其实真没什么困难的。

#### **动态规划之正则表达**

##### 10.「[正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)」

> 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
>
> - '.' 匹配任意单个字符
> - '*' 匹配零个或多个前面的那一个元素
>
> 所谓匹配，是要涵盖 **整个 **字符串 s的，而不是部分字符串。
>
> **示例 1：**   
> 输入：s = "aa", p = "a"  
> 输出：false
>
> 解释："a" 无法匹配 "aa" 整个字符串。

对于我们将要实现的这个正则表达式，难点在那里呢？

点号通配符其实很好实现，s 中的任何字符，只要遇到 . 通配符，无脑匹配就完事了。主要是这个星号通配符不好实现，一旦遇到 * 通配符，前面的那个字符可以选择重复一次，可以重复多次，也可以一次都不出现，这该怎么办？

对于这个问题，答案很简单，对于所有可能出现的情况，全部穷举一遍，只要有一种情况可以完成匹配，就认为 p 可以匹配 s。那么一旦涉及两个字符串的穷举，我们就应该条件反射地想到动态规划的技巧了。

我们先脑补一下，s 和 p 相互匹配的过程大致是，两个指针 i, j 分别在 s 和 p 上移动，如果最后两个指针都能移动到字符串的末尾，那么久匹配成功，反之则匹配失败。

**如果不考虑 * 通配符，面对两个待匹配字符 s[i] 和 p[j]，我们唯一能做的就是看他俩是否匹配**：

```java
bool isMatch(string s, string p) {
    int i = 0, j = 0;
    while (i < s.size() && j < p.size()) {
        // 「.」通配符就是万金油
        if (s[i] == p[j] || p[j] == '.') {
            // 匹配，接着匹配 s[i+1..] 和 p[j+1..]
            i++; j++;
        } else {
            // 不匹配
            return false;
        }
    }
    return i == j;
}
```

那么考虑一下，如果加入 * 通配符，局面就会稍微复杂一些，不过只要分情况来分析，也不难理解。

**当 p[j + 1] 为 * 通配符时，我们分情况讨论下**：

1、如果 s[i] == p[j]，那么有两种情况：

1.1 p[j] 有可能会匹配多个字符，比如 s = "aaa", p = "a *&quot;，那么 p[0] 会通过 * 匹配 3 个字符 &quot;a&quot;。1.2 p[i] 也有可能匹配 0 个字符，比如 s = &quot;aa&quot;, p = &quot;a*aa"，由于后面的字符可以匹配 s，所以 p[0] 只能匹配 0 次。

2、如果 s[i] != p[j]，只有一种情况：

p[j] 只能匹配 0 次，然后看下一个字符是否能和 s[i] 匹配。比如说 s = "aa", p = "b*aa"，此时 p[0] 只能匹配 0 次。

综上，可以把之前的代码针对 * 通配符进行一下改造：

```java
if (s[i] == p[j] || p[j] == '.') {
    // 匹配
    if (j < p.size() - 1 && p[j + 1] == '*') {
        // 有 * 通配符，可以匹配 0 次或多次
    } else {
        // 无 * 通配符，老老实实匹配 1 次
        i++; j++;
    }
} else {
    // 不匹配
    if (j < p.size() - 1 && p[j + 1] == '*') {
        // 有 * 通配符，只能匹配 0 次
    } else {
        // 无 * 通配符，匹配无法进行下去了
        return false;
    }
}
```

整体的思路已经很清晰了，但现在的问题是，遇到 * 通配符时，到底应该匹配 0 次还是匹配多次？多次是几次？

你看，这就是一个做「选择」的问题，要把所有可能的选择都穷举一遍才能得出结果。动态规划算法的核心就是「状态」和「选择」， **「状态」无非就是 i 和 j 两个指针的位置，「选择」就是 p[j] 选择匹配几个字符**。

根据「状态」，我们可以定义一个 dp 函数：

```java
bool dp(string& s, int i, string& p, int j);
```

dp 函数的定义如下：

**若 dp(s, i, p, j) = true，则表示 s[i..] 可以匹配 p[j..]；若 dp(s, i, p, j) = false，则表示 s[i..] 无法匹配 p[j..]** 。

根据这个定义，我们想要的答案就是 i = 0, j = 0 时 dp 函数的结果，所以可以这样使用这个 dp 函数：

```java
bool isMatch(string s, string p) {
    // 指针 i，j 从索引 0 开始移动
    return dp(s, 0, p, 0);
```

可以根据之前的代码写出 dp 函数的主要逻辑：

```java
bool dp(string& s, int i, string& p, int j) {
    if (s[i] == p[j] || p[j] == '.') {
        // 匹配
        if (j < p.size() - 1 && p[j + 1] == '*') {
            // 1.1 通配符匹配 0 次或多次
            return dp(s, i, p, j + 2)
                || dp(s, i + 1, p, j);
        } else {
            // 1.2 常规匹配 1 次
            return dp(s, i + 1, p, j + 1);
        }
    } else {
        // 不匹配
        if (j < p.size() - 1 && p[j + 1] == '*') {
            // 2.1 通配符匹配 0 次
            return dp(s, i, p, j + 2);
        } else {
            // 2.2 无法继续匹配
            return false;
        }
    }
}
```

**根据 dp 函数的定义**，这几种情况都很好解释：

1.1 通配符匹配 0 次或多次

将 j 加 2，i 不变，含义就是直接跳过 p[j] 和之后的通配符，即通配符匹配 0 次。

即便 s[i] == p[j]，依然可能出现这种情况，如下图：

![1687335517763-60de3b6e-0ede-4d33-9583-bc4603e382de](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687335517763-60de3b6e-0ede-4d33-9583-bc4603e382de-20240401175647-s2twaq1.jpeg)

将 i 加 1，j 不变，含义就是 p[j] 匹配了 s[i]，但 p[j] 还可以继续匹配，即通配符匹配多次的情况：

![1687335517862-f01d5cf9-a862-4c6c-9ca0-8d16809494a9](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687335517862-f01d5cf9-a862-4c6c-9ca0-8d16809494a9-20240401175647-r36z6di.jpeg)

两种情况只要有一种可以完成匹配即可，所以对上面两种情况求或运算。

1.2 常规匹配 1 次

由于这个条件分支是无 * 的常规匹配，那么如果 s[i] == p[j]，就是 i 和 j 分别加一：

![1687335517791-24bb6085-54f6-4e52-bd8a-23c504e24390](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687335517791-24bb6085-54f6-4e52-bd8a-23c504e24390-20240401175647-uzivgps.jpeg)

2.1 通配符匹配 0 次

类似情况 1.1，将 j 加 2，i 不变：

![1687335517849-4d38a785-3a77-4f0b-8f76-5a384779e412](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687335517849-4d38a785-3a77-4f0b-8f76-5a384779e412-20240401175647-yiqwiur.jpeg)

2.2 如果没有 * 通配符，也无法匹配，那只能说明匹配失败了：

![1687335517809-6f6257cc-50d9-443a-b2a8-133c1143de50](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687335517809-6f6257cc-50d9-443a-b2a8-133c1143de50-20240401175647-j0t8mcq.jpeg)

看图理解应该很容易了，现在可以思考一下 dp 函数的 base case：

**一个 base case 是 j == p.size() 时**，按照 dp 函数的定义，这意味着模式串 p 已经被匹配完了，那么应该看看文本串 s 匹配到哪里了，如果 s 也恰好被匹配完，则说明匹配成功：

```java
if (j == p.size()) {
    return i == s.size();
}
```

**另一个 base case 是 i == s.size() 时**，按照 dp 函数的定义，这种情况意味着文本串 s 已经全部被匹配了，那么是不是只要简单地检查一下 p 是否也匹配完就行了呢？

```java
if (i == s.size()) {
    // 这样行吗？
    return j == p.size();
}
```

**这是不正确的，此时并不能根据 j 是否等于 p.size() 来判断是否完成匹配，只要 p[j..] 能够匹配空串，就可以算完成匹配**。比如说 s = "a", p = "ab*c*"，当 i 走到 s 末尾的时候，j 并没有走到 p 的末尾，但是 p 依然可以匹配 s。

所以我们可以写出如下代码：

```java
int m = s.size(), n = p.size();

if (i == s.size()) {
    // 如果能匹配空串，一定是字符和 * 成对儿出现
    if ((n - j) % 2 == 1) {
        return false;
    }
    // 检查是否为 x*y*z* 这种形式
    for (; j + 1 < p.size(); j += 2) {
        if (p[j + 1] != '*') {
            return false;
        }
    }
    return true;
}
```

根据以上思路，就可以写出完整的代码：

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        Boolean[][] memo = new Boolean[m][n];
        return dp(s, 0, p, 0, memo);
    }

    private boolean dp(String s, int i, String p, int j, Boolean[][] memo) {
        int m = s.length(), n = p.length();
        if (j == n) return i == m;
        if (i == m) {
            if ((n - j) % 2 == 1) {
                return false;
            }
            for (; j + 1 < n; j += 2) { // 检查是否为 x*y*z* 这种形式
                if (p.charAt(j + 1) != '*') return false;
            }
            return true;
        }
        if (memo[i][j] != null) return memo[i][j];
        boolean res;
        if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') { // s[i]匹配p[j]
            if (j + 1 < n && p.charAt(j + 1) == '*') { // p[j+1] 为 *
                res = dp(s, i, p, j + 2, memo) // 匹配0次 或者 多次
                || dp(s, i + 1, p, j, memo);
            } else {
                res = dp(s, i + 1, p, j + 1, memo); // 匹配一次
            }
        } else {
            if (j + 1 < n && p.charAt(j + 1) == '*') { // p[j+1] 为 *
                res = dp(s, i, p, j + 2, memo); // 只能匹配0次
            } else {
                res = false;
            }
        }
        memo[i][j] = res;
        return res;
    }
}
```

代码中用了一个哈希表 memo 消除重叠子问题。如何一眼看出重叠子问题？可以参考前文 [动态规划系列答疑](https://labuladong.gitee.io/article/fname.html?fname=%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84) 中所讲的技巧，抽出正则表达算法的递归框架：

```java
bool dp(string& s, int i, string& p, int j) {
    dp(s, i, p, j + 2);     // 1
    dp(s, i + 1, p, j);     // 2
    dp(s, i + 1, p, j + 1); // 3
    dp(s, i, p, j + 2);     // 4
}
```

如果让你从 dp(s, i, p, j) 得到 dp(s, i+2, p, j+2)，至少有两条路径：1 -> 2 -> 2 和 3 -> 3。这就说明 (i+2, j+2) 这个状态的计算必然存在重复，也就说明存在重叠子问题，我们需要用备忘录消除重叠子问题，提高效率。

动态规划的时间复杂度为「状态的总数」*「每次递归花费的时间」，本题中状态的总数当然就是 i 和 j 的组合，也就是 M * N（M 为 s 的长度，N 为 p 的长度）；递归函数 dp 中没有循环（base case 中的不考虑，因为 base case 的触发次数有限），所以一次递归花费的时间为常数。二者相乘，总的时间复杂度为 O(MN)。

空间复杂度很简单，就是备忘录 memo 的大小，即 O(MN)。

#### 动态规划之鸡蛋掉落

##### 887.「[鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop/)」

> 给你 k 枚相同的鸡蛋，并可以使用一栋从第 1 层到第 n 层共有 n 层楼的建筑。
>
> 已知存在楼层 f ，满足 0 <= f <= n ，任何从 高于 f 的楼层落下的鸡蛋都会碎，从 f 楼层或比它低的楼层落下的鸡蛋都不会破。
>
> 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 x 扔下（满足 1 <= x <= n）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 重复使用 这枚鸡蛋。
>
> 请你计算并返回要确定 f 确切的值 的 最小操作次数 是多少？
>
> 示例 1：
>
> 输入：k = 1, n = 2  
> 输出：2  
> 输出2
>
> 解释：  
> 鸡蛋从 1 楼掉落。如果它碎了，肯定能得出 f = 0 。  
> 否则，鸡蛋从 2 楼掉落。如果它碎了，肯定能得出 f = 1 。  
> 如果它没碎，那么肯定能得出 f = 2 。  
> 因此，在最坏的情况下我们需要移动2次以确定f是多少。

你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层 0 <= F <= N，在这层楼将鸡蛋扔下去，鸡蛋**恰好没摔碎**（高于 F 的楼层都会碎，低于 F 的楼层都不会碎，如果鸡蛋没有碎，可以捡回来继续扔）。现在问你，**最坏**情况下，你**至少**要扔几次鸡蛋，才能**确定**这个楼层 F 呢？

也就是让你找摔不碎鸡蛋的最高楼层 F，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。

比方说**现在先不管鸡蛋个数的限制**，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？

最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……

以这种策略，**最坏**情况应该就是我试到第 7 层鸡蛋也没碎（F = 7），也就是我扔了 7 次鸡蛋。

先在你应该理解什么叫做「最坏情况」下了，**鸡蛋破碎一定发生在搜索区间穷尽时**，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。

现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。

最好的策略是使用二分查找思路，我先去第 (1 + 7) / 2 = 4 层扔一下：

如果碎了说明 F 小于 4，我就去第 (1 + 3) / 2 = 2 层试……

如果没碎说明 F 大于等于 4，我就去第 (5 + 7) / 2 = 6 层试……

以这种策略，**最坏**情况应该是试到第 7 层鸡蛋还没碎（F = 7），或者鸡蛋一直碎到第 1 层（F = 0）。然而无论那种最坏情况，只需要试 log7 向上取整等于 3 次，比刚才尝试 7 次要少，这就是所谓的**至少**要扔几次。

实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，**现在给你了鸡蛋个数的限制 K，直接使用二分思路就不行了**。

比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，你可以把鸡蛋捡起来再去更高的楼层尝试；但如果碎了，你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层 F 了。

其实这种情况下只能用线性扫描的方法，从下网上一层层尝试扔鸡蛋，那么最坏情况下需要扔 7 次，算法返回结果应该是 7。

有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？

很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。

如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次。最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。

说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？

你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层 0 <= F <= N，在这层楼将鸡蛋扔下去，鸡蛋**恰好没摔碎**（高于 F 的楼层都会碎，低于 F 的楼层都不会碎，如果鸡蛋没有碎，可以捡回来继续扔）。现在问你，**最坏**情况下，你**至少**要扔几次鸡蛋，才能**确定**这个楼层 F 呢？

也就是让你找摔不碎鸡蛋的最高楼层 F，但什么叫「最坏情况」下「至少」要扔几次呢？我们分别举个例子就明白了。

比方说**现在先不管鸡蛋个数的限制**，有 7 层楼，你怎么去找鸡蛋恰好摔碎的那层楼？

最原始的方式就是线性扫描：我先在 1 楼扔一下，没碎，我再去 2 楼扔一下，没碎，我再去 3 楼……

以这种策略，**最坏**情况应该就是我试到第 7 层鸡蛋也没碎（F = 7），也就是我扔了 7 次鸡蛋。

先在你应该理解什么叫做「最坏情况」下了，**鸡蛋破碎一定发生在搜索区间穷尽时**，不会说你在第 1 层摔一下鸡蛋就碎了，这是你运气好，不是最坏情况。

现在再来理解一下什么叫「至少」要扔几次。依然不考虑鸡蛋个数限制，同样是 7 层楼，我们可以优化策略。

最好的策略是使用二分查找思路，我先去第 (1 + 7) / 2 = 4 层扔一下：

如果碎了说明 F 小于 4，我就去第 (1 + 3) / 2 = 2 层试……

如果没碎说明 F 大于等于 4，我就去第 (5 + 7) / 2 = 6 层试……

以这种策略，**最坏**情况应该是试到第 7 层鸡蛋还没碎（F = 7），或者鸡蛋一直碎到第 1 层（F = 0）。然而无论那种最坏情况，只需要试 log7 向上取整等于 3 次，比刚才尝试 7 次要少，这就是所谓的**至少**要扔几次。

实际上，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数，但问题是，**现在给你了鸡蛋个数的限制 K，直接使用二分思路就不行了**。

比如说只给你 1 个鸡蛋，7 层楼，你敢用二分吗？你直接去第 4 层扔一下，如果鸡蛋没碎还好，你可以把鸡蛋捡起来再去更高的楼层尝试；但如果碎了，你就没有鸡蛋继续测试了，无法确定鸡蛋恰好摔不碎的楼层 F 了。

其实这种情况下只能用线性扫描的方法，从下网上一层层尝试扔鸡蛋，那么最坏情况下需要扔 7 次，算法返回结果应该是 7。

有的读者也许会有这种想法：二分查找排除楼层的速度无疑是最快的，那干脆先用二分查找，等到只剩 1 个鸡蛋的时候再执行线性扫描，这样得到的结果是不是就是最少的扔鸡蛋次数呢？

很遗憾，并不是，比如说把楼层变高一些，100 层，给你 2 个鸡蛋，你在 50 层扔一下，碎了，那就只能线性扫描 1～49 层了，最坏情况下要扔 50 次。

如果不要「二分」，变成「五分」「十分」都会大幅减少最坏情况下的尝试次数。比方说第一个鸡蛋每隔十层楼扔，在哪里碎了第二个鸡蛋一个个线性扫描，总共不会超过 20 次。最优解其实是 14 次。最优策略非常多，而且并没有什么规律可言。

说了这么多废话，就是确保大家理解了题目的意思，而且认识到这个题目确实复杂，就连我们手算都不容易，如何用算法解决呢？

---

对动态规划问题，直接套我们以前多次强调的框架即可：这个问题有什么「状态」，有什么「选择」，然后穷举。

**「状态」很明显，就是当前拥有的鸡蛋数 K 和需要测试的楼层数 N**。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。

**「选择」其实就是去选择哪层楼扔鸡蛋**。回顾刚才的线性扫描和二分思路，二分查找每次选择到楼层区间的中间去扔鸡蛋，而线性扫描选择一层层向上测试。不同的选择会造成状态的转移。

现在明确了「状态」和「选择」，**动态规划的基本思路就形成了**：肯定是个二维的 dp 数组或者带有两个状态参数的 dp 函数来表示状态转移；外加一个 for 循环来遍历所有选择，择最优的选择更新状态：

```java
// 定义：当前状态为 K 个鸡蛋，面对 N 层楼
// 返回这个状态下最少的扔鸡蛋次数
int dp(int K, int N):
    int res
    for 1 <= i <= N:
        res = min(res, 这次在第 i 层楼扔鸡蛋)
    return res
```

这段伪码还没有展示递归和状态转移，不过大致的算法框架已经完成了。

我们选择在第 i 层楼扔了鸡蛋之后，可能出现两种情况：鸡蛋碎了，鸡蛋没碎。**注意，这时候状态转移就来了**：

**如果鸡蛋碎了**，那么鸡蛋的个数 K 应该减一，搜索的楼层区间应该从 [1..N] 变为 [1..i-1] 共 i-1 层楼；

**如果鸡蛋没碎**，那么鸡蛋的个数 K 不变，搜索的楼层区间应该从 [1..N] 变为 [i+1..N] 共 N-i 层楼。

![1687502585200-b2552c34-17c7-4d37-ac81-992fd99f9d68](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687502585200-b2552c34-17c7-4d37-ac81-992fd99f9d68-20240401180209-h2wf31t.jpeg)

> note：细心的读者可能会问，在第 i 层楼扔鸡蛋如果没碎，楼层的搜索区间缩小至上面的楼层，是不是应该包含第 i 层楼呀？不必，因为已经包含了。开头说了 F 是可以等于 0 的，向上递归后，第 i 层楼其实就相当于第 0 层，可以被取到，所以说并没有错误。

因为我们要求的是**最坏情况**下扔鸡蛋的次数，所以鸡蛋在第 i 层楼碎没碎，取决于那种情况的结果**更大**：

```java
int dp(int K, int N):
    for 1 <= i <= N:
        // 最坏情况下的最少扔鸡蛋次数
        res = min(res, 
                  max( 
                    dp(K - 1, i - 1), // 碎
                    dp(K, N - i)      // 没碎
                  ) + 1 // 在第 i 楼扔了一次
                 )
    return res
```

递归的 base case 很容易理解，当楼层数 N 等于 0 时，显然不需要扔鸡蛋；当鸡蛋数 K 为 1 时，显然只能线性扫描所有楼层：

```java
int dp(int K, int N) {
    // base case
    if (K == 1) return N;
    if (N == 0) return 0;
    // ...
}
```

至此，其实这道题就解决了！只要添加一个备忘录消除重叠子问题即可：

```java
class Solution {
    // 备忘录
    int[][] memo;

    public int superEggDrop(int K, int N) {
        // m 最多不会超过 N 次（线性扫描）
        memo = new int[K + 1][N + 1];
        for (int[] row : memo) {
            Arrays.fill(row, -666);
        }
        return dp(K, N);
    }

    // 定义：手握 K 个鸡蛋，面对 N 层楼，最少的扔鸡蛋次数为 dp(K, N)
    int dp(int K, int N) {
        // base case
        if (K == 1) return N;
        if (N == 0) return 0;

        // 查备忘录避免冗余计算
        if (memo[K][N] != -666) {
            return memo[K][N];
        }
        // 状态转移方程
        int res = Integer.MAX_VALUE;
        for (int i = 1; i <= N; i++) {
            // 在所有楼层进行尝试，取最少扔鸡蛋次数
            res = Math.min(
                res,
                // 碎和没碎取最坏情况
                Math.max(dp(K, N - i), dp(K - 1, i - 1)) + 1
            );
        }
        // 结果存入备忘录
        memo[K][N] = res;
        return res;
    }
}
```

这个算法的时间复杂度是多少呢？**动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度**。

函数本身的复杂度就是忽略递归部分的复杂度，这里 dp 函数中有一个 for 循环，所以函数本身的复杂度是 O(N)。

子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。所以算法的总时间复杂度是 O(K*N^2), 空间复杂度 O(KN)。这个问题很复杂，但是算法代码却十分简洁，这就是动态规划的特性，穷举加备忘录/DP table 优化，真的没啥新意。*

*有读者可能不理解代码中为什么用一个 for 循环遍历楼层 [1..N]，也许会把这个逻辑和之前探讨的线性扫描混为一谈。其实不是的，*​***这只是在做一次「选择」***​ *。比方说你有 2 个鸡蛋，面对 10 层楼，你*​***这次***​*选择去哪一层楼扔呢？不知道，那就把这 10 层楼全试一遍。至于下次怎么选择不用你操心，有正确的状态转移，递归算法会把每个选择的代价都算出来，我们取最优的那个就是最优解。*

*另外，这个问题还有更好的解法，比如修改代码中的 for 循环为二分搜索，可以将时间复杂度降为 O(K*N*logN)；再改进动态规划解法可以进一步降为 O(KN)；使用数学方法解决，时间复杂度达到最优 O(K*logN)，空间复杂度达到 O(1)。

二分的解法也有点误导性，你很可能以为它跟我们之前讨论的二分思路扔鸡蛋有关系，实际上没有半毛钱关系。能用二分搜索是因为状态转移方程的函数图像具有单调性，可以快速找到最值。  
接下来我们看一看如何优化。

---

二分搜索的优化的核心是状态转移方程的单调性，首先简述一下原始动态规划的思路：

1、暴力穷举尝试在所有楼层 1 <= i <= N 扔鸡蛋，每次选择尝试次数**最少**的那一层；

2、每次扔鸡蛋有两种可能，要么碎，要么没碎；

3、如果鸡蛋碎了，F 应该在第 i 层下面，否则，F 应该在第 i 层上面；

4、鸡蛋是碎了还是没碎，取决于哪种情况下尝试次数**更多**，因为我们想求的是最坏情况下的结果。

核心的状态转移代码是这段：

```java
// 当前状态为 K 个鸡蛋，面对 N 层楼
// 返回这个状态下的最优结果
int dp(int K, int N):
    for 1 <= i <= N:
        // 最坏情况下的最少扔鸡蛋次数
        res = min(res,
                  max( 
                        dp(K - 1, i - 1), // 碎
                        dp(K, N - i)      // 没碎
                     ) + 1 // 在第 i 楼扔了一次
                 )
    return res
```

这个 for 循环就是下面这个状态转移方程的具体代码实现：

![1687502671524-4c897e67-492e-4809-b4a1-6af25c5f7038](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687502671524-4c897e67-492e-4809-b4a1-6af25c5f7038-20240401180209-icgzh7v.png)

如果能够理解这个状态转移方程，那么就很容易理解二分查找的优化思路。

首先我们根据 dp(K, N) 数组的定义（有 K 个鸡蛋面对 N 层楼，最少需要扔几次），**很容易知道 K 固定时，这个函数随着 N 的增加一定是单调递增的**，无论你策略多聪明，楼层增加测试次数一定要增加。

那么注意 dp(K - 1, i - 1) 和 dp(K, N - i) 这两个函数，其中 i 是从 1 到 N 单增的，如果我们固定 K 和 N，**把这两个函数看做关于 i 的函数，前者随着 i 的增加应该也是单调递增的，而后者随着 i 的增加应该是单调递减的**：

![1687502671692-22d48a56-c68a-48bd-af80-7407a0ada13f](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687502671692-22d48a56-c68a-48bd-af80-7407a0ada13f-20240401180210-d5e7rs8.jpeg)

这时候求二者的较大值，再求这些最大值之中的最小值，其实就是求这两条直线交点，也就是红色折线的最低点嘛。

我们前文 [二分查找的运用技巧](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_627cce2de4b01a4851fe0ed1/1) 讲过，二分查找的运用很广泛，只要能够找到具有单调性的函数关系，都很有可能可以运用二分查找来优化线性搜索的复杂度。回顾这两个 dp 函数的曲线，我们要找的最低点其实就是这种情况：

```java
for (int i = 1; i <= N; i++) {
    if (dp(K - 1, i - 1) == dp(K, N - i))
        return dp(K, N - i);
}
```

熟悉二分搜索的同学肯定敏感地想到了，这不就是相当于求 Valley（山谷）值嘛，可以用二分查找来快速寻找这个点的，直接看代码吧，将 dp 函数的线性搜索改造成了二分搜索，加快了搜索速度：

```java
int dp(int K, int N) {
    // base case
    if (K == 1) return N;
    if (N == 0) return 0;

    if (memo[K][N] != -666) {
        return memo[K][N];
    }

    // for (int i = 1; i <= N; i++) {
    //     res = Math.min(
    //         res,
    //         Math.max(dp(K, N - i), dp(K - 1, i - 1)) + 1
    //     );
    // }

    // 用二分搜索代替线性搜索
    int res = Integer.MAX_VALUE;
    int lo = 1, hi = N;
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        // 鸡蛋在第 mid 层碎了和没碎两种情况
        int broken = dp(K - 1, mid - 1);
        int not_broken = dp(K, N - mid);
        // res = min(max(碎，没碎) + 1)
        if (broken > not_broken) {
            hi = mid - 1;
            res = Math.min(res, broken + 1);
        } else {
            lo = mid + 1;
            res = Math.min(res, not_broken + 1);
        }
    }
    memo[K][N] = res;
    return res;
}
```

这个算法的时间复杂度是多少呢？**动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度**。

函数本身的复杂度就是忽略递归部分的复杂度，这里 dp 函数中用了一个二分搜索，所以函数本身的复杂度是 O(logN)。

子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是 O(KN)。

所以算法的总时间复杂度是 O(KNlogN), 空间复杂度 O(KN)。效率上比之前的算法 O(KN^2) 要高效一些。

#### 动态规划之戳气球

##### 312.「[戳气球](https://leetcode.cn/problems/burst-balloons/)」

> 有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。
>
> 现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。
>
> 求所能获得硬币的最大数量。
>
> **示例 1：**   
> 输入：nums = [3,1,5,8]  
> 输出：167
>
> 解释：  
> nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []  
> coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167

###### 回溯思路

先来顺一下解决这种问题的套路：

**我们前文多次强调过，很显然只要涉及求最值，没有任何特殊方法，一定是穷举所有可能的结果，然后对比得出最值**。

所以说，只要遇到求最值的算法问题，首先要思考的就是：如何穷举出所有可能的结果？

穷举主要有两种算法，就是回溯算法和动态规划，前者就是暴力穷举，而后者是根据状态转移方程推导「状态」。

如何将我们的扎气球问题转化成回溯算法呢？这个应该不难想到的，**我们其实就是想穷举戳气球的顺序**，不同的戳气球顺序可能得到不同的分数，我们需要把所有可能的分数中最高的那个找出来，对吧。

那么，这不就是一个「全排列」问题嘛，我们前文 [回溯算法框架套路详解](https://labuladong.gitee.io/article/fname.html?fname=%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88) 中有全排列算法的详解和代码，其实只要稍微改一下逻辑即可，伪码思路如下：

```java
int res = Integer.MIN_VALUE;
/* 输入一组气球，返回戳破它们获得的最大分数 */
int maxCoins(int[] nums) {
    backtrack(nums, 0); 
    return res;
}
/* 回溯算法的伪码解法 */
void backtrack(int[] nums, int socre) {
    if (nums 为空) {
        res = max(res, score);
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        int point = nums[i-1] * nums[i] * nums[i+1];
        int temp = nums[i];
        // 做选择
        在 nums 中删除元素 nums[i]
        // 递归回溯
        backtrack(nums, score + point);
        // 撤销选择
        将 temp 还原到 nums[i]
    }
}
```

回溯算法就是这么简单粗暴，但是相应的，算法的效率非常低。这个解法等同于全排列，所以时间复杂度是阶乘级别，非常高，题目说了 nums 的大小 n 最多为 500，所以回溯算法肯定是不能通过所有测试用例的。

###### 动态规划思路

这个动态规划问题和我们之前的动态规划系列文章相比有什么特别之处？为什么它比较难呢？

**原因在于，这个问题中我们每戳破一个气球 nums[i]，得到的分数和该气球相邻的气球 nums[i-1] 和 nums[i+1] 是有相关性的**。

我们前文 [动态规划套路框架详解](https://labuladong.gitee.io/article/fname.html?fname=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AF%A6%E8%A7%A3%E8%BF%9B%E9%98%B6) 说过运用动态规划算法的一个重要条件：**子问题必须独立**。所以对于这个戳气球问题，如果想用动态规划，必须巧妙地定义 dp 数组的含义，避免子问题产生相关性，才能推出合理的状态转移方程。

如何定义 dp 数组呢，这里需要对问题进行一个简单地转化。题目说可以认为 nums[-1] = nums[n] = 1，那么我们先直接把这两个边界加进去，形成一个新的数组 points：

```java
int maxCoins(int[] nums) {
    int n = nums.length;
    // 两端加入两个虚拟气球
    int[] points = new int[n + 2];
    points[0] = points[n + 1] = 1;
    for (int i = 1; i <= n; i++) {
        points[i] = nums[i - 1];
    }
    // ...
}
```

现在气球的索引变成了从 1 到 n，points[0] 和 points[n+1] 可以认为是两个「虚拟气球」。

那么我们可以改变问题：**在一排气球 points 中，请你戳破气球 0 和气球 n+1 之间的所有气球（不包括 0 和 n+1），使得最终只剩下气球 0 和气球 n+1 两个气球，最多能够得到多少分**？

现在可以定义 dp 数组的含义：

**dp[i][j] = x 表示，戳破气球 i 和气球 j 之间（开区间，不包括 i 和 j）的所有气球，可以获得的最高分数为 x**。

那么根据这个定义，题目要求的结果就是 dp[0][n+1] 的值，而 base case 就是 dp[i][j] = 0，其中 0 <= i <= n+1, j <= i+1，因为这种情况下，开区间 (i, j) 中间根本没有气球可以戳。

```java
// base case 已经都被初始化为 0
int[][] dp = new int[n + 2][n + 2];
```

现在我们要根据这个 dp 数组来推导状态转移方程了，根据我们前文的套路，所谓的推导「状态转移方程」，实际上就是在思考怎么「做选择」，也就是这道题目最有技巧的部分：

不就是想求戳破气球 i 和气球 j 之间的最高分数吗，如果「正向思考」，就只能写出前文的回溯算法；**我们需要「反向思考」，想一想气球 i 和气球 j 之间最后一个被戳破的气球可能是哪一个**？

其实气球 i 和气球 j 之间的所有气球都可能是最后被戳破的那一个，不防假设为 k。回顾动态规划的套路，这里其实已经找到了「状态」和「选择」：i 和 j 就是两个「状态」，最后戳破的那个气球 k 就是「选择」。

**根据刚才对 dp 数组的定义，如果最后一个戳破气球 k，dp[i][j] 的值应该为**：

```java
dp[i][j] = dp[i][k] + dp[k][j] 
         + points[i]*points[k]*points[j]
```

你不是要最后戳破气球 k 吗？那得先把开区间 (i, k) 的气球都戳破，再把开区间 (k, j) 的气球都戳破；最后剩下的气球 k，相邻的就是气球 i 和气球 j，这时候戳破 k 的话得到的分数就是 points[i]*points[k]* points[j]。

那么戳破开区间 (i, k) 和开区间 (k, j) 的气球最多能得到的分数是多少呢？嘿嘿，就是 dp[i][k] 和 dp[k][j]，这恰好就是我们对 dp 数组的定义嘛！

![1687505175055-843cab0a-7b0f-4d02-abfc-a37ce2adfec6](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687505175055-843cab0a-7b0f-4d02-abfc-a37ce2adfec6-20240401181106-xry0u9y.jpeg)

结合这个图，就能体会出 dp 数组定义的巧妙了。由于是开区间，dp[i][k] 和 dp[k][j] 不会影响气球 k；而戳破气球 k 时，旁边相邻的就是气球 i 和气球 j 了，最后还会剩下气球 i 和气球 j，这也恰好满足了 dp 数组开区间的定义。

那么，对于一组给定的 i 和 j，我们只要穷举 i < k < j 的所有气球 k，选择得分最高的作为 dp[i][j] 的值即可，这也就是状态转移方程：

```java
// 最后戳破的气球是哪个？
for (int k = i + 1; k < j; k++) {
    // 择优做选择，使得 dp[i][j] 最大
    dp[i][j] = Math.max(
        dp[i][j], 
        dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]
    );
}
```

写出状态转移方程就完成这道题的一大半了，但是还有问题：对于 k 的穷举仅仅是在做「选择」，但是应该如何穷举「状态」i 和 j 呢？

```java
for (int i = ...; ; )
    for (int j = ...; ; )
        for (int k = i + 1; k < j; k++) {
            dp[i][j] = Math.max(
                dp[i][j], 
                dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]
            );
return dp[0][n+1];
```

**关于「状态」的穷举，最重要的一点就是：状态转移所依赖的状态必须被提前计算出来**。

拿这道题举例，dp[i][j] 所依赖的状态是 dp[i][k] 和 dp[k][j]，那么我们必须保证：在计算 dp[i][j] 时，dp[i][k] 和 dp[k][j] 已经被计算出来了（其中 i < k < j）。

那么应该如何安排 i 和 j 的遍历顺序，来提供上述的保证呢？我们前文 [动态规划答疑篇](https://labuladong.gitee.io/article/fname.html?fname=%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84) 写过处理这种问题的一个鸡贼技巧：**根据 base case 和最终状态进行推导**。

note：最终状态就是指题目要求的结果，对于这道题目也就是 dp[0][n+1]。

我们先把 base case 和最终的状态在 DP table 上画出来：

![1687505296429-db65ec0e-fc70-494a-a2e3-27a22a3cc2a8](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687505296429-db65ec0e-fc70-494a-a2e3-27a22a3cc2a8-20240401181106-nk246e7.jpeg)

对于任一 dp[i][j]，我们希望所有 dp[i][k] 和 dp[k][j] 已经被计算，画在图上就是这种情况：

![1687505296411-920884e6-c4d1-4b23-b2e2-5b12d31f8132](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687505296411-920884e6-c4d1-4b23-b2e2-5b12d31f8132-20240401181106-vzmq1a2.jpeg)

那么，为了达到这个要求，可以有两种遍历方法，要么斜着遍历，要么从下到上从左到右遍历：

![1687505296451-1bebd9d1-0f14-41de-bafd-146cca4b6a27](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687505296451-1bebd9d1-0f14-41de-bafd-146cca4b6a27-20240401181106-lciy2ew.jpeg)![1687505296631-97553900-8cef-494a-886a-bd4c2b7de151](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687505296631-97553900-8cef-494a-886a-bd4c2b7de151-20240401181106-w6z4jte.jpeg)

斜着遍历有一点难写，所以一般我们就从下往上遍历，下面看完整代码：

```java
int maxCoins(int[] nums) {
    int n = nums.length;
    // 添加两侧的虚拟气球
    int[] points = new int[n + 2];
    points[0] = points[n + 1] = 1;
    for (int i = 1; i <= n; i++) {
        points[i] = nums[i - 1];
    }
    // base case 已经都被初始化为 0
    int[][] dp = new int[n + 2][n + 2];
    // 开始状态转移
    // i 应该从下往上
    for (int i = n; i >= 0; i--) {
        // j 应该从左往右
        for (int j = i + 1; j < n + 2; j++) {        
            // 最后戳破的气球是哪个？
            for (int k = i + 1; k < j; k++) {
                // 择优做选择
                dp[i][j] = Math.max(                
                    dp[i][j], 
                    dp[i][k] + dp[k][j] + points[i]*points[j]*points[k]
                );
            }
        }
    }
    return dp[0][n + 1];
}
```

至此，这道题目就完全解决了，十分巧妙，但也不是那么难，对吧？

关键在于 dp 数组的定义，需要避免子问题互相影响，所以我们反向思考，将 dp[i][j] 的定义设为开区间，考虑最后戳破的气球是哪一个，以此构建了状态转移方程。

对于如何穷举「状态」，我们使用了小技巧，通过 base case 和最终状态推导出 i, j 的遍历方向，保证正确的状态转移。

#### 动态规划之博弈问题

##### 486.「[预测赢家](https://leetcode.cn/problems/predict-the-winner/)」

> 给你一个整数数组 nums 。玩家 1 和玩家 2 基于这个数组设计了一个游戏。
>
> 玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手。开始时，两个玩家的初始分值都是 0 。每一回合，玩家从数组的任意一端取一个数字（即，nums[0] 或 nums[nums.length - 1]），取到的数字将会从数组中移除（数组长度减 1 ）。玩家选中的数字将会加到他的得分上。当数组中没有剩余数字可取时，游戏结束。
>
> 如果玩家 1 能成为赢家，返回 true 。如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 true 。你可以假设每个玩家的玩法都会使他的分数最大化。
>
> **示例 1：**   
> 输入：nums = [1,5,2]  
> 输出：false
>
> 解释：一开始，玩家 1 可以从 1 和 2 中进行选择。  
> 如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。
> 所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。  
> 因此，玩家 1 永远不会成为赢家，返回 false 。

###### 定义 dp 数组的含义

定义 dp 数组的含义是很有技术含量的，同一问题可能有多种定义方法，不同的定义会引出不同的状态转移方程，不过只要逻辑没有问题，最终都能得到相同的答案。

我建议不要迷恋那些看起来很牛逼，代码很短小的解法思路，最好是稳一点，采取可解释性最好，最容易推广的解法思路。本文就给出一种博弈问题的通用设计框架。

介绍 dp 数组的含义之前，我们先看一下 dp 数组最终的样子：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687507049769-6b1ecb60-ec82-4143-a598-ccd9c8382efa-20240401182033-u0amiuq.png)

下文讲解时，认为元组是包含 first 和 second 属性的一个类，而且为了节省篇幅，将这两个属性简写为 fir 和 sec。比如按上图的数据，我们说 dp[1][3].fir = 11，dp[0][1].sec = 2。

先回答几个读者可能提出的问题：

这个二维 dp table 中存储的是元组，怎么编程表示呢？这个 dp table 有一半根本没用上，怎么优化？很简单，都不要管，先把解题的思路想明白了再谈也不迟。

**以下是对 dp 数组含义的解释：**

dp[i][j].fir = x 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数为 x。

dp[i][j].sec = y 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数为 y。

举例理解一下，假设 piles = [2, 8, 3, 5]，索引从 0 开始，那么：

dp[0][1].fir = 8 意味着：面对石头堆 [2, 8]，先手最多能够获得 8 分；dp[1][3].sec = 5 意味着：面对石头堆 [8, 3, 5]，后手最多能够获得 5 分。

我们想求的答案是先手和后手最终分数之差，按照这个定义也就是 dp[0][n-1].fir - dp[0][n-1].sec，即面对整个 piles，先手的最优得分和后手的最优得分之差。

###### 状态转移方程

写状态转移方程很简单，首先要找到所有「状态」和每个状态可以做的「选择」，然后择优。

根据前面对 dp 数组的定义，**状态显然有三个：开始的索引 i，结束的索引 j，当前轮到的人。**

```java
dp[i][j][fir or sec]
其中：
0 <= i < piles.length
i <= j < piles.length
```

对于这个问题的每个状态，可以做的**选择有两个：选择最左边的那堆石头，或者选择最右边的那堆石头。**  我们可以这样穷举所有状态：

```java
n = piles.length
for 0 <= i < n:
    for j <= i < n:
        for who in {fir, sec}:
            dp[i][j][who] = max(left, right)
```

上面的伪码是动态规划的一个大致的框架，这道题的难点在于，两人足够聪明，而且是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？

根据我们对 dp 数组的定义，很容易解决这个难点，**写出状态转移方程：**

```java
dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)
dp[i][j].fir = max(     选择最左边的石头堆     ,     选择最右边的石头堆      )
// 解释：我作为先手，面对 piles[i...j] 时，有两种选择：

// 要么我选择最左边的那一堆石头 piles[i]，局面变成了 piles[i+1...j]，
// 然后轮到对方选了，我变成了后手，此时我作为后手的最优得分是 dp[i+1][j].sec

// 要么我选择最右边的那一堆石头 piles[j]，局面变成了 piles[i...j-1]
// 然后轮到对方选了，我变成了后手，此时我作为后手的最优得分是 dp[i][j-1].sec

if 先手选择左边:
    dp[i][j].sec = dp[i+1][j].fir
if 先手选择右边:
    dp[i][j].sec = dp[i][j-1].fir
// 解释：我作为后手，要等先手先选择，有两种情况：

// 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]
// 此时轮到我，我变成了先手，此时的最优得分是 dp[i+1][j].fir

// 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]
// 此时轮到我，我变成了先手，此时的最优得分是 dp[i][j-1].fir
```

根据 dp 数组的定义，我们也可以找出 **base case**，也就是最简单的情况：

```java
dp[i][j].fir = piles[i]
dp[i][j].sec = 0
其中 0 <= i == j < n
// 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]
// 那么显然先手的得分为 piles[i]
// 后手没有石头拿了，得分为 0
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687507197777-a7bac65f-5c80-4a91-adfa-6598d112fc04-20240401182034-c7wpph1.png)

这里需要注意一点，我们发现 base case 是斜着的，而且我们推算 dp[i][j] 时需要用到 dp[i+1][j] 和 dp[i][j-1]：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687507218190-5c69f446-78ed-4be5-b7e8-156c311b4a6a-20240401182034-vgtrl59.png)

根据前文 [动态规划答疑篇](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/zui-you-zi-fbef6/) 判断 dp 数组遍历方向的原则，算法应该倒着遍历 dp 数组：

```java
for (int i = n - 2; i >= 0; i--) {
    for (int j = i + 1; j < n; j++) {
        dp[i][j] = ...
    }
}
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687507288112-872fdc70-f9d1-434f-9cf4-181e6f44cd9f-20240401182034-b0ofals.png)

###### 代码实现

如何实现这个 fir 和 sec 元组呢，你可以用 python，自带元组类型；或者使用 C++ 的 pair 容器；或者用一个三维数组 dp[n][n][2]，最后一个维度就相当于元组；或者我们自己写一个 Pair 类：

```java
class Pair {
    int fir, sec;
    Pair(int fir, int sec) {
        this.fir = fir;
        this.sec = sec;
    }
}
```

然后直接把我们的状态转移方程翻译成代码即可，注意我们要倒着遍历数组：

```java
/* 返回游戏最后先手和后手的得分之差 */
int stoneGame(int[] piles) {
    int n = piles.length;
    // 初始化 dp 数组
    Pair[][] dp = new Pair[n][n];
    for (int i = 0; i < n; i++) 
        for (int j = i; j < n; j++)
            dp[i][j] = new Pair(0, 0);
    // 填入 base case
    for (int i = 0; i < n; i++) {
        dp[i][i].fir = piles[i];
        dp[i][i].sec = 0;
    }

    // 倒着遍历数组
    for (int i = n - 2; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            // 先手选择最左边或最右边的分数
            int left = piles[i] + dp[i+1][j].sec;
            int right = piles[j] + dp[i][j-1].sec;
            // 套用状态转移方程
            // 先手肯定会选择更大的结果，后手的选择随之改变
            if (left > right) {
                dp[i][j].fir = left;
                dp[i][j].sec = dp[i+1][j].fir;
            } else {
                dp[i][j].fir = right;
                dp[i][j].sec = dp[i][j-1].fir;
            }
        }
    }
    Pair res = dp[0][n-1];
    return res.fir - res.sec;
}
```

动态规划解法，如果没有状态转移方程指导，绝对是一头雾水，但是根据前面的详细解释，读者应该可以清晰理解这一大段代码的含义。

而且，注意到计算 dp[i][j] 只依赖其左边和下边的元素，所以说肯定有优化空间，转换成一维 dp，想象一下把二维平面压扁，也就是投影到一维。但是，一维 dp 比较复杂，可解释性比较差，大家就不必浪费这个时间去理解了。

###### 最后总结

本文给出了解决博弈问题的动态规划解法。博弈问题的前提一般都是在两个聪明人之间进行，编程描述这种游戏的一般方法是二维 dp 数组，数组中通过元组分别表示两人的最优决策。

之所以这样设计，是因为先手在做出选择之后，就成了后手，后手在对方做完选择后，就变成了先手。**这种角色转换使得我们可以重用之前的结果，典型的动态规划标志**。

读到这里的朋友应该能理解算法解决博弈问题的套路了。学习算法，一定要注重算法的模板框架，而不是一些看起来牛逼的思路，也不要奢求上来就写一个最优的解法。不要舍不得多用空间，不要过早尝试优化，不要惧怕多维数组。dp 数组就是存储信息避免重复计算的，随便用，直到咱满意为止。

## 贪心

### 贪心大纲

#### 纲领

#### 练习题

##### **剑指 Offer 14- II. 「**​[剪绳子 II](https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/description/?orderBy=hot)」

> 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为
>
> k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]* ...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> **示例 1：**   
> 输入: 2  
> 输出: 1
>
> 解释: 2 = 1 + 1, 1 × 1 = 1

这个题和剪绳子I一样的描述，就是数据范围变大了。剪绳子可以用动态规划或者贪心做，这道题对于使用DP难度就增大了一些，因为数据范围变得比较大时，long已经不足以去存储中间结果的状态，但是由于DP做法是枚举各种剪的情况然后取最大值，因此只能通过使用BigInteger的方法去做。

那么这个题范围变大的本意是想让我们使用贪心算法能更好的求解(毕竟BigInteger使用起来麻烦，贪心没有数据溢出的问题，它是找当下的最优解，不需要比较，中间结果可以直接取模)。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678088084682-6e4d3959-c0a5-464b-9452-5e478fd3ce38-20240401191457-zvv7b44.png)

我们首先考虑对于一段长n的绳子，我们可以切出的结果包含什么？

`1`​会包含吗？ 不会，因为`1 * (k - 1) < k`​, 只要把1和任何一个其他的片段组合在一起就有个更大的值 `2`​可以 `3`​可以 `4`​可以吗？ 它拆成两个`2`​的效果和本身一样，因此也不考虑`5`​以上可以吗？不可以，这些绳子必须拆，因为总有一种拆法比不拆更优，比如拆成`k / 2`​和` k - k / 2`​

综上, 最后的结果只包含`2`​和`3`​(当然当总长度为`2`​和`3`​时单独处理), 那么很显然n >= 5时， 3*(n - 3) >= 2 * (n - 2) ，因此我们优先拆成`3`​，最后剩余的拆成`2`​。最后的结果一定是由若干个`3`​和1或2个`2`​组成.

```java
class Solution {
    public int cuttingRope(int n) {
        if(n == 2) {
            return 1;
        }
        if(n == 3){
            return 2;
        }
        int mod = (int)1e9 + 7;
        long res = 1;
        while(n > 4) {
            res *= 3;
            res %= mod;
            n -= 3;
        }
        return (int)(res * n % mod);
    }
}
```

### 贪心算法之区间调度问题

什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。

比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。

什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。

比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。

然而，大部分问题明显不具有贪心选择性质。比如打斗地主，对手出对儿三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决，参见前文 [动态规划解决博弈问题](https://labuladong.github.io/algo/di-er-zhan-a01c6/yong-dong--63ceb/jing-dian--467d1/)。

#### 练习题

##### 435.「[无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)」

> 给定一个区间的集合 `intervals`​ ，其中 `intervals[i] = [start_i, end_i]`​ 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。
>
> **示例 1:**   
> 输入: intervals = [[1,2],[2,3],[3,4],[1,3]]  
> 输出: 1  
> 解释: 移除 [1,3] 后，剩下的区间没有重叠。

这个问题有许多看起来不错的贪心思路，却都不能得到正确答案。比如说：

也许我们可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得我们错误地错过了一些短的区间。或者我们每次选择可选区间中最短的那个？或者选择出现冲突最少的那个区间？这些方案都能很容易举出反例，不是正确的方案。

正确的思路其实很简单，可以分为以下三步：

1、从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中**结束最早的**（end 最小）。

2、把所有与 x 区间相交的区间从区间集合 intvs 中删除。

3、重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。

把这个思路实现成算法的话，可以按每个区间的 end 数值升序排序，因为这样处理之后实现步骤 1 和步骤 2 都方便很多，如下 GIF 所示：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620162447658.png" alt="image-20250620162447658" style="zoom:50%;" />

现在来实现算法，对于步骤 1，由于我们预先按照 end 排了序，所以选择 x 是很容易的。关键在于，如何去除与 x 相交的区间，选择下一轮循环的 x 呢？

**由于我们事先排了序**，不难发现所有与 x 相交的区间必然会与 x 的 end 相交；如果一个区间不想与 x 的 end 相交，它的 start 必须要大于（或等于）x 的 end：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620162513771.png" alt="image-20250620162513771" style="zoom:50%;" />

看下代码：

```java
public int intervalSchedule(int[][] intvs) {
	int n = intvs.length;
    if (n == 0) return 0;
    // 按 end 升序排序
    Arrays.sort(intvs, new Comparator<int[]>() {
        public int compare(int[] a, int[] b) {
            return a[1] - b[1];
        }
    });
    // 至少有一个区间不相交
    int count = 1;
    // 排序后，第一个区间就是 x
    int x_end = intvs[0][1];
    for (int[] interval : intvs) {
        int start = interval[0];
        if (start >= x_end) {
            // 找到下一个选择的区间了
            count++;
            x_end = interval[1];
        }
    }
    return n - count;
}
```

##### 452.「[用最少的箭头射爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)」

> 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。
>
> 一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。
>
> 给你一个数组 `points`​ ，*返回引爆所有气球所必须射出的* ***最小*** *弓箭数* 。
>
> **示例 1：**   
> 输入：points = [[10,16],[2,8],[1,6],[7,12]]  
> 输出：2
>
> 解释：气球可以用2支箭来爆破: -在x = 6处射出箭，击破气球[2,8]和[1,6]。 -在x = 11处发射箭，击破气球[10,16]和[7,12]。

比如说输入为 [[10,16],[2,8],[1,6],[7,12]]，算法应该返回 2，因为我们可以在 x 为 6 的地方射一箭，射爆 [2,8] 和 [1,6] 两个气球，然后在 x 为 10，11 或 12 的地方射一箭，射爆 [10,16] 和 [7,12] 两个气球。

其实稍微思考一下，这个问题和区间调度算法一模一样！如果最多有 n 个不重叠的区间，那么就至少需要 n 个箭头穿透所有区间：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620162647992.png" alt="image-20250620162647992" style="zoom:50%;" />

只是有一点不一样，在 intervalSchedule 算法中，如果两个区间的边界触碰，不算重叠；而按照这道题目的描述，箭头如果碰到气球的边界气球也会爆炸，所以说相当于区间的边界触碰也算重叠：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620162709894.png" alt="image-20250620162709894" style="zoom:50%;" />

所以只要将之前的算法稍作修改，就是这道题目的答案：

```java
int findMinArrowShots(int[][] intvs) {
    int n = points.length;
    Arrays.sort(points, Comparator.comparingInt(a -> a[1]));
    int end = points[0][1];
    int count = 1;
    for (int[] interval : intvs) {
        int start = interval[0];
        // 把 >= 改成 > 就行了
        if (start > x_end) {
            count++;
            x_end = interval[1];
        }
    }
    return count;
}
```

### 贪心算法之视频拼接

#### 1024.「[视频拼接](https://leetcode.cn/problems/video-stitching/)」

> 你将会获得一系列视频片段，这些片段来自于一项持续时长为 time 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。
>
> 使用数组 clips 描述所有的视频片段，其中 clips[i] = [starti, endi] 表示：某个视频片段开始于 starti 并于 endi 结束。
>
> 甚至可以对这些片段自由地再剪辑：
>
> - 例如，片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。
>
> 我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, time]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。
>
> **示例 1：**   
> 输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10  
> 输出：3
>
> 解释： 选中 [0,2], [8,10], [1,9] 这三个片段。  
> 然后，按下面的方案重制比赛片段： 将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。  
> 现在手上的片段为 [0,2] + [2,8] + [8,10]，而这些覆盖了整场比赛 [0, 10]。

题目并不难理解，给定一个目标区间和若干小区间，如何通过裁剪和组合小区间拼凑出目标区间？最少需要几个小区间？

**前文多次说过，区间问题肯定按照区间的起点或者终点进行排序**。

因为排序之后更容易找到相邻区间之间的联系，如果是求最值的问题，可以使用贪心算法进行求解。

区间问题特别容易用贪心算法，公众号历史文章除了 [贪心算法之区间调度](https://labuladong.github.io/algo/di-er-zhan-a01c6/tan-xin-le-9bedf/tan-xin-su-c41e8/)，还有一篇 [贪心算法玩跳跃游戏](https://labuladong.github.io/algo/di-er-zhan-a01c6/tan-xin-le-9bedf/ru-he-yun--48a7c/)，其实这个跳跃游戏就相当于一个将起点排序的区间问题，你细品，你细品。

至于到底如何排序，这个就要因题而异了，我做这道题的思路是先按照起点升序排序，如果起点相同的话按照终点降序排序。

为什么这样排序呢，主要考虑到这道题的以下两个特点：

1、要用若干短视频凑出完成视频 [0, T]，至少得有一个短视频的起点是 0。

这个很好理解，如果没有一个短视频是从 0 开始的，那么区间 [0, T] 肯定是凑不出来的。

2、如果有几个短视频的起点都相同，那么一定应该选择那个最长（终点最大）的视频。

这一条就是贪心的策略，因为题目让我们计算最少需要的短视频个数，如果起点相同，那肯定是越长越好，不要白不要，多出来了大不了剪辑掉嘛。

基于以上两个特点，将 clips 按照起点升序排序，起点相同的按照终点降序排序，最后得到的区间顺序就像这样：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620162851717.png" alt="image-20250620162851717" style="zoom:50%;" />

这样我们就可以确定，如果 clips[0] 是的起点是 0，那么 clips[0] 这个视频一定会被选择。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620162917760.png" alt="image-20250620162917760" style="zoom:50%;" />

当我们确定 clips[0] 一定会被选择之后，就可以选出下一个会被选择的视频：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620162941358.png" alt="image-20250620162941358" style="zoom:50%;" />

**我们会比较所有起点小于 clips[0][1] 的区间，根据贪心策略，它们中终点最大的那个区间就是第二个会被选中的视频**。

然后可以通过第二个视频区间贪心选择出第三个视频，以此类推，直到覆盖区间 [0, T]，或者无法覆盖返回 -1。

以上就是这道题的解题思路，仔细想想，这题的核心和前文 [贪心算法玩跳跃游戏](https://labuladong.github.io/algo/di-er-zhan-a01c6/tan-xin-le-9bedf/ru-he-yun--48a7c/) 写的跳跃游戏是相同的，如果你能看出这两者的联系，就可以说理解贪心算法的奥义了。

实现上述思路需要我们用两个变量 curEnd 和 nextEnd 来进行，如下 GIF 所示：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620163003504.png" alt="image-20250620163003504" style="zoom:50%;" />

最终代码实现如下：

```java
class Solution {
    public int videoStitching(int[][] clips, int T) {
        if (T == 0) return 0;
        // 按起点升序排列，起点相同的降序排列
        Arrays.sort(clips, (a, b) -> {
            if (a[0] == b[0]) {
                return b[1] - a[1];
            }
            return a[0] - b[0];
        });
        // 记录选择的短视频个数
        int res = 0;

        int curEnd = 0, nextEnd = 0;
        int i = 0, n = clips.length;
        while (i < n && clips[i][0] <= curEnd) {
            // 在第 res 个视频的区间内贪心选择下一个视频
            while (i < n && clips[i][0] <= curEnd) {
                nextEnd = Math.max(nextEnd, clips[i][1]);
                i++;
            }
            // 找到下一个视频，更新 curEnd
            res++;
            curEnd = nextEnd;
            if (curEnd >= T) {
                // 已经可以拼出区间 [0, T]
                return res;
            }
        }
        // 无法连续拼出区间 [0, T]
        return -1;
    }
}
```

这段代码的时间复杂度是多少呢？虽然代码中有一个嵌套的 while 循环，但这个嵌套 while 循环的时间复杂度是 O(N)。因为当 i 递增到 n 时循环就会结束，所以这段代码只会执行 O(N) 次。

但是别忘了我们对 clips 数组进行了一次排序，消耗了 O(NlogN) 的时间，所以本算法的总时间复杂度是 O(NlogN)。

### 贪心思想玩跳跃游戏

#### 练习题

##### 55.「[跳跃游戏](https://leetcode.cn/problems/jump-game/)」

> 给定一个非负整数数组 nums ，你最初位于数组的 **第一个下标** 。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个下标。
>
> **示例 1：**   
> 输入：nums = [2,3,1,1,4]  
> 输出：true  
> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。

**不知道读者有没有发现，有关动态规划的问题，大多是让你求最值的**，比如最长子序列，最小编辑距离，最长公共子串等等等。这就是规律，因为动态规划本身就是运筹学里的一种求最值的算法。

那么贪心算法作为特殊的动态规划也是一样，也一定是让你求个最值。这道题表面上不是求最值，但是可以改一改：

**请问通过题目中的跳跃规则，最多能跳多远**？如果能够越过最后一格，返回 true，否则返回 false。

所以说，这道题肯定可以用动态规划求解的。但是由于它比较简单，下一道题再用动态规划和贪心思路进行对比，现在直接上贪心的思路：

```java
boolean canJump(int[] nums) {
    int n = nums.length;
    int farthest = 0;
    for (int i = 0; i < n - 1; i++) {
        // 不断计算能跳到的最远距离
        farthest = Math.max(farthest, i + nums[i]);
        // 可能碰到了 0，卡住跳不动了
        if (farthest <= i) {
            return false;
        }
    }
    return farthest >= n - 1;
}
```

##### 45.「[跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)」

> 给定一个长度为 n 的 **0 索引**整数数组 nums。初始位置为 nums[0]。
>
> 每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:
>
> - 0 <= j <= nums[i]
> - i + j < n
>
> 返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。
>
> **示例 1:**   
> 输入: nums = [2,3,1,1,4]  
> 输出: 2
>
> 解释: 跳到最后一个位置的最小跳跃数是 2。
> 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

**现在的问题是，保证你一定可以跳到最后一格，请问你最少要跳多少次，才能跳过去**。

我们先来说说动态规划的思路，采用自顶向下的递归动态规划，可以这样定义一个 dp 函数：

```java
// 定义：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步
int dp(int[] nums, int p);
```

我们想求的结果就是 dp(nums, 0)，base case 就是当 p 超过最后一格时，不需要跳跃：

```java
if (p >= nums.length - 1) {
    return 0;
}
```

根据前文 [动态规划套路详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/) 的动规框架，就可以暴力穷举所有可能的跳法，通过备忘录 memo 消除重叠子问题，取其中的最小值最为最终答案：

```java
class Solution {
    int[] memo;
    // 主函数
    public int jump(int[] nums) {
        int n = nums.length;
        // 备忘录都初始化为 n，相当于 INT_MAX
        // 因为从 0 跳到 n - 1 最多 n - 1 步
        memo = new int[n];
        Arrays.fill(memo, n);

        return dp(nums, 0);
    }

    // 定义：从索引 p 跳到最后一格，至少需要 dp(nums, p) 步
    int dp(int[] nums, int p) {
        int n = nums.length;
        // base case
        if (p >= n - 1) {
            return 0;
        }
        // 子问题已经计算过
        if (memo[p] != n) {
            return memo[p];
        }
        int steps = nums[p];
        // 你可以选择跳 1 步，2 步...
        for (int i = 1; i <= steps; i++) {
            // 穷举每一个选择
            // 计算每一个子问题的结果
            int subProblem = dp(nums, p + i);
            // 取其中最小的作为最终结果
            memo[p] = Math.min(memo[p], subProblem + 1);
        }
        return memo[p];
    }
}
```

这个动态规划应该很明显了，按照前文 [动态规划套路详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/dong-tai-g-1e688/) 所说的套路，状态就是当前所站立的索引 p，选择就是可以跳出的步数。

该算法的时间复杂度是 递归深度 × 每次递归需要的时间复杂度，即 O(N^2)，在 LeetCode 上是无法通过所有用例的，会超时。

**贪心算法比动态规划多了一个性质：贪心选择性质**。我知道大家都不喜欢看严谨但枯燥的数学形式定义，那么我们就来直观地看一看什么样的问题满足贪心选择性质。

刚才的动态规划思路，不是要穷举所有子问题，然后取其中最小的作为结果吗？核心的代码框架是这样：

```java
int steps = nums[p];
// 你可以选择跳 1 步，2 步...
for (int i = 1; i <= steps; i++) {
    // 计算每一个子问题的结果
    int subProblem = dp(nums, p + i);
    res = min(subProblem + 1, res);
}
```

for 循环中会陷入递归计算子问题，这是动态规划时间复杂度高的根本原因。

但是，真的需要「递归地」计算出每一个子问题的结果，然后求最值吗？**直观地想一想，似乎不需要递归，只需要判断哪一个选择最具有「潜力」即可**：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687533643600-bb5869a2-a3b1-49bb-a837-0f1411785477-20240401193831-jq3q5ds.png)

比如上图这种情况，我们站在索引 0 的位置，可以向前跳 1，2 或 3 步，你说应该选择跳多少呢？

**显然应该跳 2 步调到索引 2，因为 nums[2] 的可跳跃区域涵盖了索引区间 [3..6]，比其他的都大**。如果想求最少的跳跃次数，那么往索引 2 跳必然是最优的选择。

你看，**这就是贪心选择性质，我们不需要「递归地」计算出所有选择的具体结果然后比较求最值，而只需要做出那个最有「潜力」，看起来最优的选择即可**。

绕过这个弯儿来，就可以写代码了：

```java
int jump(int[] nums) {
    int n = nums.length;
    int end = 0, farthest = 0;
    int jumps = 0;
    for (int i = 0; i < n - 1; i++) {
        farthest = Math.max(nums[i] + i, farthest);
        if (end == i) {
            jumps++;
            end = farthest;
        }
    }
    return jumps;
}
```

结合刚才那个图，就知道这段短小精悍的代码在干什么了：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687533769875-da17bf23-a8a1-43f7-bd6f-ab4dcc867776-20240401193831-x3mq9iz.png)

i 和 end 标记了可以选择的跳跃步数，farthest 标记了所有选择 [i..end] 中能够跳到的最远距离，jumps 记录了跳跃次数。

本算法的时间复杂度 O(N)，空间复杂度 O(1)，可以说是非常高效，动态规划都被吊起来打了。

至此，两道跳跃问题都使用贪心算法解决了。

## 数学

### 一行代码就能解决的算法题

#### 292.「[Nim 游戏](https://leetcode.cn/problems/nim-game/)」

> 你和你的朋友，两个人一起玩 [Nim 游戏](https://baike.baidu.com/item/Nim%E6%B8%B8%E6%88%8F/6737105)：
>
> - 桌子上有一堆石头。
> - 你们轮流进行自己的回合， **你作为先手** 。
> - 每一回合，轮到的人拿掉 1 - 3 块石头。
> - 拿掉最后一块石头的人就是获胜者。
>
> 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。
>
> **示例 1：**   
> 输入：n = 4  
> 输出：false
>
>
> 解释：  
> 以下是可能的结果:
>
> 1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。
> 2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。
> 3. 你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。
     >
     >     在所有结果中，你的朋友是赢家。

你和你的朋友面前有一堆石子，你们轮流拿，一次至少拿一颗，最多拿三颗，谁拿走最后一颗石子谁获胜。

假设你们都很聪明，由你第一个开始拿，请你写一个算法，输入一个正整数 n，返回你是否能赢（true 或 false）。

比如现在有 4 颗石子，算法应该返回 false。因为无论你拿 1 颗 2 颗还是 3 颗，对方都能一次性拿完，拿走最后一颗石子，所以你一定会输。

首先，这道题肯定可以使用动态规划，因为显然原问题存在子问题，且子问题存在重复。但是因为你们都很聪明，涉及到你和对手的博弈，动态规划会比较复杂。

**我们解决这种问题的思路一般都是反着思考**：

**如果我能赢，那么最后轮到我取石子的时候必须要剩下 1~3 颗石子，这样我才能一把拿完。**

**如何营造这样的一个局面呢？显然，如果对手拿的时候只剩 4 颗石子，那么无论他怎么拿，总会剩下 1~3 颗石子，我就能赢。**

**如何逼迫对手面对 4 颗石子呢？要想办法，让我选择的时候还有 5~7 颗石子，这样的话我就有把握让对方不得不面对 4 颗石子。**

这样一直循环下去，我们发现只要踩到 4 的倍数，就落入了圈套，永远逃不出 4 的倍数，而且一定会输。所以这道题的解法非常简单：

```java
boolean canWinNim(int n) {
    // 如果上来就踩到 4 的倍数，那就认输吧
    // 否则，可以把对方控制在 4 的倍数，必胜
    return n % 4 != 0;
}
```

#### 877.「[石子游戏](https://leetcode.cn/problems/stone-game/)」

> Alice 和 Bob 用几堆石子在做游戏。一共有偶数堆石子，**排成一行**；每堆都有 **正** 整数颗石子，数目为 piles[i] 。
>
> 游戏以谁手中的石子最多来决出胜负。石子的 **总数** 是 **奇数** ，所以没有平局。
>
> Alice 和 Bob 轮流进行，**Alice 先开始** 。 每回合，玩家从行的 **开始** 或 **结束** 处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中 **石子最多** 的玩家 **获胜** 。
>
> 假设 Alice 和 Bob 都发挥出最佳水平，当 Alice 赢得比赛时返回 true ，当 Bob 赢得比赛时返回 false 。
>
> **示例 1：**   
> 输入：piles = [5,3,4,5]  
> 输出：true
>
> 解释： Alice 先开始，只能拿前 5 颗或后 5 颗石子 。  
> 假设他取了前 5 颗，这一行就变成了 [3,4,5] 。  
> 如果 Bob 拿走前 3 颗，那么剩下的是 [4,5]，Alice 拿走后 5 颗赢得 10 分。  
> 如果 Bob 拿走后 5 颗，那么剩下的是 [3,4]，Alice 拿走后 4 颗赢得 9 分。  
> 这表明，取前 5 颗石子对 Alice 来说是一个胜利的举动，所以返回 true 。

你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。

**假设你们都很聪明**，由你第一个开始拿，请你写一个算法，输入一个数组 piles，返回你是否能赢（true 或 false）。

注意，石头的堆的数量为偶数，所以你们两人拿走的堆数一定是相同的。石头的总数为奇数，也就是你们最后不可能拥有相同多的石头，一定有胜负之分。

举个例子，piles=[2, 1, 9, 5]，你先拿，可以拿 2 或者 5，你选择 2。

piles=[1, 9, 5]，轮到对手，可以拿 1 或 5，他选择 5。

piles=[1, 9] 轮到你拿，你拿 9。

最后，你的对手只能拿 1 了。

这样下来，你总共拥有 2 + 9 = 11 颗石头，对手有 5 + 1 = 6 颗石头，你是可以赢的，所以算法应该返回 true。

你看到了，并不是简单的挑数字大的选，为什么第一次选择 2 而不是 5 呢？因为 5 后面是 9，你要是贪图一时的利益，就把 9 这堆石头暴露给对手了，那你就要输了。

这也是强调双方都很聪明的原因，算法也是求最优决策过程下你是否能赢。

这道题又涉及到两人的博弈，也可以用动态规划算法暴力试，比较麻烦。但我们只要对规则深入思考，就会大惊失色：只要你足够聪明，你是必胜无疑的，因为你是先手。

```java
boolean stoneGame(int[] piles) {
    return true;
}
```

这是为什么呢，因为题目有两个条件很重要：一是石头总共有偶数堆，石头的总数是奇数。这两个看似增加游戏公平性的条件，反而使该游戏成为了一个割韭菜游戏。我们以 piles=[2, 1, 9, 5] 讲解，假设这四堆石头从左到右的索引分别是 1，2，3，4。

如果我们把这四堆石头按索引的奇偶分为两组，即第 1、3 堆和第 2、4 堆，那么这两组石头的数量一定不同，也就是说一堆多一堆少。因为石头的总数是奇数，不能被平分。

而作为第一个拿石头的人，你可以控制自己拿到所有偶数堆，或者所有的奇数堆。

你最开始可以选择第 1 堆或第 4 堆。如果你想要偶数堆，你就拿第 4 堆，这样留给对手的选择只有第 1、3 堆，他不管怎么拿，第 2 堆又会暴露出来，你就可以拿。同理，如果你想拿奇数堆，你就拿第 1 堆，留给对手的只有第 2、4 堆，他不管怎么拿，第 3 堆又给你暴露出来了。

也就是说，你可以在第一步就观察好，奇数堆的石头总数多，还是偶数堆的石头总数多，然后步步为营，就一切尽在掌控之中了。知道了这个漏洞，可以整一整不知情的同学了。

#### 319.「[灯泡开关](https://leetcode.cn/problems/bulb-switcher/)」

> 初始时有 `n`​ 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。
>
> 第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 `i`​ 轮，你每 `i`​ 个灯泡就切换第 `i`​ 个灯泡的开关。直到第 `n`​ 轮，你只需要切换最后一个灯泡的开关。
>
> 找出并返回 `n`​  轮后有多少个亮着的灯泡。
>
> **示例 1：**   
> 输入：n = 3  
> 输出：1
> 解释：  
> 初始时, 灯泡状态 [关闭, 关闭, 关闭].  
> 第一轮后, 灯泡状态 [开启, 开启, 开启].  
> 第二轮后, 灯泡状态 [开启, 关闭, 开启].  
> 第三轮后, 灯泡状态 [开启, 关闭, 关闭].
> 你应该返回 1，因为只有一个灯泡还亮着。

有 n 盏电灯，最开始时都是关着的。现在要进行 n 轮操作：

第 1 轮操作是把每一盏电灯的开关按一下（全部打开）。

第 2 轮操作是把每两盏灯的开关按一下（就是按第 2，4，6... 盏灯的开关，它们被关闭）。

第 3 轮操作是把每三盏灯的开关按一下（就是按第 3，6，9... 盏灯的开关，有的被关闭，比如 3，有的被打开，比如 6）...

如此往复，直到第 n 轮，即只按一下第 n 盏灯的开关。

现在给你输入一个正整数 n 代表电灯的个数，问你经过 n 轮操作后，这些电灯有多少盏是亮的？

我们当然可以用一个布尔数组表示这些灯的开关情况，然后模拟这些操作过程，最后去数一下就能出结果。但是这样显得没有灵性，最好的解法是这样的：

```java
int bulbSwitch(int n) {
    return (int)Math.sqrt(n);
}
```

什么？这个问题跟平方根有什么关系？其实这个解法挺精妙，如果没人告诉你解法，还真不好想明白。

首先，因为电灯一开始都是关闭的，所以某一盏灯最后如果是点亮的，必然要被按奇数次开关。

我们假设只有 6 盏灯，而且我们只看第 6 盏灯。需要进行 6 轮操作对吧，请问对于第 6 盏灯，会被按下几次开关呢？这不难得出，第 1 轮会被按，第 2 轮，第 3 轮，第 6 轮都会被按。

为什么第 1、2、3、6 轮会被按呢？因为 6=1*6=2*3。一般情况下，因子都是成对出现的，也就是说开关被按的次数一般是偶数次。但是有特殊情况，比如说总共有 16 盏灯，那么第 16 盏灯会被按几次?

**16 =**  **1*16 =**  **2*8 =**  **4*4**

**其中因子 4 重复出现，所以第 16 盏灯会被按 5 次，奇数次。现在你应该理解这个问题为什么和平方根有关了吧？**

**不过，我们不是要算最后有几盏灯亮着吗，这样直接平方根一下是啥意思呢？稍微思考一下就能理解了。**

**就假设现在总共有 16 盏灯，我们求 16 的平方根，等于 4，这就说明最后会有 4 盏灯亮着，它们分别是第 1*1=1 盏、第 2*2=4 盏、第 3*3=9 盏和第 4*4=16 盏。**

就算有的 n 平方根结果是小数，强转成 int 型，也相当于一个最大整数上界，比这个上界小的所有整数，平方后的索引都是最后亮着的灯的索引。所以说我们直接把平方根转成整数，就是这个问题的答案。

### 随机算法

#### 洗牌算法

洗牌算法，也称随机乱置算法，就是为了解决随机打乱一个数组的问题

##### 384.「[打乱数组](https://leetcode.cn/problems/shuffle-an-array/)」

> 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 **等可能** 的。  
> 实现 Solution class:
>
> - Solution(int[] nums) 使用整数数组 nums 初始化对象
> - int[] reset() 重设数组到它的初始状态并返回
> - int[] shuffle() 返回数组随机打乱后的结果
>
> **示例 1：**
>
> 输入
>
> ["Solution", "shuffle", "reset", "shuffle"]  
> [[[1, 2, 3]], [], [], []]
>
> 输出  
> [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]
>
> 解释  
> Solution solution = new Solution([1, 2, 3]);  
> solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]  
> solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]  
> solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]

这个 shuffle 函数是算法的关键，直接看解法代码吧：

```java
class Solution {
    private int[] nums;
    private Random rand = new Random();
  
    public Solution(int[] nums) {
        this.nums = nums;
    }
  
    public int[] reset() {
        return nums;
    }
  
    // 洗牌算法
    public int[] shuffle() {
        int n = nums.length;
        int[] copy =  Arrays.copyOf(nums, n);
        for (int i = 0 ; i < n; i++) {
            // 生成一个 [i, n-1] 区间内的随机数
            int r = i + rand.nextInt(n - i);
            // 交换 nums[i] 和 nums[r]
            swap(copy, i, r);
        }
        return copy;
    }
  
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

洗牌算法的时间复杂度是 O(N)，而且逻辑很简单，关键在于让你证明为什么这样做是正确的。排序算法的结果是唯一可以很容易检验的，但随机乱置算法不一样，乱可以有很多种，你怎么能证明你的算法是「真的乱」呢？

**分析洗牌算法正确性的准则：产生的结果必须有 n! 种可能**。这个很好解释，因为一个长度为 n 的数组的全排列就有 n! 种，也就是说打乱结果总共有 n! 种。算法必须能够反映这个事实，才是正确的。

有了这个原则再看代码应该就容易理解了：

对于 nums[0]，我们把它随机换到了索引 [0, n) 上，共有 n 种可能性；

对于 nums[1]，我们把它随机换到了索引 [1, n) 上，共有 n - 1 种可能性；

对于 nums[2]，我们把它随机换到了索引 [2, n) 上，共有 n - 2 种可能性；

以此类推，该算法可以生成 n! 种可能的结果，所以这个算法是正确的，能够保证随机性。

#### 水塘抽样算法

我们如果面对「在若干元素中随机选择 k 个元素」这个问题，那该如何解决呢。

要知道洗牌算法能够生效的前提是你使用数组这种数据结构，如果让你在一条链表中随机选择 k 个元素，肯定不能再用洗牌算法来蒙混过关了。

再比如，假设我们的扫雷游戏中棋盘的长和宽非常大，已经不能在内存中装下一个大小为 m * n 的 board 数组了，我们只能维护一个大小为 k 的数组记录雷的位置：

```java
class Game {
    // 棋盘的行数和列数（非常大）
    int m, n;
    // 长度为 k 的数组，记录 k 个雷的一维索引
    int[] mines;

    // 将二维数组中的坐标 (x, y) 转化为一维数组中的索引
    int encode(int x, int y) {
        return x * n + y;
    }

    // 将一维数组中的索引转化为二维数组中的坐标 (x, y)
    int[] decode(int index) {
        return new int[] {index / n, index % n};
    }
}
```

这样的话，我们必须想办法在 [0, m*n) 中随机选取 k 个不同的数字了。

**这就是常见的随机抽样场景，常用的解法是水塘抽样算法（Reservoir Sampling）** 。水塘抽样算法是一种随机概率算法，会者不难，难者不会。

##### 382.「[链表随机节点](https://leetcode.cn/problems/linked-list-random-node/)」

> 给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 **被选中的概率一样** 。
>
> 实现 Solution 类：
>
> - Solution(ListNode head) 使用整数数组初始化对象。
> - int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。
>
> **示例：**
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687666894176-7831d520-4677-454c-ae92-5da9aa62b4fe-20240401200342-4fwnte3.png)​
>
> 输入
>
> ["Solution", "getRandom", "getRandom", "getRandom", "getRandom", "getRandom"]  
> [[[1, 2, 3]], [], [], [], [], []]
>
> 输出
>
> [null, 1, 3, 2, 2, 3]

这里说的随机是均匀随机（uniform random），也就是说，如果有 n 个元素，每个元素被选中的概率都是 1/n，不可以有统计意义上的偏差。

一般的想法就是，我先遍历一遍链表，得到链表的总长度 n，再生成一个 [0,n-1) 之间的随机数为索引，然后找到索引对应的节点。但这不符合只能遍历一次链表的要求。

这个问题的难点在于随机选择是「动态」的，比如说你现在你已经遍历了 5 个元素，你已经随机选取了其中的某个元素 a 作为结果，但是现在再给你一个新元素 b，你应该留着 a 还是将 b 作为结果呢？以什么逻辑做出的选择，才能保证你的选择方法在概率上是公平的呢？

**先说结论，当你遇到第 i 个元素时，应该有 1/i 的概率选择该元素，1 - 1/i 的概率保持原有的选择**。看代码容易理解这个思路：

```java
/* 返回链表中一个随机节点的值 */
int getRandom(ListNode head) {
    Random r = new Random();
    int i = 0, res = 0;
    ListNode p = head;
    // while 循环遍历链表
    while (p != null) {
        i++;
        // 生成一个 [0, i) 之间的整数
        // 这个整数等于 0 的概率就是 1/i
        if (0 == r.nextInt(i)) {
            res = p.val;
        }
        p = p.next;
    }
    return res;
}
```

对于概率算法，代码往往都是很浅显的，但是这种问题的关键在于证明，你的算法为什么是对的？为什么每次以 1/i 的概率更新结果就可以保证结果是平均随机的？

我们来证明一下，假设总共有 n 个元素，我们要的随机性无非就是每个元素被选择的概率都是 1/n 对吧，那么对于第 i 个元素，它被选择的概率就是：

![1687666941191-18a377eb-6b47-4f29-b81e-cd05dc550a1c](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687666941191-18a377eb-6b47-4f29-b81e-cd05dc550a1c-20240401200343-l5gqm09.png)

第 i 个元素被选择的概率是 1/i，在第 i+1 次不被替换的概率是 1 - 1/(i+1)，在第 i+2 次不被替换的概率是 1 - 1/(i+2)，以此类推，相乘的结果是第 i 个元素最终被选中的概率，也就是 1/n。因此，该算法的逻辑是正确的。

##### 398.「[随机数索引](https://leetcode.cn/problems/random-pick-index/)」

> 给你一个可能含有 **重复元素** 的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组中。
>
> 实现 Solution 类：
>
> - Solution(int[] nums) 用数组 nums 初始化对象。
> - int pick(int target) 从 nums 中选出一个满足 nums[i] == target 的随机索引 i 。如果存在多个有效的索引，则每个索引的返回概率应当相等。
>
> **示例：**
>
> 输入  
> ["Solution", "pick", "pick", "pick"]  
> [[[1, 2, 3, 3, 3]], [3], [1], [3]]
>
> 输出  
> [null, 4, 0, 2]
>
> 解释  
> Solution solution = new Solution([1, 2, 3, 3, 3]);  
> solution.pick(3); // 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。  
> solution.pick(1); // 返回 0 。因为只有 nums[0] 等于 1 。  
> solution.pick(3); // 随机返回索引 2, 3 或者 4 之一。每个索引的返回概率应该相等。

**如果要在单链表中随机选择 k 个数，只要在第 i 个元素处以 k/i 的概率选择该元素，以 1 - k/i 的概率保持原有选择即可**。代码如下：

```java
/* 返回链表中 k 个随机节点的值 */
int[] getRandom(ListNode head, int k) {
    Random r = new Random();
    int[] res = new int[k];
    ListNode p = head;

    // 前 k 个元素先默认选上
    for (int i = 0; i < k && p != null; i++) {
        res[i] = p.val;
        p = p.next;
    }

    int i = k;
    // while 循环遍历链表
    while (p != null) {
        i++;
        // 生成一个 [0, i) 之间的整数
        int j = r.nextInt(i);
        // 这个整数小于 k 的概率就是 k/i
        if (j < k) {
            res[j] = p.val;
        }
        p = p.next;
    }
    return res;
}
```

这个思路可以解决力扣第 。对于算法正确性的数学证明，和上面区别不大：

![1687667076092-936e66a6-507c-4adb-a348-66b08f91a4f7](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687667076092-936e66a6-507c-4adb-a348-66b08f91a4f7-20240401200343-zlnprm3.png)

虽然每次更新选择的概率增大了 k 倍，但是选到具体第 i 个元素的概率还是要乘 1/k，也就回到了上一个推导。

类似的，回到扫雷游戏的随机初始化问题，我们可以写一个这样的 sample 抽样函数：

```java
// 在区间 [lo, hi) 中随机抽取 k 个数字
int[] sample(int lo, int hi, int k) {
    Random r = new Random();
    int[] res = new int[k];

    // 前 k 个元素先默认选上
    for (int i = 0; i < k; i++) {
        res[i] = lo + i;
    }

    int i = k;
    // while 循环遍历数字区间
    while (i < hi - lo) {
        i++;
        // 生成一个 [0, i) 之间的整数
        int j = r.nextInt(i);
        // 这个整数小于 k 的概率就是 k/i
        if (j < k) {
            res[j] = lo + i - 1;
        }
    }
    return res;
}
```

这个函数能够在一定的区间内随机选择 k 个数字，确保抽样结果是均匀随机的且只需要 O(N) 的时间复杂度。

回到正题：

这题按理说可以使用 HashMap 来做，存储元素到索引列表的映射，然后随机从列表中取出一个元素，但是似乎这题对空间复杂度的要求较高，这个简单直接的方式会超过内存限制。

所以我们只好用时间换空间，每次 pick 都遍历一遍 nums 数组，用水塘抽样算法从中随机选出一个索引。

> 结论：当你遇到第 i 个元素时，应该有 1/i 的概率选择该元素，1 - 1/i 的概率保持原有的选择。

```java
class Solution {
    int[] nums;
    Random rand;

    public Solution(int[] nums) {
        this.nums = nums;
        this.rand = new Random();
    }

    public int pick(int target) {
        int count = 0, res = -1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != target) {
                continue;
            }
            count++;
            if (rand.nextInt(count) == 0) {
                res = i;
            }
        }

        return res;
    }
}
```

### 常用的位操作

#### 几个有趣的位操作

1. **利用或操作 | 和空格将英文字符转换为小写**

```java
('a' | ' ') = 'a'
('A' | ' ') = 'a'
```

1. **利用与操作 &amp; 和下划线将英文字符转换为大写**

```java
('b' & '_') = 'B'
('B' & '_') = 'B'
```

1. **利用异或操作 ^ 和空格进行英文字符大小写互换**

```java
('d' ^ ' ') = 'D'
('D' ^ ' ') = 'd'
```

以上操作能够产生奇特效果的原因在于 ASCII 编码。ASCII 字符其实就是数字，恰巧空格和下划线对应的数字通过位运算就能改变大小写。有兴趣的读者可以查 ASCII 码表自己算算，本文就不展开讲了。

1. **不用临时变量交换两个数**

```java
int a = 1, b = 2;
a ^= b;
b ^= a;
a ^= b;
// 现在 a = 2, b = 1
```

1. **加一**

```java
int n = 1;
n = -~n;
// 现在 n = 2
```

1. **减一**

```java
int n = 2;
n = ~-n;
// 现在 n = 1
```

1. **判断两个数是否异号**

```java
int x = -1, y = 2;
boolean f = ((x ^ y) < 0); // true

int x = 3, y = 2;
boolean f = ((x ^ y) < 0); // false
```

如果说前 6 个技巧的用处不大，这第 7 个技巧还是比较实用的，利用的是**补码编码**的符号位。整数编码最高位是符号位，负数的符号位是 1，非负数的符号位是 0，再借助异或的特性，可以判断出两个数字是否异号。

当然，如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。你可能想利用乘积来判断两个数是否异号，但是这种处理方式容易造成整型溢出，从而出现错误。

#### index & (arr.length - 1) 的运用

我在 [单调栈解题套路](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-daeca/dan-diao-z-1bebe/) 中介绍过环形数组，其实就是利用求模（余数）的方式让数组看起来头尾相接形成一个环形，永远都走不完：

```java
int[] arr = {1,2,3,4};
int index = 0;
while (true) {
    // 在环形数组中转圈
    print(arr[index % arr.length]);
    index++;
}
// 输出：1,2,3,4,1,2,3,4,1,2,3,4...
```

但模运算 % 对计算机来说其实是一个比较昂贵的操作，所以我们可以用 & 运算来求余数：

```java
int[] arr = {1,2,3,4};
int index = 0;
while (true) {
    // 在环形数组中转圈
    print(arr[index & (arr.length - 1)]);
    index++;
}
// 输出：1,2,3,4,1,2,3,4,1,2,3,4...
```

> **Note**
>
> 注意这个技巧只适用于数组长度是 2 的幂次方的情况，比如 2、4、8、16、32 以此类推。至于如何将数组长度扩展为 2 的幂次方，这也是有比较巧妙的位运算算法的，可以参考 [https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2](https://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2)

简单说，& (arr.length - 1) 这个位运算能够替代 % arr.length 的模运算，性能会更好一些。

那问题来了，现在是不断地 index++，你做到了循环遍历。但如果不断地 index--，还能做到环形数组的效果吗？

答案是，如果你使用 % 求模的方式，那么当 index 小于 0 之后求模的结果也会出现负数，你需要特殊处理。但通过 & 与运算的方式，index 不会出现负数，依然可以正常工作：

```java
int[] arr = {1,2,3,4};
int index = 0;
while (true) {
    // 在环形数组中转圈
    print(arr[index & (arr.length - 1)]);
    index--;
}
// 输出：1,4,3,2,1,4,3,2,1,4,3,2,1...
```

我们自己写代码一般用不到这个技巧，但在学习一些其他代码库时可能会经常看到，这里留个印象，到时候就不会懵逼了。

#### n & (n-1) 的运用

**n &amp; (n-1) 这个操作在算法中比较常见，作用是消除数字 n 的二进制表示中的最后一个 1**。

看个图就很容易理解了：

![1687671617454-553cc2aa-eb93-475f-9870-f0e586147f0e](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687671617454-553cc2aa-eb93-475f-9870-f0e586147f0e-20240401203035-ge4ru59.png)

其核心逻辑就是，n - 1 一定可以消除最后一个 1，同时把其后的 0 都变成 1，这样再和 n 做一次 & 运算，就可以仅仅把最后一个 1 变成 0 了。

**1、计算汉明权重（Hamming Weight)**

##### 191.「[位 1 的个数](https://leetcode.cn/problems/number-of-1-bits/)」

> 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F)）。
>
> **示例 1：**   
> 输入：n = 00000000000000000000000000001011  
> 输出：3  
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

就是让你返回 n 的二进制表示中有几个 1。因为 n & (n - 1) 可以消除最后一个 1，所以可以用一个循环不停地消除 1 同时计数，直到 n 变成 0 为止。

```java
int hammingWeight(int n) {
    int res = 0;
    while (n != 0) {
        n = n & (n - 1);
        res++;
    }
    return res;
}
```

**2、判断一个数是不是 2 的指数**

##### 231.「[2 的幂](https://leetcode.cn/problems/power-of-two/)」

> 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。
>
> 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。
>
> **示例 1：**   
> 输入：n = 1  
> 输出：true  
> 解释：2^0 = 1

一个数如果是 2 的指数，那么它的二进制表示一定只含有一个 1：

```java
2^0 = 1 = 0b0001
2^1 = 2 = 0b0010
2^2 = 4 = 0b0100
```

如果使用 n & (n-1) 的技巧就很简单了（注意运算符优先级，括号不可以省略）：

```java
boolean isPowerOfTwo(int n) {
    if (n <= 0) return false;
    return (n & (n - 1)) == 0;
}
```

#### a ^ a = 0 的运用

异或运算的性质是需要我们牢记的：

一个数和它本身做异或运算结果为 0，即 a ^ a = 0；一个数和 0 做异或运算的结果为它本身，即 a ^ 0 = a。  
**1、查找只出现一次的元素**

##### 136.「[只出现一次的数字](https://leetcode.cn/problems/single-number/)」

> 给你一个 **非空** 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
> 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
>
> **示例 1 ：**   
> 输入：nums = [2,2,1]  
> 输出：1

对于这道题目，我们只要把所有数字进行异或，成对儿的数字就会变成 0，落单的数字和 0 做异或还是它本身，所以最后异或的结果就是只出现一次的元素：

```java
int singleNumber(int[] nums) {
    int res = 0;
    for (int n : nums) {
        res ^= n;
    }
    return res;
}
```

**2、寻找缺失的元素**

##### 268.「[丢失的数字](https://leetcode.cn/problems/missing-number/)」

> 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
>
> **示例 1：**   
> 输入：nums = [3,0,1]  
> 输出：2  
> 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。

给一个长度为 n 的数组，其索引应该在 [0,n)，但是现在你要装进去 n + 1 个元素 [0,n]，那么肯定有一个元素装不下嘛，请你找出这个缺失的元素。

这道题不难的，我们应该很容易想到，把这个数组排个序，然后遍历一遍，不就很容易找到缺失的那个元素了吗？

或者说，借助数据结构的特性，用一个 HashSet 把数组里出现的数字都储存下来，再遍历 [0,n] 之间的数字，去 HashSet 中查询，也可以很容易查出那个缺失的元素。

排序解法的时间复杂度是 O(NlogN)，HashSet 的解法时间复杂度是 O(N)，但是还需要 O(N) 的空间复杂度存储 HashSet。

这个问题其实还有一个特别简单的解法：等差数列求和公式。

题目的意思可以这样理解：现在有个等差数列 0, 1, 2,..., n，其中少了某一个数字，请你把它找出来。那这个数字不就是 sum(0,1,..n) - sum(nums) 嘛？

```java
int missingNumber(int[] nums) {
    int n = nums.length;
    // 虽然题目给的数据范围不大，但严谨起见，用 long 类型防止整型溢出
    // 求和公式：(首项 + 末项) * 项数 / 2
    long expect = (0 + n) * (n + 1) / 2;
    long sum = 0;
    for (int x : nums) {
        sum += x;
    }
    return (int)(expect - sum);
}
```

不过，本文的主题是位运算，我们来讲讲如何利用位运算技巧来解决这道题。

再回顾一下异或运算的性质：一个数和它本身做异或运算结果为 0，一个数和 0 做异或运算还是它本身。

而且异或运算满足交换律和结合律，也就是说：

```java
2 ^ 3 ^ 2 = 3 ^ (2 ^ 2) = 3 ^ 0 = 3
```

而这道题索就可以通过这些性质巧妙算出缺失的那个元素，比如说 nums = [0,3,1,4]：

![1687672446058-d9354c12-1fc8-4b6e-be9b-51eb8a124277](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687672446058-d9354c12-1fc8-4b6e-be9b-51eb8a124277-20240401203035-h3i9rcr.jpeg)

为了容易理解，我们假设先把索引补一位，然后让每个元素和自己相等的索引相对应：

![1687672446055-9f918070-7f28-4cfb-b058-876d3772c5a4](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687672446055-9f918070-7f28-4cfb-b058-876d3772c5a4-20240401203035-gz97syx.jpeg)

这样做了之后，就可以发现除了缺失元素之外，所有的索引和元素都组成一对儿了，现在如果把这个落单的索引 2 找出来，也就找到了缺失的那个元素。

如何找这个落单的数字呢，**只要把所有的元素和索引做异或运算，成对儿的数字都会消为 0，只有这个落单的元素会剩下**，也就达到了我们的目的：

```java
int missingNumber(int[] nums) {
    int n = nums.length;
    int res = 0;
    // 先和新补的索引异或一下
    res ^= n;
    // 和其他的元素、索引做异或
    for (int i = 0; i < n; i++)
        res ^= i ^ nums[i];
    return res;
}
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687672561408-882c651b-a038-4b36-8cc4-00ec603f7abb-20240401203036-o2kfns6.png)

由于异或运算满足交换律和结合律，所以总是能把成对儿的数字消去，留下缺失的那个元素。

到这里，常见的位运算差不多都讲完了。这些技巧就是会者不难难者不会，也不需要死记硬背，只要有个印象就完全够用了。

### 两道常考的阶乘算法题

**1、输入一个非负整数 n，请你计算阶乘 n! 的结果末尾有几个 0**。

#### 172.「[阶乘后的零](https://leetcode.cn/problems/factorial-trailing-zeroes/)」

> 给定一个整数 n ，返回 n! 结果中尾随零的数量。
>
> 提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1
>
> **示例 1：**   
> 输入：n = 5  
> 输出：1  
> 解释：5! = 120 ，有一个尾随 0

肯定不可能真去把 n! 的结果算出来，阶乘增长可是比指数增长都恐怖，趁早死了这条心吧。

那么，结果的末尾的 0 从哪里来的？我们有没有投机取巧的方法计算出来？

首先，两个数相乘结果末尾有 0，一定是因为两个数中有因子 2 和 5，因为 10 = 2 x 5。

**也就是说，问题转化为：n! 最多可以分解出多少个因子 2 和 5**？

比如说 n = 25，那么 25! 最多可以分解出几个 2 和 5 相乘？这个主要取决于能分解出几个因子 5，因为每个偶数都能分解出因子 2，因子 2 肯定比因子 5 多得多。

25! 中 5 可以提供一个，10 可以提供一个，15 可以提供一个，20 可以提供一个，25 可以提供两个，总共有 6 个因子 5，所以 25! 的结果末尾就有 6 个 0。

**现在，问题转化为：n! 最多可以分解出多少个因子 5**？

难点在于像 25，50，125 这样的数，可以提供不止一个因子 5，怎么才能不漏掉呢？

这样，我们假设 n = 125，来算一算 125! 的结果末尾有几个 0：

首先，125 / 5 = 25，这一步就是计算有多少个像 5，15，20，25 这些 5 的倍数，它们一定可以提供一个因子 5。

但是，这些足够吗？刚才说了，像 25，50，75 这些 25 的倍数，可以提供两个因子 5，那么我们再计算出 125! 中有 125 / 25 = 5 个 25 的倍数，它们每人可以额外再提供一个因子 5。

够了吗？我们发现 125 = 5 x 5 x 5，像 125，250 这些 125 的倍数，可以提供 3 个因子 5，那么我们还得再计算出 125! 中有 125 / 125 = 1 个 125 的倍数，它还可以额外再提供一个因子 5。

这下应该够了，125! 最多可以分解出 25 + 5 + 1 = 31 个因子 5，也就是说阶乘结果的末尾有 31 个 0。

理解了这个思路，就可以理解解法代码了：

```java
class Solution {
    int trailingZeroes(int n) {
        int res = 0;
        long divisor = 5;
        while (divisor <= n) {
            res += n / divisor;
            divisor *= 5;
        }
        return res;
    }
}
```

这里 divisor 变量使用 long 型，因为假如 n 比较大，考虑 while 循环的结束条件，divisor 可能出现整型溢出。

上述代码可以改写地更简单一些：

```java
class Solution {
    int trailingZeroes(int n) {
        int res = 0;
        for (int d = n; d / 5 > 0; d = d / 5) {
            res += d / 5;
        }
        return res;
    }
}
```

**2、输入一个非负整数 K，请你计算有多少个 n，满足 n! 的结果末尾恰好有 K 个 0**。

#### 793.「[阶乘后 K 个零](https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/)」

> f(x) 是 x! 末尾是 0 的数量。回想一下 x! = 1 * 2 * 3 * ... * x，且 0! = 1 。
>
> - 例如， f(3) = 0 ，因为 3! = 6 的末尾没有 0 ；而 f(11) = 2 ，因为 11!= 39916800 末端有 2 个 0 。
>
> 给定 k，找出返回能满足 f(x) = k 的非负整数 x 的数量。
>
> **示例 1：**   
> 输入：k = 0  
> 输出：5  
> 解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。

现在是给你一个非负整数 K，问你有多少个 n，使得 n! 结果末尾有 K 个 0。

一个直观地暴力解法就是穷举呗，因为随着 n 的增加，n! 肯定是递增的，trailingZeroes(n!) 肯定也是递增的，伪码逻辑如下：

```java
int res = 0;
for (int n = 0; n < +inf; n++) {
    if (trailingZeroes(n) < K) {
        continue;
    }
    if (trailingZeroes(n) > K) {
        break;
    }
    if (trailingZeroes(n) == K) {
        res++;
    }
}
return res;
```

前文 [二分查找如何运用](https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/er-fen-sou-ae51e/) 说过，**对于这种具有单调性的函数，用 for 循环遍历，可以用二分查找进行降维打击**，对吧？

搜索有多少个 n 满足 trailingZeroes(n) == K，其实就是在问，**满足条件的 n 最小是多少，最大是多少，最大值和最小值一减，就可以算出来有多少个 n 满足条件了**，对吧？那不就是 [二分查找](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/wo-xie-le--3c789/) 中「搜索左侧边界」和「搜索右侧边界」这两个事儿嘛？

先不急写代码，因为二分查找需要给一个搜索区间，也就是上界和下界，上述伪码中 n 的下界显然是 0，但上界是 +inf，这个正无穷应该如何表示出来呢？

首先，数学上的正无穷肯定是无法编程表示出来的，我们一般的方法是用一个非常大的值，大到这个值一定不会被取到。比如说 int 类型的最大值 INT_MAX（2\^31 - 1，大约 31 亿），还不够的话就 long 类型的最大值 LONG_MAX（2\^63 - 1，这个值就大到离谱了）。

那么我怎么知道需要多大才能「一定不会被取到」呢？**这就需要认真读题，看看题目给的数据范围有多大**。

这道题目实际上给了限制，K 是在 [0, 10\^9] 区间内的整数，也就是说，trailingZeroes(n) 的结果最多可以达到 10\^9。

然后我们可以反推，当 trailingZeroes(n) 结果为 10\^9 时，n 为多少？这个不需要你精确计算出来，你只要找到一个数 hi，使得 trailingZeroes(hi) 比 10\^9 大，就可以把 hi 当做正无穷，作为搜索区间的上界。

刚才说了，trailingZeroes 函数是单调函数，那我们就可以猜，先算一下 trailingZeroes(INT_MAX) 的结果，比 10\^9 小一些，那再用 LONG_MAX 算一下，远超 10\^9 了，所以 LONG_MAX 可以作为搜索的上界。

**注意为了避免整型溢出的问题，trailingZeroes 函数需要把所有数据类型改成 long**：

```java
// 逻辑不变，数据类型全部改成 long
long trailingZeroes(long n) {
    long res = 0;
    for (long d = n; d / 5 > 0; d = d / 5) {
        res += d / 5;
    }
    return res;
}
```

现在就明确了问题：

**在区间 [0, LONG_MAX] 中寻找满足 trailingZeroes(n) == K 的左侧边界和右侧边界**。

根据前文 [二分查找算法框架](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/wo-xie-le--3c789/)，可以直接把搜索左侧边界和右侧边界的框架 copy 过来：

```java
class Solution {
    public int preimageSizeFZF(int k) {
        return (int) (rightBound(k) - leftBound(k) + 1);
    }

    private long leftBound(int target) {
        long left = 0, right = Long.MAX_VALUE;
        while (left <= right) {
            long mid = left + (right - left) / 2;
            long zeros = countZeros(mid);
            if (zeros < target) {
                left = mid + 1;
            } else if (zeros > target) {
                right = mid - 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }

    private long rightBound(int target) {
        long left = 0, right = Long.MAX_VALUE;
        while (left <= right) {
            long mid = left + (right - left) / 2;
            long zeros = countZeros(mid);
            if (zeros < target) {
                left = mid + 1;
            } else if (zeros > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return right;
    }

    private long countZeros(long n) {
        long res = 0;
        for (long d = n; d / 5 > 0; d = d / 5) {
            res += d / 5;
        }
        return res;
    }
}
```

如果对二分查找的框架有任何疑问，建议好好复习一下前文 [二分查找算法框架](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/wo-xie-le--3c789/)，这里就不展开了。

现在，这道题基本上就解决了，我们来分析一下它的时间复杂度吧。

时间复杂度主要是二分搜索，从数值上来说 LONG_MAX 是 2^63 - 1，大得离谱，但是二分搜索是对数级的复杂度，log(LONG_MAX) 是一个常数；每次二分的时候都会调用一次 trailingZeroes 函数，复杂度 O(logK)；所以总体的时间复杂度就是 O(logK)。

### 如何高效寻找素数

素数的定义看起来很简单，如果一个数如果只能被 1 和它本身整除，那么这个数就是素数。

虽然素数的定义并不复杂，恐怕没多少人真的能把素数相关的算法写得高效。

#### 204.「[计数质数](https://leetcode.cn/problems/count-primes/)」

> 给定整数 n ，返回 *所有小于非负整数 n 的质数的数量* 。
>
> **示例 1：**   
> 输入：n = 10  
> 输出：4  
> 解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。

你会如何写这个函数？我想大家应该会这样写：

```java
int countPrimes(int n) {
    int count = 0;
    for (int i = 2; i < n; i++)
        if (isPrime(i)) count++;
    return count;
}

// 判断整数 n 是否是素数
boolean isPrime(int n) {
    for (int i = 2; i < n; i++)
        if (n % i == 0)
            // 有其他整除因子
            return false;
    return true;
}
```

这样写的话时间复杂度 O(n^2)，问题很大。**首先你用 isPrime 函数来辅助的思路就不够高效；而且就算你要用 isPrime 函数，这样写算法也是存在计算冗余的**。

先来简单说下**如果你要判断一个数是不是素数，应该如何写算法**。只需稍微修改一下上面的 isPrime 代码中的 for 循环条件：

```java
boolean isPrime(int n) {
    for (int i = 2; i * i <= n; i++)
        ...
}
```

换句话说，i 不需要遍历到 n，而只需要到 sqrt(n) 即可。为什么呢，我们举个例子，假设 n = 12。

```java
12 = 2 × 6
12 = 3 × 4
12 = sqrt(12) × sqrt(12)
12 = 4 × 3
12 = 6 × 2
```

可以看到，后两个乘积就是前面两个反过来，反转临界点就在 sqrt(n)。

换句话说，如果在 [2,sqrt(n)] 这个区间之内没有发现可整除因子，就可以直接断定 n 是素数了，因为在区间 [sqrt(n),n] 也一定不会发现可整除因子。

现在，isPrime 函数的时间复杂度降为 O(sqrt(N))，**但是我们实现 countPrimes 函数其实并不需要这个函数**，以上只是希望读者明白 sqrt(n) 的含义，因为等会还会用到。

##### 高效实现 countPrimes

接下来介绍的方法叫做「素数筛选法」，这个方法是古希腊一位名叫埃拉托色尼的大佬发明的，我们在中学的教课书上见过他的大名，因为他就是第一个通过物体的影子正确计算地球周长的人，被推崇为「地理学之父」。

回到正题，素数筛选法的核心思路是和上面的常规思路反着来：

首先从 2 开始，我们知道 2 是一个素数，那么 2 × 2 = 4, 3 × 2 = 6, 4 × 2 = 8... 都不可能是素数了。

然后我们发现 3 也是素数，那么 3 × 2 = 6, 3 × 3 = 9, 3 × 4 = 12... 也都不可能是素数了。

Wikipedia 的这个 GIF 很形象：

![1.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687766875435-af45bd4d-b715-4100-8888-88c7112c720e-20240406164306-auwiy1t.gif)

看到这里，你是否有点明白这个排除法的逻辑了呢？先看我们的第一版代码：

```java
int countPrimes(int n) {
    boolean[] isPrime = new boolean[n];
    // 将数组都初始化为 true
    Arrays.fill(isPrime, true);

    for (int i = 2; i < n; i++) 
        if (isPrime[i]) 
            // i 的倍数不可能是素数了
            for (int j = 2 * i; j < n; j += i) 
                    isPrime[j] = false;
  
    int count = 0;
    for (int i = 2; i < n; i++)
        if (isPrime[i]) count++;
  
    return count;
}
```

如果上面这段代码你能够理解，那么你已经掌握了整体思路，但是还有两个细微的地方可以优化。

首先，回想刚才判断一个数是否是素数的 isPrime 函数，由于因子的对称性，其中的 for 循环只需要遍历 [2,sqrt(n)] 就够了。这里也是类似的，我们外层的 for 循环也只需要遍历到 sqrt(n)：

```java
for (int i = 2; i * i < n; i++) 
    if (isPrime[i]) 
        ...
```

除此之外，很难注意到内层的 for 循环也可以优化。我们之前的做法是：

```java
for (int j = 2 * i; j < n; j += i) 
    isPrime[j] = false;
```

这样可以把 i 的整数倍都标记为 false，但是仍然存在计算冗余。

比如 n = 25，i = 5 时算法会标记 5 × 2 = 10，5 × 3 = 15 等等数字，但是这两个数字已经被 i = 2 和 i = 3 的 2 × 5 和 3 × 5 标记了。

我们可以稍微优化一下，让 j 从 i 的平方开始遍历，而不是从 2 * i 开始：

```java
for (int j = i * i; j < n; j += i) 
    isPrime[j] = false;
```

这样，素数计数的算法就高效实现了，其实这个算法有一个名字，叫做 Sieve of Eratosthenes。看下完整的最终代码：

```java
class Solution {
    public int countPrimes(int n) {
        boolean[] isPrime = new boolean[n];
        Arrays.fill(isPrime, true);
        for (int i = 2; i * i < n; i++) 
            if (isPrime[i]) 
                for (int j = i * i; j < n; j += i) 
                    isPrime[j] = false;
    
        int count = 0;
        for (int i = 2; i < n; i++)
            if (isPrime[i]) count++;
    
        return count;
    }
}
```

**该算法的时间复杂度比较难算**，显然时间跟这两个嵌套的 for 循环有关，其操作数应该是：

n/2 + n/3 + n/5 + n/7 + ...  
= n × (1/2 + 1/3 + 1/5 + 1/7...)

括号中是素数的倒数。其最终结果是 O(N * loglogN)，有兴趣的读者可以查一下该算法的时间复杂度证明。

### 如何同时寻找缺失和重复的元素

#### 645.「[错误的集合](https://leetcode.cn/problems/set-mismatch/)」

> 集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 **丢失了一个数字** 并且 **有一个数字重复** 。
>
> 给定一个数组 nums 代表了集合 S 发生错误后的结果。
>
> 请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。
>
> **示例 1：**   
> 输入：nums = [1,2,2,4]  
> 输出：[2,3]

其实很容易解决这个问题，先遍历一次数组，用一个哈希表记录每个数字出现的次数，然后遍历一次 [1..N]，看看那个元素重复出现，那个元素没有出现，就 OK 了。

但问题是，这个常规解法需要一个哈希表，也就是 O(N) 的空间复杂度。你看题目给的条件那么巧，在 [1..N] 的几个数字中恰好有一个重复，一个缺失，**事出反常必有妖**，对吧。

O(N) 的时间复杂度遍历数组是无法避免的，所以我们可以想想办法如何降低空间复杂度，是否可以在 O(1) 的空间复杂度之下找到重复和缺失的元素呢？

这个问题的特点是，每个元素和数组索引有一定的对应关系。

我们现在自己改造下问题，**暂且将 nums 中的元素变为 [0..N-1]，这样每个元素就和一个数组索引完全对应了，这样方便理解一些**。

如果说 nums 中不存在重复元素和缺失元素，那么每个元素就和唯一一个索引值对应，对吧？

现在的问题是，有一个元素重复了，同时导致一个元素缺失了，这会产生什么现象呢？**会导致有两个元素对应到了同一个索引，而且会有一个索引没有元素对应过去**。

那么，如果我能够通过某些方法，找到这个重复对应的索引，不就是找到了那个重复元素么？找到那个没有元素对应的索引，不就是找到了那个缺失的元素了么？

那么，如何不使用额外空间判断某个索引有多少个元素对应呢？这就是这个问题的精妙之处了：

**通过将每个索引对应的元素变成负数，以表示这个索引被对应过一次了**，算法过程如下 GIF 所示：

![1687768988638-b819aa04-8f3e-4f9e-b40b-9280d02c4e61](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687768988638-b819aa04-8f3e-4f9e-b40b-9280d02c4e61-20240406165600-wb7lf2t.gif)

如果出现重复元素 4，直观结果就是，索引 4 所对应的元素已经是负数了：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687768988922-8f2bcb52-c5c8-4885-8312-e2959ab42709-20240406165600-uk8u8q3.png)

对于缺失元素 3，直观结果就是，索引 3 所对应的元素是正数：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687768989524-a583f09a-bd28-49b8-b76e-8a5678e6e881-20240406165600-hl1rs62.png)

对于这个现象，我们就可以翻译成代码了：

```java
int[] findErrorNums(int[] nums) {
    int n = nums.length;
    int dup = -1;
    for (int i = 0; i < n; i++) {
        int index = Math.abs(nums[i]);
        // nums[index] 小于 0 则说明重复访问
        if (nums[index] < 0)
            dup = Math.abs(nums[i]);
        else
            nums[index] *= -1;
    }

    int missing = -1;
    for (int i = 0; i < n; i++)
        // nums[i] 大于 0 则说明没有访问
        if (nums[i] > 0)
            missing = i;
  
    return new int[]{dup, missing};
}
```

这个问题就基本解决了，别忘了我们刚才为了方便分析，假设元素是 [0..N-1]，但题目要求是 [1..N]，所以只要简单修改两处地方即可得到原题的答案：

```java
int[] findErrorNums(int[] nums) {
    int n = nums.length;
    int dup = -1;
    for (int i = 0; i < n; i++) {
        // 现在的元素是从 1 开始的
        int index = Math.abs(nums[i]) - 1;
        if (nums[index] < 0)
            dup = Math.abs(nums[i]);
        else
            nums[index] *= -1;
    }

    int missing = -1;
    for (int i = 0; i < n; i++)
        if (nums[i] > 0)
            // 将索引转换成元素
            missing = i + 1;

    return new int[]{dup, missing};
}
```

其实，元素从 1 开始是有道理的，也必须从一个非零数开始。因为如果元素从 0 开始，那么 0 的相反数还是自己，所以如果数字 0 出现了重复或者缺失，算法就无法判断 0 是否被访问过。我们之前的假设只是为了简化题目，更通俗易懂。

### 快速幂

#### 纲领

> 求`x^n`​最简单的方法是通过循环将`n`​个`x`​乘起来，依次求`x1,x2,...x^n-1,x^n`​，时间复杂度为`O(n)`​。
>
> 快速幂法可将时间复杂度降低至`O(log2n)`​。

**快速幂解析**

> 利用十进制数字 `n`​的二进制表示，可对快速幂进行数学化解释。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678090224348-cbd3265b-5348-443e-af91-16239e7267c6-20240406173023-f44aoui.png)  
比如要求`x^11`​，正常的乘积需要循环乘11次，时间复杂度为`O(n)`​

快速幂的思想就是将指数`11`​ 可以转成二进制数`1011`​，则原来的式子可以转化成

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678090325345-fc6d084c-1b01-4c5d-9b8d-08c35f149a6f-20240406173023-viw34ac.png)，此时只运算了3次乘积，时间复杂度降至`O(logn)`​。

下方代码中的`x *= x`​是一个累乘的过程，得到四位二进制数，对应的四个权重，`x`​，`x *= x`​, ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678090465951-a72452f2-2e05-4930-ad20-1ecbc4f090e7-20240406173023-b4at283.png),![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678090500845-fa84153b-fe8d-4d48-86bc-bd5357071730-20240406173023-x5weyol.png)1011二进制数，从右至左分别为`1 1 0 1 `​，**只有在1的位置上，才有相应的权重**，这也就是为什么需要通过与运算：`(b & 1) == 1`​判断最后一位是否为1。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678090585530-c55f3d4f-7ed0-4dce-9bc7-b9ba8b5c5d23-20240406173023-35uxpt3.png)​

最终的结果就是将每一位的1 所对应的权重相乘即可：![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678090601469-363186f6-c2cb-4813-b040-d04f09f43518-20240406173023-34xqtgn.png)​

#### 练习题

##### **LCR 134. 「**​[Pow(x, n)](https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/description/?orderBy=hot)」

> 实现 [pow(x, n)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。
>
> **示例 1：**   
> 输入：x = 2.00000, n = 10  
> 输出：1024.00000

```java
class Solution {
    public double myPow(double x, int n) {
        if(x == 0) return 0;
        long b = n;
        double res = 1.0;
        if(b < 0) {
            x = 1 / x;
            b = -b;
        }
        while(b > 0){
            // 最后一位为1，需要乘上该位上的权重
            if((b & 1) == 1){
                res *= x;
            }
            x *= x;
            b >>= 1;
        }
        return res;
    }
}
```

## 经典面试题

### 分治算法详解：运算优先级

分治算法呢，可以认为是一种算法思想，通过将原问题分解成小规模的子问题，然后根据子问题的结果构造出原问题的答案。这里有点类似动态规划，所以说运用分治算法也需要满足一些条件，你的原问题结果应该可以通过合并子问题结果来计算。

其实这几个算法之间界定并没有那么清晰，有时候回溯算法加个备忘录似乎就成动态规划了，而分治算法有时候也可以加备忘录进行剪枝。

我觉得吧，没必要过分纠结每个算法的定义，定义这东西无非文学词汇而已，反正能把题做出来你说这是啥算法都行，**所以大家还是得多刷题，刷出感觉，各种算法都手到擒来**。

最典型的分治算法就是归并排序了，核心逻辑如下：

```java
void sort(int[] nums, int lo, int hi) {
    int mid = (lo + hi) / 2;
    /****** 分 ******/
    // 对数组的两部分分别排序
    sort(nums, lo, mid);
    sort(nums, mid + 1, hi);
    /****** 治 ******/
    // 合并两个排好序的子数组
    merge(nums, lo, mid, hi);
}
```

「对数组排序」是一个可以运用分治思想的算法问题，只要我先把数组的左半部分排序，再把右半部分排序，最后把两部分合并，不就是对整个数组排序了吗？

#### 241.「[为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/)」

> 给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 **按任意顺序** 返回答案。
>
> 生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104 。
>
> **示例 1：**   
> 输入：expression = "2-1-1"  
> 输出：[0,2]  
> 解释：  
> ((2-1)-1) = 0
> (2-(1-1)) = 2

看到这道题的第一感觉肯定是复杂，我要穷举出所有可能的加括号方式，是不是还要考虑括号的合法性？是不是还要考虑计算的优先级？

是的，这些都要考虑，但是不需要我们来考虑。利用分治思想和递归函数，算法会帮我们考虑一切细节，也许这就是算法的魅力吧，哈哈哈。

废话不多说，解决本题的关键有两点：

**1、不要思考整体，而是把目光聚焦局部，只看一个运算符**。

这一点我们前文经常提及，比如 [手把手刷二叉树第一期](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-66994/dong-ge-da-cbce8/) 就告诉你解决二叉树系列问题只要思考每个节点需要做什么，而不要思考整棵树需要做什么。

说白了，解决递归相关的算法问题，就是一个化整为零的过程，你必须瞄准一个小的突破口，然后把问题拆解，大而化小，利用递归函数来解决。

**2、明确递归函数的定义是什么，相信并且利用好函数的定义**。

这也是前文经常提到的一个点，因为递归函数要自己调用自己，你必须搞清楚函数到底能干嘛，才能正确进行递归调用。

**下面来具体解释下这两个关键点怎么理解**。

我们先举个例子，比如我给你输入这样一个算式：

1 + 2 * 3 - 4 * 5

请问，这个算式有几种加括号的方式？请在一秒之内回答我。

估计你回答不出来，因为括号可以嵌套，要穷举出来肯定得费点功夫。

不过呢，嵌套这个事情吧，我们人类来看是很头疼的，但对于算法来说嵌套括号不要太简单，一次递归就可以嵌套一层，一次搞不定大不了多递归几次。

所以，作为写算法的人类，我们只需要思考，如果不让括号嵌套（即只加一层括号），有几种加括号的方式？

还是上面的例子，显然我们有四种加括号方式：

(1) + (2 * 3 - 4 * 5)

(1 + 2) * (3 - 4 * 5)

(1 + 2 * 3) - (4 * 5)

(1 + 2 * 3 - 4) * (5)

发现规律了么？**其实就是按照运算符进行分割，给每个运算符的左右两部分加括号**，这就是之前说的第一个关键点，不要考虑整体，而是聚焦每个运算符。

现在单独说上面的第三种情况：

(1 + 2 * 3) - (4 * 5)

我们用减号 - 作为分隔，把原算式分解成两个算式 1 + 2 * 3 和 4 * 5。

分治分治，分而治之，**这一步就是把原问题进行了「分」，我们现在要开始「治」了**。

1 + 2 * 3 可以有两种加括号的方式，分别是：

(1) + (2 * 3) = 7

(1 + 2) * (3) = 9

或者我们可以写成这种形式：

1 + 2 * 3 = [9, 7]

而 4 * 5 当然只有一种加括号方式，就是 4 * 5 = [20]。

然后呢，你能不能通过上述结果推导出 (1 + 2 * 3) - (4 * 5) 有几种加括号方式，或者说有几种不同的结果？

显然，可以推导出来 (1 + 2 * 3) - (4 * 5) 有两种结果，分别是：

9 - 20 = -11

7 - 20 = -13

那你可能要问了， 1 + 2 * 3 = [9, 7] 的结果是我们自己看出来的，如何让算法计算出来这个结果呢？

这个简单啊，再回头看下题目给出的函数签名：

```java
// 定义：计算算式 input 所有可能的运算结果
List<Integer> diffWaysToCompute(String input);
```

这个函数不就是干这个事儿的吗？**这就是我们之前说的第二个关键点，明确函数的定义，相信并且利用这个函数定义**。

你甭管这个函数怎么做到的，你相信它能做到，然后用就行了，最后它就真的能做到了。

那么，对于 (1 + 2 * 3) - (4 * 5) 这个例子，我们的计算逻辑其实就是这段代码：

```java
List<Integer> diffWaysToCompute("(1 + 2 * 3) - (4 * 5)") {
    List<Integer> res = new LinkedList<>();
    /****** 分 ******/
    List<Integer> left = diffWaysToCompute("1 + 2 * 3");
    List<Integer> right = diffWaysToCompute("4 * 5");
    /****** 治 ******/
    for (int a : left)
        for (int b : right)
            res.add(a - b);

    return res;
}
```

好，现在 (1 + 2 * 3) - (4 * 5) 这个例子是如何计算的，你应该完全理解了吧，那么回来看我们的原始问题。

原问题 1 + 2 * 3 - 4 * 5 是不是只有 (1 + 2 * 3) - (4 * 5) 这一种情况？是不是只能从减号 - 进行分割？

不是，每个运算符都可以把原问题分割成两个子问题，刚才已经列出了所有可能的分割方式：

(1) + (2 * 3 - 4 * 5)

(1 + 2) * (3 - 4 * 5)

(1 + 2 * 3) - (4 * 5)

(1 + 2 * 3 - 4) * (5)

所以，我们需要穷举上述的每一种情况，可以进一步细化一下解法代码：

```java
List<Integer> diffWaysToCompute(String input) {
    List<Integer> res = new LinkedList<>();
    for (int i = 0; i < input.length(); i++) {
        char c = input.charAt(i);
        // 扫描算式 input 中的运算符
        if (c == '-' || c == '*' || c == '+') {
            /****** 分 ******/
            // 以运算符为中心，分割成两个字符串，分别递归计算
            List<Integer> 
                left = diffWaysToCompute(input.substring(0, i));
            List<Integer> 
                right = diffWaysToCompute(input.substring(i + 1));
            /****** 治 ******/
            // 通过子问题的结果，合成原问题的结果
            for (int a : left)
                for (int b : right)
                    if (c == '+')
                        res.add(a + b);
                    else if (c == '-')
                        res.add(a - b);
                    else if (c == '*')
                        res.add(a * b);
        }
    }
    // base case
    // 如果 res 为空，说明算式是一个数字，没有运算符
    if (res.isEmpty()) {
        res.add(Integer.parseInt(input));
    }
    return res;
}
```

有了刚才的铺垫，这段代码应该很好理解了吧，就是扫描输入的算式 input，每当遇到运算符就进行分割，递归计算出结果后，根据运算符来合并结果。

**这就是典型的分治思路，先「分」后「治」，先按照运算符将原问题拆解成多个子问题，然后通过子问题的结果来合成原问题的结果**。

当然，一个重点在这段代码：

```java
// base case
// 如果 res 为空，说明算式是一个数字，没有运算符
if (res.isEmpty()) {
    res.add(Integer.parseInt(input));
}
```

递归函数必须有个 base case 用来结束递归，其实这段代码就是我们分治算法的 base case，代表着你「分」到什么时候可以开始「治」。

我们是按照运算符进行「分」的，一直这么分下去，什么时候是个头？显然，当算式中不存在运算符的时候就可以结束了。

那为什么以 res.isEmpty() 作为判断条件？因为当算式中不存在运算符的时候，就不会触发 if 语句，也就不会给 res 中添加任何元素。

至此，这道题的解法代码就写出来了，但是时间复杂度是多少呢？

如果单看代码，真的很难通过 for 循环的次数看出复杂度是多少，所以我们需要改变思路，本题在求所有可能的计算结果，不就**相当于在求算式 input 的所有合法括号组合**吗？

那么，对于一个算式，有多少种合法的括号组合呢？这就是著名的「卡特兰数」了，最终结果是一个组合数，推导过程稍有些复杂，我这里就不写了，有兴趣的读者可以自行搜索了解一下。

**其实本题还有一个小的优化，可以进行递归剪枝**，减少一些重复计算，比如说输入的算式如下：

1 + 1 + 1 + 1 + 1

那么按照算法逻辑，按照运算符进行分割，一定存在下面两种分割情况：

(1 + 1) + (1 + 1 + 1)

(1 + 1 + 1) + (1 + 1)

算法会依次递归每一种情况，其实就是冗余计算嘛，所以我们可以对解法代码稍作修改，加一个备忘录来避免这种重复计算：

```java
// 备忘录
HashMap<String, List<Integer>> memo = new HashMap<>();

List<Integer> diffWaysToCompute(String input) {
    // 避免重复计算
    if (memo.containsKey(input)) {
        return memo.get(input);
    }
    /****** 其他都不变 ******/
    List<Integer> res = new LinkedList<>();
    for (int i = 0; i < input.length(); i++) {
        // ...
    }
    if (res.isEmpty()) {
        res.add(Integer.parseInt(input));
    }
    /***********************/

    // 将结果添加进备忘录
    memo.put(input, res);
    return res;
}
```

所以最终解法如下：

```java
class Solution {
    private Map<String, List<Integer>> memo = new HashMap<>();
    public List<Integer> diffWaysToCompute(String expression) {
        if (memo.containsKey(expression)) {
            return memo.get(expression);
        }
        List<Integer> res = new LinkedList<>();
        int n = expression.length();
        for (int i = 0; i < n; i++) {
            char ch = expression.charAt(i);
            if (ch == '+' || ch == '-' || ch == '*') {
                List<Integer> left = diffWaysToCompute(expression.substring(0, i));
                List<Integer> right = diffWaysToCompute(expression.substring(i + 1));
                for (int a : left) {
                    for (int b : right) {
                        if (ch == '+') {
                            res.add(a + b);
                        } else if (ch == '-') {
                            res.add(a - b);
                        } else if (ch == '*') {
                            res.add(a * b);
                        }
                    }
                }
            }
        }
        if (res.isEmpty()) {
            res.add(Integer.parseInt(expression));
        }
        memo.put(expression, res);
        return res;
    }
}
```

### 一个方法解决三道区间问题

所谓区间问题，就是线段问题，让你合并所有线段、找出线段的交集等等。主要有两个技巧：

**1、排序**。常见的排序方法就是按照区间起点排序，或者先按照起点升序排序，若起点相同，则按照终点降序排序。当然，如果你非要按照终点排序，无非对称操作，本质都是一样的。

**2、画图**。就是说不要偷懒，勤动手，两个区间的相对位置到底有几种可能，不同的相对位置我们的代码应该怎么去处理。  
废话不多说，下面我们来做题。

#### 练习题

##### 1288.「[删除被覆盖区间](https://leetcode.cn/problems/remove-covered-intervals/)」

> 给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。
>
> 只有当 c <= a 且 b <= d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。
>
> 在完成所有删除操作后，请你返回列表中剩余区间的数目。
>
> **示例：**   
> 输入：intervals = [[1,4],[3,6],[2,8]]  
> 输出：2  
> 解释：区间 [3,6] 被区间 [2,8] 覆盖，所以它被删除了。

题目问我们，去除被覆盖区间之后，还剩下多少区间，**那么我们可以先算一算，被覆盖区间有多少个，然后和总数相减就是剩余区间数**。

对于这种区间问题，如果没啥头绪，首先排个序看看，比如我们按照区间的起点进行升序排序：

![1687858124268-f52d4875-4b78-4cff-8548-805a075f4552](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687858124268-f52d4875-4b78-4cff-8548-805a075f4552-20240406202525-tyvxh57.jpeg)

排序之后，两个相邻区间可能有如下三种相对位置：

![1687858124450-af7a308f-119a-4fc2-b8c8-b3a56fb9b339](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687858124450-af7a308f-119a-4fc2-b8c8-b3a56fb9b339-20240406202525-yowc0hz.jpeg)

对于这三种情况，我们应该这样处理：

对于情况一，找到了覆盖区间。

对于情况二，两个区间可以合并，成一个大区间。

对于情况三，两个区间完全不相交。

依据几种情况，我们可以写出如下代码：

```java
class Solution {
    public int removeCoveredIntervals(int[][] intervals) {
        Arrays.sort(intervals, (o1, o2) -> {
            if (o1[0] == o2[0]) {
                return o2[1] - o1[1];
            }
            return o1[0] - o2[0];
        });
        int right = intervals[0][1];
        int count = 0;
        for (int i = 1; i < intervals.length; i++) {
            //重合 由于left是递增的所以只用判断intervals[i][1] <= right即可，也不需要left变量
            if (intervals[i][1] <= right) {
                count++;
            } else {
                right = intervals[i][1];
            }
        }
        return intervals.length - count;
    }
}
```

以上就是本题的解法代码，起点升序排列，终点降序排列的目的是防止如下情况：

![1687858298795-99179046-6705-43c0-8813-648077102ad1](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687858298795-99179046-6705-43c0-8813-648077102ad1-20240406202525-tgfd4qs.jpeg)

对于这两个起点相同的区间，我们需要保证长的那个区间在上面（按照终点降序)，这样才会被判定为覆盖，否则会被错误地判定为相交，少算一个覆盖区间。

> 由于left是单调递增的，所以只需要判断和更改right就可以了

##### 56.「[区间合并](https://leetcode.cn/problems/merge-intervals/)」

> 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。
>
> **示例 1：**   
> 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]  
> 输出：[[1,6],[8,10],[15,18]]  
> 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].

我们解决区间问题的一般思路是先排序，然后观察规律。

一个区间可以表示为 [start, end]，前文 [区间调度问题](https://labuladong.gitee.io/article/fname.html?fname=%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B9%8B%E5%8C%BA%E9%97%B4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98) 需要按 end 排序，以便满足贪心选择性质。

而对于区间合并问题，其实按 end 和 start 排序都可以，不过为了清晰起见，我们选择按 start 排序：

![1687859142452-24905586-41b0-46bf-9603-74f5f8b0190b](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687859142452-24905586-41b0-46bf-9603-74f5f8b0190b-20240406202525-md5n5q3.jpeg)

**显然，对于几个相交区间合并后的结果区间 x，x.start 一定是这些相交区间中 start 最小的，x.end 一定是这些相交区间中 end 最大的**：

![1687859142920-c1ef5e66-6799-4878-a793-8aa5c03e0244](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687859142920-c1ef5e66-6799-4878-a793-8aa5c03e0244-20240406202525-r1j7c1q.jpeg)

由于已经排了序，x.start 很好确定，求 x.end 也很容易，可以类比在数组中找最大值的过程：

```java
int max_elem = arr[0];
for (int i = 1; i < arr.length; i++) 
    max_elem = max(max_elem, arr[i]);
return max_elem;
```

然后就可以写出完整代码：

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (o1, o2) -> {
            return o1[0] - o2[0];
        });
        LinkedList<int[]> res = new LinkedList<>();
        res.add(intervals[0]);
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] <= res.getLast()[1]) { // 有交集
                res.getLast()[1] = Math.max(res.getLast()[1], intervals[i][1]);
            } else {
                res.add(intervals[i]);
            }
        }
        return res.toArray(new int[0][0]);
    }
}
```

![1.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687859232143-ecee301d-208f-4462-b135-e9f977b59b5a-20240406202525-jgyujmj.gif)

##### 986.「[区间列表的交集](https://leetcode.cn/problems/interval-list-intersections/)」

> 给定两个由一些**闭区间** **组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对**​**不相交**​**的，并且**​**已经排序**​ **。**
>
> **返回这**​**两个区间列表的交集**​ **。**
>
> **形式上，**  [a, b]（其中 a <= b）表示实数 x 的集合，而 a <= x <= b 。
>
> 两个闭区间的 **交集** 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。
>
> **示例 1：**
>
> ![1687859927272-50328713-eb44-4722-a9ba-340aa42ebbd2](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687859927272-50328713-eb44-4722-a9ba-340aa42ebbd2-20240406202526-qxqb5ix.png)​
>
> 输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]  
> 输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]

题目很好理解，就是让你找交集，注意区间都是闭区间。

解决区间问题的思路一般是先排序，以便操作，不过题目说已经排好序了，那么可以用两个索引指针在 A 和 B 中游走，把交集找出来，代码大概是这样的：

```java
// A, B 形如 [[0,2],[5,10]...]
int[][] intervalIntersection(int[][] A, int[][] B) {
    int i = 0, j = 0;
    List<int[]> res = new ArrayList<>();
    while (i < A.length && j < B.length) {
        int start = Math.max(A[i][0], B[j][0]);
        int end = Math.min(A[i][1], B[j][1]);
        // ...
        i++;
        j++;
    }
    return res.toArray(new int[res.size()][]);
}
```

不难，我们先老老实实分析一下各种情况。

首先，**对于两个区间**，我们用 [a1, a2] 和 [b1, b2] 表示在 A 和 B 中的两个区间，那么什么情况下这两个区间**没有交集**呢：

![1687859995989-a70d73e2-a813-47f7-882d-a2acebb08edb](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687859995989-a70d73e2-a813-47f7-882d-a2acebb08edb-20240406202526-fgb0xga.jpeg)

只有这两种情况，写成代码的条件判断就是这样：

```java
if b2 < a1 or a2 < b1:
    [a1,a2] 和 [b1,b2] 无交集
```

那么，什么情况下，两个区间存在交集呢？根据命题的否定，上面逻辑的否命题就是存在交集的条件：

```java
# 不等号取反，or 也要变成 and
if b2 >= a1 and a2 >= b1:
    [a1,a2] 和 [b1,b2] 存在交集
```

接下来，两个区间存在交集的情况有哪些呢？穷举出来：

![1687860041253-b568e40a-b8ea-46c4-b0bf-5a5cb4dcb9ab](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687860041253-b568e40a-b8ea-46c4-b0bf-5a5cb4dcb9ab-20240406202526-l2ua4r3.jpeg)

这很简单吧，就这四种情况而已。那么接下来思考，这几种情况下，交集是否有什么共同点呢？

![1687860040440-356a49a3-09dc-4410-9b45-f9506af1ae92](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687860040440-356a49a3-09dc-4410-9b45-f9506af1ae92-20240406202526-n29jpeb.jpeg)

我们惊奇地发现，交集区间是有规律的！如果交集区间是 [c1, c2]，那么 c1 = max(a1, b1)，c2 = min(a2 ,b2)！这一点就是寻找交集的核心，我们把代码更进一步：

```java
while (i < A.length && j < B.length) {
    int a1 = A[i][0], a2 = A[i][1];
    int b1 = B[j][0], b2 = B[j][1];
    if (b2 >= a1 && a2 >= b1) {
        res.add(new int[]{Math.max(a1, b1), Math.min(a2, b2)});
    }
    // ...
}
```

最后一步，我们的指针 i 和 j 肯定要前进（递增）的，什么时候应该前进呢？

![1687860098062-e16ec447-59e4-4bb4-9299-19d7460179ec](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687860098062-e16ec447-59e4-4bb4-9299-19d7460179ec-20240406202526-ekyr2hx.gif)

结合动画示例就很好理解了，是否前进，只取决于 a2 和 b2 的大小关系：

```java
while (i < A.length && j < B.length) {
    // ...

    if (b2 < a2) {
        j++;
    } else {
        i++;
    }
}
```

以此思路写出代码：

```java
// A, B 形如 [[0,2],[5,10]...]
int[][] intervalIntersection(int[][] A, int[][] B) {
    // 双指针
    int i = 0, j = 0;
    List<int[]> res = new ArrayList<>();
    while (i < A.length && j < B.length) {
        int a1 = A[i][0], a2 = A[i][1];
        int b1 = B[j][0], b2 = B[j][1];
        // 两个区间存在交集
        if (b2 >= a1 && a2 >= b1) {
            // 计算出交集，加入 res
            res.add(new int[]{Math.max(a1, b1), Math.min(a2, b2)});
        }
        // 指针前进
        if (b2 < a2) {
            j++;
        } else {
            i++;
        }
    }
    return res.toArray(new int[res.size()][]);
}
```

总结一下，区间类问题看起来都比较复杂，情况很多难以处理，但实际上通过观察各种不同情况之间的共性可以发现规律，用简洁的代码就能处理。

### 贪心思想玩斗地主

斗地主中，大小连续的牌可以作为顺子，有时候我们把对子拆掉，结合单牌，可以组合出更多的顺子，可能更容易赢。

那么如何合理拆分手上的牌，合理地拆出顺子呢？我们今天看一道非常有意思的算法题，连续子序列的划分问题。

#### 659.「[分割数组为连续子序列](https://leetcode.cn/problems/split-array-into-consecutive-subsequences/)」

> 给你一个按 **非递减顺序** 排列的整数数组 nums 。
>
> 请你判断是否能在将 nums 分割成 **一个或多个子序列** 的同时满足下述 **两个** 条件：
>
> - 每个子序列都是一个 **连续递增序列**（即，每个整数 **恰好** 比前一个整数大 **1** ）。
> - 所有子序列的长度 **至少** 为 3。
>
> 如果可以分割 nums 并满足上述条件，则返回 true ；否则，返回 false 。
>
> **示例 1：**   
> 输入：nums = [1,2,3,3,4,5]  
> 输出：true  
> 解释：nums 可以分割成以下子序列：  
> [1,2,3,3,4,5] --> 1, 2, 3  
> [1,2,3,3,4,5] --> 3, 4, 5

给你输入一个**升序排列**的数组 nums（可能包含重复数字），请你判断 nums 是否能够被分割成若干个**长度至少为 3** 的子序列，每个子序列都由连续的整数组成。

**对于这种涉及连续整数的问题，应该条件反射地想到排序**，不过题目说了，输入的 nums 本就是排好序的。

那么，我们如何判断 nums 是否能够被划分成若干符合条件的子序列呢？

类似前文 [回溯算法进行集合划分](https://labuladong.github.io/algo/di-san-zha-24031/bao-li-sou-96f79/jing-dian--93320/)，我们想把 nums 的元素划分到若干个子序列中，其实就是下面这个代码逻辑：

```java
for (int v : nums) {
    if (...) {
        // 将 v 分配到某个子序列中
    } else {
        // 实在无法分配 v
        return false;
    }
    return true;
}
```

关键在于，我们怎么知道当前元素 v 如何进行分配呢？

肯定得分情况讨论，把情况讨论清楚了，题目也就做出来了。

总共有两种情况：

**1、当前元素 v 自成一派，「以自己开头」构成一个长度至少为 3 的序列**。

比如输入 nums = [1,2,3,6,7,8]，遍历到元素 6 时，它只能自己开头形成一个符合条件的子序列 [6,7,8]。

**2、当前元素 v 接到已经存在的子序列后面**。

比如输入 nums = [1,2,3,4,5]，遍历到元素 4 时，它只能接到已经存在的子序列 [1,2,3] 后面。它没办法自成开头形成新的子序列，因为少了个 6。

但是，如果这两种情况都可以，应该如何选择？

比如说，输入 nums = [1,2,3,4,5,5,6,7]，对于元素 4，你说它应该形成一个新的子序列 [4,5,6] 还是接到子序列 [1,2,3] 后面呢？

显然，nums 数组的正确划分方法是分成 [1,2,3,4,5] 和 [5,6,7]，所以元素 4 应该**优先判断自己是否能够接到其他序列后面**，如果不行，再判断是否可以作为新的子序列开头。

这就是整体的思路，想让算法代码实现这两个选择，需要两个哈希表来做辅助：

freq 哈希表帮助一个元素判断自己是否能够作为开头，need 哈希表帮助一个元素判断自己是否可以被接到其他序列后面。

- **freq 记录每个元素出现的次数**，比如 freq[3] == 2 说明元素 3 在 nums 中出现了 2 次。

那么如果我发现 freq[3], freq[4], freq[5] 都是大于 0 的，那就说明元素 3 可以作为开头组成一个长度为 3 的子序列。

- **need 记录哪些元素可以被接到其他子序列后面**。

比如说现在已经组成了两个子序列 [1,2,3,4] 和 [2,3,4]，那么 need[5] 的值就应该是 2，说明对元素 5 的需求为 2。

明白了这两个哈希表的作用，我们就可以看懂解法了：

```java
class Solution {
    public boolean isPossible(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<>(); // 记录每个数字的频率
        Map<Integer, Integer> need = new HashMap<>(); // 记录哪些元素可以被接到其他子序列后面
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        for (int num : nums) {
            if (freq.get(num) == 0) { // 此数字已经用完了
                continue;
            }
            if (need.getOrDefault(num, 0) > 0) { // 先判断能否拼接到以前的序列中
                need.put(num, need.get(num) - 1); // 拼到以前的序列，需求-1
                freq.put(num, freq.get(num) - 1); // 频率-1
                need.put(num + 1, need.getOrDefault(num + 1, 0) + 1); // 对下一个数字的需求+1
            } else if (freq.getOrDefault(num, 0) > 0
                       && freq.getOrDefault(num + 1, 0) > 0
                       && freq.getOrDefault(num + 2, 0) > 0) {  // 自成一个序列
                freq.put(num, freq.get(num) - 1);
                freq.put(num + 1, freq.get(num + 1) - 1);
                freq.put(num + 2, freq.get(num + 2) - 1);
                need.put(num + 3, need.getOrDefault(num + 3, 0) + 1);
            } else {
                return false;
            }
        }
        return true;
    }
}
```

至此，这道题就解决了。

### 烧饼排序算法

#### 969.「[煎饼排序](https://leetcode.cn/problems/pancake-sorting/)」

> 给你一个整数数组 `arr`​ ，请使用 **煎饼翻转** 完成对数组的排序。
>
> 一次煎饼翻转的执行过程如下：
>
> - 选择一个整数 k ，1 <= k <= arr.length
> - 反转子数组 arr[0...k-1]（**下标从 0 开始**）
>
> 例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [**1**,**2**,**3**,4] 。
>
> 以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。
>
> **示例 1：**   
> 输入：[3,2,4,1]  
> 输出：[4,2,4,3]
>
> 解释：  
> 我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。  
> 初始状态 arr = [3, 2, 4, 1]  
> 第一次翻转后（k = 4）：arr = [1, 4, 2, 3]  
> 第二次翻转后（k = 2）：arr = [4, 1, 2, 3]  
> 第三次翻转后（k = 4）：arr = [3, 2, 1, 4]  
> 第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。

假设盘子上有 n 块**面积大小不一**的烧饼，你如何用一把锅铲进行若干次翻转，让这些烧饼的大小有序（小的在上，大的在下）？

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687937564507-5382d97f-8a56-4b88-8e3b-0e42b098b1be-20240406222151-69bpz3q.png)

设想一下用锅铲翻转一堆烧饼的情景，其实是有一点限制的，我们每次只能将最上面的若干块饼子翻转：

‍

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687937563612-97fd3e4a-65e9-4765-a512-1d1e678afc04-20240406222151-vxzfk32.png)​

我们的问题是，**如何使用算法得到一个翻转序列，使得烧饼堆变得有序**？

如果我们找到了前 n 个烧饼中最大的那个，然后设法将这个饼子翻转到最底下：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687937600827-1d37cb84-7058-4b8f-a5e5-ebba6c40f2eb-20240406222151-q8qnt5t.png)

那么，原问题的规模就可以减小，递归调用 pancakeSort(A, n-1) 即可：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687937602147-15aa4acb-59ae-46f0-a75f-4d08d486e4fd-20240406222151-9pu4umc.png)

接下来，对于上面的这 n - 1 块饼，如何排序呢？还是先从中找到最大的一块饼，然后把这块饼放到底下，再递归调用 pancakeSort(A, n-1-1)……

你看，这就是递归性质，总结一下思路就是：

1、找到 n 个饼中最大的那个。

2、把这个最大的饼移到最底下。

3、递归调用 pancakeSort(A, n - 1)。

base case：n == 1 时，排序 1 个饼时不需要翻转。

那么，最后剩下个问题，**如何设法将某块烧饼翻到最后呢**？

其实很简单，比如第 3 块饼是最大的，我们想把它换到最后，也就是换到第 n 块。可以这样操作：

1、用锅铲将前 3 块饼翻转一下，这样最大的饼就翻到了最上面。

2、用锅铲将前 n 块饼全部翻转，这样最大的饼就翻到了第 n 块，也就是最后一块。

以上两个流程理解之后，基本就可以写出解法了，不过题目要求我们写出具体的反转操作序列，这也很简单，只要在每次翻转烧饼时记录下来就行了。

```java
class Solution {
    // 记录反转操作序列
    LinkedList<Integer> res = new LinkedList<>();

    List<Integer> pancakeSort(int[] cakes) {
        sort(cakes, cakes.length);
        return res;
    }

    void sort(int[] cakes, int n) {
        // base case
        if (n == 1) return;
    
        // 寻找最大饼的索引
        int maxCake = 0;
        int maxCakeIndex = 0;
        for (int i = 0; i < n; i++)
            if (cakes[i] > maxCake) {
                maxCakeIndex = i;
                maxCake = cakes[i];
            }
    
        // 第一次翻转，将最大饼翻到最上面
        reverse(cakes, 0, maxCakeIndex);
        res.add(maxCakeIndex + 1);
        // 第二次翻转，将最大饼翻到最下面
        reverse(cakes, 0, n - 1);
        res.add(n);

        // 递归调用
        sort(cakes, n - 1);
    }

    void reverse(int[] arr, int i, int j) {
        while (i < j) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
            i++; j--;
        }
    }
}
```

只要把上述的思路用代码实现即可，唯一需要注意的是，数组索引从 0 开始，而我们要返回的结果是从 1 开始算的。

通过刚才的详细解释，这段代码应该是很清晰了。

算法的时间复杂度很容易计算，因为递归调用的次数是 n，每次递归调用都需要一次 for 循环，时间复杂度是 O(n)，所以总的复杂度是 O(n^2)。

**最后，我们可以思考一个问题**：按照我们这个思路，得出的操作序列长度应该为 2(n - 1)，因为每次递归都要进行 2 次翻转并记录操作，总共有 n 层递归，但由于 base case 直接返回结果，不进行翻转，所以最终的操作序列长度应该是固定的 2(n - 1)。

### 字符串乘法计算

#### 43.「[字符串相乘](https://leetcode.cn/problems/multiply-strings/)」

> 给定两个以字符串形式表示的非负整数 `num1`​ 和 `num2`​，返回 `num1`​ 和 `num2`​ 的乘积，它们的乘积也表示为字符串形式。
>
> **注意：** 不能使用任何内置的 BigInteger 库或直接将输入转换为整数。
>
> **示例 1:**   
> 输入: num1 = "2", num2 = "3"  
> 输出: "6"

需要注意的是，num1 和 num2 可以非常长，所以不可以把他们直接转成整型然后运算，唯一的思路就是模仿我们手算乘法。

比如说我们手算 123 × 45，应该会这样计算：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687937781096-95050472-9098-4d76-9980-bf64a0bc37f9-20240406224754-kzmo4ox.png)

计算 123 × 5，再计算 123 × 4，最后错一位相加。这个流程恐怕小学生都可以熟练完成，但是你是否能**把这个运算过程进一步机械化**，写成一套算法指令让没有任何智商的计算机来执行呢？

你看这个简单过程，其中涉及乘法进位，涉及错位相加，还涉及加法进位；而且还有一些不易察觉的问题，比如说两位数乘以两位数，结果可能是四位数，也可能是三位数，你怎么想出一个标准化的处理方式？这就是算法的魅力，如果没有计算机思维，简单的问题可能都没办法自动化处理。

首先，我们这种手算方式还是太「高级」了，我们要再「低级」一点，123 × 5 和 123 × 4 的过程还可以进一步分解，最后再相加：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687937766296-9f9aaf82-4416-4138-92b3-accb6cc38f1b-20240406224754-ujpozvp.png)

现在 123 并不大，如果是个很大的数字的话，是无法直接计算乘积的。我们可以用一个数组在底下接收相加结果：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687937770034-178d3961-53ff-481d-bdf6-7d1fe3dbcc1f-20240406224755-47zz3ol.png)

整个计算过程大概是这样，**有两个指针 i，j 在 num1 和 num2 上游走，计算乘积，同时将乘积叠加到 res 的正确位置**，如下 GIF 图所示：

![1687937765708-97feaae1-c0bf-4baa-90cc-538d1de56937](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687937765708-97feaae1-c0bf-4baa-90cc-538d1de56937-20240406224755-r8cwiub.gif)

现在还有一个关键问题，如何将乘积叠加到 res 的正确位置，或者说，如何通过 i，j 计算 res 的对应索引呢？

其实，细心观察之后就发现，**num1[i] 和 num2[j] 的乘积对应的就是 res[i+j] 和 res[i+j+1] 这两个位置**。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687937774278-10b86c70-5daa-44e4-8c6e-cf6c45e697f9-20240406224755-q5al55r.png)

明白了这一点，就可以用代码模仿出这个计算过程了：

```java
public String multiply(String num1, String num2) {
    int m = num1.length(), n = num2.length();
    // 结果最多为 m + n 位数
    int[] res = new int[m + n];
    // 从个位数开始逐位相乘
    for (int i = m - 1; i >= 0; i--)
    for (int j = n - 1; j >= 0; j--) {
        int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
        // 乘积在 res 对应的索引位置
        int p1 = i + j, p2 = i + j + 1;
        // 叠加到 res 上
        int sum = mul + res[p2];
        res[p2] = sum % 10;
        res[p1] += sum / 10;
    }
    // 结果前缀可能存的 0（未使用的位）
    int i = 0;
    while (i < res.length && res[i] == 0)
    i++;
    // 将计算结果转化成字符串
    StringBuilder sb = new StringBuilder();
    for (; i < res.length; i++)
    sb.append(res[i]);

    String str = sb.toString();
    return str.length() == 0 ? "0" : str;
}

```

至此，字符串乘法算法就完成了。

**总结一下**，我们习以为常的一些思维方式，在计算机看来是非常难以做到的。比如说我们习惯的算术流程并不复杂，但是如果让你再进一步，翻译成代码逻辑，并不简单。算法需要将计算流程再简化，通过边算边叠加的方式来得到结果。

俗话教育我们，不要陷入思维定式，不要程序化，要发散思维，要创新。但我觉得程序化并不是坏事，可以大幅提高效率，减小失误率。算法不就是一套程序化的思维吗，只有程序化才能让计算机帮助我们解决复杂问题呀！

也许算法就是一种**寻找思维定式的思维**吧，希望本文对你有帮助。

### 实现一个计算器

#### 224.「[基本计算器](https://leetcode.cn/problems/basic-calculator/)」

> 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。
>
> 注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。
>
> **示例 1：**   
> 输入：s = "(1+(4+5+2)-3)+(6+8)"  
> 输出：23

我们最终要实现的计算器功能如下：

1、输入一个字符串，可以包含 + - * /、数字、括号以及空格，你的算法返回运算结果。

2、要符合运算法则，括号的优先级最高，先乘除后加减。

3、除号是整数除法，无论正负都向 0 取整（5/2=2，-5/2=-2）。

4、可以假定输入的算式一定合法，且计算过程不会出现整型溢出，不会出现除数为 0 的意外情况。

可以看到，这就已经非常接近我们实际生活中使用的计算器了，虽然我们以前肯定都用过计算器，但是如果简单思考一下其算法实现，就会大惊失色：

1、按照常理处理括号，要先计算最内层的括号，然后向外慢慢化简。这个过程我们手算都容易出错，何况写成算法呢！

2、要做到先乘除，后加减，这一点教会小朋友还不算难，但教给计算机恐怕有点困难。

3、要处理空格。我们为了美观，习惯性在数字和运算符之间打个空格，但是计算之中得想办法忽略这些空格。

我记得很多大学数据结构的教材上，在讲栈这种数据结构的时候，应该都会用计算器举例，但是有一说一，讲的真的垃圾，不知道多少未来的计算机科学家就被这种简单的数据结构劝退了。

那么本文就来聊聊怎么实现上述一个功能完备的计算器功能，**关键在于层层拆解问题，化整为零，逐个击破**，几条简单的算法规则就可以处理极其复杂的运算，相信这种思维方式能帮大家解决各种复杂问题。

下面就来拆解，从最简单的一个问题开始。

##### 字符串转整数

是的，就是这么一个简单的问题，首先告诉我，怎么把一个字符串形式的**正**整数，转化成 int 型？

```java
String s = "458";

int n = 0;
for (int i = 0; i < s.length(); i++) {
    char c = s.charAt(i);
    n = 10 * n + (c - '0');
}
// n 现在就等于 458
```

这个还是很简单的吧，老套路了。但是即便这么简单，依然有坑： **(c - '0') 的这个括号不能省略，否则可能造成整型溢出**。

因为变量 c 是一个 ASCII 码，如果不加括号就会先加后减，想象一下 s 如果接近 INT_MAX，就会溢出。所以用括号保证先减后加才行。

##### 处理加减法

现在进一步，**如果输入的这个算式只包含加减法，而且不存在空格**，你怎么计算结果？我们拿字符串算式 1-12+3 为例，来说一个很简单的思路：

1、先给第一个数字加一个默认符号 +，变成 +1-12+3。

2、把一个运算符和数字组合成一对儿，也就是三对儿 +1，-12，+3，把它们转化成数字，然后放到一个栈中。

3、将栈中所有的数字求和，就是原算式的结果。

我们直接看代码，结合一张图就看明白了：

```java
public int calculate(String s) {
    Stack<Integer> stk = new Stack<>();
    // 记录算式中的数字
    int num = 0;
    // 记录 num 前的符号，初始化为 +
    char sign = '+';
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        // 如果是数字，连续读取到 num
        if (Character.isDigit(c)) 
            num = 10 * num + (c - '0');
        // 如果不是数字，就是遇到了下一个符号，
        // 之前的数字和符号就要存进栈中
        if (!Character.isDigit(c) || i == s.length() - 1) {
            switch (sign) {
                case '+':
                    stk.push(num); break;
                case '-':
                    stk.push(-num); break;
            }
            // 更新符号为当前符号，数字清零
            sign = c;
            num = 0;
        }
    }
    // 将栈中所有结果求和就是答案
    int res = 0;
    while (!stk.empty()) {
        res += stk.peek();
        stk.pop();
    }
    return res;
}
```

我估计就是中间带 switch 语句的部分有点不好理解吧，i 就是从左到右扫描，sign 和 num 跟在它身后。当 s[i] 遇到一个运算符时，情况是这样的：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687944666104-d8cf356e-6e9d-4093-b794-7adbffb31f41-20240407101656-ljf58ul.png)

所以说，此时要根据 sign 的 case 不同选择 nums 的正负号，存入栈中，然后更新 sign 并清零 nums 记录下一对儿符合和数字的组合。

另外注意，不只是遇到新的符号会触发入栈，当 i 走到了算式的尽头（i == s.size() - 1 ），也应该将前面的数字入栈，方便后续计算最终结果。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687944665808-4264eb18-f18a-4465-8356-1f6538bd34fe-20240407101657-sf4qu4p.png)

至此，仅处理紧凑加减法字符串的算法就完成了，请确保理解以上内容，后续的内容就基于这个框架修修改改就完事儿了。

##### 处理乘除法

其实思路跟仅处理加减法没啥区别，拿字符串 2-3*4+5 举例，核心思路依然是把字符串分解成符号和数字的组合。比如上述例子就可以分解为 +2，-3，* 4，+5 几对儿，我们刚才不是没有处理乘除号吗，很简单，**其他部分都不用变**，在 switch 部分加上对应的 case 就行了：

```java
for (int i = 0; i < s.length(); i++) {
    char c = s.charAt(i);
    if (Character.isDigit(c)) 
        num = 10 * num + (c - '0');

    if (!Character.isDigit(c) || i == s.length() - 1) {
        switch (sign) {
            int pre;
            case '+':
                stk.push(num); break;
            case '-':
                stk.push(-num); break;
            // 只要拿出前一个数字做对应运算即可
            case '*':
                pre = stk.peek();
                stk.pop();
                stk.push(pre * num);
                break;
            case '/':
                pre = stk.peek();
                stk.pop();
                stk.push(pre / num);
                break;
        }
        // 更新符号为当前符号，数字清零
        sign = c;
        num = 0;
    }
}
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687944698299-2b4af3d7-4024-43d9-881c-fb10202b4d5b-20240407101657-2kf8ukr.png)

**乘除法优先于加减法体现在，乘除法可以和栈顶的数结合，而加减法只能把自己放入栈**。

现在我们思考一下**如何处理字符串中可能出现的空格字符**。其实也非常简单，想想空格字符的出现，会影响我们现有代码的哪一部分？

```java
// 如果 c 非数字
if (!isdigit(c) || i == s.size() - 1) {
    switch (c) {...}
    sign = c;
    num = 0;
}
```

显然空格会进入这个 if 语句，但是我们并不想让空格的情况进入这个 if，因为这里会更新 sign 并清零 nums，空格根本就不是运算符，应该被忽略。

那么只要多加一个条件即可：

```java
if ((!isdigit(c) && c != ' ') || i == s.size() - 1) {
    ...
}
```

好了，现在我们的算法已经可以按照正确的法则计算加减乘除，并且自动忽略空格符，剩下的就是如何让算法正确识别括号了。

##### 处理括号

处理算式中的括号看起来应该是最难的，但真没有看起来那么难。

```java
public int calculate(String s) {
    Deque<Character> deque = new LinkedList<>();
    for (char c : s.toCharArray()) {
        deque.add(c);
    }
  
    return helper(deque);
}

/**
* 在helper函数里翻译链表的叫法为 deque，
* 并将判断是否为数字的函数名变为Java版函数名
*/
private int helper(Deque<Character> s) {
    Deque<Integer> stack = new LinkedList<>();
    char sign = '+';
    int num = 0;

    while (!s.isEmpty()) {
        char c = s.pop();
        if (Character.isDigit(c)) {
            num = 10 * num + Character.getNumericValue(c);
        }

        if ((!Character.isDigit(c) && c != ' ') || s.isEmpty()) {
            if (sign == '+') {
                stack.push(num);
            } else if (sign == '-') {
                stack.push(-num);
            } else if (sign == '*') {
                stack.push(stack.pop() * num);
            } else if (sign == '/') {
                stack.push(stack.pop() / num);
            }
            num = 0;
            sign = c;
        }
    }

    int sum = 0;
    for (int i : stack) {
        sum += i;
    }
    return sum;
}
```

那么，为什么说处理括号没有看起来那么难呢，**因为括号具有递归性质**。我们拿字符串 3*(4-5/2)-6 举例：

```java
calculate(3 * (4 - 5/2) - 6)
= 3 * calculate(4 - 5/2) - 6
= 3 * 2 - 6
= 0
```

可以脑补一下，无论多少层括号嵌套，通过 calculate 函数递归调用自己，都可以将括号中的算式化简成一个数字。**换句话说，括号包含的算式，我们直接视为一个数字就行了**。

现在的问题是，递归的开始条件和结束条件是什么？**遇到 ( 开始递归，遇到 ) 结束递归**：

```java
public int calculate(String s) {
    Queue<Character> queueS = new LinkedList<Character>();
    for(char c : s.toCharArray()) {
        queueS.add(c);
    }
    
    return helper(queueS);
}
    
private int helper(Queue<Character> s) {
    Stack<Integer> stack = new Stack<Integer>();
    char sign = '+';
    int num = 0;

    while (!s.isEmpty()) {
        char c = s.poll();
        if (Character.isDigit(c)) {
            num = 10 * num + Character.getNumericValue(c);
        }
        // 遇到左括号开始递归计算 num
        if (c == '(') {
            num = helper(s);
        }

        if ((!Character.isDigit(c) && c != ' ') || s.isEmpty()) {
            if (sign == '+') {
                stack.push(num);
            } else if (sign == '-') {
                stack.push(-num);
            } else if (sign == '*') {
                stack.push(stack.pop() * num);
            } else if (sign == '/') {
                stack.push(stack.pop() / num);   
            }
            num = 0;
            sign = c;
        }
        // 遇到右括号返回递归结果
        if (c == ')') {
            break;
        }
    }
    int res = 0;
    for (int i : stack) {
        res += i;
    }
    return res;
}
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687944823713-fb73d882-4d87-4237-b0ae-1494e4e9bc07-20240407101657-97ezuve.png)  
​![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687944829613-ac2e480a-6856-41cd-a6a9-7b150a4f5c06-20240407101658-3tuvvlo.png)  
​![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687944826583-29a4a275-4041-47e3-b0c6-e15a0974c79f-20240407101658-8ra3w6o.png)

你看，加了两三行代码，就可以处理括号了，这就是递归的魅力。至此，计算器的全部功能就实现了，通过对问题的层层拆解化整为零，再回头看，这个问题似乎也没那么复杂嘛。

### 高效解决接雨水问题

#### 42.「[接雨水](https://leetcode.cn/problems/trapping-rain-water/)」

> 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
>
> **示例 1：**
>
> ![image-20250620151639237](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620151639237.png)
>
> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]  
> 输出：6  
> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水)。

##### 核心思路

对于这种问题，我们不要想整体，而应该去想局部；就像之前的文章写的动态规划问题处理字符串问题，不要考虑如何处理整个字符串，而是去思考应该如何处理每一个字符。

这么一想，可以发现这道题的思路其实很简单。具体来说，仅仅对于位置 i，能装下多少水呢？

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620151701475.png" alt="image-20250620151701475" style="zoom:50%;" />

能装 2 格水，因为 height[i] 的高度为 0，而这里最多能盛 2 格水，2-0=2。

为什么位置 i 最多能盛 2 格水呢？因为，位置 i 能达到的水柱高度和其左边的最高柱子、右边的最高柱子有关，我们分别称这两个柱子高度为 l_max 和 r_max；**位置 i 最大的水柱高度就是 min(l_max, r_max)** 。

更进一步，对于位置 i，能够装的水为：

```java
water[i] = min(
               # 左边最高的柱子
               max(height[0..i]),  
               # 右边最高的柱子
               max(height[i..end]) 
            ) - height[i]
```

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620151723797.png" alt="image-20250620151723797" style="zoom:50%;" />

这就是本问题的核心思路，我们可以简单写一个暴力算法：

```java
int trap(int[] height) {
    int n = height.length;
    int res = 0;
    for (int i = 1; i < n - 1; i++) {
        int l_max = 0, r_max = 0;
        // 找右边最高的柱子
        for (int j = i; j < n; j++)
            r_max = Math.max(r_max, height[j]);
        // 找左边最高的柱子
        for (int j = i; j >= 0; j--)
            l_max = Math.max(l_max, height[j]);
        // 如果自己就是最高的话，
        // l_max == r_max == height[i]
        res += Math.min(l_max, r_max) - height[i];
    }
    return res;
}
```

有之前的思路，这个解法应该是很直接粗暴的，时间复杂度 O(N^2)，空间复杂度 O(1)。但是很明显这种计算 r_max 和 l_max 的方式非常笨拙，一般的优化方法就是备忘录。

##### 备忘录优化

之前的暴力解法，不是在每个位置 i 都要计算 r_max 和 l_max 吗？我们直接把结果都提前计算出来，别傻不拉几的每次都遍历，这时间复杂度不就降下来了嘛。

**我们开两个数组 r_max 和 l_max 充当备忘录，l_max[i] 表示位置 i 左边最高的柱子高度，r_max[i] 表示位置 i 右边最高的柱子高度**。预先把这两个数组计算好，避免重复计算：

```java
class Solution {
    int trap(int[] height) {
        if (height.length == 0) {
            return 0;
        }
        int n = height.length;
        int res = 0;
        // 数组充当备忘录
        int[] l_max = new int[n];
        int[] r_max = new int[n];
        // 初始化 base case
        l_max[0] = height[0];
        r_max[n - 1] = height[n - 1];
        // 从左向右计算 l_max
        for (int i = 1; i < n; i++)
            l_max[i] = Math.max(height[i], l_max[i - 1]);
        // 从右向左计算 r_max
        for (int i = n - 2; i >= 0; i--)
            r_max[i] = Math.max(height[i], r_max[i + 1]);
        // 计算答案
        for (int i = 1; i < n - 1; i++)
            res += Math.min(l_max[i], r_max[i]) - height[i];
        return res;
    }
}
```

这个优化其实和暴力解法思路差不多，就是避免了重复计算，把时间复杂度降低为 O(N)，已经是最优了，但是空间复杂度是 O(N)。下面来看一个精妙一些的解法，能够把空间复杂度降低到 O(1)。

##### 双指针解法

这种解法的思路是完全相同的，但在实现手法上非常巧妙，我们这次也不要用备忘录提前计算了，而是用双指针**边走边算**，节省下空间复杂度。

首先，看一部分代码：

```java
int trap(int[] height) {
    int left = 0, right = height.length - 1;
    int l_max = 0, r_max = 0;
  
    while (left < right) {
        l_max = Math.max(l_max, height[left]);
        r_max = Math.max(r_max, height[right]);
        // 此时 l_max 和 r_max 分别表示什么？
        left++; right--;
    }
}
```

对于这部分代码，请问 l_max 和 r_max 分别表示什么意义呢？

很容易理解，**l_max 是 height[0..left] 中最高柱子的高度，r_max 是 height[right..end] 的最高柱子的高度**。

明白了这一点，直接看解法：

```java
class Solution {
    int trap(int[] height) {
        int left = 0, right = height.length - 1;
        int l_max = 0, r_max = 0;

        int res = 0;
        while (left < right) {
            l_max = Math.max(l_max, height[left]);
            r_max = Math.max(r_max, height[right]);

            // res += min(l_max, r_max) - height[i]
            if (l_max < r_max) {
                res += l_max - height[left];
                left++;
            } else {
                res += r_max - height[right];
                right--;
            }
        }
        return res;
    }
}
```

你看，其中的核心思想和之前一模一样，换汤不换药。但是细心的读者可能会发现次解法还是有点细节差异：

之前的备忘录解法，l_max[i] 和 r_max[i] 分别代表 height[0..i] 和 height[i..end] 的最高柱子高度。

```java
res += Math.min(l_max[i], r_max[i]) - height[i];
```

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620151803270.png" alt="image-20250620151803270" style="zoom:50%;" />

但是双指针解法中，l_max 和 r_max 代表的是 height[0..left] 和 height[right..end] 的最高柱子高度。比如这段代码：

```java
if (l_max < r_max) {
    res += l_max - height[left];
    left++; 
}
```

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620151834463.png" alt="image-20250620151834463" style="zoom:50%;" />

此时的 l_max 是 left 指针左边的最高柱子，但是 r_max 并不一定是 left 指针右边最高的柱子，这真的可以得到正确答案吗？

其实这个问题要这么思考，我们只在乎 min(l_max, r_max)。**对于上图的情况，我们已经知道 l_max &lt; r_max 了，至于这个 r_max 是不是右边最大的，不重要。重要的是 height[i] 能够装的水只和较低的 l_max 之差有关**：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620151859215.png" alt="image-20250620151859215" style="zoom:50%;" />

这样，接雨水问题就解决了。

#### 11.「[盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)」

> 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
>
> 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
>
> 返回容器可以储存的最大水量。
>
> **说明：** 你不能倾斜容器。
>
> **示例 1：**
>
> <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20250620151926104.png" alt="image-20250620151926104" style="zoom:70%;" />
>
> 输入：[1,8,6,2,5,4,8,3,7]  
> 输出：49
> 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分)的最大值为 49。

这题和接雨水问题很类似，可以完全套用前文的思路，而且还更简单。两道题的区别在于：

**接雨水问题给出的类似一幅直方图，每个横坐标都有宽度，而本题给出的每个横坐标是一条竖线，没有宽度**。

我们前文讨论了半天 l_max 和 r_max，实际上都是为了计算 height[i] 能够装多少水；而本题中 height[i] 没有了宽度，那自然就好办多了。

举个例子，如果在接雨水问题中，你知道了 height[left] 和 height[right] 的高度，你能算出 left 和 right 之间能够盛下多少水吗？

不能，因为你不知道 left 和 right 之间每个柱子具体能盛多少水，你得通过每个柱子的 l_max 和 r_max 来计算才行。

反过来，就本题而言，你知道了 height[left] 和 height[right] 的高度，能算出 left 和 right 之间能够盛下多少水吗？

可以，因为本题中竖线没有宽度，所以 left 和 right 之间能够盛的水就是：

```python
min(height[left], height[right]) * (right - left)
```

类似接雨水问题，高度是由 height[left] 和 height[right] 较小的值决定的。

解决这道题的思路依然是双指针技巧：

**用 left 和 right 两个指针从两端向中心收缩，一边收缩一边计算 [left, right] 之间的矩形面积，取最大的面积值即是答案**。

先直接看解法代码吧：

```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int res = 0;
        while (left < right) {
            // [left, right] 之间的矩形面积
            int cur_area = Math.min(height[left], height[right]) * (right - left);
            res = Math.max(res, cur_area);
            // 双指针技巧，移动较低的一边
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return res;
    }
}
```

代码和接雨水问题大致相同，不过肯定有读者会问，下面这段 if 语句为什么要移动较低的一边：

```java
// 双指针技巧，移动较低的一边
if (height[left] < height[right]) {
    left++;
} else {
    right--;
}
```

**其实也好理解，因为矩形的高度是由 min(height[left], height[right]) 即较低的一边决定的**：

你如果移动较低的那一边，那条边可能会变高，使得矩形的高度变大，进而就「有可能」使得矩形的面积变大；相反，如果你去移动较高的那一边，矩形的高度是无论如何都不会变大的，所以不可能使矩形的面积变得更大。

至此，这道题也解决了。

### 解决括号相关的问题

对括号的有效性判断多次在笔试中出现，现实中也很常见，比如说我们写的代码，编辑器会检查括号是否正确闭合。而且我们的代码可能会包含三种括号 [](){}，判断起来有一点难度。

#### 20.「[有效的括号](https://leetcode.cn/problems/valid-parentheses/)」

> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
>
> 有效字符串需满足：
>
> 1. 左括号必须用相同类型的右括号闭合。
> 2. 左括号必须以正确的顺序闭合。
> 3. 每个右括号都有一个对应的相同类型的左括号。
>
> **示例 1：**   
> 输入：s = "()"  
> 输出：true

解决这个问题之前，我们先降低难度，思考一下，**如果只有一种括号 ()** ，应该如何判断字符串组成的括号是否有效呢？

假设字符串中只有圆括号，如果想让括号字符串有效，那么必须做到：

**每个右括号 ) 的左边必须有一个左括号 ( 和它匹配**。

比如说字符串 ()))(( 中，中间的两个右括号**左边**就没有左括号匹配，所以这个括号组合是无效的。

那么根据这个思路，我们可以写出算法：

```java
/**
* 一个字符串合法括号字符串的条件:
* 1. 左右括号数量相等;
* 2. 任意一个位置左括号的数量都大于等于右括号的数量。
*/

/**
 * 定义一个函数，检验字符串是否为合法括号字符串
 * @param str 待检验的字符串
 * @return boolean 类型，是/否合法括号字符串
 */
boolean isValid(String str) {
    // 待匹配的左括号数量
    int left = 0;
    for (int i = 0; i < str.length(); i++) {
        if (str.charAt(i) == '(') {
            left++;
        } else {
            // 遇到右括号
            left--;
        }

        // 右括号太多
        if (left == -1)
            return false;
    }
    // 是否所有的左括号都被匹配了
    return left == 0;
}
```

如果只有圆括号，这样就能正确判断有效性。对于三种括号的情况，我一开始想模仿这个思路，定义三个变量 left1，left2，left3 分别处理每种括号，虽然要多写不少 if else 分支，但是似乎可以解决问题。

但实际上直接照搬这种思路是不行的，比如说只有一个括号的情况下 (()) 是有效的，但是多种括号的情况下， [(]) 显然是无效的。

仅仅记录每种左括号出现的次数已经不能做出正确判断了，我们要加大存储的信息量，可以利用栈来模仿类似的思路。栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。

我们这道题就用一个名为 left 的栈代替之前思路中的 left 变量，**遇到左括号就入栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配**：

```java
boolean isValid(String str) {
    Stack<Character> left = new Stack<>();
    for (char c : str.toCharArray()) {
        if (c == '(' || c == '{' || c == '[')
            left.push(c);
        else { // 字符 c 是右括号
            if (!left.empty() && leftOf(c) == left.peek())
                left.pop();
            else
                // 和最近的左括号不匹配
                return false;
        }
    }
    // 是否所有的左括号都被匹配了
    return left.empty();
}

char leftOf(char c) {
    if (c == '}') return '{';
    if (c == ')') return '(';
    return '[';
}
```

#### 921.「[使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)」

> 只有满足下面几点之一，括号字符串才是有效的：
>
> - 它是一个空字符串，或者
> - 它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者
> - 它可以被写作 (A)，其中 A 是有效字符串。
>
> 给定一个括号字符串 s ，在每一次操作中，你都可以在字符串的任何位置插入一个括号
>
> - 例如，如果 s = "()))" ，你可以插入一个开始括号为 "(()))" 或结束括号为 "())))" 。
>
> 返回 *为使结果字符串* *​`s`​*​ *有效而必须添加的最少括号数*。
>
> **示例 1：**   
> 输入：s = "())"  
> 输出：1

给你输入一个字符串 s，你可以在其中的任意位置插入左括号 ( 或者右括号 )，请问你最少需要几次插入才能使得 s 变成一个有效的括号串？

比如说输入 s = "())("，算法应该返回 2，因为我们至少需要插入两次把 s 变成 "(())()"，这样每个左括号都有一个右括号匹配，s 是一个有效的括号串。

这其实和前文的判断括号有效性非常类似，我们直接看代码：

```java
/**
 * 给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。
 * 在完成此题时，保证输入始终是有效的。
 * 
 * 示例：
 * 输入："())"
 * 输出：1
 */
public int minAddToMakeValid(String S) {
    // 记录插入次数
    int res = 0;
    // 变量记录右括号的需求量
    int need = 0;

    for (int i = 0; i < S.length(); i++) {
        if (S.charAt(i) == '(') {
            // 对右括号的需求 + 1
            need++;
        }

        if (S.charAt(i) == ')') {
            // 对右括号的需求 - 1
            need--;

            if (need == -1) {
                need = 0;
                // 需插入一个左括号
                res++;
            }
        }
    }

    // 插入剩余所需的右括号
    return res + need;
}
```

#### 1541.「[平衡括号字符串的最少插入次数](https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/)」

> 给你一个括号字符串 s ，它只包含字符 '(' 和 ')' 。一个括号字符串被称为平衡的当它满足：
>
> - 任何左括号 '(' 必须对应两个连续的右括号 '))' 。
> - 左括号 '(' 必须在对应的连续两个右括号 '))' 之前。
>
> 比方说 "())"， "())(())))" 和 "(())())))" 都是平衡的， ")()"， "()))" 和 "(()))" 都是不平衡的。
>
> 你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。
>
> 请你返回让 s 平衡的最少插入次数。
>
> **示例 1：**
>
> 输入：s = "(()))"  
> 输出：1  
> 解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。  
> 我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 "(())))" 。

现在假设 1 个左括号需要匹配 2 个右括号才叫做有效的括号组合，那么给你输入一个括号串 s，请问你如何计算使得 s 有效的最小插入次数呢？

**核心思路还是和刚才一样，通过一个 need 变量记录对右括号的需求数，根据 need 的变化来判断是否需要插入**。

第一步，我们按照刚才的思路正确维护 need 变量：

```java
int minInsertions(String s) {
    // need 记录需右括号的需求量
    int res = 0, need = 0;
  
    for (int i = 0; i < s.length(); i++) {
        // 一个左括号对应两个右括号
        if (s.charAt(i) == '(') {
            need += 2;
        }
    
        if (s.charAt(i) == ')') {
            need--;
        }
    }
  
    return res + need;
}
```

现在想一想，当 need 为什么值的时候，我们可以确定需要进行插入？

**首先，类似第一题，当 need == -1 时，意味着我们遇到一个多余的右括号，显然需要插入一个左括号**。

比如说当 s = ")"，我们肯定需要插入一个左括号让 s = "()"，但是由于一个左括号需要两个右括号，所以对右括号的需求量变为 1：

```java
if (s[i] == ')') {
    need--;
    // 说明右括号太多了
    if (need == -1) {
        // 需要插入一个左括号
        res++;
        // 同时，对右括号的需求变为 1
        need = 1;
    }
}
```

**另外，当遇到左括号时，若对右括号的需求量为奇数，需要插入 1 个右括号**。因为一个左括号需要两个右括号嘛，右括号的需求必须是偶数，这一点也是本题的难点。

所以遇到左括号时要做如下判断：

```java
if (s[i] == '(') {
    need += 2;
    if (need % 2 == 1) {
        // 插入一个右括号
        res++;
        // 对右括号的需求减一
        need--;
    }
}
```

综上，我们可以写出正确的代码：

```java
public int minInsertions(String s) {
    int res = 0, need = 0;

    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) == '(') {
            need += 2;
            if (need % 2 == 1) {
                res++;
                need--;
            }
        }
    
        if (s.charAt(i) == ')') {
            need--;
            if (need == -1) {
                res++;
                need = 1;
            }
        }
    }
  
    return res + need;
}
```
