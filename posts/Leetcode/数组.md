## 数组

### 数组

#### 练习题

##### **LCR 120.** 「[寻找文件副本](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/description/)」

> 设备中存有 `n`​ 个文件，文件 `id`​ 记于数组 `documents`​。若文件 `id`​ 相同，则定义为该文件存在副本。请返回任一存在副本的文件 `id`​。
>
> **示例 1：**   
> 输入： [2, 3, 1, 0, 2, 5, 3]  
> 输出：2 或 3

题目说明尚未被充分使用，即在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内。此说明含义：数组元素的索引和值是一对多的关系。 因此，可遍历数组并通过交换操作，使元素的索引与值一一对应（即`nums[i] = i`​）。因而，就能通过索引映射对应的值，起到与字典等价的作用。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677592614198-42119b32-1e15-4b80-8a8b-e1c51a7f3955-20240324211707-pa4vlkg.png" alt="image.png" style="zoom:50%;" />  

遍历中，第一次遇到数字 xxx 时，将其交换至索引 xxx 处；而当第二次遇到数字 xxx 时，一定有`nums[x] = x`​ ，此时即可得到一组重复数字。

**算法流程：**

1. 遍历数组 nums ，设索引初始值为 `i = 0`:

    - 若`nums[i] = i`​：说明此数字已在对应索引位置，无需交换，因此跳过；
    - 若`nums[nums[i]] = nums[i]`​：代表索引`nums[i]`​处和索引`i `​处的元素值都为`nums[i]`​，即找到一组重复值，返回此值 `nums[i]`​；
    - 否则：交换索引为`i`​和 `nums[i]`​的元素值，将此数字交换至对应索引位置。
2. 若遍历完毕尚未返回，则返回 −1。

**复杂度分析：**

- 时间复杂度 O(N)： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1)。  
- 空间复杂度 O(1) ： 使用常数复杂度的额外空间。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/a1.png" alt="a1" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/a2.png" alt="a2" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/a3.png" alt="a3" style="zoom:50%;" />
--- | --- | ---
<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/a4.png" alt="a4" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/a5.png" alt="a5" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/a6.png" alt="a6" style="zoom:50%;" />
<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/a7.png" alt="a7" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/a8.png" alt="a8" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/a9.png" alt="a9" style="zoom:50%;" />

```java
class Solution {
    public int findRepeatDocument(int[] documents) {
        int n = documents.length;
        int i = 0;
        while (i < n) {
            if (documents[i] == i) {
                ++i;
                continue;
            }
            if (documents[i] == documents[documents[i]]) {
                return documents[i];
            }
            int temp = documents[i];
            documents[i] = documents[temp];
            documents[temp] = temp;
        }
        return -1;
    }
}
```

```go
func findRepeatDocument(documents []int) int {
    i, n := 0, len(documents)
    for i < n {
        if documents[i] == i {
            i++
            continue
        }
        if documents[i] == documents[documents[i]] {
            return documents[i]
        }
        documents[i], documents[documents[i]] = documents[documents[i]], documents[i]
    }
    return -1
}
```

##### **LCR 121.** 「[寻找目标值 - 二维数组](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/description/?orderBy=hot)」

> `m`​*`n`​ 的二维数组 `plants`​ 记录了园林景观的植物排布情况，具有以下特性：
>
> - 每行中，每棵植物的右侧相邻植物不矮于该植物；
> - 每列中，每棵植物的下侧相邻植物不矮于该植物。
>
> 请判断 `plants`​ 中是否存在目标高度值 `target`​。
>
> **示例:**
>
> 现有矩阵 matrix 如下：  
> [
> [1,   4,  7, 11, 15],
> [2,   5,  8, 12, 19],
> [3,   6,  9, 16, 22],
> [10, 13, 14, 17, 24],
> [18, 21, 23, 26, 30]  
> ]  
> 给定 target = 5，返回 true。  
> 给定 target = 20，返回 false。

> 若使用暴力法遍历矩阵 matrix ，则时间复杂度为 O(NM) 。暴力法未利用矩阵 “从上到下递增、从左到右递增” 的特点，显然不是最优解法。

如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值 target 。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677645488780-71fd3666-0f6c-42ea-8a28-517ca29cd8be-20240324211707-vq6u4t7.png" alt="image.png" style="zoom:50%;" />

“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 标志数 ，以 matrix 中的 左下角元素 为标志数 flag ，则有:

- 若 flag > target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。
- 若 flag < target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。

**算法流程：**

1. 从矩阵 matrix 右上角角元素（索引设为 (i, j) ）开始遍历，并与目标值对比：

    1. 当 matrix[i][j] > target 时，需要变小，执行 j-- ，即往走边走；
    2. 当 matrix[i][j] < target 时，需要变大，执行 i++ ，即往下边走；
    3. 当 matrix[i][j] = target 时，返回 true ，代表找到目标值。
2. 若行索引或列索引越界，则代表矩阵中无目标值，返回 false。

**复杂度分析：**

- 时间复杂度 O(M+N) ：其中，N 和 M分别为矩阵行数和列数，此算法最多循环 M+N次。
- 空间复杂度 O(1) : i, j 指针使用常数大小额外空间。

```java
public boolean findNumberIn2DArray(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }
    int row = matrix.length, col = matrix[0].length;
    int i = 0, j = col - 1;
    while (i < row && j >= 0) {
        if (matrix[i][j] == target) return true;
        else if (matrix[i][j] < target) ++i;
        else --j;
    }
    return false;
}
```

```go
func findTargetIn2DPlants(plants [][]int, target int) bool {
    if plants == nil || len(plants) == 0 || len(plants[0]) == 0 {
        return false
    }
    row, col := len(plants), len(plants[0])
    i, j := 0, col - 1
    for i < row && j >= 0 {
        if plants[i][j] < target {
            i++
        } else if plants[i][j] > target {
            j--
        } else {
            return true
        }
    }
    return false
}
```

##### **LCR 158.「**​[库存管理 II](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/description/)」

> 仓库管理员以数组 `stock`​ 形式记录商品库存表。`stock[i]`​ 表示商品 `id`​，可能存在重复。请返回库存表中数量大于 `stock.length / 2`​ 的商品 `id`​。
>
> **示例 1:**   
> 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]  
> 输出: 2

本题常见的三种解法：

- 哈希表统计法： 遍历数组 nums ，用 HashMap 统计各数字的数量，即可找出 众数 。此方法时间和空间复杂度均为 O(N)。
- 数组排序法： 将数组 nums 排序，数组中点的元素 一定为众数。
- 摩尔投票法： 核心理念为 票数正负抵消 。此方法时间和空间复杂度分别为 O(N) 和 O(1) ，为本题的最佳解法。

**摩尔投票法：**

设输入数组 nums 的众数为 x ，数组长度为 n 。

- 推论一： 若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的 票数和 >0。
- 推论二： 若数组的前 a 个数字的 票数和 =0，则 数组剩余 (n−a) 个数字的 票数和一定仍 >0 ，即后 (n−a) 个数字的 众数仍为 x 。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679040448237-3bb044ad-3758-46aa-8df3-2e3871a4b682-20240324211707-r9jp99o.png" alt="image.png" style="zoom:50%;" />  
根据以上推论，记数组首个元素为 n1，众数为 x ，遍历并统计票数。当发生 票数和 = 0 时，剩余数组的众数一定不变 ，这是由于：

- **当 n1=x ：**  抵消的所有数字中，有一半是众数 *x* 。
- **当 n1≠x：**  抵消的所有数字中，众数 x 的数量最少为 0 个，最多为一半。

利用此特性，每轮假设发生 **票数和 = 0** 都可以 **缩小剩余数组区间** 。当遍历完成时，最后一轮假设的数字即为众数。

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-mqrUIY-Picture2.png" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-MfsWQB-Picture3.png" alt="img" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-dhVmEY-Picture4.png" alt="img" style="zoom:50%;" />
--- | --- | ---
<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-QdHZir-Picture5.png" alt="img" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-WWGfIa-Picture6.png" alt="img" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-WvtbDg-Picture7.png" alt="img" style="zoom:50%;" />
<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-qbANWt-Picture8.png" alt="img" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-FyPKfT-Picture9.png" alt="img" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-wbGYtp-Picture10.png" alt="img" style="zoom:50%;" />
<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-sLvIAG-Picture11.png" alt="img" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-wYupjD-Picture12.png" alt="img" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-fSpbfK-Picture13.png" alt="img" style="zoom:50%;" />
<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-ccBkhy-Picture14.png" alt="img" style="zoom:50%;" /> | <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/1603612327-yArPBb-Picture15.png" alt="img" style="zoom:50%;" />

复杂度分析：

- 时间复杂度 O(N)： N 为数组 nums 长度。
- 空间复杂度 O(1)： votes 变量使用常数大小的额外空间。

```java
class Solution {
    public int majorityElement(int[] nums) {
        int x = 0, votes = 0;
        for(int num : nums){
            if(votes == 0) x = num;
            votes += num == x ? 1 : -1;
        }
        return x;
    }
}
```

```go
func inventoryManagement(nums []int) int {
    x, count := 0, 0
    for _, num := range nums {
        if count == 0 {
            x = num
        }
        if x == num {
            count++
        } else {
            count--
        }
    }
    return x
}
```
