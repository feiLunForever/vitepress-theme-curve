# 核心框架

## 双指针

### 数组双指针

#### 概念

> 在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：**左右指针**和**快慢指针**。
>
> - 所谓左右指针，就是两个指针相向而行或者相背而行；
> - 而所谓快慢指针，就是两个指针同向而行，一快一慢。

#### 练习题

##### 快慢指针

###### 27.「 [移除元素](https://leetcode.cn/problems/remove-element/)」

> 给你一个数组 `nums`​  和一个值 `val`​，你需要 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 移除所有数值等于 `val`​  的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 `O(1)`​ 额外空间并 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** **修改输入数组**。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> **示例 1：**   
> 输入：nums = [3,2,2,3], val = 3  
> 输出：2, nums = [2,2]
>
> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。

删除过程如下：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1675059883348-708387b6-1b75-433f-b9c0-3eb62b84a0d8-20240221152050-epf4ss0.gif" alt="image" style="zoom:90%;" />

```java
public int removeElement(int[] nums, int val) {
	int fast = 0, slow = 0;
	while(fast < nums.length) {
		if(nums[fast] == val) {
			fast++;
		} else {
			nums[slow++] = nums[fast++];
		}
	}
	return slow;
}
```

```go
func removeElement(nums []int, val int) int {
    slow := 0
    for fast := 0; fast < len(nums); fast++ {
        if (nums[fast] != val) {
            nums[slow] = nums[fast]
            slow++
        }
    }
    return slow
}
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

> **注意** 这里和有序数组去重的解法有一个细节差异，我们这里是先给 `nums[slow]`​ 赋值然后再给 `slow++`​，这样可以保证 `nums[0..slow-1]`​ 是不包含值为 `val`​ 的元素的，最后的结果数组长度就是 `slow`​。

###### 26.「 [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)」

> 给你一个 **非严格递增排列** 的数组 `nums`​ ，请你 **[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums`​ 中唯一元素的个数。
>
> 考虑 `nums`​ 的唯一元素的数量为 `k`​ ，你需要做以下事情确保你的题解可以被通过：
>
> - 更改数组 `nums`​ ，使 `nums`​ 的前 `k`​ 个元素包含唯一元素，并按照它们最初在 `nums`​ 中出现的顺序排列。`nums`​ 的其余元素与 `nums`​ 的大小不重要。
> - 返回 `k`​ 。
>
> **示例 1：**
>
> 输入：nums = [1,1,2]  
> 输出：2, nums = [1,2,_]
>
> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

高效解决这道题就要用到快慢指针技巧：

我们让 `慢指针 slow`​ 走在后面，`快指针 fast`​ 走在前面探路，找到一个不重复的元素就赋值给 `slow`​ 并让 `slow`​ 前进一步。

这样，就保证了 `nums[0..slow]`​ 都是无重复的元素，当 `fast`​ 指针遍历完整个数组 `nums`​ 后，`nums[0..slow]`​ 就是整个数组去重之后的结果。

```java
int removeDuplicates(int[] nums) {
	int slow = 0, fast = 0;
	int n = nums.length;
	while (fast < n) {
		if (nums[slow] == nums[fast]) {
			++fast;
		} else {
			++slow; // 去掉重复，保留第一位，所以slow指向下一个重复项
			nums[slow] = nums[fast++];
		}
	}
	return slow + 1; // 数组长度为索引 + 1
}
```

```go
func removeDuplicates(nums []int) int {
	slow := 0
	for fast := 0; fast < len(nums); fast++ {
		if nums[fast] != nums[slow] {
			slow++
			nums[slow] = nums[fast]
		}
	}
	return slow + 1
}
```

算法执行的过程如下 GIF 图：


<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1675059883315-6636ea29-b564-4e3f-9c58-21ac48579cec-20240221152050-aqt6966.gif" alt="image" style="zoom:50%;" />

###### 83.「 [删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)」

> 给定一个已排序的链表的头 head ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。  
> **示例 1：**  
>
>  <img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1689327636327-10fe2430-9123-48a2-81ca-b57ff0d6c140-20240221152050-yqrs90k.jpeg" alt="image" style="zoom:60%;" />  
>
> 输入：head = [1,1,2]  
>
> 输出：[1,2]

其实和数组去重是一模一样的，唯一的区别是把数组赋值操作变成操作指针而已。

```java
public ListNode deleteDuplicates(ListNode head) {
	if(head == null) return null;
	ListNode fast = head, slow = head;
	while (fast != null) {
		if (fast.val == slow.val) {
			fast = fast.next;
		} else {
			slow.next = fast;
			slow = slow.next;
			fast = fast.next;
		}
	}
	slow.next = null;
	return head;
}
```

```go
func deleteDuplicates(head *ListNode) *ListNode {
	if head == nil {
		return nil
	}
	slow, fast := head, head
	for fast != nil {
		if slow.Val == fast.Val {
			fast = fast.Next
		} else {
			slow.Next = fast
			slow = slow.Next
			fast = fast.Next
		}
	}
	slow.Next = nil
	return head
}
```

算法执行的过程请看下面这个 GIF：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1675059883363-8a5c764e-643f-451a-86c9-5aab77c28c66-20240221152050-7cvjsc1.gif" alt="image" style="zoom:40%;" />​

###### 283.「 [移动零](https://leetcode.cn/problems/move-zeroes/)」

> 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。
>
> **示例 1:**   
> 输入: nums = [0,1,0,3,12]  
> 输出: [1,3,12,0,0]

比如说给你输入 nums = [0,1,4,0,2]，你的算法没有返回值，但是会把 nums 数组原地修改成 [1,4,2,0,0]。

```java
public void moveZeroes(int[] nums) {
	int slow = 0, fast = 0;
	int n = nums.length;
	while (fast < n) {
		if (nums[fast] == 0) {
			++fast;
		} else {
			nums[slow++] = nums[fast++];
		}
	}
	while (slow < n) {
		nums[slow++] = 0;
	}
}
```

```go
func moveZeroes(nums []int)  {
    slow, fast, n := 0, 0, len(nums)
    for fast < n {
        if nums[fast] == 0 {
            fast++
        } else {
            nums[slow] = nums[fast]
            slow++
            fast++
        }
    }
    for ;slow < n; slow++ {
        nums[slow] = 0
    }
}
```

##### 左右指针

###### 二分查找

```java
int binarySearch(int[] nums, int target) {
  int left = 0, right = nums.length - 1; // 一左一右两个指针相向而行
  while(left <= right) {
    int mid = (right + left) / 2;
    if(nums[mid] == target) return mid;
    else if(nums[mid] < target) left = mid + 1;
    else if(nums[mid] > target) right = mid - 1;
  }
  return -1;
}
```

###### 167.「 [两数之和 II](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)」

> 给你一个下标从 **1** 开始的整数数组 `numbers`​ ，该数组已按 **非递减顺序排列**，请你从数组中找出满足相加之和等于目标数 `target`​ 的两个数。如果设这两个数分别是 `numbers[index1]`​ 和 `numbers[index2]`​ ，则 `1 <= index1 < index2 <= numbers.length`​ 。
>
> 以长度为 2 的整数数组 `[index1, index2]`​ 的形式返回这两个整数的下标 `index1`​ 和 `index2`​。
>
> 你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。
> 你所设计的解决方案必须只使用常量级的额外空间。
> **示例 1：**
> 输入：numbers = [2,7,11,15], target = 9
> 输出：[1,2]
> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。

只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 就可以调整 sum 的大小：

```java
int[] twoSum(int[] nums, int target) {
  int left = 0, right = nums.length - 1; // 一左一右两个指针相向而行
  while(left < right) {
    int sum = nums[left] + nums[right];
    if(sum == target) {
      return new int[] {left + 1, right + 1}; // 题目要求的索引是从 1 开始的
    } else if(sum < target) { // 让 sum 大一点
      left++;
    } else if(sum > target) { // 让 sum 小一点
      right--;
    }
  }
  return new int[] {-1, -1};
}
```

```go
func twoSum(numbers []int, target int) []int {
    left, right := 0, len(numbers) - 1
    for left <= right {
        sum := numbers[left] + numbers[right]
        if sum == target {
            return []int {left + 1, right + 1}
        } else if sum < target {
            left++
        } else {
            right--
        }
    }
    return []int {-1, -1}
}
```

###### 344.「 [反转字符串](https://leetcode.cn/problems/reverse-string/)」

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
> 不要给另外的数组分配额外的空间，你必须[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)​**修改输入数组**、使用 O(1) 的额外空间解决这一问题。
> **示例 1：**
> 输入：s = ["h","e","l","l","o"]
> 输出：["o","l","l","e","h"]

让你反转一个 char[] 类型的字符数组。

```java
void reverseString(char[] s) {
  int left = 0, right = s.length - 1; // 一左一右两个指针相向而行
  while(left < right) { // 交换 s[left] 和 s[right]
    char temp = s[left];
    s[left] = s[right];
    s[right] = temp;
    left++;
    right--;
  }
}
```

```go
func reverseString(s []byte) {
	for left, right := 0, len(s) - 1; left <= right; left, right = left + 1, right - 1 {
		s[left], s[right] = s[right], s[left]
	}
}
```

###### 5.「 [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)」

> 给你一个字符串 s，找到 s 中最长的回文子串。
> 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。
> **示例 1：**
> 输入：s = "babad"
> 输出："bab"
> 解释："aba" 同样是符合题意的答案。

首先明确一下，回文串就是正着读和反着读都一样的字符串。

比如说字符串 aba 和 abba 都是回文串，因为它们对称，反过来还是和本身一样；反之，字符串 abac 就不是回文串。

找回文串的难点在于，回文串的的长度可能是奇数也可能是偶数，解决该问题的核心是**从中心向两端扩散的双指针技巧**。

如果回文串的长度为奇数，则它有一个中心字符；如果回文串的长度为偶数，则可以认为它有两个中心字符。所以我们可以先实现这样一个函数：

```java
String palindrome(String s, int l, int r) { // 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串
  while(l >= 0 && r < s.length() 
        && s.charAt(l) == s.charAt(r)) { // 防止索引越界
    l--;
    r++; // 双指针，向两边展开
  }
  return s.substring(l + 1, r); // 返回以 s[l] 和 s[r] 为中心的最长回文串
}
```

这样，如果输入相同的 l 和 r，就相当于寻找长度为奇数的回文串，如果输入相邻的 l 和 r，则相当于寻找长度为偶数的回文串。
那么回到最长回文串的问题，解法的大致思路就是：

```java
for 0 <= i < len(s):
    找到以 s[i] 为中心的回文串
    找到以 s[i] 和 s[i+1] 为中心的回文串
    更新答案
```

翻译成代码，就可以解决最长回文子串这个问题：

```java
String longestPalindrome(String s) {
  String res = "";
  for(int i = 0; i < s.length(); i++) { // 以 s[i] 为中心的最长回文子串
    // 以 s[i] 和 s[i+1] 为中心的最长回文子串
    String s1 = palindrome(s, i, i);
    String s2 = palindrome(s, i, i + 1);
    // res = longest(res, s1, s2)
    res = res.length() > s1.length() ? res : s1;
    res = res.length() > s2.length() ? res : s2;
  }
  return res;
}
```

```go
func longestPalindrome(s string) string {
    res := ""
    for i := 0; i < len(s); i++ {
        s1 := palindrome(s, i, i)
        s2 := palindrome(s, i, i + 1)
        if len(res) < len(s1) {
            res = s1
        }
        if len(res) < len(s2) {
            res = s2
        }
    }
    return res
}

func palindrome(s string, left int, right int) string {
    for left >=0 && right < len(s) && s[left] == s[right] {
        left--
        right++
    }
    return s[left + 1 : right]
}
```

你应该能发现最长回文子串使用的左右指针和之前题目的左右指针有一些不同：之前的左右指针都是从两端向中间相向而行，而回文子串问题则是让左右指针从中心向两端扩展。不过这种情况也就回文串这类问题会遇到，所以我也把它归为左右指针了。

###### 977.[「有序数组的平方」](https://leetcode.cn/problems/squares-of-a-sorted-array/)

> 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
>
> 示例 1：  
> 输入：nums = [-4,-1,0,3,10]  
> 输出：[0,1,9,16,100]  
> 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

数组其实是有序的， 只不过负数平方之后可能成为最大数了。

那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

此时可以考虑双指针法了，i 指向起始位置，j 指向终止位置。

定义一个新数组 result，和 A 数组一样的大小，让 k 指向 result 数组终止位置。

如果 A[i] * A[i] < A[j] * A[j] 那么 result[k--] = A[j] * A[j]; 。

如果 A[i] * A[i] >= A[j] * A[j] 那么 result[k--] = A[i] * A[i]; 。

如动画所示：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1675059883444-45ed9874-2d76-4a3d-9e3d-54da5c8c8175-20240221152052-2vefnmf.gif" alt="image" style="zoom:90%;" />

```java
class Solution {
  public int[] sortedSquares(int[] nums) {
    int right = nums.length - 1;
    int left = 0;
    int[] result = new int[nums.length];
    int index = result.length - 1;
    while(left <= right) {
      if(nums[left] * nums[left] > nums[right] * nums[right]) { // 正数的相对位置是不变的， 需要调整的是负数平方后的相对位置
        result[index--] = nums[left] * nums[left];
        ++left;
      } else {
        result[index--] = nums[right] * nums[right];
        --right;
      }
    }
    return result;
  }
}
```

```go
func sortedSquares(nums []int) []int {
    left, right, i := 0, len(nums) - 1, len(nums) - 1
    res := make([]int, len(nums))
    for left <= right {
        sqrt1, sqrt2 := nums[left] * nums[left], nums[right] * nums[right]
        if sqrt1 < sqrt2 {
            res[i] = sqrt2
            right--
        } else {
            res[i] = sqrt1
            left++
        }
        i--
    }
    return res
}
```

此时的时间复杂度为 O(n)。

###### 870.「 [优势洗牌](https://leetcode.cn/problems/advantage-shuffle/)」

> 给定两个长度相等的数组 `nums1`​ 和 `nums2`​，`nums1`​ 相对于 `nums2`​ 的*优势*可以用满足 `nums1[i] > nums2[i]`​ 的索引 `i`​ 的数目来描述。
>
> 返回 nums1 的**任意**排列，使其相对于 `nums2`​ 的优势最大化。
>
> **输入：** nums1 = [2,7,11,15], nums2 = [1,10,4,11]  
> **输出：** [2,11,7,15]

**这就像田忌赛马的情景，nums1 就是田忌的马，nums2 就是齐王的马，数组中的元素就是马的战斗力，你就是孙膑，展示你真正的技术吧**。

仔细想想，这个题的解法还是有点扑朔迷离的。什么时候应该放弃抵抗去送人头，什么时候应该硬刚？这里面应该有一种算法策略来最大化「优势」。

送人头一定是迫不得已而为之的权宜之计，否则隔壁田忌就会以为你是齐王买来的演员。只有田忌的上等马比不过齐王的上等马时，才会用下等马去和齐王的上等马互换。

对于比较复杂的问题，可以尝试从特殊情况考虑。

你想，谁应该去应对齐王最快的马？肯定是田忌最快的那匹马，我们简称一号选手。

**如果田忌的一号选手比不过齐王的一号选手**，那其他马肯定是白给了，显然这种情况应该用田忌垫底的马去送人头，降低己方损失，保存实力，增加接下来比赛的胜率。

**但如果田忌的一号选手能比得过齐王的一号选手**，那就和齐王硬刚好了，反正这把田忌可以赢。

你也许说，这种情况下说不定田忌的二号选手也能干得过齐王的一号选手？如果可以的话，让二号选手去对决齐王的一号选手，不是更节约？

就好比，如果考 60 分就能过的话，何必考 90 分？每多考一分就亏一分，刚刚好卡在 60 分是最划算的。

**这种节约的策略是没问题的，但是没有必要。这也是本题有趣的地方，需要绕个脑筋急转弯**：

我们暂且把田忌的一号选手称为 T1，二号选手称为 T2，齐王的一号选手称为 Q1。

如果 T2 能赢 Q1，你试图保存己方实力，让 T2 去战 Q1，把 T1 留着是为了对付谁？

显然，你担心齐王还有战力大于 T2 的马，可以让 T1 去对付。

但是你仔细想想，现在 T2 已经是可以战胜 Q1 的，Q1 可是齐王的最快的马耶，齐王剩下的那些马里，怎么可能还有比 T2 更强的马？

所以，没必要节约，最后我们得出的策略就是：

**将齐王和田忌的马按照战斗力排序，然后按照排名一一对比。如果田忌的马能赢，那就比赛，如果赢不了，那就换个垫底的来送人头，保存实力**。

上述思路的代码逻辑如下：

```java
int n = nums1.length;

sort(nums1); // 田忌的马
sort(nums2); // 齐王的马

// 从最快的马开始比
for (int i = n - 1; i >= 0; i--) {
    if (nums1[i] > nums2[i]) {
        // 比得过，跟他比
    } else {
        // 比不过，换个垫底的来送人头
    }
}
```

根据这个思路，我们需要对两个数组排序，但是 nums2 中元素的顺序不能改变，因为计算结果的顺序依赖 nums2 的顺序，所以不能直接对 nums2 进行排序，而是利用其他数据结构来辅助。

同时，最终的解法还用到前文 [双指针技巧汇总](https://labuladong.gitee.io/algo/di-ling-zh-bfe1b/shuang-zhi-fa4bd/) 总结的双指针算法模板，用以处理「送人头」的情况：

```java
int[] advantageCount(int[] nums1, int[] nums2) {
    int n = nums1.length;
    // 给 nums2 降序排序
    PriorityQueue<int[]> maxpq = new PriorityQueue<>(
        (int[] pair1, int[] pair2) -> { 
            return pair2[1] - pair1[1];
        }
    );
    for (int i = 0; i < n; i++) {
        maxpq.offer(new int[]{i, nums2[i]});
    }
    // 给 nums1 升序排序
    Arrays.sort(nums1);

    // nums1[left] 是最小值，nums1[right] 是最大值
    int left = 0, right = n - 1;
    int[] res = new int[n];

    while (!maxpq.isEmpty()) {
        int[] pair = maxpq.poll();
        // maxval 是 nums2 中的最大值，i 是对应索引
        int i = pair[0], maxval = pair[1];
        if (maxval < nums1[right]) {
            // 如果 nums1[right] 能胜过 maxval，那就自己上
            res[i] = nums1[right];
            right--;
        } else {
            // 否则用最小值混一下，养精蓄锐
            res[i] = nums1[left];
            left++;
        }
    }
    return res;
}
```

算法的时间复杂度很好分析，也就是二叉堆和排序的复杂度 O(nlogn)。

在Go语言中，没有内置的优先队列数据结构，其实我们没有必要用优先级队列，不就是想记录nums2数组对应原来的下标位置么，我们可以这样：

> 创建一个下标数组 ids，对ids 排序，即 ids[0] 对应 nums2中最大的下标，ids[1] 对应 nums2中第二大值的下标，……。

```java
for (int i = 0; i < n; i++) {
    ids[i] = i;
}
Arrays.sort(ids, (i, j) -> nums2[j] - nums2[i]);
```

所以go语言实现如下：

```go
func advantageCount(nums1 []int, nums2 []int) []int {
		n := len(nums1)
    
    slices.Sort(nums1)

    ids := make([]int, n) // ids 记录nums2的坐标 [0, n-1]
    for i := range ids {
        ids[i] = i;
    }

    // ids[0] 代表 nums2 最大元素 对应的下标
    slices.SortFunc(ids, func(i, j int) int {return nums2[j] - nums2[i]})

    left, right := 0, n - 1
    res := make([]int, n)

    for _, x := range ids {
        index := x // nums2 下标
        maxValue := nums2[x] // nums2 的 值
        if nums1[right] > maxValue {
            res[index] = nums1[right]
            right--
        } else {
            res[index] = nums1[left]
            left++
        }
    }

    return res
}
```

###### LCR 181. 「[字符串中的单词反转](https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/description/)」

> 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。
>
> **示例 1：**
>
> 输入: "the sky is blue"  
> 输出: "blue is sky the"

**算法解析**：

- 倒序遍历字符串 s ，记录单词左右索引边界 l , r ；
- 每确定一个单词的边界，则将其添加至单词列表 StringBuilder 中 ；
- 最终，将单词列表拼接为字符串，并返回即可。

**复杂度分析：**

- 时间复杂度 O(N) ： 其中 N 为字符串 s 的长度，线性遍历字符串。
- 空间复杂度 O(N)： 新建的 StringBuilder 中的字符串总长度 ≤N ，占用 O(N) 大小的额外空间。

```java
class Solution {
    public String reverseWords(String s) {
        int r = s.length() - 1;
        StringBuilder sb = new StringBuilder();
        while (r >= 0) {
            while (r >= 0 && s.charAt(r) == ' ') --r;
            if (r < 0) break;
            int l = r - 1;
            while (l >= 0 && s.charAt(l) != ' ') --l;
            for (int i = l + 1; i <= r; i++) {
                sb.append(s.charAt(i));
            }
            sb.append(' ');
            r = l;
        }
        return sb.length() > 1 ? sb.substring(0, sb.length() - 1) : "";
    }
}
```

```go
func reverseMessage(message string) string {
    var res string
    for right := len(message) - 1; right >= 0; {
        for right >= 0 && message[right] == ' ' {
            right--
        }
        if right < 0 {
            break
        }
        left := right - 1
        for left >= 0 && message[left] != ' ' {
            left--
        }
        res += message[left + 1 : right + 1] + " "
        right = left
    }
    if len(res) > 0 {
        res = res[:len(res) - 1]
    }
    return res
}
```

##### nSum 问题

###### 167.「<span data-type="text" id="">两数之和 II</span>」

###### 15.「[三数之和](https://leetcode.cn/problems/3sum/)」

> 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请
>
> 你返回所有和为 0 且不重复的三元组。
>
> **注意：** 答案中不可以包含重复的三元组。
>
> **示例 1：**
>
> 输入：nums = [-1,0,1,2,-1,-4]  
> 输出：[[-1,-1,2],[-1,0,1]]
>
> 解释： nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。  
> nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。  
> nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
>
> 不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。 注意，输出的顺序和三元组的顺序并不重要。

nSum 系列问题的核心思路就是**排序 + 双指针**。

先给数组从小到大排序，然后双指针 lo 和 hi 分别在数组开头和结尾，这样就可以控制 nums[lo] 和 nums[hi] 这两数之和的大小：

如果你想让它俩的和大一些，就让 lo++，如果你想让它俩的和小一些，就让 hi--。

但是本题有一个坑。。。

比如说输入为 nums = [1,3,1,2,2,3], target = 4，那么算法返回的结果就是：[[1,3],[2,2]]（注意，我要求返回元素，而不是索引）。

对于修改后的问题，关键难点是现在可能有多个和为 target 的数对儿，还不能重复，比如上述例子中 [1,3] 和 [3,1] 就算重复，只能算一次。

首先，基本思路肯定还是排序加双指针。

但是，这样实现会造成重复的结果，比如说 nums = [1,1,1,2,2,3,3], target = 4，得到的结果中 [1,3] 肯定会重复。

出问题的地方在于 sum == target 条件的 if 分支，当给 res 加入一次结果后，lo 和 hi 不仅应该相向而行，而且应该跳过所有重复的元素：

<img src="https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1689758153104-dca704cf-9f36-4242-ad7e-4e6fb36090ca-20240221152054-l0rnmyg.png" alt="image.png" style="zoom:50%;" />​

所以，可以对双指针的 while 循环做出如下修改：

```sql
while (lo < hi) {
    int sum = nums[lo] + nums[hi];
    // 记录索引 lo 和 hi 最初对应的值
    int left = nums[lo], right = nums[hi];
    if (sum < target)      lo++;
    else if (sum > target) hi--;
    else {
        res.push_back({left, right});
        // 跳过所有重复的元素
        while (lo < hi && nums[lo] == left) lo++;
        while (lo < hi && nums[hi] == right) hi--;
    }
}
```

这样就可以保证一个答案只被添加一次，重复的结果都会被跳过，可以得到正确的答案。不过，受这个思路的启发，其实前两个 if 分支也是可以做一点效率优化，跳过相同的元素：

```sql
vector<vector<int>> twoSumTarget(vector<int>& nums, int target) {
    // nums 数组必须有序
    sort(nums.begin(), nums.end());
    int lo = 0, hi = nums.size() - 1;
    vector<vector<int>> res;
    while (lo < hi) {
        int sum = nums[lo] + nums[hi];
        int left = nums[lo], right = nums[hi];
        if (sum < target) {
            while (lo < hi && nums[lo] == left) lo++;
        } else if (sum > target) {
            while (lo < hi && nums[hi] == right) hi--;
        } else {
            res.push_back({left, right});
            while (lo < hi && nums[lo] == left) lo++;
            while (lo < hi && nums[hi] == right) hi--;
        }
    }
    return res;
}
```

这样，一个通用化的 twoSum 函数就写出来了，请确保你理解了该算法的逻辑，我们后面解决 3Sum 和 4Sum 的时候会复用这个函数。

这个函数的时间复杂度非常容易看出来，双指针操作的部分虽然有那么多 while 循环，但是时间复杂度还是 O(N)，而排序的时间复杂度是 O(NlogN)，所以这个函数的时间复杂度是 O(NlogN)。

```java
public List<List<Integer>> threeSum(int[] nums) {
	List<List<Integer>> res = new LinkedList<>();
    if (nums == null || nums.length < 3) return res;
    Arrays.sort(nums);
    for (int i = 0; i < nums.length; i++) {
    	if (i > 0 && nums[i] == nums[i - 1]) continue; // 为保证不重复，跳过使用过的相同数字
        int left = i + 1, right = nums.length - 1;
        while (left < right) {
        	int sum = nums[i] + nums[left] + nums[right];
        	if (sum == 0) {
        		res.add(Arrays.asList(nums[i], nums[left], nums[right]));
            	while (left < right && nums[left] == nums[left + 1]) ++left;
            	while (left < right && nums[right] == nums[right - 1]) --right;
            	++left;
            	--right;
        	} else if (sum < 0) {
        		++left;
    		} else {
        		--right;
        	}    
    	}
	}
	return res;
}
```

```go
func threeSum(nums []int) [][]int {
    var res [][]int
    if len(nums) < 3 {
        return res
    }
    slices.Sort(nums)
    for i := 0; i < len(nums); i++ {
        if i > 0 && nums[i] == nums[i - 1] {
            continue
        }
        left, right := i + 1, len(nums) - 1
        for left < right {
            sum := nums[i] + nums[left] + nums[right]
            if sum == 0 {
                res = append(res, []int{nums[i], nums[left], nums[right]})
                for left < right && nums[left] == nums[left + 1] {
                    left++
                }
                for left < right && nums[right] == nums[right - 1] {
                    right--
                }
                left++
                right--
            } else if sum < 0 {
                left++
            } else {
                right--
            }
        }
    }
    return res
}
```

###### 18.「[四数之和](https://leetcode.cn/problems/4sum/)」

> 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且**不重复**的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：
>
> - 0 <= a, b, c, d < n
> - a、b、c 和 d **互不相同**
> - nums[a] + nums[b] + nums[c] + nums[d] == target
>
> 你可以按 **任意顺序** 返回答案 。
>
> **示例 1：**
>
> 输入：nums = [1,0,-1,0,-2,2], target = 0  
> 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new LinkedList<>();
        if (nums == null || nums.length < 4) return res;
        Arrays.sort(nums);
        for (int i = 0; i < nums.length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < nums.length - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                int left = j + 1, right = nums.length - 1;
                while (left < right) {
                    long temp = (long) nums[i] + (long) nums[j] + (long) nums[left] + (long) nums[right];
                    if (temp == target) {
                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        while (left < right && nums[left] == nums[left + 1]) left++;
                        while (left < right && nums[right] == nums[right - 1]) right--;
                        left++;
                        right--;
                    } else if (temp < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
            }
        }
        return res;
    }
}
```

```go
func fourSum(nums []int, target int) [][]int {
    var res [][]int
    n := len(nums)
    slices.Sort(nums)
    for i := 0; i < n - 3; i++ {
        if i > 0 && nums[i] == nums[i - 1] {
            continue
        }
        for j := i + 1; j < n - 2; j++ {
            if j > i + 1 && nums[j] == nums[j - 1] {
                continue
            }
            for left, right := j + 1, n - 1; left < right; {
                sum := nums[i] + nums[j] + nums[left] + nums[right]
                if sum == target {
                    res = append(res, []int{nums[i], nums[j], nums[left], nums[right]})
                    for (left < right && nums[left] == nums[left + 1]) {
                        left++
                    }
                    for (left < right && nums[right] == nums[right - 1]) {
                        right--
                    }
                    left++
                    right--
                } else if sum < target {
                    left++
                } else {
                    right--
                }
            }
        }
    }
    return res
}
```

###### **LCR 179. 「**​[查找总价格为目标值的两个商品](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/)」

> 输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。
>
> **示例 1：**
>
> 输入：nums = [2,7,11,15], target = 9  
> 输出：[2,7] 或者 [7,2]

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        // 左右双指针
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int sum = nums[left] + nums[right];
            if (sum < target) {
                // 让和大一点
                left++;
            } else if (sum > target) {
                // 让和小一点
                right--;
            } else {
                // 找到两个数
                return new int[]{nums[left], nums[right]};
            }
        }
        return null;
    }
}
```

```go
func twoSum(price []int, target int) []int {
    
    for left, right := 0, len(price) - 1; left < right; {
        sum := price[left] + price[right]
        if sum == target {
            return []int {price[left], price[right]}
        } else if sum < target {
            left++
        } else {
            right--
        }
    }
    return []int {-1, -1}
}
```

### 链表双指针

#### 练习题

##### 21.「 [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)」

> 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
>
> **示例 1：**   
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1675762065446-1b3a8cc9-6538-4c44-bfbd-eb02a169b6b2-20240221152054-9qw0qke.jpeg)  
> 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4]

这题比较简单，我们直接看解法：

```java
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
  ListNode root = new ListNode(-1); // 虚拟头结点
  ListNode p = root, p1 = list1, p2 = list2;
  while (p1 != null && p2 != null) {
    if (p1.val < p2.val) {
      p.next = p1;
      p1 = p1.next;
    } else {
      p.next = p2;
      p2 = p2.next;
    }
    p = p.next;
  }
  if (p1 != null) {
    p.next = p1;
  }
  if (p2 != null) {
    p.next = p2;
  }
  return root.next;
}
```

我们的 while 循环每次比较 p1 和 p2 的大小，把较小的节点接到结果链表上，看如下 GIF：![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1675766562810-bc483411-fc51-41c5-9c2b-11c45e614621-20240221152054-t91y8ak.gif)  
形象地理解，这个算法的逻辑类似于拉拉链，l1, l2 类似于拉链两侧的锯齿，指针 p 就好像拉链的拉索，将两个有序链表合并；或者说这个过程像蛋白酶合成蛋白质，l1, l2 就好比两条氨基酸，而指针 p 就好像蛋白酶，将氨基酸组合成蛋白质。

**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 dummy 节点**。你可以试试，如果不使用 dummy 虚拟节点，代码会复杂很多，而有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。

PS：经常有读者问我，什么时候需要用虚拟头结点？我这里总结下：**当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理**。

比如说，让你把两条有序链表合并成一条新的有序链表，是不是要创造一条新链表？再比你想把一条链表分解成两条链表，是不是也在创造新链表？这些情况都可以使用虚拟头结点简化边界情况的处理。

go实现如下：

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    root := &ListNode{Val: -1}
    p, p1, p2 := root, list1, list2
    for p1 != nil && p2 != nil {
        if p1.Val < p2.Val {
            p.Next = p1
            p1 = p1.Next
        } else {
            p.Next = p2
            p2 = p2.Next
        }
        p = p.Next
    }
    if p1 != nil {
        p.Next = p1
    }
    if p2 != nil {
        p.Next = p2
    }
    return root.Next
}
```

##### 86.「 [分隔链表](https://leetcode.cn/problems/partition-list/)」

> 给你一个链表的头节点 `head`​ 和一个特定值 `x`​ ，请你对链表进行分隔，使得所有 **小于** `x`​ 的节点都出现在 **大于或等于** `x`​ 的节点之前。
>
> 你应当 **保留** 两个分区中每个节点的初始相对位置。
>
> **示例 1：**   
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1675766650615-ffdd0acd-51aa-4f28-b32a-201fe7663989-20240221152054-3o8bynz.jpeg)  
> 输入：head = [1,4,3,2,5,2], x = 3 输出：[1,2,2,4,3,5]

```java
public ListNode partition(ListNode head, int x) {
  ListNode big = new ListNode(-1), small = new ListNode(-1);
  ListNode p = head, p1 = big, p2 = small;
  while (p != null) {
    if (p.val < x) {
      p2.next = p;
      p2 = p2.next;
    } else {
      p1.next = p;
      p1 = p1.next;
    }
    p = p.next;
  }
  p1.next = null;
  p2.next = big.next;
  return small.next;
}
```

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func partition(head *ListNode, x int) *ListNode {
	small, big := &ListNode{Val: -1}, &ListNode{Val: -1}
    p, p1, p2 := head, small, big
	for p != nil {
		if p.Val < x {
			p1.Next = p
			p1 = p1.Next
		} else {
			p2.Next = p
			p2 = p2.Next
		}
		p = p.Next
	}
	p2.Next = nil
	p1.Next = big.Next

	return small.Next
}
```

##### 23.「 [合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)」

> 给你一个链表数组，每个链表都已经按升序排列。
>
> 请你将所有链表合并到一个升序链表中，返回合并后的链表。
>
> **示例 1：**
>
> 输入：lists = [[1,4,5],[1,3,4],[2,6]]  
> 输出：[1,1,2,3,4,4,5,6]
>
> 解释：  
> 链表数组如下： [
> 1->4->5,
> 1->3->4,
> 2->6  
> ]  
> 将它们合并到一个有序链表中得到。  
> 1->1->2->3->4->4->5->6

合并 k 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 k 个节点中的最小节点，接到结果链表上？

这里我们就要用到 [优先级队列（二叉堆）](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-daeca/er-cha-dui-1a386/) 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 k 个节点中的最小节点：

```java
ListNode mergeKLists(ListNode[] lists) {
    if (lists.length == 0) return null;
    // 虚拟头结点
    ListNode dummy = new ListNode(-1);
    ListNode p = dummy;
    // 优先级队列，最小堆
    PriorityQueue<ListNode> pq = new PriorityQueue<>(
        lists.length, (a, b)->(a.val - b.val));
    // 将 k 个链表的头结点加入最小堆
    for (ListNode head : lists) {
        if (head != null)
            pq.add(head);
    }

    while (!pq.isEmpty()) {
        // 获取最小节点，接到结果链表中
        ListNode node = pq.poll();
        p.next = node;
        if (node.next != null) {
            pq.add(node.next);
        }
        // p 指针不断前进
        p = p.next;
    }
    return dummy.next;
}
```

这个算法是面试常考题，它的时间复杂度是多少呢？

优先队列 pq 中的元素个数最多是 k，所以一次 poll 或者 add 方法的时间复杂度是 O(logk)；所有的链表节点都会被加入和弹出 pq，**所以算法整体的时间复杂度是 O(Nlogk)，其中 k 是链表的条数，N 是这些链表的节点总数**。

##### 19.「 [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)」

> 给你一个链表，删除链表的倒数第 `n`​  个结点，并且返回链表的头结点。
>
> **示例 1：**   
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1675845653420-de13ba3e-03d8-4441-8263-12bdea643b69-20240221152102-8o3a271.jpeg)  
> 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]

从前往后寻找单链表的第 k 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 k 个节点呢？

那你可能说，假设链表有 n 个节点，倒数第 k 个节点就是正数第 n - k + 1 个节点，不也是一个 for 循环的事儿吗？

是的，但是算法题一般只给你一个 ListNode 头结点代表一条单链表，你不能直接得出这条链表的长度 n，而需要先遍历一遍链表算出 n 的值，然后再遍历链表计算第 n - k + 1 个节点。

也就是说，这个解法需要遍历两次链表才能得到出倒数第 k 个节点。

那么，我们能不能**只遍历一次链表**，就算出倒数第 k 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。

这个解法就比较巧妙了，假设 k = 2，思路如下：

首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1675845707156-3bcf66ad-a926-4aff-bfac-4232e543be88-20240221152102-znc7xc6.png)

现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针了对吧？

趁这个时候，再用一个指针 p2 指向链表头节点 head：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1675845699368-756cb28c-660b-405d-99c8-65aecbabf367-20240221152102-l73qajw.png)

接下来就很显然了，让 p1 和 p2 同时向前走，p1 走到链表末尾的空指针时前进了 n - k 步，p2 也从 head 开始前进了 n - k 步，停留在第 n - k + 1 个节点上，即恰好停链表的倒数第 k 个节点上：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1675845700517-8182aeb4-1c3c-4faa-92e7-dabd38921644-20240221152103-u7o7v8d.png)

这样，只遍历了一次链表，就获得了倒数第 k 个节点 p2。  
上述逻辑的代码如下：

```java
// 返回链表的倒数第 k 个节点
ListNode findFromEnd(ListNode head, int k) {
    ListNode p1 = head;
    // p1 先走 k 步
    for (int i = 0; i < k; i++) {
        p1 = p1.next;
    }
    ListNode p2 = head;
    // p1 和 p2 同时走 n - k 步
    while (p1 != null) {
        p2 = p2.next;
        p1 = p1.next;
    }
    // p2 现在指向第 n - k + 1 个节点，即倒数第 k 个节点
    return p2;
}
```

当然，如果用 big O 表示法来计算时间复杂度，无论遍历一次链表和遍历两次链表的时间复杂度都是 O(N)，但上述这个算法更有技巧性。

回到这个题，最终解法如下：

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
  ListNode root = new ListNode(-1);
  root.next = head;
  ListNode fast = root, slow = root;
  for (int i = 0; i < n + 1; i++) { // 先走n + 1步（找到倒数第n + 1个节点）
    fast = fast.next;
  }
  while (fast != null) {
    fast = fast.next;
    slow = slow.next;
  }
  slow.next = slow.next.next;
  return root.next;
}
```

这个逻辑就很简单了，要删除倒数第 n 个节点，就得获得倒数第 n + 1 个节点的引用，可以用我们实现的 findFromEnd 来操作。

不过注意我们又使用了虚拟头结点的技巧，也是为了防止出现空指针的情况，比如说链表总共有 5 个节点，题目就让你删除倒数第 5 个节点，也就是第一个节点，那按照算法逻辑，应该首先找到倒数第 6 个节点。但第一个节点前面已经没有节点了，这就会出错。

但有了我们虚拟节点 dummy 的存在，就避免了这个问题，能够对这种情况进行正确的删除。

##### 876.「 [链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)」

> 给你单链表的头结点 `head`​ ，请你找出并返回链表的中间结点。
>
> 如果有两个中间结点，则返回第二个中间结点。
>
> **示例 1：**
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240221151151-7eybrzf.png)
>
> 输入：[1,2,3,4,5]  
> 输出：此列表中的结点 3 (序列化形式：[3,4,5])
>
> 返回的结点值为 3 。

问题的关键也在于我们无法直接得到单链表的长度 n，常规方法也是先遍历链表计算 n，再遍历一次得到第 n / 2 个节点，也就是中间节点。

如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：

我们让两个指针 slow 和 fast 分别指向链表头结点 head。

**每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点**。

上述思路的代码实现如下：

```java
ListNode middleNode(ListNode head) {
    // 快慢指针初始化指向 head
    ListNode slow = head, fast = head;
    // 快指针走到末尾时停止
    while (fast != null && fast.next != null) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
    }
    // 慢指针指向中点
    return slow;
}
```

需要注意的是，如果链表长度为偶数，也就是说中点有两个的时候，我们这个解法返回的节点是靠后的那个节点。

另外，这段代码稍加修改就可以直接用到判断链表成环的算法题上。

##### 判断链表是否包含环

判断链表是否包含环属于经典问题了，解决方案也是用快慢指针：

每当慢指针 slow 前进一步，快指针 fast 就前进两步。

如果 fast 最终遇到空指针，说明链表中没有环；如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环。

只需要把寻找链表中点的代码稍加修改就行了：

```java
boolean hasCycle(ListNode head) {
    // 快慢指针初始化指向 head
    ListNode slow = head, fast = head;
    // 快指针走到末尾时停止
    while (fast != null && fast.next != null) {
        // 慢指针走一步，快指针走两步
        slow = slow.next;
        fast = fast.next.next;
        // 快慢指针相遇，说明含有环
        if (slow == fast) {
            return true;
        }
    }
    // 不包含环
    return false;
}
```

当然，这个问题还有进阶版：如果链表中含有环，如何计算这个环的起点？

这里简单提一下解法：

```java
ListNode detectCycle(ListNode head) {
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) break;
    }
    // 上面的代码类似 hasCycle 函数
    if (fast == null || fast.next == null) {
        // fast 遇到空指针说明没有环
        return null;
    }

    // 重新指向头结点
    slow = head;
    // 快慢指针同步前进，相交点就是环起点
    while (slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
```

可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。

为什么要这样呢？这里简单说一下其中的原理。

我们假设快慢指针相遇时，慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1676121302252-f445876e-8ae4-484d-bddd-d04ac3a0c1b0-20240221152103-h5hwrcb.png)

fast 一定比 slow 多走了 k 步，这多走的 k 步其实就是 fast 指针在环里转圈圈，所以 k 的值就是环长度的「整数倍」。

假设相遇点距环的起点的距离为 m，那么结合上图的 slow 指针，环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。

巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。因为结合上图的 fast 指针，从相遇点开始走 k 步可以转回到相遇点，那走 k - m 步肯定就走到环起点了：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1676121302342-9c048ef7-d41c-49dd-aa43-944123c843c0-20240221152103-isc4g3s.png)

所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后一定会相遇，相遇之处就是环的起点了。

##### 160.「 [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)」

> 给你两个单链表的头节点 `headA`​ 和 `headB`​ ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null`​ 。
>
> **示例 1：**
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1676121469119-552f516c-ec41-4190-8f3b-17b9090acce2-20240221152104-9m3149w.png)
>
> 输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
>
> 输出：Intersected at '2' 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0)。 从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

给你输入两个链表的头结点 headA 和 headB，这两个链表可能存在相交。

如果相交，你的算法应该返回相交的那个节点；如果没相交，则返回 null。

比如题目给我们举的例子，如果输入的两个链表如下图：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1676281109582-6cc3a99f-f3ef-4f8f-b10e-9071d26b1b31-20240221152104-m1d1f1c.png)

那么我们的算法应该返回 c1 这个节点。

这个题直接的想法可能是用 HashSet 记录一个链表的所有节点，然后和另一条链表对比，但这就需要额外的空间。

如果不用额外的空间，只使用两个指针，你如何做呢？

难点在于，由于两条链表的长度可能不同，两条链表之间的节点无法对应：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1676281110026-4b6b1e4f-4371-4a08-94c7-ca35f3e388f8-20240221152104-ozap8zp.png)

如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能**同时**走到公共节点，也就无法得到相交节点 c1。

**解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1**。

所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1676281110227-96d10eb2-0264-448a-ab2f-109b0668e433-20240221152104-ig45od8.png)

那你可能会问，如果说两个链表没有相交点，是否能够正确的返回 null 呢？

这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。

按照这个思路，可以写出如下代码：

```java
ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    // p1 指向 A 链表头结点，p2 指向 B 链表头结点
    ListNode p1 = headA, p2 = headB;
    while (p1 != p2) {
        // p1 走一步，如果走到 A 链表末尾，转到 B 链表
        if (p1 == null) p1 = headB;
        else            p1 = p1.next;
        // p2 走一步，如果走到 B 链表末尾，转到 A 链表
        if (p2 == null) p2 = headA;
        else            p2 = p2.next;
    }
    return p1;
}
```

这样，这道题就解决了，空间复杂度为 O(1)，时间复杂度为 O(N)。

## 二叉树纲领

### 纲领

#### 深入理解前中后序

首先，回顾一下 [学习数据结构和算法的框架思维](https://labuladong.github.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/) 中说到的二叉树遍历框架：

```java
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
}
```

先不管所谓前中后序，单看 traverse 函数，你说它在做什么事情？

其实它就是一个能够遍历二叉树所有节点的一个函数，和你遍历数组或者链表本质上没有区别。

**所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候**，那么进一步，你把代码写在不同位置，代码执行的时机也不同：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676365214596-e7c5c5f1-1d18-40e3-8bf6-38bfde456ece-20240222220612-sjac0mi.png)

比如说，如果让你**倒序打印**一条单链表上所有节点的值，你怎么搞？

实现方式当然有很多，但如果你对递归的理解足够透彻，可以利用后序位置来操作：

```java
/* 递归遍历单链表，倒序打印链表元素 */
void traverse(ListNode head) {
    if (head == null) {
        return;
    }
    traverse(head.next);
    // 后序位置
    print(head.val);
}
```

结合上面那张图，你应该知道为什么这段代码能够倒序打印单链表了吧，本质上是利用递归的堆栈帮你实现了倒序遍历的效果。  
那么说回二叉树也是一样的，只不过多了一个中序位置罢了。

教科书里只会问你前中后序遍历结果分别是什么，所以对于一个只上过大学数据结构课程的人来说，他大概以为二叉树的前中后序只不过对应三种顺序不同的 List<Integer> 列表。

但是我想说，**前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点**，绝不仅仅是三个顺序不同的 List：

前序位置的代码在刚刚进入一个二叉树节点的时候执行；

后序位置的代码在将要离开一个二叉树节点的时候执行；

中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。

你注意本文的用词，我一直说前中后序「位置」，就是要和大家常说的前中后序「遍历」有所区别：你可以在前序位置写代码往一个 List 里面塞元素，那最后得到的就是前序遍历结果；但并不是说你就不可以写更复杂的代码做更复杂的事。

画成图，前中后序三个位置在二叉树上是这样：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676365584596-cac4d720-0145-4037-a1ca-cd004141907c-20240222220612-96usgqu.png)

**你可以发现每个节点都有「唯一」属于自己的前中后序位置**，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。这里你也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。

说了这么多基础的，就是要帮你对二叉树建立正确的认识，然后你会发现：

**二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作**。

#### 后序位置的特殊之处

说后序位置之前，先简单说下中序和前序。

中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。

前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。

你可以发现，前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676365865728-cd655334-f8c6-47a7-b542-3311a270355c-20240222220612-k4ob0zy.png)

这不奇怪，因为本文开头就说了前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻。

**但这里面大有玄妙，意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

举具体的例子，现在给你一棵二叉树，我问你两个简单的问题：

1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？

2、如何打印出每个节点的左右子树各有多少节点？

第一个问题可以这样写代码：

```java
// 二叉树遍历函数
void traverse(TreeNode root, int level) {
    if (root == null) {
        return;
    }
    // 前序位置
    printf("节点 %s 在第 %d 层", root, level);
    traverse(root.left, level + 1);
    traverse(root.right, level + 1);
}

// 这样调用
traverse(root, 1);
```

第二个问题可以这样写代码：

```java
// 定义：输入一棵二叉树，返回这棵二叉树的节点总数
int count(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftCount = count(root.left);
    int rightCount = count(root.right);
    // 后序位置
    printf("节点 %s 的左子树有 %d 个节点，右子树有 %d 个节点",
            root, leftCount, rightCount);

    return leftCount + rightCount + 1;
}
```

这两个问题的根本区别在于：一个节点在第几层，你从根节点遍历过来的过程就能顺带记录；而以一个节点为根的整棵子树有多少个节点，你需要遍历完子树之后才能数清楚。

结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息。

**那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。

#### 层序遍历

二叉树题型主要是用来培养递归思维的，而层序遍历属于迭代遍历，也比较简单，这里就过一下代码框架吧：

```java
// 输入一棵二叉树的根节点，层序遍历这棵二叉树
void levelTraverse(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    // 从上到下遍历二叉树的每一层
    while (!q.isEmpty()) {
        int sz = q.size();
        // 从左到右遍历每一层的每个节点
        for (int i = 0; i < sz; i++) {
            TreeNode cur = q.poll();
            // 将下一层节点放入队列
            if (cur.left != null) {
                q.offer(cur.left);
            }
            if (cur.right != null) {
                q.offer(cur.right);
            }
        }
    }
}
```

这里面 while 循环和 for 循环分管从上到下和从左到右的遍历：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676366084541-289c99da-1148-4c7e-bf6c-f288c0c9f800-20240222220612-kybmht8.png)

#### 二叉树解题总纲

二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

> 综上，遇到一道二叉树的题目时的通用思考过程是：
>
> **1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 traverse 函数配合外部变量来实现。
>
> **2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。
>
> **3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做**。

### 练习题

#### 104.「 [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)」

> 给定一个二叉树 `root`​ ，返回其最大深度。
>
> 二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。
>
> **示例 1：**
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240222221419-xcsde5s.png)
>
> 输入：root = [3,9,20,null,null,15,7]
> 输出：3

你做这题的思路是什么？显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，**这就是遍历二叉树计算答案的思路**。

解法代码如下：

```java
// 记录最大深度
int res = 0;
// 记录遍历到的节点的深度
int depth = 0;

// 主函数
int maxDepth(TreeNode root) {
	traverse(root);
	return res;
}

// 二叉树遍历框架
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    depth++;
    if (root.left == null && root.right == null) {
        // 到达叶子节点，更新最大深度
        res = Math.max(res, depth);
    }
    traverse(root.left);
    traverse(root.right);
    // 后序位置
    depth--;
}
```

这个解法应该很好理解，但为什么需要在前序位置增加 depth，在后序位置减小 depth？

因为前面说了，前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，depth 记录当前递归到的节点深度，你把 traverse 理解成在二叉树上游走的一个指针，所以当然要这样维护。

至于对 res 的更新，你放到前中后序位置都可以，只要保证在进入节点之后，离开节点之前（即 depth 自增之后，自减之前）就行了。

当然，你也很容易发现一棵二叉树的最大深度可以通过子树的最大深度推导出来，**这就是分解问题计算答案的思路**。

解法代码如下：

```java
// 定义：输入根节点，返回这棵二叉树的最大深度
int maxDepth(TreeNode root) {
	if (root == null) {
		return 0;
	}
	// 利用定义，计算左右子树的最大深度
	int leftMax = maxDepth(root.left);
	int rightMax = maxDepth(root.right);
	// 整棵树的最大深度等于左右子树的最大深度取最大值，
    // 然后再加上根节点自己
	int res = Math.max(leftMax, rightMax) + 1;

	return res;
}
```

只要明确递归函数的定义，这个解法也不难理解，但为什么主要的代码逻辑集中在后序位置？

因为这个思路正确的核心在于，你确实可以通过子树的最大深度推导出原树的深度，所以当然要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。

## 动态规划

### 纲领

首先，**动态规划问题的一般形式就是求最值**。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。

既然是要求最值，核心问题是什么呢？**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。

动态规划这么简单，就是穷举就完事了？我看到的动态规划问题都很难啊！

首先，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出**正确的「状态转移方程」** ，才能正确地穷举。而且，你需要判断算法问题是否**具备「最优子结构」** ，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题**存在「重叠子问题」** ，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。具体什么意思等会会举例详解，但是在实际的算法问题中，写出状态转移方程是最困难的，这也就是为什么很多朋友觉得动态规划问题困难的原因，我来提供我总结的一个思维框架，辅助你思考状态转移方程：

**明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义**。

按上面的套路走，最后的解法代码就会是如下的框架：

```java
// 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        // 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

// 自底向上迭代的动态规划
// 初始化 base case
dp[0][0][...] = base case
// 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要举集中于如何列出状态转移方程。

### 练习题

#### 509.「 [斐波那契数](https://leetcode.cn/problems/fibonacci-number/)」

> **斐波那契数** （通常用 F(n) 表示）形成的序列称为 **斐波那契数列** 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
>
> F(0) = 0，F(1) = 1  
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1  
> 给定 n ，请计算 F(n) 。
>
> **示例 1：**   
> 输入：n = 2  
> 输出：1  
> 解释：F(2) = F(1) + F(0) = 1 + 0 = 1

**1、暴力递归**

斐波那契数列的数学形式就是递归的，写成代码就是这样：

```java
int fib(int N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
```

这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676366988564-d5de04f6-543c-49e9-8eb4-96574e5aec7e-20240228160136-liyj2y0.png)  
PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。

这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。

**递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间**。

首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2<sup>n)</sup>。

然后计算解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。所以，这个算法的时间复杂度为二者相乘，即 O(2<sup>n)</sup>，指数级别，爆炸。

观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。

这就是动态规划问题的第一个性质：**重叠子问题**。下面，我们想办法解决这个问题。

**2、带备忘录的递归解法**

明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。

一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。

```java
int fib(int N) {
    // 备忘录全初始化为 0
    int[] memo = new int[N + 1];
    // 进行带备忘录的递归
    return helper(memo, N);
}

int helper(int[] memo, int n) {
    // base case
    if (n == 0 || n == 1) return n;
    // 已经计算过，不用再计算了
    if (memo[n] != 0) return memo[n];
    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
    return memo[n];
}
```

现在，画出递归树，你就知道「备忘录」到底做了什么。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676367058748-5d662e4f-dd14-4b46-a219-1d366aaf4a93-20240228160137-kprucq1.png)

实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676367062913-29bec5f1-9515-4835-9b3b-238493cd42c3-20240228160137-bhfuitc.png)

**递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间**。

子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) … f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。

解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。

所以，本算法的时间复杂度是 O(n)，比起暴力算法，是降维打击。

至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和常见的动态规划解法已经差不多了，只不过这种解法是「自顶向下」进行「递归」求解，我们更常见的动态规划代码是「自底向上」进行「递推」求解。

啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。

啥叫「自底向上」？反过来，我们直接从最底下、最简单、问题规模最小、已知结果的 f(1) 和 f(2)（base case）开始往上推，直到推到我们想要的答案 f(20)。这就是「递推」的思路，这也是动态规划一般都脱离了递归，而是由循环迭代完成计算的原因。

**3、dp 数组的迭代（递推）解法**

有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，通常叫做 DP table，在这张表上完成「自底向上」的推算岂不美哉！

```java
int fib(int N) {
    if (N == 0) return 0;
    int[] dp = new int[N + 1];
    // base case
    dp[0] = 0; dp[1] = 1;
    // 状态转移
    for (int i = 2; i <= N; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }

    return dp[N];
}
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676367121795-5abd6cfc-8737-43a7-a68f-f02239d0ab0e-20240228160138-er72y0m.png)
画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。

这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676367147399-912a1321-753e-49f7-a82e-8df86e86b35c-20240228160138-nwo4s14.png)
为啥叫「状态转移方程」？其实就是为了听起来高端。

f(n) 的函数参数会不断变化，所以你把参数 n 想做一个状态，这个状态 n 是由状态 n - 1 和状态 n - 2 转移（相加）而来，这就叫状态转移，仅此而已。

你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。

可见列出「状态转移方程」的重要性，它是解决问题的核心，而且很容易发现，其实状态转移方程直接代表着暴力解法。

**千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程**。

只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。

这个例子的最后，讲一个细节优化。

细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。

所以，可以进一步优化，把空间复杂度降为 O(1)。这也就是我们最常见的计算斐波那契数的算法：

```java
int fib(int n) {
    if (n == 0 || n == 1) {
        // base case
        return n;
    }
    // 分别代表 dp[i - 1] 和 dp[i - 2]
    int dp_i_1 = 1, dp_i_2 = 0;
    for (int i = 2; i <= n; i++) {
        // dp[i] = dp[i - 1] + dp[i - 2];
        int dp_i = dp_i_1 + dp_i_2;
        // 滚动更新
        dp_i_2 = dp_i_1;
        dp_i_1 = dp_i;
    }
    return dp_i_1;
}
```

这一般是动态规划问题的最后一步优化，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试缩小 DP table 的大小，只记录必要的数据，从而降低空间复杂度。

上述例子就相当于把 DP table 的大小从 n 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。

有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。

#### 322.「 [零钱兑换](https://leetcode.cn/problems/coin-change/)」

> 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
>
> 计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
>
> 你可以认为每种硬币的数量是无限的。
>
> **示例 1：**
>
> 输入：coins = [1, 2, 5], amount = 11  
> 输出：3
> 解释：11 = 5 + 5 + 1

**1、暴力递归**

首先，这个问题是动态规划问题，因为它具有「最优子结构」的。**要符合「最优子结构」，子问题间必须互相独立**。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。

比如说，假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。

得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，「每门科目考到最高」这些子问题是互相独立，互不干扰的。

但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，不能同时达到满分，数学分数高，语文分数就会降低，反之亦然。

这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为「每门科目考到最高」的子问题并不独立，语文数学成绩户互相影响，无法同时最优，所以最优子结构被破坏。

回到凑零钱问题，为什么说它符合最优子结构呢？假设你有面值为 1, 2, 5 的硬币，你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10, 9, 6 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1, 2, 5 的硬币），求个最小值，就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。
PS：关于最优子结构的问题，后文 [动态规划答疑篇](https://labuladong.github.io/algo/di-er-zhan-a01c6/dong-tai-g-a223e/zui-you-zi-fbef6/) 还会再举例探讨。

那么，既然知道了这是个动态规划问题，就要思考如何列出正确的状态转移方程？

**1、确定 base case**，这个很简单，显然目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。

**2、确定「状态」，也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。

**3、确定「选择」，也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

**4、明确 dp 函数/数组的定义**。我们这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。

**所以我们可以这样定义 dp 函数：dp(n) 表示，输入一个目标金额 n，返回凑出目标金额 n 所需的最少硬币数量**。

搞清楚上面这几个关键点，解法的伪码就可以写出来了：

```java
// 伪码框架
int coinChange(int[] coins, int amount) {
    // 题目要求的最终结果是 dp(amount)
    return dp(coins, amount)
}

// 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币
int dp(int[] coins, int n) {
    // 做选择，选择需要硬币最少的那个结果
    for (int coin : coins) {
        res = min(res, 1 + dp(coins, n - coin))
    }
    return res
}
```

根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：

```java
int coinChange(int[] coins, int amount) {
    // 题目要求的最终结果是 dp(amount)
    return dp(coins, amount)
}

// 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币
int dp(int[] coins, int amount) {
    // base case
    if (amount == 0) return 0;
    if (amount < 0) return -1;

    int res = Integer.MAX_VALUE;
    for (int coin : coins) {
        // 计算子问题的结果
        int subProblem = dp(coins, amount - coin);
        // 子问题无解则跳过
        if (subProblem == -1) continue;
        // 在子问题中选择最优解，然后加一
        res = Math.min(res, subProblem + 1);
    }

    return res == Integer.MAX_VALUE ? -1 : res;
}
```

> PS：这里 coinChange 和 dp 函数的签名完全一样，所以理论上不需要额外写一个 dp 函数。但为了后文讲解方便，这里还是另写一个 dp 函数来实现主要逻辑。
>
> 另外，我经常看到有人问，子问题的结果为什么要加 1（subProblem + 1），而不是加硬币金额之类的。我这里统一提示一下，动态规划问题的关键是 dp 函数/数组的定义，你这个函数的返回值代表什么？你回过头去搞清楚这一点，然后就知道为什么要给子问题的返回值加 1 了。

至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：  
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676367601469-b97ada64-09ae-4e9d-a01a-e9dcad386854-20240228160139-en5gw0a.png)  
至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 amount = 11, coins = {1,2,5} 时画出递归树看看：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676367602952-663ab3ff-43a5-49cf-a9bf-7a2a010812a9-20240228160139-5j7hzcf.png)

**递归算法的时间复杂度分析：子问题总数 x 解决每个子问题所需的时间**。

子问题总数为递归树的节点个数，但算法会进行剪枝，剪枝的时机和题目给定的具体硬币面额有关，所以可以想象，这棵树生长的并不规则，确切算出树上有多少节点是比较困难的。对于这种情况，我们一般的做法是按照最坏的情况估算一个时间复杂度的上界。

**假设目标金额为** **n**，给定的硬币个数为 **k**，那么递归树最坏情况下高度为 **n**（全用面额为 1 的硬币），然后再假设这是一棵满 **k** **叉树，则节点的总数在** **k^n** 这个数量级。

**接下来看每个子问题的复杂度，由于每次递归包含一个 for 循环，复杂度为** ****O(k)****​ **，相乘得到总时间复杂度为** ****O(k^n)****​ **，指数级别。**

**2、带备忘录的递归**

类似之前斐波那契数列的例子，只需要稍加修改，就可以通过备忘录消除子问题：

```java
int[] memo;

int coinChange(int[] coins, int amount) {
    memo = new int[amount + 1];
    // 备忘录初始化为一个不会被取到的特殊值，代表还未被计算
    Arrays.fill(memo, -666);

    return dp(coins, amount);
}

int dp(int[] coins, int amount) {
    if (amount == 0) return 0;
    if (amount < 0) return -1;
    // 查备忘录，防止重复计算
    if (memo[amount] != -666)
        return memo[amount];

    int res = Integer.MAX_VALUE;
    for (int coin : coins) {
        // 计算子问题的结果
        int subProblem = dp(coins, amount - coin);
        // 子问题无解则跳过
        if (subProblem == -1) continue;
        // 在子问题中选择最优解，然后加一
        res = Math.min(res, subProblem + 1);
    }
    // 把计算结果存入备忘录
    memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
    return memo[amount];
}
```

不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。

**3、dp 数组的迭代解法**

当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，dp 数组的定义和刚才 dp 函数类似，也是把「状态」，也就是目标金额作为变量。不过 dp 函数体现在函数参数，而 dp 数组体现在数组索引：

**dp 数组的定义：当目标金额为 i 时，至少需要 dp[i] 枚硬币凑出**。

根据我们文章开头给出的动态规划代码框架可以写出如下解法：

```java
int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    // 数组大小为 amount + 1，初始值也为 amount + 1
    Arrays.fill(dp, amount + 1);

    // base case
    dp[0] = 0;
    // 外层 for 循环在遍历所有状态的所有取值
    for (int i = 0; i < dp.length; i++) {
        // 内层 for 循环在求所有选择的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin < 0) {
                continue;
            }
            dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676367839724-c219d541-93a5-40eb-878b-cd7ff2104a38-20240228160140-gzbddm0.png)

> PS：为啥 dp 数组中的值都初始化为 amount + 1 呢，因为凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币），所以初始化为 amount + 1 就相当于初始化为正无穷，便于后续取最小值。为啥不直接初始化为 int 型的最大值 Integer.MAX_VALUE 呢？因为后面有 dp[i - coin] + 1，这就会导致整型溢出。

#### **LCR 131.「**​[砍竹子 I](https://leetcode.cn/problems/jian-sheng-zi-lcof/description/?orderBy=hot&amp;languageTags=java)​ **」**

> 现需要将一根长为正整数 `bamboo_len`​ 的竹子砍为若干段，每段长度均为正整数。请返回每段竹子长度的最大乘积是多少。
>
> **示例 1：**
>
> 输入: 2  
> 输出: 1  
> 解释: 2 = 1 + 1, 1 × 1 = 1

我们想要求长度为 n 的绳子剪掉后的最大乘积，可以从前面比 n 小的绳子转移而来。

用一个 dp 数组记录从 0 到 n 长度的绳子剪掉后的最大乘积，也就是 dp[i]表示长度为 i 的绳子剪成 m 段后的最大乘积，初始化 dp[2] = 1。

我们先把绳子剪掉第一段（长度为 j），如果只剪掉长度为 1，对最后的乘积无任何增益，所以从长度为 2 开始剪。

剪了第一段后，剩下(i - j)长度可以剪也可以不剪。如果不剪的话长度乘积即为 j * (i - j)；如果剪的话长度乘积即为 j * dp[i - j]。取两者最大值 max(j * (i - j), j * dp[i - j])。

第一段长度 j 可以取的区间为[2,i)，对所有 j 不同的情况取最大值，因此最终 dp[i]的转移方程为 dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))

最后返回 dp[n]即可。

> 为什么最后 max 里面一定要加上 dp[i] ？
>
> 对于长度为 i 的绳子有 j 种剪法，因此要跟之前的剪法相比是否乘积更大~

```java
class Solution {
    public int cuttingBamboo(int bamboo_len) {
        int[] dp = new int[bamboo_len + 1]; // dp[i] -> 长度i时，最大乘积
        dp[2] = 1;
        for (int i = 3; i <= bamboo_len; i++) { // 长度 i
            for (int j = 2; j < i; j++) { // 切成 j
                int max = Math.max(j * (i - j), j * dp[i - j]); // 切成 j，剩余的(i-j) 切不切
                dp[i] = Math.max(max, dp[i]); // 对于长度为 i 的绳子有 j 种剪法，因此要跟之前的剪法相比是否乘积更大
            }
        } 
        return dp[bamboo_len];
    }
}
```

#### LCR 137.「模糊搜索验证」

#### **LCR 161.「**​[连续天数的最高销售额](https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/description/)」

> 某公司每日销售额记于整数数组 `sales`​，请返回所有 **连续** 一或多天销售额总和的最大值。
>
> 要求实现时间复杂度为 `O(n)`​ 的算法。
>
> **示例 1:**
>
> 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]  
> 输出: 6  
> 解释: 连续子数组 [4,-1,2,1] 的和最大为 6。

解决这个问题还可以用动态规划技巧解决，但是 `dp`​ 数组的定义比较特殊。按照我们常规的动态规划思路，一般是这样定义 `dp`​ 数组：

> **​`nums[0..i]`​** ​ **中的「最大的子数组和」为** **​`dp[i]`​** ​。

如果这样定义的话，整个 `nums`​ 数组的「最大子数组和」就是 `dp[n-1]`​。如何找状态转移方程呢？按照数学归纳法，假设我们知道了 `dp[i-1]`​，如何推导出 `dp[i]`​ 呢？

如下图，按照我们刚才对 `dp`​ 数组的定义，`dp[i] = 5`​ ，也就是等于 `nums[0..i]`​ 中的最大子数组和：

![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240826105959-sbjcxzp.png)​

那么在上图这种情况中，利用数学归纳法，你能用 `dp[i]`​ 推出 `dp[i+1]`​ 吗？

**实际上是不行的，因为子数组一定是连续的，按照我们当前** **​`dp`​**​ **数组定义，并不能保证** **​`nums[0..i]`​** ​ **中的最大子数组与** **​`nums[i+1]`​** ​ **是相邻的**，也就没办法从 `dp[i]`​ 推导出 `dp[i+1]`​。

所以说我们这样定义 `dp`​ 数组是不正确的，无法得到合适的状态转移方程。对于这类子数组问题，我们就要重新定义 `dp`​ 数组的含义：

> **以** **​`nums[i]`​** ​ **为结尾的「最大子数组和」为** **​`dp[i]`​** ​。

这种定义之下，想得到整个 `nums`​ 数组的「最大子数组和」，不能直接返回 `dp[n-1]`​，而需要遍历整个 `dp`​ 数组：

```java
int res = Integer.MIN_VALUE;
for (int i = 0; i < n; i++) {
    res = Math.max(res, dp[i]);
}
return res;
```

依然使用数学归纳法来找状态转移关系：假设我们已经算出了 `dp[i-1]`​，如何推导出 `dp[i]`​ 呢？

可以做到，`dp[i]`​ 有两种「选择」，要么与前面的相邻子数组连接，形成一个和更大的子数组；要么不与前面的子数组连接，自成一派，自己作为一个子数组。

如何选择？既然要求「最大子数组和」，当然选择结果更大的那个啦：

```java
// 要么自成一派，要么和前面的子数组合并
dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
```

综上，我们已经写出了状态转移方程，就可以直接写出解法了：

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        // 定义：dp[i] 记录以 nums[i] 为结尾的「最大子数组和」
        int[] dp = new int[n];
        // base case
        // 第一个元素前面没有子数组
        dp[0] = nums[0];
        // 状态转移方程
        for (int i = 1; i < n; i++) {
            dp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);
        }
        // 得到 nums 的最大子数组
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

压缩版：

```java
public int maxSubArray(int[] nums) {
    int dp_0 = nums[0];
    int max = nums[0];
    for (int i = 1; i < nums.length; i++) {
        int dp_1 = Math.max(nums[i], nums[i] + dp_0);
        dp_0 = dp_1;
        max = Math.max(max, dp_1);
    }
    return max;
}
```

#### **LCR 165.「**​[解密数字](https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/description/)」

> 有一串神秘的密文 `ciphertext`​，经调查，密文的特点和规则如下：
>
> - 密文由非负整数组成
> - 数字 0-25 分别对应字母 a-z
>
> 请根据上述规则将密文 `ciphertext`​ 解密为字母，并返回共有多少种解密结果。
>
> **示例 1:**
> 输入: 12258
> 输出: 5
> 解释: 12258 有 5 种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"

根据题意，可按照下图的思路，总结出 “递推公式” （即转移方程）。 因此，此题可用动态规划解决，以下按照流程解题。
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679408205040-1e1357cc-d890-4e41-a315-30ba9806a2b3-20240228160142-4s9mkxz.png)

```java
public int translateNum(int num) {
    if (num <= 0) return 1;
	String str = num + "";
	int[] dp = new int[str.length() + 1]; // dp[i] 代表前i个字符解码数量[0...i-1]
	dp[0] = dp[1] = 1; // 空串和单字符都是1种
	for (int i = 2; i <= str.length(); i++) {
    	char cur = str.charAt(i - 1), pre = str.charAt(i - 2);
    	if (cur >= '0' && cur <= '9') { // s[i]可以单独作为字母
        	dp[i] += dp[i - 1];
    	}
    	if (pre == '1' || pre == '2' && cur <= '5') { // s[i]和s[i-1]可以作为字母
        	dp[i] += dp[i - 2];
    	}
	}
	return dp[str.length()];
}
```

复杂度分析：

- 时间复杂度 O(N) ： N 为字符串 s 的长度（即数字 num 的位数 log⁡(num)），其决定了循环次数。
- 空间复杂度 O(N) ： 字符串 s 使用 O(N) 大小的额外空间。

#### **LCR 166.「**​[珠宝的最高价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/)」

> 现有一个记作二维矩阵 `frame`​ 的珠宝架，其中 `frame[i][j]`​ 为该位置珠宝的价值。拿取珠宝的规则为：
>
> - 只能从架子的左上角开始拿珠宝
> - 每次可以移动到右侧或下侧的相邻位置
> - 到达珠宝架子的右下角时，停止拿取
>
> 注意：珠宝的价值都是大于 0 的。除非这个架子上没有任何珠宝，比如 `frame = [[0]]`​。
>
> **示例 1:**   
> 输入:  
> [
> [1,3,1],
> [1,5,1],
> [4,2,1]  
> ]  
> 输出: 12
>
> 解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物

从棋盘的左上角开始拿格子里的礼物，并每次 向右 或者 向下 移动一格、直到到达棋盘的右下角。 根据题目说明，易得某单元格只可能从上边单元格或左边单元格到达。

设 f(i,j) 为从棋盘左上角走至单元格 (i,j) 的礼物最大累计价值，易得到以下递推关系：f(i,j) = MAX( f(i,j−1) 和 f(i−1,j) ) + 当前单元格礼物价值 grid(i,j)。  
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679408475282-a2ff7b58-859e-4920-a681-69d56b1f0241-20240228160142-10iwker.png)  
因此，可用动态规划解决此问题，以上公式便为转移方程。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679408487219-53346c3f-584f-48cd-bc42-51f654ebd57d-20240228160142-zoyvlyw.png)

动态规划解析：

状态定义： 设动态规划矩阵 dp ，dp(i,j) 代表从棋盘的左上角开始，到达单元格 (i,j) 时能拿到礼物的最大累计价值。  
转移方程：

1. 当 i=0 且 j=0 时，为起始元素；
2. 当 i=0 且 j≠0 时，为矩阵第一行元素，只可从左边到达；
3. 当 i≠0 且 j=0 时，为矩阵第一列元素，只可从上边到达；
4. 当 i≠0 且 j≠0 时，可从左边或上边到达；

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679408615728-65a6a346-40a9-44a6-9352-92aa2c501a63-20240228160142-h5rd4xn.png)

- 初始状态： dp[0][0]=grid[0][0] ，即到达单元格 (0,0)时能拿到礼物的最大累计价值为 grid[0][0]；
- 返回值： dp[m−1][n−1]，m,n 分别为矩阵的行高和列宽，即返回 dp 矩阵右下角元素。

**复杂度分析：**

- 时间复杂度 O(MN) ： M,N 分别为矩阵行高、列宽；动态规划需遍历整个 grid 矩阵，使用 O(MN) 时间。
- 空间复杂度 O(N)

```java
public int maxValue(int[][] grid) {
    int m = grid.length, n = grid[0].length;
    int[][] dp = new int[m][n]; // dp[i][j] [dp[0[0] -> dp[i][j]] 最大值
    dp[0][0] = grid[0][0];
    for (int i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];
    for (int j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    return dp[m - 1][n - 1];
}
```

#### **LCR 168.「**​[丑数](https://leetcode.cn/problems/chou-shu-lcof/)」

> 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
>
> **示例:**
>
> 输入: n = 10  
> 输出: 12  
> 解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。

> 丑数的递推性质： 丑数只包含因子 2,3,5，因此有 “丑数 === 某较小丑数 × 某因子” （例如：10=5×2 ）。

设已知长度为 *n* 的丑数序列![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679483669925-db0970d2-3019-45c1-9845-226cfb731876-20240228160142-igw3syw.png)，求第 n+1 个丑数 ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679483706574-6b53faa6-fd68-48df-a164-f01451df4a3f-20240228160143-lg0kz8u.png)。根根据递推性质，丑数 ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679483706574-6b53faa6-fd68-48df-a164-f01451df4a3f-20240228160143-5j441ln.png)只可能是以下三种情况其中之一（索引 a,b,c 为未知数）：
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679483762519-0eca31cc-9060-4956-bb01-278c7a6d6a99-20240228160143-2vo4gxj.png)
**丑数递推公式：**  若索引 a,b,c 满足以上条件，则下个丑数 ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679483706574-6b53faa6-fd68-48df-a164-f01451df4a3f-20240228160143-13kdg9g.png)为以下三种情况中的 **最小值** ；
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679483803769-690b5ff5-8de3-4fdb-9c7b-f2596ddd3956-20240228160143-1m2pce0.png)
由于![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679483706574-6b53faa6-fd68-48df-a164-f01451df4a3f-20240228160143-zehjq4i.png)是 **最接近**![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679483837815-bbc372a3-43c9-425d-8da7-7b12c51f5d8c-20240228160143-x7d0ymm.png)的丑数，因此索引 a,b,c 需满足以下条件：
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679483859325-f7be317e-96c8-4ce7-8aef-7b472e8f6f57-20240228160143-93q338o.png)
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679483868906-0efad6fc-471a-47c2-bb98-52b73aa432e2-20240228160144-do6y01p.png)
因此，可设置指针 a,b,c 指向首个丑数（即 1 )，循环根据递推公式得到下个丑数，并每轮将对应指针执行 +1 即可。

> 假设当前存在 3 个数组 nums2, nums3, nums5 分别代表丑数序列从 1 开始分别乘以 2, 3, 5 的序列， 即
>
> nums2 = {1*2, 2*2, 3*2, 4*2, 5*2, 6*2, 8*2...} nums3 = {1*3, 2*3, 3*3, 4*3, 5*3, 6*3, 8*3...}
>
> nums5 = {1*5, 2*5, 3*5, 4*5, 5*5, 6*5, 8*5...}
>
> \# 注意 7 不是丑数.
>
> \# 2, 3, 5 这前 3 个丑数一定要乘以其它的丑数， 所得的结果才是新的丑数， 所以上例中没有出现 7*2, 7*3, 7*

**合并过程中重复解的处理**

nums2, nums3, nums5 中是存在重复的解的， 例如 nums2[2] == 3*2, nums3[1] == 2*3 都计算出了 6 这个结果， 所以在合并 3 个有序数组的过程中， 还需要跳过相同的结果， 这也就是为什么在比较的时候， 需要使用 3 个并列的 if... if... if... 而不是 if... else if... else 这种结构的原因。 当比较到元素 6 时， if (dp[i] == dp[p2] * 2)...if (dp[i] == dp[p3] * 3)... 可以同时指向 nums2, nums3 中 元素 6 的下一个元素。

**动态规划解析：**

- **状态定义：**  设动态规划列表 *dp* ，`dp[i]` ​代表第 `i+1`​ 个丑数；
- **转移方程：**
    1. 当索引 a,b,c 满足以下条件时，`dp[i]` ​为三种情况的最小值；
    2. 每轮计算 `dp[i]` ​后，需要更新索引 a,b,c 的值，使其始终满足方程条件。实现方法：分别独立判断 dp[i] 和 dp[a]×2, dp[b]×3, dp[c]×5 的大小关系，若相等则将对应索引 a , *b* , *c* 加 1 ；

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679484074981-14af5f0c-e3df-4d84-9758-83bf8f4053c9-20240228160144-d8sp522.png)

- **初始状态：**  `dp[0]`​=1 ，即第一个丑数为 1 ；
- **返回值：**  `dp[n-1]`​ ，即返回第 *n* 个丑数；

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679484277579-e30d9a90-ccea-4b6a-b12a-ce937654f383-20240228160144-4hy1oql.gif)

**复杂度分析：**

- 时间复杂度 O(N) ： 其中 N=n，动态规划需遍历计算 dp 列表。
- 空间复杂度 O(N) ： 长度为 N 的 dp 列表使用 O(N)的额外空间。

```java
class Solution {
    public int nthUglyNumber(int n) {
        int a = 0, b = 0, c = 0;
        int[] dp = new int[n];
        dp[0] = 1;
        for(int i = 1; i < n; i++) {
            int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;
            dp[i] = Math.min(Math.min(n2, n3), n5);
            if(dp[i] == n2) a++;
            if(dp[i] == n3) b++;
            if(dp[i] == n5) c++;
        }
        return dp[n - 1];
    }
}
```

#### **LCR 185.「**​[统计结果概率](https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/description/?orderBy=hot)」

> 你选择掷出 `num`​ 个色子，请返回所有点数总和的概率。
>
> 你需要用一个浮点数数组返回答案，其中第 `i`​ 个元素代表这 `num`​ 个骰子所能掷出的点数集合中第 `i`​ 小的那个的概率。
>
> **示例 1:**
>
> 输入: 1  
> 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]

题目需要我们求出所有点数出现的概率，根据概率的计算公式，点数 *k* 出现概率就算公式为：![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680254288899-c7bf6e7d-8594-4f22-9159-d1dd61ebb555-20240228160144-2ebavu6.png)  
投掷 n 个骰子，所有点数出现的总次数是 ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680254322281-d4a2cb83-6ab7-4059-9e53-5cc4d59e6bed-20240228160145-r6neni5.png) ,因为一共有 n 枚骰子，每枚骰子的点数都有 6 种可能出现的情况。

我们的目的就是 计算出投掷完 n 枚骰子后每个点数出现的次数。

使用动态规划解决问题一般分为三步：

1. 表示状态
2. 找出状态转移方程
3. 边界处理

**表示状态**

分析问题的状态时，不要分析整体，只分析最后一个阶段即可！因为动态规划问题都是划分为多个阶段的，各个阶段的状态表示都是一样，而我们的最终答案在就是在最后一个阶段。

对于这道题，最后一个阶段是什么呢？

通过题目我们知道一共投掷 n 枚骰子，那最后一个阶段很显然就是：当投掷完 n 枚骰子后，各个点数出现的次数。

> 注意，这里的点数指的是前 n 枚骰子的点数和，而不是第 n 枚骰子的点数，下文同理。

找出了最后一个阶段，那状态表示就简单了。

- 首先用数组的第一维来表示阶段，也就是投掷完了几枚骰子。
- 然后用第二维来表示投掷完这些骰子后，可能出现的点数。
- 数组的值就表示，该阶段各个点数出现的次数。

所以状态表示就是这样的：dp[i][j] ，表示投掷完 i 枚骰子后，点数 j 的出现次数。

**找出状态转移方程**

找状态转移方程也就是找各个阶段之间的转化关系，同样我们还是只需分析最后一个阶段，分析它的状态是如何得到的。

最后一个阶段也就是投掷完 n 枚骰子后的这个阶段，我们用 dp[n][j] 来表示最后一个阶段点数 j 出现的次数。

单单看第 n 枚骰子，它的点数可能为 1,2,3,...,6 ，因此投掷完 n 枚骰子后点数 j 出现的次数，可以由投掷完 n−1 枚骰子后，对应点数 j−1,j−2,j−3,...,j−6 出现的次数之和转化过来。

```java
for (第n枚骰子的点数 i = 1; i <= 6; i ++) {
    dp[n][j] += dp[n-1][j - i]
}
```

**边界处理**  
这里的边界处理很简单，只要我们把可以直接知道的状态初始化就好了。

我们可以直接知道的状态是啥，就是第一阶段的状态：投掷完 1 枚骰子后，它的可能点数分别为 1,2,3,...,6，并且每个点数出现的次数都是 1 .

```java
for (int i = 1; i <= 6; i ++) {
    dp[1][i] = 1;
}
```

**最终代码：**

```java
class Solution {
    public double[] dicesProbability(int n) {
        int min = n, max = n * 6;
        double[][] dp = new double[n + 1][max + 1]; // dp[i][j] 代表 i 个筛子，投掷 j 点的概率
        for (int i = 1; i <= 6; i++) { // 一个筛子投掷的概率
            dp[1][i] = 1.0 / 6;
        }
        for (int i = 2; i <= n; i++) { // 第 i 个筛子
            for (int j = i; j <= 6 * i; j++) { // 投掷范围 [i, 6*i]
                for (int k = 1; k <= 6; k++) { // 每个筛子可能出现的结果 [1, 6]
                    if (j <= k) break;
                    dp[i][j] += dp[i - 1][j - k] * 1 / 6;
                }
            }
        }
        double[] res = new double[max - min + 1];
        for (int k = min, i = 0; k <= max; k++, i++) {
            res[i] = dp[n][k];
        }
        return res;
    }
}
```

## 回溯算法

### 纲领

解决一个回溯问题，实际上就是一个决策树的遍历过程，站在回溯树的一个节点上，你只需要思考 3 个问题：

1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。

如果你不理解这三个词语的解释，没关系，我们后面会用「全排列」和「N 皇后问题」这两个经典的回溯算法问题来帮你理解这些词语是什么意思，现在你先留着印象。

代码方面，回溯算法的框架：

```java
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
  
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

**其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」** ，特别简单。

### 练习题

#### 51.「 [N 皇后](https://leetcode.cn/problems/n-queens/)」

> 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
>
> **n 皇后问题** 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 `n`​ ，返回所有不同的 **n**  **皇后问题** 的解决方案。
>
> 每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'`​ 和 `'.'`​ 分别代表了皇后和空位。
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676452052013-1adb9cca-d7de-4f3b-9b07-300a14d96e96-20240229204725-st95fq0.jpeg)​
>
> 输入：n = 4  
> 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
>
> 解释：如上图所示，4 皇后问题存在两个不同的解法。

**为了判断一个位置所在的列和两条斜线上是否已经有皇后，使用三个集合**  ***col***​ **、**​***left***​ **、**​***right*** 分别记录每一列以及两个方向的每条斜线上是否有皇后。

- 列的表示法很直观，一共有 N 列，每一列的下标范围从 0 到 N−1，使用列的下标即可明确表示每一列。
- 如何表示两个方向的斜线呢？对于每个方向的斜线，需要找到斜线上的每个位置的行下标与列下标之间的关系。

    - 右对角线为从左上到右下方向，同一条斜线上的每个位置满足行下标与列下标之差相等，即 `_row - j_`​。例如 (0,0) 和 (3,3) 在同一条方向一的斜线上。因此使用行下标与列下标之差即可明确表示每一条右对角线的斜线。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1690795674696-45e11422-ea69-4476-871e-40fc7e6b0a7e-20240229204725-843vjyt.png)

- 左对角线为从右上到左下方向，同一条斜线上的每个位置满足行下标与列下标之和相等，即 `_row + j_`​。例如 (3,0) 和 (1,2) 在同一条方向二的斜线上。因此使用行下标与列下标之和即可明确表示每一条左对角线的斜线。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1690795763175-93d20a7c-a902-49cd-8608-a4574d2787c1-20240229204725-dvg9h78.png)

每次放置皇后时，对于每个位置判断其是否在三个集合中，如果三个集合都不包含当前位置，则当前位置是可以放置皇后的位置。

```java
class Solution {
    public List<List<String>> solveNQueens(int n) {
        LinkedList<Integer> trace = new LinkedList<>(); // 记录每一行的Q 列的位置
        Set<Integer> left = new HashSet<>(); // 记录左对角线的Q
        Set<Integer> right = new HashSet<>(); // 记录右对角线的Q
        boolean[] col = new boolean[n]; // 记录每一列的Q
        List<List<String>> res = new LinkedList<>();
        backTrace(0, n, trace, left, right, col, res);
        return res;
    }

    private void backTrace(int row, int n, LinkedList<Integer> trace, Set<Integer> left, Set<Integer> right, boolean[] col, List<List<String>> res) {
        if(row == n) {
            res.add(buildBoard(trace));
            return;
        }
        for (int j = 0; j < n; j++) {
            int leftIndex = row + j;
            int rightIndex = row - j;
            if(!left.contains(leftIndex) && !right.contains(rightIndex) && !col[j]) {
                left.add(leftIndex);
                right.add(rightIndex);
                col[j] = true;
                trace.add(j);
                backTrace(row+1,n,trace,left,right,col,res);
                left.remove(leftIndex);
                right.remove(rightIndex);
                col[j] = false;
                trace.removeLast();
            }
        }
    }

    private List<String> buildBoard(LinkedList<Integer> trace) {
        List<String> res = new ArrayList<>(trace.size());
        for (int col : trace) {
            char[] chars = new char[trace.size()];
            Arrays.fill(chars,'.');
            chars[col] = 'Q';
            res.add(new String(chars));
        }
        return res;
    }
}
```

#### 52.「 [N 皇后 II](https://leetcode.cn/problems/n-queens-ii/)」

> **n 皇后问题** 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 n ，返回 **n 皇后问题** 不同的解决方案的数量。
>
> **示例 1：**
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1676455001813-b3defe3e-59a5-446d-9a9f-5445e421e770-20240229204725-vbvnkzn.png)​
>
> 输入：n = 4  
> 输出：2  
> 解释：如上图所示，4 皇后问题存在两个不同的解法。

其实你把我们上面写的解法 copy 过去也可以解决这个问题，因为我们计算出来的 res 就存储了所有合法的棋盘嘛，那么 res 中元素的个数不就是所有可行解法的总数吗？

是这样的，但要知道创建和存储这些具体的棋盘解法是要消耗空间和时间的，所以效率上可能会差一些。

更好的办法就是直接把 res 变量变成 int 类型，每次在 base case 找到一个合法答案的时候递增 res 变量即可：

```java
class Solution {
    private int count = 0;

    public int totalNQueens(int n) {
        boolean[] col = new boolean[n];
        Set<Integer> left = new HashSet<>();
        Set<Integer> right = new HashSet<>();
        backTrace(0, n, left, right, col);
        return count;
    }

    private void backTrace(int row, int n, Set<Integer> left, Set<Integer> right, boolean[] col) {
        if (row == n) {
            ++count;
            return;
        }
        for (int i = 0; i < n; i++) {
            int leftIndex = row + i;
            int rightIndex = row - i;
            if (!left.contains(leftIndex) && !right.contains(rightIndex) && !col[i]) {
                left.add(leftIndex);
                right.add(rightIndex);
                col[i] = true;
                backTrace(row + 1, n, left, right, col);
                left.remove(leftIndex);
                right.remove(rightIndex);
                col[i] = false;
            }
        }
    }
}
```

#### LCR 129.「**[字母迷宫](https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/)**」

> 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
>
> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
>
> 例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678086966870-c8b7981b-e8bb-43c6-8837-30ce787b6542-20240229204725-5bxecqx.jpeg)​
>
> **示例 1：**
> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
> 输出：true

本问题是典型的矩阵搜索问题，可使用 **深度优先搜索（DFS）+ 剪枝** 解决。

- 深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。
- 剪枝： 在搜索中，遇到 `这条路不可能和目标字符串匹配成功`​ 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 `可行性剪枝`​ 。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678087047673-c1ec3386-6d0f-4e57-8a23-c06b83ba2767-20240229204726-1pfqqtx.png)

**DFS 解析：**

- 递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 `k`​ 。
- 终止条件：

    - 返回 false： (1) 行或列索引越界 或 (2) 当前矩阵元素与目标字符不同 或 (3) 当前矩阵元素已访问过 （ (3) 可合并至 (2) ） 。
    - 返回 true： `k = len(word) - 1`​ ，即字符串 `word`​ 已全部匹配。
- 递推工作：

    - 标记当前矩阵元素： 将 `board[i][j]`​ 修改为 空字符 `''`​ ，代表此元素已访问过，防止之后搜索时重复访问。
    - 搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需找到一条可行路径就直接返回，不再做后续 DFS ），并记录结果至 `res `​。
    - 还原当前矩阵元素： 将 `board[i][j]`​ 元素还原至初始值，即 `word[k] `​。
- 返回值： 返回布尔量 `res`​ ，代表是否搜索到目标字符串。

```java
public boolean exist(char[][] board, String word) {
	boolean[][] used = new boolean[board.length][board[0].length];
    for (int i = 0; i < board.length; i++) {
    	for (int j = 0; j < board[0].length; j++) {
        	if (backTrack(board, used, i, j, word, 0)) {
            	return true;
            }
        }
    }
    return false;
}

private boolean backTrack(char[][] board, boolean[][] used, int row, int col, String word, int index) {
    if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) return false;
    if(used[row][col]) return false;
    if (board[row][col] != word.charAt(index)) return false;
    if (word.length() - 1 == index) return true;
    used[row][col] = true;
    ++index;
    boolean res = backTrack(board, used, row - 1, col, word, index)
    	|| backTrack(board, used, row + 1, col, word, index)
        || backTrack(board, used, row, col - 1, word, index)
        || backTrack(board, used, row, col + 1, word, index);
        used[row][col] = false;
    return res;
}
```

#### LCR 137.「**[模糊搜索验证](https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)**」

> 请实现一个函数用来匹配包含'. '和' *'的正则表达式。模式中的字符'.'表示任意一个字符，而'* '表示它前面的字符可以出现任意次（含 0 次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但与"aa.a"和"ab*a&quot;均不匹配。输入: s = &quot;aa&quot; p = &quot;a*"
>
> 输出: true
>
> 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

我们先脑补一下，s 和 p 相互匹配的过程大致是，两个指针 i, j 分别在 s 和 p 上移动，如果最后两个指针都能移动到字符串的末尾，那么久匹配成功，反之则匹配失败。

**如果不考虑 * 通配符，面对两个待匹配字符 s[i] 和 p[j]，我们唯一能做的就是看他俩是否匹配**：

```java
bool isMatch(string s, string p) {
    int i = 0, j = 0;
    while (i < s.size() && j < p.size()) {
        // 「.」通配符就是万金油
        if (s[i] == p[j] || p[j] == '.') {
            // 匹配，接着匹配 s[i+1..] 和 p[j+1..]
            i++; j++;
        } else {
            // 不匹配
            return false;
        }
    }
    return i == j;
}
```

那么考虑一下，如果加入 * 通配符，局面就会稍微复杂一些，不过只要分情况来分析，也不难理解。

**当 p[j + 1] 为 * 通配符时，我们分情况讨论下**：

1、如果 s[i] == p[j]，那么有两种情况：

1.1 p[j] 有可能会匹配多个字符，比如 s = "aaa", p = "a *&quot;，那么 p[0] 会通过 * 匹配 3 个字符 &quot;a&quot;。1.2 p[i] 也有可能匹配 0 个字符，比如 s = &quot;aa&quot;, p = &quot;a*aa"，由于后面的字符可以匹配 s，所以 p[0] 只能匹配 0 次。

2、如果 s[i] != p[j]，只有一种情况：

p[j] 只能匹配 0 次，然后看下一个字符是否能和 s[i] 匹配。比如说 s = "aa", p = "b*aa"，此时 p[0] 只能匹配 0 次。

综上，可以把之前的代码针对 * 通配符进行一下改造：

```java
if (s[i] == p[j] || p[j] == '.') {
    // 匹配
    if (j < p.size() - 1 && p[j + 1] == '*') {
        // 有 * 通配符，可以匹配 0 次或多次
    } else {
        // 无 * 通配符，老老实实匹配 1 次
        i++; j++;
    }
} else {
    // 不匹配
    if (j < p.size() - 1 && p[j + 1] == '*') {
        // 有 * 通配符，只能匹配 0 次
    } else {
        // 无 * 通配符，匹配无法进行下去了
        return false;
    }
}
```

整体的思路已经很清晰了，但现在的问题是，遇到 * 通配符时，到底应该匹配 0 次还是匹配多次？多次是几次？

你看，这就是一个做「选择」的问题，要把所有可能的选择都穷举一遍才能得出结果。动态规划算法的核心就是「状态」和「选择」， **「状态」无非就是 i 和 j 两个指针的位置，「选择」就是 p[j] 选择匹配几个字符**。

##### 回溯解法

根据「状态」，我们可以定义一个 dp 函数：

```c
bool dp(string& s, int i, string& p, int j);
```

dp 函数的定义如下：

**若 dp(s, i, p, j) = true，则表示 s[i..] 可以匹配 p[j..]；若 dp(s, i, p, j) = false，则表示 s[i..] 无法匹配 p[j..]** 。

根据这个定义，我们想要的答案就是 i = 0, j = 0 时 dp 函数的结果，所以可以这样使用这个 dp 函数：

```c
bool isMatch(string s, string p) {
    // 指针 i，j 从索引 0 开始移动
    return dp(s, 0, p, 0);
```

可以根据之前的代码写出 dp 函数的主要逻辑：

```c
bool dp(string& s, int i, string& p, int j) {
    if (s[i] == p[j] || p[j] == '.') {
        // 匹配
        if (j < p.size() - 1 && p[j + 1] == '*') {
            // 1.1 通配符匹配 0 次或多次
            return dp(s, i, p, j + 2)
                || dp(s, i + 1, p, j);
        } else {
            // 1.2 常规匹配 1 次
            return dp(s, i + 1, p, j + 1);
        }
    } else {
        // 不匹配
        if (j < p.size() - 1 && p[j + 1] == '*') {
            // 2.1 通配符匹配 0 次
            return dp(s, i, p, j + 2);
        } else {
            // 2.2 无法继续匹配
            return false;
        }
    }
}
```

**根据 dp 函数的定义**，这几种情况都很好解释：

1.1 通配符匹配 0 次或多次

将 j 加 2，i 不变，含义就是直接跳过 p[j] 和之后的通配符，即通配符匹配 0 次。

即便 s[i] == p[j]，依然可能出现这种情况，如下图：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678175295477-248c8f0f-3fdf-491d-9771-22b9db07368c-20240229204726-yivcaud.png)

将 i 加 1，j 不变，含义就是 p[j] 匹配了 s[i]，但 p[j] 还可以继续匹配，即通配符匹配多次的情况：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678175286848-6c9a4fc2-af31-448b-8fb6-65f6e2c58599-20240229204726-tn3eg4j.png)

两种情况只要有一种可以完成匹配即可，所以对上面两种情况求或运算。

1.2 常规匹配 1 次

由于这个条件分支是无 * 的常规匹配，那么如果 s[i] == p[j]，就是 i 和 j 分别加一：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678175287867-1900ccd4-97aa-42c6-ba89-656fc3662474-20240229204727-fdnvmcv.png)

2.1 通配符匹配 0 次

类似情况 1.1，将 j 加 2，i 不变：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678175302815-43f92159-d028-46ef-8a86-fb99a592bd1a-20240229204727-ypeb2g3.png)

2.2 如果没有 * 通配符，也无法匹配，那只能说明匹配失败了：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678175300394-db4ab92e-9d41-4fce-bcc4-ba6c36e4d30a-20240229204728-hpi3374.png)

看图理解应该很容易了，现在可以思考一下 dp 函数的 base case：

**一个 base case 是 j == p.size() 时**，按照 dp 函数的定义，这意味着模式串 p 已经被匹配完了，那么应该看看文本串 s 匹配到哪里了，如果 s 也恰好被匹配完，则说明匹配成功：

```java
if (j == p.size()) {
    return i == s.size();
}
```

**另一个 base case 是 i == s.size() 时**，按照 dp 函数的定义，这种情况意味着文本串 s 已经全部被匹配了，那么是不是只要简单地检查一下 p 是否也匹配完就行了呢？

```java
if (i == s.size()) {
    // 这样行吗？
    return j == p.size();
}
```

**这是不正确的，此时并不能根据 j 是否等于 p.size() 来判断是否完成匹配，只要 p[j..] 能够匹配空串，就可以算完成匹配**。比如说 s = "a", p = "ab*c*"，当 i 走到 s 末尾的时候，j 并没有走到 p 的末尾，但是 p 依然可以匹配 s。

所以我们可以写出如下代码：

```c
int m = s.size(), n = p.size();

if (i == s.size()) {
    // 如果能匹配空串，一定是字符和 * 成对儿出现
    if ((n - j) % 2 == 1) {
        return false;
    }
    // 检查是否为 x*y*z* 这种形式
    for (; j + 1 < p.size(); j += 2) {
        if (p[j + 1] != '*') {
            return false;
        }
    }
    return true;
}
```

根据以上思路，就可以写出完整的代码：

```java
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length(), n = p.length();
        boolean[][] memo = new boolean[m][n];
        return dfs(s, 0, p, 0, memo);
    }

    private boolean dfs(String s, int i, String p, int j, boolean[][] memo) {
        // bad case
        if (j == p.length()) return i == s.length(); // p字符串匹配完的时候，查看s字符串是否匹配完
        if (i == s.length()) { // 当s字符串匹配完的时候，有两种情况，情况一，两个字符串都匹配完，情况二，p: a; s: ab*c*
            if (((p.length() - j) & 1) == 1) return false;// 一定是字符和 * 成对儿出现
            for (int k = j; k < p.length(); k += 2) {
                if (p.charAt(k + 1) != '*') return false;
            }
            return true;
        }
        if (memo[i][j]) return true;
        boolean res;
        // 一共两种情况，p[j] 与 s[i] 匹配，p[j] 与 s[i] 不匹配
        if (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.') { // 当p[j] 与 s[i] 匹配时，有两种情况
            if (j + 1 < p.length() && p.charAt(j + 1) == '*') { // 当p[j+1] == '*' 时，有两种情况
                res = dfs(s, i, p, j + 2, memo) // p[j] 匹配0次
                    || dfs(s, i + 1, p, j, memo); // p[j] 匹配多次
            } else { // p[j] 匹配1次
                res = dfs(s, i + 1, p, j + 1, memo);
            }

        } else { // p[j] 与 s[i] 不匹配
            // p[j] 只能匹配0次, 且p[j+1] = *
            if (j + 1 < p.length() && p.charAt(j + 1) == '*') {
                res = dfs(s, i, p, j + 2, memo);
            } else {
                res = false;
            }
        }
        memo[i][j] = res;
        return res;
    }
}
```

时间复杂度为「状态的总数」*「每次递归花费的时间」，本题中状态的总数当然就是 i 和 j 的组合，也就是 M * N（M 为 s 的长度，N 为 p 的长度）；递归函数 dp 中没有循环（base case 中的不考虑，因为 base case 的触发次数有限），所以一次递归花费的时间为常数。二者相乘，总的时间复杂度为 O(MN)。

空间复杂度很简单，就是备忘录 memo 的大小，即 O(MN)。

##### 动态规划解法

```java
class Solution {
	public boolean isMatch(String s, String p) {
		int m = s.length(), n = p.length();
		boolean[][] dp = new boolean[m + 1][n + 1]; // dp[i][j] 代表 s[i..] 和 p[j..] 是否匹配
		dp[m][n] = true; // 空串匹配
		// s串匹配 空串，dp[0-m][0] 都为false
		for (int i = n - 2; i >= 0; i--) { // 空串匹配 p[j..]，主要看 p[j..] 是否是 x*z*y*.. 形式
			dp[m][i] = p.charAt(i + 1) == '*' && dp[m][i + 2];
		}
		for (int i = m - 1; i >= 0; i--) {
			for (int j = n - 1; j >= 0; j--) {
				if (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') { // 分两种情况，当 s[i] == p[j] 时
					if (j + 1 < n && p.charAt(j + 1) == '*') { // p串下一位是*，有两种情况
						dp[i][j] = dp[i][j + 2] // 匹配0次，p串后退2步（a*）
							|| dp[i + 1][j]; // 匹配多长，s串直接后退一步
					} else {
						dp[i][j] = dp[i + 1][j + 1]; // p串下一位是正常字符，则各种后退一步
					}
				} else { // 当 s[i] != p[j] 时
					if (j + 1 < n && p.charAt(j + 1) == '*') { // p串下一位是*，则只能匹配0次
						dp[i][j] = dp[i][j + 2];
					} else {
						dp[i][j] = false;
					}
				}
			}
		}
		return dp[0][0];
	}
}
```

#### **LCR 153.「**​[二叉树中和为目标值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)」

> 给你二叉树的根节点 `root`​ 和一个整数目标和 `targetSum`​ ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。  
> **叶子节点** 是指没有子节点的节点。
>
> **示例 1：**   
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678714859621-1002e486-dc51-4036-afaa-ec806e4d12a8-20240229204728-24vxtiz.jpeg)  
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22  
> 输出：[[5,4,11,2],[5,8,4,5]]

```java
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int target) {
        List<List<Integer>> res = new LinkedList<>();
        if (root == null) return res;
        dfs(root, target, new LinkedList<>(), res);
        return res;
    }

    private void dfs(TreeNode root, int target, LinkedList<Integer> trace, List<List<Integer>> res) {
        if (root == null) return;
        trace.add(root.val);
        if (root.left == null && root.right == null && target - root.val == 0) {
            res.add(new ArrayList<>(trace));
        } else {
            dfs(root.left, target - root.val, trace, res);
            dfs(root.right, target - root.val, trace, res);
        }
        trace.removeLast();
    }
}
```

#### **LCR 130.「**​[衣橱整理](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/description/)」

> 家居整理师将待整理衣橱划分为 `m x n`​ 的二维矩阵 `grid`​，其中 `grid[i][j]`​ 代表一个需要整理的格子。整理师自 `grid[0][0]`​ 开始 **逐行逐列** 地整理每个格子。
>
> 整理规则为：在整理过程中，可以选择 **向右移动一格** 或 **向下移动一格**，但不能移动到衣柜之外。同时，不需要整理 `digit(i) + digit(j) > cnt`​ 的格子，其中 `digit(x)`​ 表示数字 `x`​ 的各数位之和。
>
> 请返回整理师 **总共需要整理多少个格子**。
>
> **示例 1：**
> 输入：`m = 4, n = 7, cnt = 5`​
> 输出：`18`​

```java
class Solution {
    public int movingCount(int m, int n, int k) {
        boolean[][] used = new boolean[m][n];
        return dfs(used, m, n, k, 0, 0);
    }

    private int dfs(boolean[][] used, int m, int n, int k, int i, int j) {
        if (i >= m || j >= n || used[i][j] || (bitSum(i) + bitSum(j)) > k) {
            return 0;
        }
        used[i][j] = true;
        return 1 + dfs(used, m, n, k, i + 1, j) + dfs(used, m, n, k, i, j + 1);
    }

    private int bitSum(int i) {
        int sum = 0;
        while (i > 0) {
            sum += (i % 10);
            i /= 10;
        }
        return sum;
    }
}
```

## BFS

BFS 的核心思想应该不难理解的，就是把一些问题抽象成图，从一个点开始，向四周开始扩散。一般来说，我们写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。

BFS 相对 DFS 的最主要的区别是：**BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多**，至于为什么，我们后面介绍了框架就很容易看出来了。

### 常见场景

我们先举例一下 BFS 出现的常见场景好吧，**问题的本质就是让你在一幅「图」中找到从起点 start 到终点 target 的最近距离，这个例子听起来很枯燥，但是 BFS 算法问题其实都是在干这个事儿**，把枯燥的本质搞清楚了，再去欣赏各种问题的包装才能胸有成竹嘛。

这个广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少？如果这个迷宫带「传送门」可以瞬间传送呢？

再比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？

再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？

再比如……

净整些花里胡哨的，这些问题都没啥奇技淫巧，本质上就是一幅「图」，让你从一个起点，走到终点，问最短路径。这就是 BFS 的本质，框架搞清楚了直接默写就好。

### 框架

```java
public class BFS {
    // 计算从起点 start 到终点 target 的最近距离
    int BFS(TreeNode start, TreeNode target) {
        Queue<TreeNode> q = new LinkedList<>(); // 核心数据结构
        Set<TreeNode> visited = new HashSet<>(); // 避免走回头路

        q.offer(start); // 将起点加入队列
        visited.add(start);
        int step = 0; // 记录扩散的步数

        while (!q.isEmpty()) {
            int sz = q.size();
            /* 将当前队列中的所有节点向四周扩散 */
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.poll();
                /* 划重点：这里判断是否到达终点 */
                if (cur.equals(target))
                    return step;
                /* 将 cur 的相邻节点加入队列 */
                if (cur.left != null) {
                    q.offer(cur.left);
                    visited.add(cur.left);
                }
                if (cur.right != null) {
                    q.offer(cur.right);
                    visited.add(cur.right);
                }
            }
            /* 划重点：更新步数在这里 */
            step++;
        }
        return step;
    }
}
```

### 练习题

#### 111.「 [二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)」

> 给定一个二叉树，找出其最小深度。
>
> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
> **说明：** 叶子节点是指没有子节点的节点。
>
> **示例 1：**   
> ​![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677315408601-e0936928-0bcb-45aa-9bef-9ca62c4aa3b1-20240307182750-xr52w96.jpeg)  
> 输入：root = [3,9,20,null,null,15,7]  
> 输出：2

怎么套到 BFS 的框架里呢？首先明确一下起点 start 和终点 target 是什么，怎么判断到达了终点？

**显然起点就是 root 根节点，终点就是最靠近根节点的那个「叶子节点」嘛**，叶子节点就是两个子节点都是 null 的节点：

```java
if (cur.left == null && cur.right == null) // 到达叶子节点
```

那么，按照我们上述的框架稍加改造来写解法即可：

```java
int minDepth(TreeNode root) {
    if (root == null) return 0;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);
    // root 本身就是一层，depth 初始化为 1
    int depth = 1;
  
    while (!q.isEmpty()) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            TreeNode cur = q.poll();
            /* 判断是否到达终点 */
            if (cur.left == null && cur.right == null) 
                return depth;
            /* 将 cur 的相邻节点加入队列 */
            if (cur.left != null)
                q.offer(cur.left);
            if (cur.right != null) 
                q.offer(cur.right);
        }
        /* 这里增加步数 */
        depth++;
    }
    return depth;
}
```

这里注意这个 while 循环和 for 循环的配合，**while 循环控制一层一层往下走，for 循环利用 sz 变量控制从左到右遍历每一层二叉树节点**：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677316700301-08aadcc5-898b-4613-afd4-66626b5fe1d2-20240307182750-2kr84uf.png)

这一点很重要，这个形式在普通 BFS 问题中都很常见，但是在 [Dijkstra 算法模板框架](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/dijkstra-s-6d0b2/) 中我们修改了这种代码模式，读完并理解本文后你可以去看看 BFS 算法是如何演变成 Dijkstra 算法在加权图中寻找最短路径的。

话说回来，二叉树本身是很简单的数据结构，我想上述代码你应该可以理解的，其实其他复杂问题都是这个框架的变形，再探讨复杂问题之前，我们解答两个问题：

**1、为什么 BFS 可以找到最短距离，DFS 不行吗**？  
首先，你看 BFS 的逻辑，depth 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。

DFS 不能找最短路径吗？其实也是可以的，但是时间复杂度相对高很多。你想啊，DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长对不对？而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。

形象点说，DFS 是线，BFS 是面；DFS 是单打独斗，BFS 是集体行动。这个应该比较容易理解吧。

**2、既然 BFS 那么好，为啥 DFS 还要存在**？

BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。

还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点数为 N，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 O(logN)。

但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 N/2，用 Big O 表示的话也就是 O(N)。

由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。

#### 752.「 [打开转盘锁](https://leetcode.cn/problems/open-the-lock/)」

> 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： `'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'`​ 。每个拨轮可以自由旋转：例如把 `'9'`​ 变为 `'0'`​，`'0'`​ 变为 `'9'`​ 。每次旋转都只能旋转一个拨轮的一位数字。
>
> 锁的初始数字为 `'0000'`​ ，一个代表四个拨轮的数字的字符串。
>
> 列表 `deadends`​ 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
>
> 字符串 `target`​ 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 `-1`​ 。
>
> **示例 1:**
>
> 输入：`deadends = ["0201","0101","0102","1212","2002"], target = "0202"`​
>
> 输出：6
>
> 解释： `可能的移动序列为 "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202"。`​
>
> `注意 "0000" -> "0001" -> "0002" -> "0102" -> "0202" 这样的序列是不能解锁的，因为当拨动到 "0102" 时这个锁就会被锁定。`​

题目中描述的就是我们生活中常见的那种密码锁，如果没有任何约束，最少的拨动次数很好算，就像我们平时开密码锁那样直奔密码拨就行了。

但现在的难点就在于，不能出现 deadends，应该如何计算出最少的转动次数呢？

**第一步，我们不管所有的限制条件，不管 deadends 和 target 的限制，就思考一个问题：如果让你设计一个算法，穷举所有可能的密码组合，你怎么做**？

穷举呗，再简单一点，如果你只转一下锁，有几种可能？总共有 4 个位置，每个位置可以向上转，也可以向下转，也就是有 8 种可能对吧。

比如说从 "0000" 开始，转一次，可以穷举出 "1000", "9000", "0100", "0900"... 共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能…

**仔细想想，这就可以抽象成一幅图，每个节点有 8 个相邻的节点**，又让你求最短距离，这不就是典型的 BFS 嘛，框架就可以派上用场了。

```java
int openLock(String[] deadends, String target) {
    // 记录需要跳过的死亡密码
    Set<String> deads = new HashSet<>();
    for (String s : deadends) deads.add(s);
    // 记录已经穷举过的密码，防止走回头路
    Set<String> visited = new HashSet<>();
    Queue<String> q = new LinkedList<>();
    // 从起点开始启动广度优先搜索
    int step = 0;
    q.offer("0000");
    visited.add("0000");

    while (!q.isEmpty()) {
        int sz = q.size();
        /* 将当前队列中的所有节点向周围扩散 */
        for (int i = 0; i < sz; i++) {
            String cur = q.poll();

            /* 判断是否到达终点 */
            if (deads.contains(cur))
                continue;
            if (cur.equals(target))
                return step;

            /* 将一个节点的未遍历相邻节点加入队列 */
            for (int j = 0; j < 4; j++) {
                String up = plusOne(cur, j);
                if (!visited.contains(up)) {
                    q.offer(up);
                    visited.add(up);
                }
                String down = minusOne(cur, j);
                if (!visited.contains(down)) {
                    q.offer(down);
                    visited.add(down);
                }
            }
        }
        /* 在这里增加步数 */
        step++;
    }
    // 如果穷举完都没找到目标密码，那就是找不到了
    return -1;
}

private String plus(String cur, int j) {
    char[] chars = cur.toCharArray();
    if (chars[j] == '9') {
        chars[j] = '0';
    } else {
        chars[j] += 1;
    }
    return new String(chars);
}

private String minus(String cur, int j) {
    char[] chars = cur.toCharArray();
    if (chars[j] == '0') {
        chars[j] = '9';
    } else {
        chars[j] -= 1;
    }
    return new String(chars);
}
```

至此，我们就解决这道题目了。有一个比较小的优化：可以不需要 dead 这个哈希集合，可以直接将这些元素初始化到 visited 集合中，效果是一样的，可能更加优雅一些。

#### **LCR 149.「**​[彩灯装饰记录 I](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)」

> 一棵圣诞树记作根节点为 `root`​ 的二叉树，节点值为该位置装饰彩灯的颜色编号。请按照从 **左** 到 **右** 的顺序返回每一层彩灯编号。
>
> **示例 1：**
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240307190034-ry99443.png)
>
> `输入：root = [8,17,21,18,null,null,6]`​
>
> `输出：[8,17,21,18,6]`​

```java
public int[] levelOrder(TreeNode root) {
    if (root == null) return new int[0];
	List<Integer> res = new LinkedList<>();
	LinkedList<TreeNode> queue = new LinkedList<>();
	queue.offer(root);
	while (!queue.isEmpty()) {
    	int sz = queue.size();
    	for (int i = 0; i < sz; i++) {
        	TreeNode node = queue.poll();
        	res.add(node.val);
        	if (node.left != null) queue.offer(node.left);
        	if (node.right != null) queue.offer(node.right);
    	}
	}
	int[] result = new int[res.size()];
	for (int i = 0; i < res.size(); i++) {
    	result[i] = res.get(i);
	}
	return result;
}
```

#### **LCR 151.「**​[彩灯装饰记录 III](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)」

> 一棵圣诞树记作根节点为 `root`​ 的二叉树，节点值为该位置装饰彩灯的颜色编号。请按照如下规则记录彩灯装饰结果：
>
> - 第一层按照从左到右的顺序记录
> - 除第一层外每一层的记录顺序均与上一层相反。即第一层为从左到右，第二层为从右到左。
>
> **示例 1：**
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240307190034-ry99443.png)
>
> `输入：root = [8,17,21,18,null,null,6]`​
>
> `输出：[[8],[21,17],[18,6]]`​

层序遍历 + 双端队列  
利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列） tmp ，并规定：

- 奇数层 则添加至 tmp 尾部 ，
- 偶数层 则添加至 tmp 头部 。

算法流程：

- 特例处理： 当树的根节点为空，则直接返回空列表 [] ；
- 初始化： 打印结果空列表 res ，包含根节点的双端队列 deque ；
- BFS 循环： 当 deque 为空时跳出；

    - 新建列表 tmp ，用于临时存储当前层打印结果；
    - 当前层打印循环： 循环次数为当前层节点数（即 deque 长度）；

        - 出队： 队首元素出队，记为 node；
        - 打印： 若为奇数层，将 node.val 添加至 tmp 尾部；否则，添加至 tmp 头部；
        - 添加子节点： 若 node 的左（右）子节点不为空，则加入 deque ；
    - 将当前层结果 tmp 转化为 list 并添加入 res ；
- 返回值： 返回打印结果列表 res 即可；

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678706476014-bab82ed7-a922-48a3-86db-8fdce7125002-20240307182751-uv0epwu.gif)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) return res;
        LinkedList<TreeNode> q = new LinkedList<>();
        q.offer(root);
        while (!q.isEmpty()) {
            int sz = q.size();
            LinkedList<Integer> temp = new LinkedList<>();
            for (int i = 0; i < sz; i++) {
                TreeNode cur = q.pop();
                if ((res.size() & 1) == 0) {
                    temp.addLast(cur.val);
                } else {
                    temp.addFirst(cur.val);
                }
                if (cur.left != null) q.offer(cur.left);
                if (cur.right != null) q.offer(cur.right);
            }
            res.add(temp);
        }
        return res;
    }
}
```

复杂度分析：

- 时间复杂度 O(N) ： N 为二叉树的节点数量，即 BFS 需循环 N 次，占用 O(N) ；双端队列的队首和队尾的添加和删除操作的时间复杂度均为 O(1) 。
- 空间复杂度 O(N)： 最差情况下，即当树为满二叉树时，最多有 N/2 个树节点 同时 在 deque 中，使用 O(N) 大小的额外空间。

## 二分查找

### 概念

#### 最基本的二分查找

- **为什么 while 循环的条件中是 &lt;=，而不是 &lt;** ？

    - 因为初始化 `right`​ 的赋值是 `nums.length - 1`​，即最后一个元素的索引，而不是 `nums.length`​。
    - `while(left <= right)`​ 的终止条件是 `left == right + 1`​，写成区间的形式就是 `[right + 1, right]`​，或者带个具体的数字进去 `[3, 2]`​，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。
    - `while(left < right)`​ 的终止条件是 `left == right`​，写成区间的形式就是 `[right, right]`​，或者带个具体的数字进去 `[2, 2]`​，**这时候区间非空**，还有一个数 2，但此时 while 循环终止了。也就是说这区间 `[2, 2]`​ 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。
- **为什么** ****​`left = mid + 1`​****​ **，**​**​`right = mid - 1`​**​ **？我看有的代码是** ****​`right = mid`​****​ **或者** ****​`left = mid`​****​ **，没有这些加加减减，到底怎么回事，怎么判断**？

    - 刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 `[left, right]`​。那么当我们发现索引 `mid`​ 不是要找的 `target`​ 时，下一步应该去搜索哪里呢？  
      当然是去搜索区间 `[left, mid-1]`​ 或者区间 `[mid+1, right]`​ 对不对？**因为** ****​`mid`​****​ **已经搜索过，应该从搜索区间中去除**。

```java
public int binary_search(int[] nums, int target) {
    // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算
    if (target < nums[0] || target > nums[nums.length - 1]) {
        return -1;
    }
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + ((right - left) >> 1);
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        }
    }
    return -1;
}
```

#### 寻找左边界的二分查找

- **为什么该算法能够搜索左侧边界**

    - 找到 target 时不要立即返回，而是缩小「搜索区间」的上界 `right`​，在区间 `[left, mid-1]`​ 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。

```java
public int left_bound(int[] nums, int target) {
  if(target < nums[0] || target > nums[nums.length - 1]) { // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算
    return -1;
  }
  int left = 0, right = nums.length - 1;
  while(left <= right) {
    int mid = left + ((right - left) >> 1);
    if(nums[mid] < target) { // 当前 < target，所以直接上调左边界
      left = mid + 1;
    } else if(nums[mid] > target) { // 当前 > target，所以直接下调右边界
      right = mid - 1;
    } else if(nums[mid] == target) { // 当前 = target，不确定mid就是最左边界，锁定左边界，下调右边界
      right = mid - 1;
    }
  }
  return nums[left] == target ? left : -1; // 判断一下 nums[left] 是不是 target
}
```

#### 寻找右边界的二分查找

- **为什么这个算法能够找到右侧边界**

    - 当 `nums[mid] == target`​ 时，不要立即返回，而是增大「搜索区间」的左边界 `left`​，使得区间不断向右靠拢，达到锁定右侧边界的目的。

```java
public int right_bound(int[] nums, int target) {
  if(target < nums[0] || target > nums[nums.length - 1]) { // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算
    return -1;
  }
  int left = 0, right = nums.length - 1;
  while(left <= right) {
    int mid = left + ((right - left) >> 1);
    if(nums[mid] < target) {
      left = mid + 1;
    } else if(nums[mid] > target) {
      right = mid - 1;
    } else if(nums[mid] == target) {
      // 当前 = target，不确定mid就是最右边界，锁定右边界，上调左边界
      // 别返回，锁定右侧边界
      left = mid + 1;
    }
  }
  return nums[right] == target ? right : -1; // 判断一下 nums[right] 是不是 target
}
```

### 练习题

#### 34.「[在排序数组中查找元素的第一个和最后一个位置」](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

> 给你一个按照非递减顺序排列的整数数组 `nums`​，和一个目标值 `target`​。请你找出给定目标值在数组中的开始位置和结束位置。
>
> 如果数组中不存在目标值 `target`​，返回 `[-1, -1]`​。
>
> **示例 1：**
>
> `输入：nums = [5,7,7,8,8,10], target = 8`​
>
> `输出：[3,4]`​

```java
public int[] searchRange(int[] nums, int target) {
  if(nums.length == 0) {
    return new int[] {-1, -1};
  }
  return new int[] {leftBound(nums, target), rightBound(nums, target)};
}

private int leftBound(int[] nums, int target) {
  int left = 0, right = nums.length - 1;
  if(target < nums[left] || target > nums[right]) {
    return -1;
  }
  while(left <= right) {
    int mid = left + ((right - left) >> 1);
    if(nums[mid] < target) {
      left = mid + 1;
    } else if(nums[mid] > target) {
      right = mid - 1;
    } else if(nums[mid] == target) {
      right = mid - 1;
    }
  }
  return nums[left] == target ? left : -1;
}

private int rightBound(int[] nums, int target) {
  int left = 0, right = nums.length - 1;
  if(target < nums[left] || target > nums[right]) {
    return -1;
  }
  while(left <= right) {
    int mid = left + ((right - left) >> 1);
    if(nums[mid] < target) {
      left = mid + 1;
    } else if(nums[mid] > target) {
      right = mid - 1;
    } else if(nums[mid] == target) {
      left = mid + 1;
    }
  }
  return nums[right] == target ? right : -1;
}
```

#### **LCR 128.「**​[库存管理 I](https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/description/)​ **」**

> 仓库管理员以数组 `stock`​ 形式记录商品库存表。`stock[i]`​ 表示商品 `id`​，可能存在重复。原库存表按商品 `id`​ 升序排列。现因突发情况需要进行商品紧急调拨，管理员将这批商品 `id`​ 提前依次整理至库存表最后。请你找到并返回库存表中编号的 **最小的元素** 以便及时记录本次调拨。
>
> **示例 1：**
>
> 输入：numbers = [3,4,5,1,2]
>
> 输出：1

```java
class Solution {
    /**
    * 为什么要一直跟numbers[right]比较？
    * 如果是numbers[mid] 与 numbers[left]比较，当numbers[mid] > numbers[left] 不知道最小值在哪边
    * [3,4,5,1,2] 最小值在mid右边；[1,2,3,4,5] 最小值在mid左边
    * @param numbers
    * @return
    */
    public int minArray(int[] numbers) {
        if (numbers.length == 1) return numbers[0];
        int left = 0, right = numbers.length - 1;
        while (left <= right) { // 终止条件: left = right + 1
            int mid = left + ((right - left) >> 1);
            if (numbers[mid] > numbers[right]) { // 说明最小数字一定在当前middle的右边
                left = mid + 1; // 左指针移到middle+1位置，搜索空间是[middle+1, right]
            } else if (numbers[mid] < numbers[right]) { // 说明最小数字一定在当前middle的左边
                right = mid; // 这种情况middle可能正好是最小值，所以右指针不能移动到middle-1，需要移动到middle位置, 搜索空间是[left, middle]
            } else {
                --right; // 比如4 3 4 4 4，middle在中间的4，和left、right都相等, 没法判断最小值具体在哪一边, 所以right左移一位，从右向左暴力缩小查找范围
            }
        }
        return numbers[left];
    }
}
```

#### **875.「**​[爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/description/)」

> 珂珂喜欢吃香蕉。这里有 `n`​ 堆香蕉，第 `i`​ 堆中有 `piles[i]`​ 根香蕉。警卫已经离开了，将在 `h`​ 小时后回来。
>
> 珂珂可以决定她吃香蕉的速度 `k`​ （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 `k`​ 根。如果这堆香蕉少于 `k`​ 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。
>
> 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。
>
> 返回她可以在 `h`​ 小时内吃掉所有香蕉的最小速度 `k`​（`k`​ 为整数）。
>
> **示例 1：**
>
> 输入：piles = [3,6,7,11], h = 8
>
> 输出：4

题目中存在单调关系，就可以尝试使用二分搜索的思路来解决。

按步骤思考即可：

**1、确定 x, f(x), target 分别是什么，并写出函数 f 的代码**。

自变量 x 是什么呢？回忆之前的函数图像，二分搜索的本质就是在搜索自变量。

所以，题目让求什么，就把什么设为自变量，珂珂吃香蕉的速度就是自变量 x。

那么，在 x 上单调的函数关系 f(x) 是什么？

显然，吃香蕉的速度越快，吃完所有香蕉堆所需的时间就越少，速度和时间就是一个单调函数关系。

所以，f(x) 函数就可以这样定义：

若吃香蕉的速度为 x 根/小时，则需要 f(x) 小时吃完所有香蕉。

代码实现如下：

```java
// 定义：速度为 x 时，需要 f(x) 小时吃完所有香蕉
// f(x) 随着 x 的增加单调递减
int f(int[] piles, int x) {
    int hours = 0;
    for (int i = 0; i < piles.length; i++) {
        hours += piles[i] / x;
        if (piles[i] % x > 0) {
            hours++;
        }
    }
    return hours;
}
```

target 就很明显了，吃香蕉的时间限制 H 自然就是 target，是对 f(x) 返回值的最大约束。

**2、找到 x 的取值范围作为二分搜索的搜索区间，初始化 left 和 right 变量**。

珂珂吃香蕉的速度最小是多少？多大是多少？

显然，最小速度应该是 1，最大速度是 piles 数组中元素的最大值，因为每小时最多吃一堆香蕉，胃口再大也白搭嘛。

这里可以有两种选择，要么你用一个 for 循环去遍历 piles 数组，计算最大值，要么你看题目给的约束，piles 中的元素取值范围是多少，然后给 right 初始化一个取值范围之外的值。

我选择第二种，题目说了 1 <= piles[i] <= 10^9，那么我就可以确定二分搜索的区间边界：

```java
public int minEatingSpeed(int[] piles, int H) {
    int left = 1;
    // 注意，right 是开区间，所以再加一
    int right = 1000000000 + 1;

    // ...
}
```

**3、根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码**。

现在我们确定了自变量 x 是吃香蕉的速度，f(x) 是单调递减的函数，target 就是吃香蕉的时间限制 H，题目要我们计算最小速度，也就是 x 要尽可能小。

这就是搜索左侧边界的二分搜索嘛，不过注意 f(x) 是单调递减的，不要闭眼睛套框架，需要结合上图进行思考，写出代码：

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int left = 1; // 速度最小的时候，耗时最长
        int right = 1000000001; // 速度最大的时候，耗时最短
        while (left <= right) {
            int mid = left + ((right - left) >> 1);
            long hours = calculate(piles, mid);
            if (hours > h) { // 耗时太长，吃的太慢
                left = mid + 1;
            } else if (hours < h) { // 耗时短，找左边界
                right = mid - 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }

    private long calculate(int[] piles, int speed) {
        long hours = 0;
        for (int pile : piles) {
            hours += (pile / speed);
            if (pile % speed != 0) {
                ++hours;
            }
        }
        return hours;
    }
}
```

#### **1011.「**​[在 D 天内送达包裹的能力](https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/)」

> 传送带上的包裹必须在 `days`​ 天内从一个港口运送到另一个港口。
>
> 传送带上的第 `i`​ 个包裹的重量为 `weights[i]`​。每一天，我们都会按给出重量（`weights`​）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。
>
> 返回能在 `days`​ 天内将传送带上的所有包裹送达的船的最低运载能力。
>
> **示例 1：**
>
> 输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5
>
> 输出：15
>
> 解释： 船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示： 第 1 天：1, 2, 3, 4, 5 第 2 天：6, 7 第 3 天：8 第 4 天：9 第 5 天：10
>
> 请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。

和上一道题一样的，我们按照流程来就行：

**1、确定 x, f(x), target 分别是什么，并写出函数 f 的代码**。

题目问什么，什么就是自变量，也就是说船的运载能力就是自变量 x。

运输天数和运载能力成反比，所以可以让 f(x) 计算 x 的运载能力下需要的运输天数，那么 f(x) 是单调递减的。

函数 f(x) 的实现如下：

```java
// 定义：当运载能力为 x 时，需要 f(x) 天运完所有货物
// f(x) 随着 x 的增加单调递减
int f(int[] weights, int x) {
    int days = 0;
    for (int i = 0; i < weights.length; ) {
        // 尽可能多装货物
        int cap = x;
        while (i < weights.length) {
            if (cap < weights[i]) break;
            else cap -= weights[i];
            i++;
        }
        days++;
    }
    return days;
}
```

对于这道题，target 显然就是运输天数 D，我们要在 f(x) == D 的约束下，算出船的最小载重。

**2、找到 x 的取值范围作为二分搜索的搜索区间，初始化 left 和 right 变量**。

船的最小载重是多少？最大载重是多少？

显然，船的最小载重应该是 weights 数组中元素的最大值，因为每次至少得装一件货物走，不能说装不下嘛。

最大载重显然就是weights 数组所有元素之和，也就是一次把所有货物都装走。

这样就确定了搜索区间 [left, right)：

```java
public int shipWithinDays(int[] weights, int days) {
    int left = 0;
    // 注意，right 是开区间，所以额外加一
    int right = 1;
    for (int w : weights) {
        left = Math.max(left, w);
        right += w;
    }

    // ...
}
```

**3、需要根据题目的要求，确定应该使用搜索左侧还是搜索右侧的二分搜索算法，写出解法代码**。  
现在我们确定了自变量 x 是船的载重能力，f(x) 是单调递减的函数，target 就是运输总天数限制 D，题目要我们计算船的最小载重，也就是 x 要尽可能小。  
这就是搜索左侧边界的二分搜索嘛，结合上图就可写出二分搜索代码：

```java
class Solution {
    public int shipWithinDays(int[] weights, int days) {
        int l = 0, r = 0;
        for (int weight : weights) {
            l = Math.max(l, weight);
            r += weight;
        }
        while (l <= r) {
            int mid = l + ((r - l) >> 1);
            int cost = cal(weights, mid);
            if (cost > days) { // 花费时间长
                l = mid + 1;
            } else if (cost < days) { // 花费时间短，缩短左边界
                r = mid - 1;
            } else {
                r = mid - 1;
            }
        }
        return l;
    }

    private int cal(int[] weights, int w) {
        int cost = 0;
        for (int i = 0; i < weights.length;) {
            int cap = w;
            while (i < weights.length && cap >= weights[i]) {
                cap -= weights[i];
                ++i;
            }
            ++cost;
        }
        return cost;
    }
}
```

#### **410.「**​[分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/description/)」

> 给定一个非负整数数组 `nums`​ 和一个整数 `k`​ ，你需要将这个数组分成 `k`​  个非空的连续子数组。
>
> 设计一个算法使得这 `k`​  个子数组各自和的最大值最小。
>
> **示例 1：**
>
> 输入：nums = [7,2,5,10,8], m = 2  
> 输出：18  
> 解释： 一共有四种方法将 nums 分割为 2 个子数组。  其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。 因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。

简单说，给你输入一个数组 nums 和数字 m，你要把 nums 分割成 m 个子数组。

肯定有不止一种分割方法，每种分割方法都会把 nums 分成 m 个子数组，这 m 个子数组中肯定有一个和最大的子数组对吧。

我们想要找一个分割方法，该方法分割出的最大子数组和是所有方法中最大子数组和最小的。

请你的算法返回这个分割方法对应的最大子数组和。

我滴妈呀，这个题目看了就觉得难的不行，完全没思路，这题怎么运用我们之前说套路，转化成二分搜索呢？

**其实，这道题和上面讲的运输问题是一模一样的，不相信的话我给你改写一下题目**：

你只有一艘货船，现在有若干货物，每个货物的重量是 nums[i]，现在你需要在 m 天内将这些货物运走，请问你的货船的最小载重是多少？

这不就是刚才我们解决的力扣第 1011 题「在 D 天内送达包裹的能力」吗？

货船每天运走的货物就是 nums 的一个子数组；在 m 天内运完就是将 nums 划分成 m 个子数组；让货船的载重尽可能小，就是让所有子数组中最大的那个子数组元素之和尽可能小。

所以这道题的解法直接复制粘贴运输问题的解法代码即可：

```java
class Solution {
    public int splitArray(int[] nums, int k) {
        int l = 0, r = 0;
        for (int num : nums) {
            l = Math.max(l, num);
            r += num;
        }
        while (l <= r) {
            int mid = l + ((r - l) >> 1);
            int sum = cal(nums, mid);
            if (sum > k) { // 如果分割数太多，说明「子数组各自的和的最大值」太小，此时需要将「子数组各自的和的最大值」调大
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return l;
    }

    private int cal(int[] nums, int x) {
        int sum = 0;
        for (int i = 0; i < nums.length; ) {
            int cap = x;
            while (i < nums.length && cap >= nums[i]) {
                cap -= nums[i];
                ++i;
            }
            ++sum;
        }
        return sum;
    }

}
```

#### **LCR 179.「**​[查找总价格为目标值的两个商品](https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/)」

> 购物车内的商品价格按照升序记录于数组 `price`​。请在购物车中找到两个商品的价格总和刚好是 `target`​。若存在多种情况，返回任一结果即可。
>
> **示例 1：**   
> 输入：nums = [2,7,11,15], target = 9  
> 输出：[2,7] 或者 [7,2]

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int l = 0, r = nums.length - 1;
        while (l <= r) {
            int mid = nums[l] + nums[r];
            if (mid < target) {
                ++l;
            } else if (mid > target) {
                --r;
            } else {
                return new int[]{nums[l], nums[r]};
            }
        }
        return null;
    }
}
```

## 滑动窗口

### 提纲

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059883392-b69cdbaa-c9fe-4253-a8aa-2d7498abfa1d-20240314140054-pql4yxv.gif)  
其实从动画中可以发现滑动窗口也可以理解为双指针法的一种！只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

实现滑动窗口，主要确定如下三点：

- 窗口内是什么？
- 如何移动窗口的起始位置？
- 如何移动窗口的结束位置？

### 练习题

#### 209.[「长度最小的子数组」](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

> 给定一个含有 `n`​  个正整数的数组和一个正整数 `target`​。
>
> 找出该数组中满足其总和大于等于 `target`​ 的长度最小的 连续子数组，并返回其长度 **。** 如果不存在符合条件的子数组，返回 `0`​ 。
>
> 示例：  
> 输入：s = 7, nums = [2,3,1,2,4,3]  
> 输出：2  
> 解释：子数组 [4,3] 是该条件下的长度最小的子数组。

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

解题的关键在于 窗口的起始位置如何移动，如图所示：

![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059884806-3838d8b8-10f8-4cc6-bd9d-b3e96f2ee896-20240314140055-byr5f53.png)  
可以发现**滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

```java
class Solution {
  public int minSubArrayLen(int s, int[] nums) { // 滑动窗口
    int left = 0;
    int sum = 0;
    int result = Integer.MAX_VALUE;
    for(int right = 0; right < nums.length; right++) {
      sum += nums[right];
      while(sum >= s) {
        result = Math.min(result, right - left + 1);
        sum -= nums[left++];
      }
    }
    return result == Integer.MAX_VALUE ? 0 : result;
  }
}
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

#### 76. [「最小覆盖子串」](https://leetcode.cn/problems/minimum-window-substring/)

> 给你一个字符串 `s`​ 、一个字符串 `t`​ 。返回 `s`​ 中涵盖 `t`​ 所有字符的最小子串。如果 `s`​ 中不存在涵盖 `t`​ 所有字符的子串，则返回空字符串 `""`​ 。
>
> 输入：s = "ADOBECODEBANC", t = "ABC"
>
> 输出："BANC"
>
> 解释：最小覆盖子串 "BANC" 包含来自字符串 t 的 'A'、'B' 和 'C'。

就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，且这个子串一定是所有可能子串中最短的。  
如果我们使用暴力解法，代码大概是这样的：

```java
for (int i = 0; i < s.size(); i++)
    for (int j = i + 1; j < s.size(); j++)
        if s[i:j] 包含 t 的所有字母:
            更新答案
```

思路很直接，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。

**滑动窗口算法的思路是这样**：

1、我们在字符串 `S`​ 中使用双指针中的左右指针技巧，初始化 `left = right = 0`​，把索引**左闭右开**区间 `[left, right)`​ 称为一个「窗口」。

> PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 `left = right = 0`​ 时区间 `[0, 0)`​ 中没有元素，但只要让 `right`​ 向右移动（扩大）一位，区间 `[0, 1)`​ 就包含一个元素 `0`​ 了。如果你设置为两端都开的区间，那么让 `right`​ 向右移动一位后开区间 `(0, 1)`​ 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 `[0, 0]`​ 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。

2、我们先不断地增加 `right`​ 指针扩大窗口 `[left, right)`​，直到窗口中的字符串符合要求（包含了 `T`​ 中的所有字符）。

3、此时，我们停止增加 `right`​，转而不断增加 `left`​ 指针缩小窗口 `[left, right)`​，直到窗口中的字符串不再符合要求（不包含 `T`​ 中的所有字符了）。同时，每次增加 `left`​，我们都要更新一轮结果。

4、重复第 2 和第 3 步，直到 `right`​ 到达字符串 `S`​ 的尽头。

这个思路其实也不难，**第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解**，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。

下面画图理解一下，`needs`​ 和 `window`​ 相当于计数器，分别记录 `T`​ 中字符出现次数和「窗口」中的相应字符的出现次数。

初始状态：  
![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059885185-d160beeb-9d2a-4601-b820-16bfbaf6f5a8-20240314140055-hpy6mk3.jpeg)  
增加 right，直到窗口 [left, right) 包含了 T 中所有字符：  
![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059886526-61664137-90bd-4e83-877c-4d0c6aac661f-20240314140055-6xg1n3r.jpeg)  
现在开始增加 left，缩小窗口 [left, right)：  
![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059886600-c653ac2c-7d58-41c8-8d16-55ba324c3ac3-20240314140055-2d7sl8v.jpeg)  
直到窗口中的字符串不再符合要求，left 不再继续移动：  
![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059887954-b5a86dfc-922c-4f2d-bf0c-6befcfd23fdc-20240314140055-8xvpr3w.jpeg)  
之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。

如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。**现在我们来看看这个滑动窗口代码框架怎么用**：

首先，初始化 window 和 need 两个哈希表，记录窗口中的字符和需要凑齐的字符：

```java
HashMap<char, int> need, window;
for (char c : t) need[c]++;
```

然后，使用 `left`​ 和 `right`​ 变量初始化窗口的两端，不要忘了，区间 `[left, right)`​ 是左闭右开的，所以初始情况下窗口没有包含任何元素：

```java
int left = 0, right = 0;
int valid = 0; 
while (right < s.size()) {
    // 开始滑动
}
```

**其中** ****​`valid`​****​ **变量表示窗口中满足** ****​`need`​****​ **条件的字符个数**，如果 `valid`​ 和 `need.size`​ 的大小相同，则说明窗口已满足条件，已经完全覆盖了串 `T`​。

**现在开始套模板，只需要思考以下几个问题**：

1、什么时候应该移动 `right`​ 扩大窗口？窗口加入字符时，应该更新哪些数据？

2、什么时候窗口应该暂停扩大，开始移动 `left`​ 缩小窗口？从窗口移出字符时，应该更新哪些数据？

3、我们要的结果应该在扩大窗口时还是缩小窗口时进行更新？

如果一个字符进入窗口，应该增加 `window`​ 计数器；如果一个字符将移出窗口的时候，应该减少 `window`​ 计数器；当 `valid`​ 满足 `need`​ 时应该收缩窗口；应该在收缩窗口的时候更新最终结果。

下面是完整代码：

```java
public String minWindow(String s, String t) {
    Map<Character, Integer> need = new HashMap<>(); // 记录每个字符需要的次数
    for (int i = 0; i < t.length(); i++) {
        need.put(t.charAt(i), need.getOrDefault(t.charAt(i), 0) + 1);
    }
    Map<Character, Integer> window = new HashMap<>(); // 记录窗口中每个字符出现的次数
    int l = 0, r = 0;
    int match = 0; // 记录每个匹配的字符个数
    int len = Integer.MAX_VALUE; // 记录匹配字符串的长度
    int start = 0;
    while (r < s.length()) {
        char ch = s.charAt(r++);
        window.put(ch, window.getOrDefault(ch, 0) + 1); // 将该字符放入窗口中
        if (need.containsKey(ch) && need.get(ch).equals(window.get(ch))) {
            ++match;
        }
        while (match == need.size()) { // 当窗口完全包含目标字符时，调整窗口
            if (r - l < len) { // 更新结果
                len = r - l;
                start = l;
            }
            char remove = s.charAt(l++); // 收缩窗口
            if (need.containsKey(remove)) {
                if (need.get(remove).equals(window.get(remove))) { // 只有该字符出现的次数一致时，才能代表之前match加过1
                    --match;
                }
                window.put(remove, window.getOrDefault(remove, 0) - 1);
            }
        }
    }
    return len == Integer.MAX_VALUE ? "" : s.substring(start, start + len);
}
```

需要注意的是，当我们发现某个字符在 window 的数量满足了 need 的需要，就要更新 valid，表示有一个字符已经满足要求。而且，你能发现，两次对窗口内数据的更新操作是完全对称的。

当 valid == need.size() 时，说明 T 中所有字符已经被覆盖，已经得到一个可行的覆盖子串，现在应该开始收缩窗口了，以便得到「最小覆盖子串」。

移动 left 收缩窗口时，窗口内的字符都是可行解，所以应该在收缩窗口的阶段进行最小覆盖子串的更新，以便从可行解中找到长度最短的最终结果。

至此，应该可以完全理解这套框架了，滑动窗口算法又不难，就是细节问题让人烦得很。**以后遇到滑动窗口算法，你就按照这框架写代码，保准没有 bug，还省事儿**。

#### 567.「[字符串的排列](https://leetcode.cn/problems/permutation-in-string/)」

> 给你两个字符串 `s1`​ 和 `s2`​ ，写一个函数来判断 `s2`​ 是否包含 `s1`​ 的排列。如果是，返回 `true`​ ；否则，返回 `false`​ 。  
> 换句话说，`s1`​ 的排列之一是 `s2`​ 的 **子串** 。
>
> 输入：s1 = "ab" s2 = "eidbaooo"  
> 输出：true  
> 解释：s2 包含 s1 的排列之一 ("ba").

```java
public boolean checkInclusion(String s1, String s2) {
    Map<Character, Integer> need = new HashMap<>();
    for (int i = 0; i < s1.length(); i++) {
        need.put(s1.charAt(i), need.getOrDefault(s1.charAt(i), 0) + 1);
    }
    Map<Character, Integer> window = new HashMap<>();
    int l = 0, r = 0;
    int match = 0;
    while (r < s2.length()) {
        char ch = s2.charAt(r++);
        window.put(ch, window.getOrDefault(ch, 0) + 1);
        if (need.containsKey(ch) && need.get(ch).equals(window.get(ch))) {
            ++match;
        }
        while (r - l >= s1.length()) {
            if (match == need.size()) return true;
            char remove = s2.charAt(l++);
            if (need.containsKey(remove) && need.get(remove).equals(window.get(remove))) {
                --match;
            }
            window.put(remove, window.getOrDefault(remove, 0) - 1);
        }
    }
    return false;
}
```

对于这道题的解法代码，基本上和最小覆盖子串一模一样，只需要改变几个地方：

1、本题移动 `left`​ 缩小窗口的时机是窗口大小大于 `t.size()`​ 时，应为排列嘛，显然长度应该是一样的。

2、当发现 `valid == need.size()`​ 时，就说明窗口中就是一个合法的排列，所以立即返回 `true`​。

至于如何处理窗口的扩大和缩小，和最小覆盖子串完全相同。

> PS：由于这道题中 `[left, right)`​ 其实维护的是一个**定长**的窗口，窗口大小为 `t.size()`​。因为定长窗口每次向前滑动时只会移出一个字符，所以可以把内层的 while 改成 if，效果是一样的。

#### 438.「 [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)」

> 给定两个字符串 `s`​ 和 `p`​，找到 `s`​  中所有 `p`​  的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。
>
> **异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。
>
> 输入: s = "cbaebabacd", p = "abc"  
> 输出: [0,6]  
> 解释:  
> 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。  
> 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

呵呵，这个所谓的字母异位词，不就是排列吗，搞个高端的说法就能糊弄人了吗？**相当于，输入一个串** ****​`S`​****​ **，一个串** ****​`T`​****​ **，找到** ****​`S`​****​ **中所有** ****​`T`​****​ **的排列，返回它们的起始索引**。

直接默写一下框架，明确刚才讲的 4 个问题，即可秒杀这道题：

```java
public List<Integer> findAnagrams(String s, String p) {
    Map<Character, Integer> need = new HashMap<>();
    for (int i = 0; i < p.length(); i++) {
        need.put(p.charAt(i), need.getOrDefault(p.charAt(i), 0) + 1);
    }
    Map<Character, Integer> window = new HashMap<>();
    int l = 0, r = 0;
    int match = 0;
    List<Integer> res = new LinkedList<>();
    while (r < s.length()) {
        char ch = s.charAt(r++);
        window.put(ch, window.getOrDefault(ch, 0) + 1);
        if (need.containsKey(ch) && need.get(ch).equals(window.get(ch))) {
            ++match;
        }
        while (r - l >= p.length()) {
            if (match == need.size()) {
                res.add(l);
            }
            char remove = s.charAt(l++);
            if (need.containsKey(remove) && need.get(remove).equals(window.get(remove))) {
                --match;
            }
            window.put(remove, window.getOrDefault(remove, 0) - 1);
        }
    }
    return res;
}
```

跟寻找字符串的排列一样，只是找到一个合法异位词（排列）之后将起始索引加入 `res`​ 即可。

#### 3.「 [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)」

> 给定一个字符串 `s`​ ，请你找出其中不含有重复字符的 **最长子串** 的长度。
>
> 输入: s = "abcabcbb"  
> 输出: 3  
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

```java
public int lengthOfLongestSubstring(String s) {
	HashMap<Character, Integer> windows = new HashMap<>();
	int left = 0, right = 0;
	int max = 0;
	while (right < s.length()) {
		char ch = s.charAt(right);
		right++;
		windows.put(ch, windows.getOrDefault(ch, 0) + 1);
		while (windows.get(ch) > 1) {
			Character remove = s.charAt(left);
			left++;
			windows.put(remove, windows.get(remove) - 1);
		}
		max = Math.max(max, right - left);
	}
	return max;
}
```

这就是变简单了，连 `need`​ 和 `valid`​ 都不需要，而且更新窗口内数据也只需要简单的更新计数器 `window`​ 即可。

当 `window[c]`​ 值大于 1 时，说明窗口中存在重复字符，不符合条件，就该移动 `left`​ 缩小窗口了嘛。

唯一需要注意的是，在哪里更新结果 `res`​ 呢？我们要的是最长无重复子串，哪一个阶段可以保证窗口中的字符串是没有重复的呢？

这里和之前不一样，要在收缩窗口完成后更新 `res`​，因为窗口收缩的 while 条件是存在重复元素，换句话说收缩完成后一定保证窗口中没有重复嘛。

#### **LCR 180.「**​[文件组合](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)」

> 待传输文件被切分成多个部分，按照原排列顺序，每部分文件编号均为一个 **正整数**（至少含有两个文件）。传输要求为：连续文件编号总和为接收方指定数字 `target`​ 的所有文件。请返回所有符合该要求的文件传输组合列表。
>
> **注意**，返回时需遵循以下规则：
>
> - 每种组合按照文件编号 **升序** 排列；
> - 不同组合按照第一个文件编号 **升序** 排列。
>
> **示例 1：**   
> 输入：target = 9  
> 输出：[[2,3,4],[4,5]]

这题可以用滑动窗口技巧，相当于问你数组 nums = [1,2,...,target] 中和为 target 的子数组。  
前文 [滑动窗口框架](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_627ccf3be4b01a4851fe1012/1) 说过，使用滑动窗口算法需要搞清楚以下几个问题：  
1、什么时候应该扩大窗口？  
2、什么时候应该缩小窗口？  
3、什么时候得到一个合法的答案？  
本题很简单直接，以上三个问题的答案是：  
1、当窗口中元素和小于 target 时，扩大窗口。  
2、当窗口中元素和大于 target 时，缩小窗口。  
3、当窗口中元素和等于 target 且窗口中元素个数大于等于 2 时。  
需要注意的是，本题的数组 nums 中所有元素都是正整数，不包含负数，所以可以直接用滑动窗口技巧；如果数组 nums 中可能包含负数，那么就不能直接用滑动窗口算法了，因为无法确切地判断什么时候应该收缩窗口。

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int left = 1, right = 2;
        int sum = left;
        List<int[]> res = new LinkedList<>();
        while (right < target) {
            sum += right; // 将当前元素加进来
            ++right; // 扩大窗口
            while (sum > target) { // 缩减窗口
                sum -= left; // 将左边界剔除
                ++left; // 左边界右移
            }
            if (sum == target && (right - left) > 1) { // 找到一组
                int[] arr = new int[right - left];
                int k = 0;
                for (int i = left; i < right; i++) {
                    arr[k++] = i;
                }
                res.add(arr);
            }
        }
        int[][] rs = new int[res.size()][];
        for (int i = 0; i < res.size(); i++) {
            rs[i] = res.get(i);
        }
        return rs;
    }
}
```

## 前缀和

### 概念

**前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。**

核心代码就是下面这段：

```java
class PrefixSum {
    // 前缀和数组
    private int[] prefix;
  
    /* 输入一个数组，构造前缀和 */
    public PrefixSum(int[] nums) {
        prefix = new int[nums.length + 1];
        // 计算 nums 的累加和
        for (int i = 1; i < prefix.length; i++) {
            prefix[i] = prefix[i - 1] + nums[i - 1];
        }
    }

    /* 查询闭区间 [i, j] 的累加和 */
    public int query(int i, int j) {
        return prefix[j + 1] - prefix[i];
    }
}
```

![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059888004-cf8f61aa-ea2f-4a85-bcf3-482543e2b5f8-20240318155015-mce14gf.jpeg)  
`prefix[i]`​就代表着`nums[0..i-1]`​所有元素的累加和，如果我们想求区间`nums[i..j]`​的累加和，只要计算

`prefix[j+1] - prefix[i]`​ 即可，而不需要遍历整个区间求和。

### 练习题

#### 303.「 [区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable/)」

> 给定一个整数数组  nums，处理以下类型的多个查询:
>
> 1. 计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 **和** ，其中 left <= right
>
> 实现 NumArray 类：
>
> - NumArray(int[] nums) 使用数组 nums 初始化对象
> - int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 **总和** ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] )
>
> **示例 1：**   
> 输入：  
> ["NumArray", "sumRange", "sumRange", "sumRange"]  
> [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]  
> 输出：  
> [null, 1, -1, -3]  
> 解释：  
> NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);  
> numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)  
> numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1))
> numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))

题目要求你实现这样一个类：

```java
class NumArray {

    public NumArray(int[] nums) {}
  
    /* 查询闭区间 [left, right] 的累加和 */
    public int sumRange(int left, int right) {}
}
```

`sumRange`​ 函数需要计算并返回一个索引区间之内的元素和，没学过前缀和的人可能写出如下代码：

```java
class NumArray {

    private int[] nums;

    public NumArray(int[] nums) {
        this.nums = nums;
    }
  
    public int sumRange(int left, int right) {
        int res = 0;
        for (int i = left; i <= right; i++) {
            res += nums[i];
        }
        return res;
    }
}
```

这样，可以达到效果，但是效率很差，因为 `sumRange`​ 方法会被频繁调用，而它的时间复杂度是 `O(N)`​，其中 `N`​ 代表 `nums`​ 数组的长度。  
这道题的最优解法是使用前缀和技巧，将 `sumRange`​ 函数的时间复杂度降为 `O(1)`​，说白了就是不要在 `sumRange`​ 里面用 for 循环，咋整？  
直接看代码实现：

```java
class NumArray {
    // 前缀和数组
    private int[] preSum;

    /* 输入一个数组，构造前缀和 */
    public NumArray(int[] nums) {
        // preSum[0] = 0，便于计算累加和
        preSum = new int[nums.length + 1];
        // 计算 nums 的累加和
        for (int i = 1; i < preSum.length; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
    }
  
    /* 查询闭区间 [left, right] 的累加和 */
    public int sumRange(int left, int right) {
        return preSum[right + 1] - preSum[left];
    }
}
```

核心思路是我们 new 一个新的数组 `preSum`​​ 出来，`preSum[i]`​​ 记录 `nums[0..i-1]`​​ 的累加和，看图 10 = 3 + 5 + 2：  
​![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059889490-7b4781a4-94d9-4a26-91b6-dd71a658ba5b-20240318155015-8cxuekx.png)  
看这个 preSum 数组，如果我想求索引区间 [1, 4] 内的所有元素之和，就可以通过 preSum[5] - preSum[1] 得出。  
这样，sumRange 函数仅仅需要做一次减法运算，避免了每次进行 for 循环调用，最坏时间复杂度为常数 O(1)。

#### 304.「 [二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)」

> 给定一个二维矩阵 matrix，以下类型的多个请求：
>
> - 计算其子矩形范围内元素的总和，该子矩阵的 **左上角** 为 (row1, col1) ，**右下角** 为 (row2, col2) 。
>
> 实现 NumMatrix 类：
>
> - NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化
> - int sumRegion(int row1, int col1, int row2, int col2) 返回 **左上角**(row1, col1) 、**右下角**(row2, col2) 所描述的子矩阵的元素 **总和** 。
>
> ![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675083454015-cff9b1d6-6f17-4239-a5fb-1d12288064fc-20240318155015-tqz3p05.png)**输入:**   
> ["NumMatrix","sumRegion","sumRegion","sumRegion"]  
> [[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]  
> **输出:**   
> [null, 8, 11, 12]  
> **解释:**   
> NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);  
> numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)  
> numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)  
> numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)

按照题目要求，矩阵左上角为坐标原点 (0, 0)，那么 sumRegion([2,1,4,3]) 就是图中红色的子矩阵，你需要返回该子矩阵的元素和 8。  
当然，你可以用一个嵌套 for 循环去遍历这个矩阵，但这样的话 sumRegion 函数的时间复杂度就高了，你算法的格局就低了。  
注意任意子矩阵的元素和可以转化成它周边几个大矩阵的元素和的运算：  
​![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059889862-ac87ed03-a12e-4c06-be6f-22a3373e3815-20240318155015-e29ytmj.png)  
而这四个大矩阵有一个共同的特点，就是左上角都是 (0, 0) 原点。  
那么做这道题更好的思路和一维数组中的前缀和是非常类似的，我们可以维护一个二维 preSum 数组，专门记录以原点为顶点的矩阵的元素之和，就可以用几次加减运算算出任何一个子矩阵的元素和：

```java
class NumMatrix {
    private final int[][] preSum;

    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        preSum = new int[m + 1][n + 1]; // 计算原点(0,0)到所有位置(i-1,j-1)的元素和
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) { //（i,j）位置的前置和等于上一行的前缀和+前一列的前缀和+当前位置的元素-左上角位置的前缀和，因为加重复了
                //其实也可以简单的理解为和下面方法中求[row1,col1,row2,col2]的前缀和一样，通过相邻的几个矩阵相加减来求
                preSum[i][j] = preSum[i - 1][j] + preSum[i][j - 1] - preSum[i - 1][j - 1] + matrix[i - 1][j - 1];
            }
        }
    }

    public int sumRegion(int x1, int y1, int x2, int y2) { // 因为我们的presum前缀和数组整体右移和下移了一位，所以presum[i][j]其实求的前置和不包括(i,j)的
        return preSum[x2 + 1][y2 + 1] - preSum[x1][y2 + 1] - preSum[x2 + 1][y1] + preSum[x1][y1];
    }
}
```

这样，sumRegion 函数的时间复杂度也用前缀和技巧优化到了 O(1)，这是典型的「空间换时间」思路。

#### 528.「 [按权重随机选择](https://leetcode.cn/problems/random-pick-with-weight/)」

> 给你一个 下标从 0 开始 的正整数数组 w ，其中 w[i] 代表第 i 个下标的权重。  
> 请你实现一个函数 pickIndex ，它可以 随机地 从范围 [0, w.length - 1] 内（含 0 和 w.length - 1）选出并返回一个下标。选取下标 i 的 概率 为 w[i] / sum(w) 。
>
> - 例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。  
    >   输入：  
    >   ["Solution","pickIndex"]  
    >   [[[1]],[]]  
    >   输出：  
    >   [null,0]  
    >   解释：  
    >   Solution solution = new Solution([1]);  
    >   solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。

假设给你输入的权重数组是 w = [1,3,2,1]，我们想让概率符合权重，那么可以抽象一下，根据权重画出这么一条彩色的线段：  
​![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059900330-a63dade7-da4a-440c-80b0-4d419962ef94-20240318155015-blff1v7.jpeg)  
如果我在线段上面随机丢一个石子，石子落在哪个颜色上，我就选择该颜色对应的权重索引，那么每个索引被选中的概率是不是就是和权重相关联了？  
所以，你再仔细看看这条彩色的线段像什么？这不就是 [前缀和数组](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-48c1d/xiao-er-me-f69af/) 嘛：  
​![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059900566-14567d39-3c57-4ec0-9f26-a3bd3d86c128-20240318155015-c5zwiat.jpeg)  
那么接下来，如何模拟在线段上扔石子？  
当然是随机数，比如上述前缀和数组 preSum，取值范围是 [1, 7]，那么我生成一个在这个区间的随机数 target = 5，就好像在这条线段中随机扔了一颗石子：  
​![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059901475-7d12126a-9ca0-49f9-9b2c-8d29881c397d-20240318155015-oykim07.jpeg)  
还有个问题，preSum 中并没有 5 这个元素，我们应该选择比 5 大的最小元素，也就是 6，即 preSum 数组的索引 3：  
​![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059901567-2ea0f376-9ffe-49e6-9dbf-2adb82808d49-20240318155015-dgyym4o.jpeg)**如何快速寻找数组中大于等于目标值的最小元素？**  ******[二分搜索算法](https://labuladong.github.io/algo/2/20/29/)****** **就是我们想要的**。  
到这里，这道题的核心思路就说完了，主要分几步：  
1、根据权重数组 `w`​​ 生成前缀和数组 `preSum`​​。  
2、生成一个取值在 `preSum`​​ 之内的随机数，用二分搜索算法寻找大于等于这个随机数的最小元素索引。  
​![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059902870-a0c72773-b524-495d-8c37-601bbe60ae0e-20240318155015-4au1sfd.jpeg)  
下面来抠细节，继续前面的例子：  
​![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059903039-71de918e-94c9-4b88-87a0-91bfce83a6da-20240318155015-qhxar7o.jpeg)  
就比如这个 preSum 数组，你觉得随机数 target 应该在什么范围取值？闭区间 [0, 7] 还是左闭右开 [0, 7)？  
都不是，应该在闭区间 [1, 7] 中选择，**因为前缀和数组中 0 本质上是个占位符**，仔细体会一下：  
​![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059903161-2bc3f16f-989c-4592-b4cb-5eac446299c7-20240318155016-jvybvxr.jpeg)  
所以要这样写代码：

```java
int n = preSum.length;
// target 取值范围是闭区间 [1, preSum[n - 1]]
int target = rand.nextInt(preSum[n - 1]) + 1;
```

接下来，在 `preSum`​ 中寻找大于等于 `target`​ 的最小元素索引，应该用什么品种的二分搜索？搜索左侧边界的还是搜索右侧边界的？

实际上应该使用搜索左侧边界的二分搜索。

**当目标元素 target 不存在数组 nums 中时，搜索左侧边界的二分搜索的返回值可以做以下几种解读**：

1、返回的这个值是 nums 中大于等于 target 的最小元素索引。

2、返回的这个值是 target 应该插入在 nums 中的索引位置。

3、返回的这个值是 nums 中小于 target 的元素个数。

比如在有序数组 nums = [2,3,5,7] 中搜索 target = 4，搜索左边界的二分算法会返回 2，你带入上面的说法，都是对的。

所以以上三种解读都是等价的。

综上，我们可以写出最终解法代码：

```java
class Solution {

    private final int[] preSum;

    private final Random random;

    public Solution(int[] w) {
        preSum = new int[w.length + 1]; // 构建前缀和数组，偏移一位留给 preSum[0]
        for (int i = 1; i <= w.length; i++) {
            preSum[i] = preSum[i - 1] + w[i - 1]; // preSum[i] = sum(w[0..i-1])
        }
        random = new Random();
    }

    public int pickIndex() {
        // Java 的 nextInt(n) 方法在 [0, n) 中生成一个随机整数
        // 再加一就是在闭区间 [1, preSum[n - 1]] 中随机选择一个数字
        int target = random.nextInt(preSum[preSum.length - 1]) + 1;
        return leftBound(preSum, target) - 1; // 别忘了前缀和数组 preSum 和原始数组 w 有一位索引偏移
    }

    private int leftBound(int[] nums, int target) {
        if(nums.length == 0) return -1;
        int l = 0, r = nums.length - 1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] > target) {
                r = mid - 1;
            } else if (nums[mid] < target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return l;
    }
}
```

#### **LCR 191.「**​[按规则计算统计结果](https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/)」

> 为了深入了解这些生物群体的生态特征，你们进行了大量的实地观察和数据采集。数组 `arrayA`​ 记录了各个生物群体数量数据，其中 `arrayA[i]`​ 表示第 `i`​ 个生物群体的数量。请返回一个数组 `arrayB`​，该数组为基于数组 `arrayA`​ 中的数据计算得出的结果，其中 `arrayB[i]`​ 表示将第 `i`​ 个生物群体的数量从总体中排除后的其他数量的乘积。
>
> **示例:**
>
> 输入: [1,2,3,4,5]  
> 输出: [120,60,40,30,24]

```java
class Solution {
    public int[] constructArr(int[] a) {
        int n = a.length;
        if (n == 0) return new int[]{};
        int[] preSuffix = new int[n]; // preSuffix[i] ->  0..i 前缀乘积
        int[] postSuffix = new int[n]; // preSuffix[i] ->  i..n-1 后缀乘积
        preSuffix[0] = a[0];
        for (int i = 1; i < n; i++) {
            preSuffix[i] = preSuffix[i - 1] * a[i];
        }
        postSuffix[n - 1] = a[n - 1];
        for (int i = n - 2; i >= 0; i--) {
            postSuffix[i] = postSuffix[i + 1] * a[i];
        }
        int[] res = new int[n];
        res[0] = postSuffix[1];
        res[n - 1] = preSuffix[n - 2];
        for (int i = 1; i < n - 1; i++) {
            res[i] = preSuffix[i - 1] * postSuffix[i + 1];
        }
        return res;
    }
}
```

## 差分数组

### 提纲

**差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减**。

比如说，我给你输入一个数组 nums，然后又要求给区间 nums[2..6] 全部加 1，再给 nums[3..9] 全部减 3，再给 nums[0..4] 全部加 2，再给…

一通操作猛如虎，然后问你，最后 nums 数组的值是什么？

常规的思路很容易，你让我给区间 nums[i..j] 加上 val，那我就一个 for 循环给它们都加上呗，还能咋样？这种思路的时间复杂度是 O(N)，由于这个场景下对 nums 的修改非常频繁，所以效率会很低下。

这里就需要差分数组的技巧，类似前缀和技巧构造的 prefix 数组，我们先对 nums 数组构造一个 diff 差分数组，**diff[i] 就是 nums[i] 和 nums[i-1] 之差**：

```java
int[] diff = new int[nums.length];
// 构造差分数组
diff[0] = nums[0];
for (int i = 1; i < nums.length; i++) {
    diff[i] = nums[i] - nums[i - 1];
}
```

![1675059891329-445c7d64-7cc7-427f-9629-ae238dc611c0](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059891329-445c7d64-7cc7-427f-9629-ae238dc611c0-20240319185932-yfdl078.png)  
通过这个 diff 差分数组是可以反推出原始数组 nums 的，代码逻辑如下：

```java
int[] res = new int[diff.length];
// 根据差分数组构造结果数组
res[0] = diff[0];
for (int i = 1; i < diff.length; i++) {
    res[i] = res[i - 1] + diff[i];
}
```

**这样构造差分数组 diff，就可以快速进行区间增减的操作**，如果你想对区间 nums[i..j] 的元素全部加 3，那么只需要让 diff[i] += 3，然后再让 diff[j+1] -= 3 即可：  
![1675059892860-95279b5a-e678-49e8-b874-c4ce11c248fb](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059892860-95279b5a-e678-49e8-b874-c4ce11c248fb-20240319185932-26cgxuw.png)**原理很简单，回想 diff 数组反推 nums 数组的过程，diff[i] += 3 意味着给 nums[i..] 所有的元素都加了 3，然后 diff[j+1] -= 3 又意味着对于 nums[j+1..] 所有元素再减 3，那综合起来，是不是就是对 nums[i..j] 中的所有元素都加 3 了**？

只要花费 O(1) 的时间修改 diff 数组，就相当于给 nums 的整个区间做了修改。多次修改 diff，然后通过 diff 数组反推，即可得到 nums 修改后的结果。

现在我们把差分数组抽象成一个类，包含 increment 方法和 result 方法：

```java
// 差分数组工具类
class Difference {
    // 差分数组
    private int[] diff;
  
    /* 输入一个初始数组，区间操作将在这个数组上进行 */
    public Difference(int[] nums) {
        assert nums.length > 0;
        diff = new int[nums.length];
        // 根据初始数组构造差分数组
        diff[0] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            diff[i] = nums[i] - nums[i - 1];
        }
    }

    /* 给闭区间 [i, j] 增加 val（可以是负数）*/
    public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }

    /* 返回结果数组 */
    public int[] result() {
        int[] res = new int[diff.length];
        // 根据差分数组构造结果数组
        res[0] = diff[0];
        for (int i = 1; i < diff.length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }
}
```

这里注意一下 increment 方法中的 if 语句：

```java
public void increment(int i, int j, int val) {
    diff[i] += val;
    if (j + 1 < diff.length) {
        diff[j + 1] -= val;
    }
}
```

当 j+1 >= diff.length 时，说明是对 nums[i] 及以后的整个数组都进行修改，那么就不需要再给 diff 数组减 val 了。

### 练习题

#### 1109.「 [航班预订统计](https://leetcode.cn/problems/corporate-flight-bookings/)」

> 这里有 `n`​ 个航班，它们分别从 `1`​ 到 `n`​ 进行编号。
>
> 有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [first(i), last(i), seats(i)] 意味着在从 first(i) 到 last(i) （**包含**first(i) 和 last(i) ）的 **每个航班** 上预订了 seats(i) 个座位。
>
> 请你返回一个长度为 `n`​ 的数组 `answer`​，里面的元素是每个航班预定的座位总数。
>
> **输入：** bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5  
> **输出：** [10,55,45,25,25]
>
> **解释：**
>
> 航班编号          1    2   3    4   5  
> 预订记录 1 ：   10  10  
> 预订记录 2 ：       20  20  
> 预订记录 3 ：       25  25  25  25  
> 总座位数：      10  55  45  25  25  
> 因此，answer = [10,55,45,25,25]

这个题目就在那绕弯弯，其实它就是个差分数组的题，我给你翻译一下：  
给你输入一个长度为 `n`​ 的数组 `nums`​，其中所有元素都是 0。再给你输入一个 `bookings`​，里面是若干三元组 `(i, j,k)`​，每个三元组的含义就是要求你给 `nums`​ 数组的闭区间 `[i-1,j-1]`​ 中所有元素都加上 `k`​。请你返回最后的 `nums`​ 数组是多少？

> PS：因为题目说的 `n`​ 是从 1 开始计数的，而数组索引从 0 开始，所以对于输入的三元组 `(i, j,k)`​，数组区间应该对应 `[i-1,j-1]`​。

这么一看，不就是一道标准的差分数组题嘛？

```java
int[] corpFlightBookings(int[][] bookings, int n) {
    // nums 初始化为全 0
    int[] nums = new int[n];
    // 构造差分解法
    Difference df = new Difference(nums);

    for (int[] booking : bookings) {
        // 注意转成数组索引要减一哦
        int i = booking[0] - 1;
        int j = booking[1] - 1;
        int val = booking[2];
        // 对区间 nums[i..j] 增加 val
        df.increment(i, j, val);
    }
    // 返回最终的结果数组
    return df.result();
}
```

这道题就解决了。

```java
public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] diff = new int[n];
        for(int[] booking : bookings) {
            int i = booking[0] - 1;
            int j = booking[1] - 1;
            int val = booking[2];
            diff[i] += val;
            if(j + 1 < n) {
                diff[j + 1] -= val;
            }
        }

        int[] res = new int[n];
        res[0] = diff[0];
        for(int i = 1; i < n; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }
```

#### 1094.「 [拼车](https://leetcode.cn/problems/car-pooling/)」

> 车上最初有 `capacity`​ 个空座位。车 **只能** 向一个方向行驶（也就是说，**不允许掉头或改变方向**）
>
> 给定整数 `capacity`​ 和一个数组 `trips`​ ,  `trip[i] = [numPassenger`​<sub>​`si`​</sub>​`, from`​<sub>​`i`​</sub>​`, to`​<sub>​`i`​</sub>​ 表示第 `i`​ 次旅行有 `numPassenger`​<sub>​`i`​</sub>​ 乘客，接他们和放他们的位置分别是 `from`​<sub>​`i`​</sub>​ 和 ` to`​<sub>​`i`​</sub>​ 。这些位置是从汽车的初始位置向东的公里数。
>
> **输入：** trips = [[2,1,5],[3,3,7]], capacity = 4  
> **输出：** false

比如输入：

```shell
trips = [[2,1,5],[3,3,7]], capacity = 4
```

这就不能一次运完，因为 `trips[1]`​ 最多只能上 2 人，否则车就会超载。

相信你已经能够联想到差分数组技巧了：`trips[i]`​ 代表着一组区间操作，旅客的上车和下车就相当于数组的区间加减；只要结果数组中的元素都小于 **​`capacity`​**​，就说明可以不超载运输所有旅客。

但问题是，差分数组的长度（车站的个数）应该是多少呢？题目没有直接给，但给出了数据取值范围：

```java
0 <= trips[i][1] < trips[i][2] <= 1000
```

车站编号从 0 开始，最多到 1000，也就是最多有 1001 个车站，那么我们的差分数组长度可以直接设置为 1001，这样索引刚好能够涵盖所有车站的编号：

```java
class Solution {
    public Boolean carPooling(int[][] trips, int capacity) {
        Difference diff = new Difference(new int[1001]);
        for (int[] trip : trips) {
            int val = trip[0];
            // 乘客数量
            int i = trip[1];
            // 第 trip[1] 站乘客上车
            int j = trip[2] - 1;
            // 第 trip[2] 站乘客已经下车，即乘客在车上的区间是 [trip[1], trip[2] - 1]
            diff.add(i, j, val);
        }
        return diff.check(capacity);
    }
    class Difference {
        private final int[] diff;
        public Difference(int[] nums) {
            this.diff = new int[nums.length];
            diff[0] = nums[0];
            for (int i = 1; i < nums.length; i++) {
                diff[i] = nums[i] - nums[i - 1];
            }
        }
        public void add(int i, int j, int val) {
            diff[i] += val;
            if (j + 1 < diff.length) {
                diff[j + 1] -= val;
            }
        }
        public Boolean check(int capacity) {
            int pre = diff[0];
            if (pre > capacity) return false;
            for (int i = 1; i < diff.length; i++) {
                pre += diff[i];
                if (pre > capacity) return false;
            }
            return true;
        }
    }
}
```

至此，这道题也解决了。

```java
public boolean carPooling(int[][] trips, int capacity) {
        int[] diff = new int[1001];
        for(int[] trip : trips) {
            int val = trip[0];
            int i = trip[1];
            int j = trip[2] - 1;
            diff[i] += val;
            if(j + 1 < diff.length) {
                diff[j + 1] -= val;
            }
        }
        int max = diff[0];
        if(max > capacity) return false;
        for(int i = 1; i < diff.length; i++) {
            max += diff[i];
            if(max > capacity) return false;
        }
        return true;
    }
```

## 单调栈

### 模板

现在给你出这么一道题：输入一个数组 `nums`​，请你返回一个等长的结果数组，结果数组中对应索引存储着下一个更大元素，如果没有更大的元素，就存 -1。函数签名如下：

```java
int[] nextGreaterElement(int[] nums);
```

比如说，输入一个数组 `nums = [2,1,2,4,3]`​，你返回数组 `[4,2,4,-1,-1]`​。因为第一个 2 后面比 2 大的数是 4; 1 后面比 1 大的数是 2；第二个 2 后面比 2 大的数是 4; 4 后面没有比 4 大的数，填 -1；3 后面没有比 3 大的数，填 -1。

这道题的暴力解法很好想到，就是对每个元素后面都进行扫描，找到第一个更大的元素就行了。但是暴力解法的时间复杂度是 `O(n^2)`​。

这个问题可以这样抽象思考：把数组的元素想象成并列站立的人，元素大小想象成人的身高。这些人面对你站成一列，如何求元素「2」的下一个更大元素呢？很简单，如果能够看到元素「2」，那么他后面可见的第一个人就是「2」的下一个更大元素，因为比「2」小的元素身高不够，都被「2」挡住了，第一个露出来的就是答案。  
​![1675059903229-fb23de19-5375-4bef-956d-aef044858551](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059903229-fb23de19-5375-4bef-956d-aef044858551-20240320144925-ehkh5b5.jpeg)  
这个情景很好理解吧？带着这个抽象的情景，先来看下代码。

```java
public int[] nextGreaterElement(int[] nums) {
    int n = nums.length;
    // 存放答案的数组
    int[] res = new int[n];
    Stack<Integer> s = new Stack<>(); 
    // 倒着往栈里放
    for (int i = n - 1; i >= 0; i--) {
        // 判定个子高矮
        while (!s.isEmpty() && s.peek() <= nums[i]) {
            // 矮个起开，反正也被挡着了。。。
            s.pop();
        }
        // nums[i] 身后的更大元素
        res[i] = s.isEmpty() ? -1 : s.peek();
        s.push(nums[i]);
    }
    return res;
}
```

这就是单调队列解决问题的模板。for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个「个子高」元素之间的元素排除，因为他们的存在没有意义，前面挡着个「更高」的元素，所以他们不可能被作为后续进来的元素的下一个更大元素了。

这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 O(n^2)，但是实际上这个算法的复杂度只有 O(n)。

分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度。

### 练习题

#### 496.「 [下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)」

> `nums1`​ 中数字 `x`​ 的 **下一个更大元素** 是指 `x`​ 在 `nums2`​ 中对应位置 **右侧** 的 **第一个** 比 `x`​  大的元素。
>
> 给你两个 **没有重复元素** 的数组 `nums1`​ 和 `nums2`​ ，下标从 **0** 开始计数，其中`nums1`​ 是 `nums2`​ 的子集。
>
> 对于每个 `0 <= i < nums1.length`​ ，找出满足 `nums1[i] == nums2[j]`​ 的下标 `j`​ ，并且在 `nums2`​ 确定 `nums2[j]`​ 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1`​ 。
>
> 返回一个长度为 `nums1.length`​ 的数组 `ans`​ 作为答案，满足 `ans[i]`​ 是如上所述的 **下一个更大元素** 。
>
> **示例 1：**   
> 输入：nums1 = [4,1,2], nums2 = [1,3,4,2].  
> 输出：[-1,3,-1]  
> 解释：nums1 中每个值的下一个更大元素如下所述：
>
> - 4 ，用加粗斜体标识，nums2 = [1,3,**4**,2]。不存在下一个更大元素，所以答案是 -1 。
> - 1 ，用加粗斜体标识，nums2 = [**1**,3,4,2]。下一个更大元素是 3 。
> - 2 ，用加粗斜体标识，nums2 = [1,3,4,**2**]。不存在下一个更大元素，所以答案是 -1 。

这道题给你输入两个数组 `nums1`​ 和 `nums2`​，让你求 `nums1`​ 中的元素在 `nums2`​ 中的下一个更大元素，函数签名如下：

```java
int[] nextGreaterElement(int[] nums1, int[] nums2)
```

其实和把我们刚才的代码改一改就可以解决这道题了，因为题目说 `nums1`​ 是 `nums2`​ 的子集，那么我们先把 `nums2`​ 中每个元素的下一个更大元素算出来存到一个映射里，然后再让 `nums1`​ 中的元素去查表即可：

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Map<Integer, Integer> num2Greater = nextGreaterElement(nums2);
        int[] res = new int[nums1.length];
        for (int i = 0; i < nums1.length; i++) {
            res[i] = num2Greater.get(nums1[i]);
        }
        return res;
    }

    private Map<Integer, Integer> nextGreaterElement(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        Stack<Integer> stack = new Stack<>();
        for (int i = nums.length - 1; i >= 0; i--) { // 从后往前遍历
            while (!stack.isEmpty() && stack.peek() <= nums[i]) { // 去掉小的元素
                stack.pop();
            }
            map.put(nums[i], stack.isEmpty() ? -1 : stack.peek());
            stack.push(nums[i]);
        }
        return map;
    }
}
```

#### 739.「 [每日温度](https://leetcode.cn/problems/daily-temperatures/)」

> 给定一个整数数组 `temperatures`​ ，表示每天的温度，返回一个数组 `answer`​ ，其中 `answer[i]`​ 是指对于第 `i`​ 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0`​ 来代替。
>
> **示例 1:**   
> 输入: temperatures = [73,74,75,71,69,72,76,73]  
> 输出: [1,1,4,2,1,1,0,0]

给你一个数组 `temperatures`​，这个数组存放的是近几天的天气气温，你返回一个等长的数组，计算：对于每一天，你还要至少等多少天才能等到一个更暖和的气温；如果等不到那一天，填 0。函数签名如下：

```java
int[] dailyTemperatures(int[] temperatures);
```

比如说给你输入 `temperatures = [73,74,75,71,69,76]`​，你返回 `[1,1,3,2,1,0]`​。因为第一天 73 华氏度，第二天 74 华氏度，比 73 大，所以对于第一天，只要等一天就能等到一个更暖和的气温，后面的同理。

这个问题本质上也是找下一个更大元素，只不过现在不是问你下一个更大元素的值是多少，而是问你当前元素距离下一个更大元素的索引距离而已。

相同的思路，直接调用单调栈的算法模板，稍作改动就可以，直接上代码吧：

```java
public int[] dailyTemperatures(int[] temperatures) {
    int n = temperatures.length;
    int[] res = new int[n];
    Stack<Integer> stack = new Stack<>(); // 这里放元素索引，而不是元素
    for (int i = n - 1; i >= 0; i--) {
        while (!stack.isEmpty() && temperatures[stack.peek()] <= temperatures[i]) {
            stack.pop();
        }
        res[i] = stack.isEmpty() ? 0 : stack.peek() - i; // 得到索引间距
        stack.push(i); // 将索引入栈，而不是元素
    }
    return res;
}
```

#### 503.「 [下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)」

> 给定一个循环数组 `nums`​ （ `nums[nums.length - 1]`​ 的下一个元素是 `nums[0]`​ ），返回 *​`nums`​*​ *中每个元素的* ***下一个更大元素*** 。
>
> 数字 `x`​ 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1`​ 。
>
> **示例 1:**   
> 输入: nums = [1,2,1]  
> 输出: [2,-1,2]  
> 解释: 第一个 1 的下一个更大的数是 2；  
> 数字 2 找不到下一个更大的数；
> 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。

同样是求下一个更大元素，现在假设给你的数组是个环形的，如何处理？输入一个「环形数组」，请你计算其中每个元素的下一个更大元素。

比如输入 [2,1,2,4,3]，你应该返回 [4,2,4,-1,4]，因为拥有了环形属性，**最后一个元素 3 绕了一圈后找到了比自己大的元素 4**。  
这个问题肯定还是要用单调栈的解题模板，但难点在于，比如输入是 [2,1,2,4,3]，对于最后一个元素 3，如何找到元素 4 作为下一个更大元素。

**对于这种需求，常用套路就是将数组长度翻倍**：  
​![1675059903153-b9d419f2-909d-44dc-b4fb-f75e2d0f1028](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059903153-b9d419f2-909d-44dc-b4fb-f75e2d0f1028-20240320144925-qgkyhqu.jpeg)  
这样，元素 3 就可以找到元素 4 作为下一个更大元素了，而且其他的元素都可以被正确地计算。  
有了思路，最简单的实现方式当然可以把这个双倍长度的数组构造出来，然后套用算法模板。但是，**我们可以不用构造新数组，而是利用循环数组的技巧来模拟数组长度翻倍的效果**。直接看代码吧：

```java
int[] nextGreaterElements(int[] nums) {
    int n = nums.length;
    int[] res = new int[n];
    Stack<Integer> s = new Stack<>();
    // 数组长度加倍模拟环形数组
    for (int i = 2 * n - 1; i >= 0; i--) {
        // 索引 i 要求模，其他的和模板一样
        while (!s.isEmpty() && s.peek() <= nums[i % n]) {
            s.pop();
        }
        res[i % n] = s.isEmpty() ? -1 : s.peek();
        s.push(nums[i % n]);
    }
    return res;
}
```

这样，就可以巧妙解决环形数组的问题，时间复杂度 O(N)。

#### **316.「**​[去除重复c字母](https://leetcode.cn/problems/remove-duplicate-letters/)」

> 给你一个字符串 `s`​ ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。
>
> **示例 1：**   
> 输入：s = "bcabc"  
> 输出："abc"

题目的要求总结出来有三点：

要求一、**要去重**。

要求二、去重字符串中的字符顺序**不能打乱 s 中字符出现的相对顺序**。

要求三、在所有符合上一条要求的去重字符串中，**字典序最小**的作为最终结果。

上述三条要求中，要求三可能有点难理解，举个例子。

比如说输入字符串 s = "babc"，去重且符合相对位置的字符串有两个，分别是 "bac" 和 "abc"，但是我们的算法得返回 "abc"，因为它的字典序更小。

按理说，如果我们想要有序的结果，那就得对原字符串排序对吧，但是排序后就不能保证符合 s 中字符出现顺序了，这似乎是矛盾的。

其实这里会借鉴前文 [单调栈解题框架](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_627cd21ce4b01a4851fe126d/1) 中讲到的「单调栈」的思路，没看过也无妨，等会你就明白了。

**我们先暂时忽略要求三，用「栈」来实现一下要求一和要求二**，至于为什么用栈来实现，后面你就知道了：

```java
String removeDuplicateLetters(String s) {
    // 存放去重的结果
    Stack<Character> stk = new Stack<>();
    // 布尔数组初始值为 false，记录栈中是否存在某个字符
    // 输入字符均为 ASCII 字符，所以大小 256 够用了
    boolean[] inStack = new boolean[256];

    for (char c : s.toCharArray()) {
        // 如果字符 c 存在栈中，直接跳过
        if (inStack[c]) continue;
        // 若不存在，则插入栈顶并标记为存在
        stk.push(c);
        inStack[c] = true;
    }

    StringBuilder sb = new StringBuilder();
    while (!stk.empty()) {
        sb.append(stk.pop());
    }
    // 栈中元素插入顺序是反的，需要 reverse 一下
    return sb.reverse().toString();
}
```

这段代码的逻辑很简单吧，就是用布尔数组 inStack 记录栈中元素，达到去重的目的，**此时栈中的元素都是没有重复的**。

如果输入 s = "bcabc"，这个算法会返回 "bca"，已经符合要求一和要求二了，但是题目希望要的答案是 "abc" 对吧。

那我们想一想，如果想满足要求三，保证字典序，需要做些什么修改？

在向栈 stk 中插入字符 'a' 的这一刻，我们的算法需要知道，字符 'a' 的字典序和之前的两个字符 'b' 和 'c' 相比，谁大谁小？

**如果当前字符 'a' 比之前的字符字典序小，就有可能需要把前面的字符 pop 出栈，让 'a' 排在前面，对吧**？

那么，我们先改一版代码：

```java
String removeDuplicateLetters(String s) {
    Stack<Character> stk = new Stack<>();
    boolean[] inStack = new boolean[256];

    for (char c : s.toCharArray()) {
        if (inStack[c]) continue;

        // 插入之前，和之前的元素比较一下大小
        // 如果字典序比前面的小，pop 前面的元素
        while (!stk.isEmpty() && stk.peek() > c) {
            // 弹出栈顶元素，并把该元素标记为不在栈中
            inStack[stk.pop()] = false;
        }

        stk.push(c);
        inStack[c] = true;
    }

    StringBuilder sb = new StringBuilder();
    while (!stk.empty()) {
        sb.append(stk.pop());
    }
    return sb.reverse().toString();
}
```

这段代码也好理解，就是插入了一个 while 循环，连续 pop 出比当前字符小的栈顶字符，直到栈顶元素比当前元素的字典序还小为止。只是不是有点「单调栈」的意思了？

这样，对于输入 s = "bcabc"，我们可以得出正确结果 "abc" 了。

但是，如果我改一下输入，假设 s = "bcac"，按照刚才的算法逻辑，返回的结果是 "ac"，而正确答案应该是 "bac"，分析一下这是怎么回事？

很容易发现，因为 s 中只有唯一一个 'b'，即便字符 'a' 的字典序比字符 'b' 要小，字符 'b' 也不应该被 pop 出去。

那问题出在哪里？

**我们的算法在 stk.peek() &gt; c 时才会 pop 元素，其实这时候应该分两种情况**：

情况一、如果 stk.peek() 这个字符之后还会出现，那么可以把它 pop 出去，反正后面还有嘛，后面再 push 到栈里，刚好符合字典序的要求。

情况二、如果 stk.peek() 这个字符之后不会出现了，前面也说了栈中不会存在重复的元素，那么就不能把它 pop 出去，否则你就永远失去了这个字符。

回到 s = "bcac" 的例子，插入字符 'a' 的时候，发现前面的字符 'c' 的字典序比 'a' 大，且在 'a' 之后还存在字符 'c'，那么栈顶的这个 'c' 就会被 pop 掉。

while 循环继续判断，发现前面的字符 'b' 的字典序还是比 'a' 大，但是在 'a' 之后再没有字符 'b' 了，所以不应该把 'b' pop 出去。

**那么关键就在于，如何让算法知道字符 'a' 之后有几个 'b' 有几个 'c' 呢**？

也不难，只要再改一版代码：

```java
String removeDuplicateLetters(String s) {
    Stack<Character> stk = new Stack<>();

    // 维护一个计数器记录字符串中字符的数量
    // 因为输入为 ASCII 字符，大小 256 够用了
    int[] count = new int[256];
    for (int i = 0; i < s.length(); i++) {
        count[s.charAt(i)]++;
    }

    boolean[] inStack = new boolean[256];
    for (char c : s.toCharArray()) {
        // 每遍历过一个字符，都将对应的计数减一
        count[c]--;

        if (inStack[c]) continue;

        while (!stk.isEmpty() && stk.peek() > c) {
            // 若之后不存在栈顶元素了，则停止 pop
            if (count[stk.peek()] == 0) {
                break;
            }
            // 若之后还有，则可以 pop
            inStack[stk.pop()] = false;
        }
        stk.push(c);
        inStack[c] = true;
    }

    StringBuilder sb = new StringBuilder();
    while (!stk.empty()) {
        sb.append(stk.pop());
    }
    return sb.reverse().toString();
}
```

我们用了一个计数器 count，当字典序较小的字符试图「挤掉」栈顶元素的时候，在 count 中检查栈顶元素是否是唯一的，只有当后面还存在栈顶元素的时候才能挤掉，否则不能挤掉。

至此，这个算法就结束了，时间空间复杂度都是 O(N)。

**你还记得我们开头提到的三个要求吗？我们是怎么达成这三个要求的**？

要求一、通过 inStack 这个布尔数组做到栈 stk 中不存在重复元素。

要求二、我们顺序遍历字符串 s，通过「栈」这种顺序结构的 push/pop 操作记录结果字符串，保证了字符出现的顺序和 s 中出现的顺序一致。

这里也可以想到为什么要用「栈」这种数据结构，因为先进后出的结构允许我们立即操作刚插入的字符，如果用「队列」的话肯定是做不到的。

要求三、我们用类似单调栈的思路，配合计数器 count 不断 pop 掉不符合最小字典序的字符，保证了最终得到的结果字典序最小。

当然，由于栈的结构特点，我们最后需要把栈中元素取出后再反转一次才是最终结果。

## 单调队列

### 提纲

也许这种数据结构的名字你没听过，其实没啥难的，就是一个「队列」，只是使用了一点巧妙的方法，使得队列中的元素全都是单调递增（或递减）的。

为啥要发明「单调队列」这种结构呢，主要是为了解决下面这个场景：

**给你一个数组 window，已知其最值为 A，如果给 window 中添加一个数 B，那么比较一下 A 和 B 就可以立即算出新的最值；但如果要从 window 数组中减少一个数，就不能直接得到最值了，因为如果减少的这个数恰好是 A，就需要遍历 window 中的所有元素重新寻找新的最值**。

这个场景很常见，但不用单调队列似乎也可以，比如优先级队列也是一种特殊的队列，专门用来动态寻找最值的，我创建一个大（小）顶堆，不就可以很快拿到最大（小）值了吗？

如果单纯地维护最值的话，优先级队列很专业，队头元素就是最值。但优先级队列无法满足标准队列结构「先进先出」的**时间顺序**，因为优先级队列底层利用二叉堆对元素进行动态排序，元素的出队顺序是元素的大小顺序，和入队的先后顺序完全没有关系。

所以，现在需要一种新的队列结构，既能够维护队列元素「先进先出」的时间顺序，又能够正确维护队列中所有元素的最值，这就是「单调队列」结构。

「单调队列」这个数据结构主要用来辅助解决滑动窗口相关的问题，前文 [滑动窗口核心框架](https://labuladong.github.io/algo/di-ling-zh-bfe1b/wo-xie-le--f02cd/) 把滑动窗口算法作为双指针技巧的一部分进行了讲解，但有些稍微复杂的滑动窗口问题不能只靠两个指针来解决，需要上更先进的数据结构。

比方说，你注意看前文 [滑动窗口核心框架](https://labuladong.github.io/algo/di-ling-zh-bfe1b/wo-xie-le--f02cd/) 讲的几道题目，每当窗口扩大（right++）和窗口缩小（left++）时，你单凭移出和移入窗口的元素即可决定是否更新答案。

但就本文开头说的那个判断一个窗口中最值的例子，你就无法单凭移出窗口的那个元素更新窗口的最值，除非重新遍历所有元素，但这样的话时间复杂度就上来了，这是我们不希望看到的。

### 练习题

#### **LCR 183.「**​[望远镜中最高的海拔](https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)」

> 科技馆内有一台虚拟观景望远镜，它可以用来观测特定纬度地区的地形情况。该纬度的海拔数据记于数组 `heights`​ ，其中 `heights[i]`​ 表示对应位置的海拔高度。请找出并返回望远镜视野范围 `limit`​ 内，可以观测到的最高海拔值。
>
> **示例:**   
> 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3  
> 输出: [3,3,5,5,6,7]
> 解释:  
> ​![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680252289130-e5a15abb-b4be-4319-8312-9d245617320e-20240321201605-t373xmf.png)​

接下来，我们就借助单调队列结构，用 O(1) 时间算出每个滑动窗口中的最大值，使得整个算法在线性时间完成。  
先把这道「滑动窗口」问题的解答框架搭出来：

```java
int[] maxSlidingWindow(int[] nums, int k) {
    MonotonicQueue window = new MonotonicQueue();
    List<Integer> res = new ArrayList<>();
  
    for (int i = 0; i < nums.length; i++) {
        if (i < k - 1) {
            //先把窗口的前 k - 1 填满
            window.push(nums[i]);
        } else {
            // 窗口开始向前滑动
            // 移入新元素
            window.push(nums[i]);
            // 将当前窗口中的最大元素记入结果
            res.add(window.max());
            // 移出最后的元素
            window.pop(nums[i - k + 1]);
        }
    }
    // 将 List 类型转化成 int[] 数组作为返回值
    int[] arr = new int[res.size()];
    for (int i = 0; i < res.size(); i++) {
        arr[i] = res.get(i);
    }
    return arr;
}
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681124787679-716f6e82-ca5b-4aba-b767-ce7321fd6590-20240321201606-zxk562f.png)  
观察滑动窗口的过程就能发现，实现「单调队列」必须使用一种数据结构支持在头部和尾部进行插入和删除，很明显双链表是满足这个条件的。

「单调队列」的核心思路和「单调栈」类似，push 方法依然在队尾添加元素，但是要把前面比自己小的元素都删掉：

```java
class MonotonicQueue {
// 双链表，支持头部和尾部增删元素
// 维护其中的元素自尾部到头部单调递增
private LinkedList<Integer> maxq = new LinkedList<>();

// 在尾部添加一个元素 n，维护 maxq 的单调性质
public void push(int n) {
    // 将前面小于自己的元素都删除
    while (!maxq.isEmpty() && maxq.getLast() < n) {
        maxq.pollLast();
    }
    maxq.addLast(n);
}
```

你可以想象，加入数字的大小代表人的体重，把前面体重不足的都压扁了，直到遇到更大的量级才停住。  
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681124831976-40ffff92-6c82-4dab-a5ac-8ec069e01307-20240321201606-x20u7zd.png)  
如果每个元素被加入时都这样操作，最终单调队列中的元素大小就会保持一个**单调递减**的顺序，因此我们的 max 方法可以可以这样写：

```java
class MonotonicQueue {
    // 为了节约篇幅，省略上文给出的代码部分...

    public int max() {
        // 队头的元素肯定是最大的
        return maxq.getFirst();
    }
}
```

pop 方法在队头删除元素 n，也很好写：

```java
class MonotonicQueue {
    // 为了节约篇幅，省略上文给出的代码部分...

    public void pop(int n) {
        if (n == maxq.getFirst()) {
            maxq.pollFirst();
        }
    }
}
```

之所以要判断 data.getFirst() == n，是因为我们想删除的队头元素 n 可能已经被「压扁」了，可能已经不存在了，所以这时候就不用删除了：  
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681124902655-00edd7ac-ca2e-4e3a-9d41-800d62263500-20240321201606-m7wz1v4.png)  
至此，单调队列设计完毕，看下完整的解题代码：

```java
/* 单调队列的实现 */
class MonotonicQueue {
    LinkedList<Integer> maxq = new LinkedList<>();
    public void push(int n) {
        // 将小于 n 的元素全部删除
        while (!maxq.isEmpty() && maxq.getLast() < n) {
            maxq.pollLast();
        }
        // 然后将 n 加入尾部
        maxq.addLast(n);
    }
  
    public int max() {
        return maxq.getFirst();
    }
  
    public void pop(int n) {
        if (n == maxq.getFirst()) {
            maxq.pollFirst();
        }
    }
}

/* 解题函数的实现 */
int[] maxSlidingWindow(int[] nums, int k) {
    MonotonicQueue window = new MonotonicQueue();
    List<Integer> res = new ArrayList<>();
  
    for (int i = 0; i < nums.length; i++) {
        if (i < k - 1) {
            //先填满窗口的前 k - 1
            window.push(nums[i]);
        } else {
            // 窗口向前滑动，加入新数字
            window.push(nums[i]);
            // 记录当前窗口的最大值
            res.add(window.max());
            // 移出旧数字
            window.pop(nums[i - k + 1]);
        }
    }
    // 需要转成 int[] 数组再返回
    int[] arr = new int[res.size()];
    for (int i = 0; i < res.size(); i++) {
        arr[i] = res.get(i);
    }
    return arr;
}
```

单独看 push 操作的复杂度确实不是 O(1)，但是算法整体的复杂度依然是 O(N) 线性时间。要这样想，nums 中的每个元素最多被 push 和 pop 一次，没有任何多余操作，所以整体的复杂度还是 O(N)。空间复杂度就很简单了，就是窗口的大小 O(k)。

#### **LCR 184.「**​[设计自助结算系统](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/description/?orderBy=hot)」

> 请设计一个自助结账系统，该系统需要通过一个队列来模拟顾客通过购物车的结算过程，需要实现的功能有：
>
> - `get_max()`​：获取结算商品中的最高价格，如果队列为空，则返回 -1
> - `add(value)`​：将价格为 `value`​ 的商品加入待结算商品队列的尾部
> - `remove()`​：移除第一个待结算的商品价格，如果队列为空，则返回 -1
>
> 注意，为保证该系统运转高效性，以上函数的均摊时间复杂度均为 O(1)
>
> **示例 1：**   
> 输入:  ["MaxQueue","push_back","push_back","max_value","pop_front","max_value"] [[],[1],[2],[],[],[]]  
> 输出: [null,null,null,2,1,2]

我们知道对于一个普通队列，push_back 和 pop_front 的时间复杂度都是 O(1)\mathcal{O}(1)O(1)，因此我们直接使用队列的相关操作就可以实现这两个函数。

对于 max_value 函数，我们通常会这样思考，即每次入队操作时都更新最大值：  
![1.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681125348088-2a000388-d2ab-4257-a72f-55c7300b0dd3-20240321201613-d0tdg75.gif)  
但是当出队时，这个方法会造成信息丢失，**即当最大值出队后，我们无法知道队列里的下一个最大值。** ![1.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681125426109-af782941-fb34-4ec9-9a44-3ddf1565f296-20240321201617-28cg58f.gif)  
解题思路

为了解决上述问题，我们只需记住当前最大值出队后，队列里的下一个最大值即可。

具体方法是使用一个双端队列 dequedequedeque，在每次入队时，如果 dequedequedeque 队尾元素小于即将入队的元素 valuevaluevalue，则将小于 valuevaluevalue 的元素全部出队后，再将 valuevaluevalue 入队；否则直接入队。  
​![1.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681125550989-ce660e33-2068-4a56-87e8-c8244ffc9b21-20240321201624-wv0zgjv.gif)  
这时，辅助队列 dequedeque_deque_ 队首元素就是队列的最大值。

```java
class MaxQueue {

    private final LinkedList<Integer> queue;
    private final LinkedList<Integer> maxQueue; // 单调队列

    public MaxQueue() {
        queue = new LinkedList<>();
        maxQueue = new LinkedList<>();
    }

    public int max_value() {
        return maxQueue.isEmpty() ? -1 : maxQueue.peekFirst();
    }

    public void push_back(int value) {
        queue.offer(value);
        while (!maxQueue.isEmpty() && maxQueue.peekLast() < value) { // 后面进来的值，会把之前的值压扁
            maxQueue.removeLast();
        }
        maxQueue.offer(value);
    }

    public int pop_front() {
        if(queue.isEmpty()) return -1;
        if (queue.peekFirst().equals(maxQueue.peekFirst())) {
            maxQueue.removeFirst();
        }
        return queue.removeFirst();
    }
}
```

## 前缀树

Trie 树又叫字典树、前缀树、单词查找树，是一种二叉树衍生出来的高级数据结构，主要应用场景是处理字符串前缀相关的操作。

### Trie 树原理

**Trie 树本质上就是一棵从二叉树衍生出来的多叉树**。

二叉树节点的代码实现是这样：

```java
/* 基本的二叉树节点 */
class TreeNode {
    int val;
    TreeNode left, right;
}
```

其中 left, right 存储左右子节点的指针，所以二叉树的结构是这样：  
​![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686732385520-0ee122f8-071b-477b-a94b-c84c43d5d688-20240322101349-ahh04zs.png)  
多叉树节点的代码实现是这样：

```java
/* 基本的多叉树节点 */
class TreeNode {
    int val;
    TreeNode[] children;
}
```

其中 children 数组中存储指向孩子节点的指针，所以多叉树的结构是这样：  
​![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686732426169-e5dc4e95-cfa8-468c-9ec1-fd0320a4a75d-20240322101350-4jda1jr.png)  
而 TrieMap 中的树节点 TrieNode 的代码实现是这样：

```java
/* Trie 树节点实现 */
class TrieNode<V> {
    V val = null;
    TrieNode<V>[] children = new TrieNode[256];
}
```

这个 val 字段存储键对应的值，children 数组存储指向子节点的指针。

**但是和之前的普通多叉树节点不同，TrieNode 中 children 数组的索引是有意义的，代表键中的一个字符**。

比如说 children[97] 如果非空，说明这里存储了一个字符 'a'，因为 'a' 的 ASCII 码为 97。

我们的模板只考虑处理 ASCII 字符，所以 children 数组的大小设置为 256。不过这个可以根据具体问题修改，比如改成更小的数组或者 HashMap<Character, TrieNode> 都是一样的效果。

有了以上铺垫，Trie 树的结构是这样的：  
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686732480981-9a906672-4c4d-44fe-b66b-06cec8f0610d-20240322101351-6n0r5jl.png)  
一个节点有 256 个子节点指针，但大多数时候都是空的，可以省略掉不画，**所以一般你看到的 Trie 树长这样**：  
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686732506084-47d85ea1-dde2-49da-bb5c-d38722453cfe-20240322101352-wbt98no.png)  
这是在 TrieMap<Integer> 中插入一些键值对后的样子，白色节点代表 val 字段为空，橙色节点代表 val 字段非空。

**这里要特别注意，TrieNode 节点本身只存储 val 字段，并没有一个字段来存储字符，字符是通过子节点在父节点的 children 数组中的索引确定的**。

**形象理解就是，Trie 树用「树枝」存储字符串（键），用「节点」存储字符串（键）对应的数据（值）。所以我在图中把字符标在树枝，键对应的值 val 标在节点上**：  
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686732570855-e0482ca9-71de-4efd-a706-7f0256b6fa28-20240322101353-9cdf0j5.png)  
明白这一点很重要，有助于之后你理解代码实现。

现在你应该知道为啥 Trie 树也叫前缀树了，因为其中的字符串共享前缀，相同前缀的字符串集中在 Trie 树中的一个子树上，给字符串的处理带来很大的便利。

### TrieMap/TrieSet API 及实现

首先我们看一下本文实现的 TrieMap 的 API，为了举例 API 的功能，假设 TrieMap 中已经存储了如下键值对：  
​![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686732740846-d35aa699-3889-4eee-9dc1-469ae02e24be-20240322101354-9dxw9ax.png)

```java
// 底层用 Trie 树实现的键值映射
// 键为 String 类型，值为类型 V
class TrieMap<V> {

    /***** 增/改 *****/

    // 在 Map 中添加 key
    public void put(String key, V val);

    /***** 删 *****/

    // 删除键 key 以及对应的值
    public void remove(String key);

    /***** 查 *****/

    // 搜索 key 对应的值，不存在则返回 null
    // get("the") -> 4
    // get("tha") -> null
    public V get(String key);

    // 判断 key 是否存在在 Map 中
    // containsKey("tea") -> false
    // containsKey("team") -> true
    public boolean containsKey(String key);

    // 在 Map 的所有键中搜索 query 的最短前缀
    // shortestPrefixOf("themxyz") -> "the"
    public String shortestPrefixOf(String query);

    // 在 Map 的所有键中搜索 query 的最长前缀
    // longestPrefixOf("themxyz") -> "them"
    public String longestPrefixOf(String query);

    // 搜索所有前缀为 prefix 的键
    // keysWithPrefix("th") -> ["that", "the", "them"]
    public List<String> keysWithPrefix(String prefix);

    // 判断是和否存在前缀为 prefix 的键
    // hasKeyWithPrefix("tha") -> true
    // hasKeyWithPrefix("apple") -> false
    public boolean hasKeyWithPrefix(String prefix);

    // 通配符 . 匹配任意字符，搜索所有匹配的键
    // keysWithPattern("t.a.") -> ["team", "that"]
    public List<String> keysWithPattern(String pattern);

    // 通配符 . 匹配任意字符，判断是否存在匹配的键
    // hasKeyWithPattern(".ip") -> true
    // hasKeyWithPattern(".i") -> false
    public boolean hasKeyWithPattern(String pattern);

    // 返回 Map 中键值对的数量
    public int size();
}
```

至于 TrieSet 的 API 大同小异，所以这里不重复列举，后文直接给出实现。

**接下来是重头戏，我们一个一个实现 TrieMap 的上述 API 函数**。

首先，TrieMap 类中一定需要记录 Trie 的根节点 root，以及 Trie 树中的所有节点数量用于实现 size() 方法：

```java
class TrieMap<V> {
    // ASCII 码个数
    private static final int R = 256;
    // 当前存在 Map 中的键值对个数
    private int size = 0;

    private static class TrieNode<V> {
        V val = null;
        TrieNode<V>[] children = new TrieNode[R];
    }

    // Trie 树的根节点
    private TrieNode<V> root = null;

    /* 其他 API 的实现... */

    public int size() {
        return size;
    }
}
```

另外，我们再实现一个工具函数 getNode：

```java
// 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null
private TrieNode<V> getNode(TrieNode<V> node, String key) {
    TrieNode<V> p = node;
    // 从节点 node 开始搜索 key
    for (int i = 0; i < key.length(); i++) {
        if (p == null) {
            // 无法向下搜索
            return null;
        }
        // 向下搜索
        char c = key.charAt(i);
        p = p.children[c];
    }
    return p;
}
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686732888512-e7f7f0ab-76ec-491b-9b37-8b0927208ae6-20240322101355-n0mh224.png)  
有了这个 getNode 函数，就能实现 containsKey 方法和 get 方法了：

```java
// 搜索 key 对应的值，不存在则返回 null
public V get(String key) {
    // 从 root 开始搜索 key
    TrieNode<V> x = getNode(root, key);
    if (x == null || x.val == null) {
        // x 为空或 x 的 val 字段为空都说明 key 没有对应的值
        return null;
    }
    return x.val;
}

// 判断 key 是否存在在 Map 中
public boolean containsKey(String key) {
    return get(key) != null;
}
```

**这里需要注意，就算 getNode(key) 的返回值 x 非空，也只能说字符串 key 是一个「前缀」；除非 x.val 同时非空，才能判断键 key 存在**。

不过，这个特性恰好能够帮我们实现 hasKeyWithPrefix 方法：

```java
// 判断是和否存在前缀为 prefix 的键
public boolean hasKeyWithPrefix(String prefix) {
    // 只要能找到一个节点，就是存在前缀
    return getNode(root, prefix) != null;
}
```

类似 getNode 方法的逻辑，我们可以实现 shortestPrefixOf 方法，只要在第一次遇到存有 val 的节点的时候返回就行了：

```java
// 在所有键中寻找 query 的最短前缀
public String shortestPrefixOf(String query) {
    TrieNode<V> p = root;
    // 从节点 node 开始搜索 key
    for (int i = 0; i < query.length(); i++) {
        if (p == null) {
            // 无法向下搜索
            return "";
        }
        if (p.val != null) {
            // 找到一个键是 query 的前缀
            return query.substring(0, i);
        }
        // 向下搜索
        char c = query.charAt(i);
        p = p.children[c];
    }

    if (p != null && p.val != null) {
        // 如果 query 本身就是一个键
        return query;
    }
    return "";
}
```

**这里需要注意的是 for 循环结束之后我们还需要额外检查一下**。

因为之前说了 Trie 树中「树枝」存储字符串，「节点」存储字符串对应的值，for 循环相当于只遍历了「树枝」，但漏掉了最后一个「节点」，即 query 本身就是 TrieMap 中的一个键的情况。

如果你理解了 shortestPrefixOf 的实现，那么 longestPrefixOf 也是非常类似的：

```java
// 在所有键中寻找 query 的最长前缀
public String longestPrefixOf(String query) {
    TrieNode<V> p = root;
    // 记录前缀的最大长度
    int max_len = 0;

    // 从节点 node 开始搜索 key
    for (int i = 0; i < query.length(); i++) {
        if (p == null) {
            // 无法向下搜索
            break;
        }
        if (p.val != null) {
            // 找到一个键是 query 的前缀，更新前缀的最大长度
            max_len = i;
        }
        // 向下搜索
        char c = query.charAt(i);
        p = p.children[c];
    }

    if (p != null && p.val != null) {
        // 如果 query 本身就是一个键
        return query;
    }
    return query.substring(0, max_len);
}
```

每次遇到 p.val 非空的时候说明找到一个键，但是我们不急着返回，而是更新 max_len 变量，记录最长前缀的长度。

同样的，在 for 循环结束时还是要特殊判断一下，处理 query 本身就是键的情况。

接下来，我们来实现 keysWithPrefix 方法，得到所有前缀为 prefix 的键。

看过前文 [手把手刷二叉树（总结篇）](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_63a84ecde4b030cacaff6731/1) 的读者应该可以想到，先利用 getNode 函数在 Trie 树中找到 prefix 对应的节点 x，然施展多叉树的遍历算法，遍历以 x 为根的这棵 Trie 树，找到所有键值对：  
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686733282397-df766d55-ee07-4c77-8fe4-b94762e7b8be-20240322101355-99tq1lp.png)  
代码实现如下：

```java
// 搜索前缀为 prefix 的所有键
public List<String> keysWithPrefix(String prefix) {
    List<String> res = new LinkedList<>();
    // 找到匹配 prefix 在 Trie 树中的那个节点
    TrieNode<V> x = getNode(root, prefix);
    if (x == null) {
        return res;
    }
    // DFS 遍历以 x 为根的这棵 Trie 树
    traverse(x, new StringBuilder(prefix), res);
    return res;
}

// 遍历以 node 节点为根的 Trie 树，找到所有键
private void traverse(TrieNode<V> node, StringBuilder path, List<String> res) {
    if (node == null) {
        // 到达 Trie 树底部叶子结点
        return;
    }

    if (node.val != null) {
        // 找到一个 key，添加到结果列表中
        res.add(path.toString());
    }

    // 回溯算法遍历框架
    for (char c = 0; c < R; c++) {
        // 做选择
        path.append(c);
        traverse(node.children[c], path, res);
        // 撤销选择
        path.deleteCharAt(path.length() - 1);
    }
}
```

这段代码中 traverse 函数你可能看起来特别熟悉，就是 [回溯算法核心套路](https://labuladong.github.io/article/fname.html?fname=%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3%E4%BF%AE%E8%AE%A2%E7%89%88) 中讲的回溯算法代码框架。

关于回溯算法框架和标准多叉树框架的区别我在 [图论算法基础](https://labuladong.github.io/article/fname.html?fname=%E5%9B%BE) 中探讨过，关键在于遍历「节点」和遍历「树枝」的区别。由于 Trie 树将字符存储在「树枝」上，traverse 函数是在遍历树枝上的字符，所以采用的是回溯算法框架。

另外，再注意一下这段逻辑：

```java
// 回溯算法遍历框架
for (char c = 0; c < R; c++) {
    // 做选择
    path.append(c);
    traverse(node.children[c], path, res);
    // 撤销选择
    path.deleteCharAt(path.length() - 1);
}
```

回顾一下我们 Trie 树的图：  
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686733553684-7fc64607-aa69-4594-bd71-741082e159bf-20240322101356-tw1pid0.png)  
你是否会有疑问：代码中 for 循环会执行 256 次，但是图中的一个节点只有几个子节点，也就是说每个节点的 children 数组中大部分都是空指针，这不会有问题吗？

是不是应该把代码改成这样：

```java
// 回溯算法遍历框架
for (char c = 0; c < R; c++) {
    // 做选择
    path.append(c);
    if (node.children[c] != null) {
        traverse(node.children[c], path, res);
    }
    // 撤销选择
    path.deleteCharAt(path.length() - 1);
}
```

答案是，改不改都行，这两种写法从逻辑上讲完全相同，因为 traverse 函数开始的时候如果发现 node == null 也会直接返回。

我为了保持框架的一致性，就没有在 for 循环中判断子节点是否为空，而是依赖递归函数的 base case。当然你完全可以按照自己的喜好来实现。

下面来实现 keysWithPattern 方法，使用通配符来匹配多个键，其关键就在于通配符 . 可以匹配所有字符。

在代码实现上，用 path 变量记录匹配键的路径，遇到通配符时使用类似回溯算法的框架就行了：

```java
// 通配符 . 匹配任意字符
public List<String> keysWithPattern(String pattern) {
    List<String> res = new LinkedList<>();
    traverse(root, new StringBuilder(), pattern, 0, res);
    return res;
}

// 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..]
private void traverse(TrieNode<V> node, StringBuilder path, String pattern, int i, List<String> res) {
    if (node == null) {
        // 树枝不存在，即字符 pattern[i-1] 匹配失败
        return;
    }
    if (i == pattern.length()) {
        // pattern 匹配完成
        if (node.val != null) {
            // 如果这个节点存储着 val，则找到一个匹配的键
            res.add(path.toString());
        }
        return;
    }
    char c = pattern.charAt(i);
    if (c == '.') {
        // pattern[i] 是通配符，可以变化成任意字符
        // 多叉树（回溯算法）遍历框架
        for (char j = 0; j < R; j++) {
            path.append(j);
            traverse(node.children[j], path, pattern, i + 1, res);
            path.deleteCharAt(path.length() - 1);
        }
    } else {
        // pattern[i] 是普通字符 c
        path.append(c);
        traverse(node.children[c], path, pattern, i + 1, res);
        path.deleteCharAt(path.length() - 1);
    }
}
```

下面这个 GIF 画了匹配 "t.a." 的过程，应该就容易理解上述代码的逻辑了：  
![a.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686733677902-e1eeb33c-7c94-44fe-bb63-01e3a952422b-20240322101356-e85pchp.gif)  
可以看到，keysWithPattern 和 keysWithPrefix 的实现是有些类似的，而且这两个函数还有一个潜在的特性：**它们返回的结果列表一定是符合「字典序」的**。

原因应该不难理解，每一个节点的 children 数组都是从左到右进行遍历，即按照 ASCII 码从小到大的顺序递归遍历，得到的结果自然是符合字典序的。

好，现在我们实现了 keysWithPattern 方法得到模式串匹配的所有键，那你是否可以实现 hasKeyWithPattern 方法，仅仅判断是否存在键匹配模式串？

```java
// 一个偷懒的实现
public boolean hasKeyWithPattern(String pattern) {
    return !keysWithPattern(pattern).isEmpty();
}
```

这是一个偷懒的实现，因为它的复杂度比较高。我们的目的仅仅是判断是否存在匹配模式串的键，你却把所有匹配的键都算出来了，这显然是没有必要的。

我们只需稍微改写一下 keysWithPattern 方法就可以高效实现 hasKeyWithPattern 方法：

```java
// 判断是和否存在前缀为 prefix 的键
public boolean hasKeyWithPattern(String pattern) {
    // 从 root 节点开始匹配 pattern[0..]
    return hasKeyWithPattern(root, pattern, 0);
}

// 函数定义：从 node 节点开始匹配 pattern[i..]，返回是否成功匹配
private boolean hasKeyWithPattern(TrieNode<V> node, String pattern, int i) {
    if (node == null) {
        // 树枝不存在，即匹配失败
        return false;
    }
    if (i == pattern.length()) {
        // 模式串走到头了，看看匹配到的是否是一个键
        return node.val != null;
    }
    char c = pattern.charAt(i);
    // 没有遇到通配符
    if (c != '.') {
        // 从 node.children[c] 节点开始匹配 pattern[i+1..]
        return hasKeyWithPattern(node.children[c], pattern, i + 1);
    }
    // 遇到通配符
    for (int j = 0; j < R; j++) {
        // pattern[i] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回
        if (hasKeyWithPattern(node.children[j], pattern, i + 1)) {
            return true;
        }
    }
    // 都没有匹配
    return false;
}
```

有之前的铺垫，这个实现应该是不难理解的，类似于 [回溯算法解数独游戏](https://labuladong.github.io/article/fname.html?fname=sudoku) 中找到一个可行解就提前结束递归的做法。

到这里，TrieMap 的所有和前缀相关的方法都实现完了，还剩下 put 和 remove 这两个基本方法了，其实它们的难度不大，就是递归修改数据结构的那一套，如果不熟悉的话可以参见 [二叉搜索树基本操作](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_63a84fb7e4b07b0558298a07/1)。

先说 put 方法的实现吧，直接看代码：

```java
// 在 map 中添加或修改键值对
public void put(String key, V val) {
    if (!containsKey(key)) {
        // 新增键值对
        size++;
    }
    // 需要一个额外的辅助函数，并接收其返回值
    root = put(root, key, val, 0);
}

// 定义：向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点
private TrieNode<V> put(TrieNode<V> node, String key, V val, int i) {
    if (node == null) {
        // 如果树枝不存在，新建
        node = new TrieNode<>();
    }
    if (i == key.length()) {
        // key 的路径已插入完成，将值 val 存入节点
        node.val = val;
        return node;
    }
    char c = key.charAt(i);
    // 递归插入子节点，并接收返回值
    node.children[c] = put(node.children[c], key, val, i + 1);
    return node;
}
```

因为是递归修改数据结构，所以我们必须额外创建一个返回类型为 TrieNode 的辅助函数，并且在递归调用的时候接收其返回值，拼接到父节点上。

**前文说了，Trie 树中的键就是「树枝」，值就是「节点」，所以插入的逻辑就是沿路新建「树枝」，把 key 的整条「树枝」构建出来之后，在树枝末端的「节点」中存储 val**：  
![a.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686733830632-8aaf3e42-ab53-44b1-966f-4e4930f988e7-20240322101356-5b71bro.gif)  
最后，我们说一下 remove 函数，似乎所有数据结构的删除操作相对其他操作都会更复杂一些。

比如说下图这个场景，如果你想删除键 "team"，那么需要删掉 "eam" 这条树枝才是符合逻辑的：  
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686733849863-79a0e1f3-3686-46f6-9057-58849b73be8e-20240322101357-n5a3j10.png)  
删多了肯定不行，但删少了也不行，否则前文实现的 hasKeyWithPrefix 就会出错。

那么如何控制算法来正确地进行删除呢？

首先，递归修改数据结构的时候，如果一个节点想删掉自己，直接返回空指针就行了。

**其次，一个节点如何知道自己是否需要被删除呢？主要看自己的 val 字段是否为空以及自己的 children 数组是否全都是空指针**。

这里就要利用前文 [手把手刷二叉树（总结篇）](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_63a84ecde4b030cacaff6731/1) 中说到的后序位置的特点了：

一个节点要先递归处理子树，然后在后序位置检查自己的 val 字段和 children 列表，判断自己是否需要被删除。

如果自己的 val 字段为空，说明自己没有存储值，如果同时自己的 children 数组全是空指针，说明自己下面也没有接树枝，即不是任何一个键的前缀。这种情况下这个节点就没有存在的意义了，应该删掉自己。

直接看代码：

```java
// 在 Map 中删除 key
public void remove(String key) {
    if (!containsKey(key)) {
        return;
    }
    // 递归修改数据结构要接收函数的返回值
    root = remove(root, key, 0);
    size--;
}

// 定义：在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点
private TrieNode<V> remove(TrieNode<V> node, String key, int i) {
    if (node == null) {
        return null;
    }
    if (i == key.length()) {
        // 找到了 key 对应的 TrieNode，删除 val
        node.val = null;
    } else {
        char c = key.charAt(i);
        // 递归去子树进行删除
        node.children[c] = remove(node.children[c], key, i + 1);
    }
    // 后序位置，递归路径上的节点可能需要被清理
    if (node.val != null) {
        // 如果该 TireNode 存储着 val，不需要被清理
        return node;
    }
    // 检查该 TrieNode 是否还有后缀
    for (int c = 0; c < R; c++) {
        if (node.children[c] != null) {
            // 只要存在一个子节点（后缀树枝），就不需要被清理
            return node;
        }
    }
    // 既没有存储 val，也没有后缀树枝，则该节点需要被清理
    return null;
}
```

到这里，TrieMap 的所有 API 就实现完了，完整代码如下：

```java
class TrieMap<V> {
    // ASCII 码个数
    private static final int R = 256;
    // 当前存在 Map 中的键值对个数
    private int size = 0;
    // Trie 树的根节点
    private TrieNode<V> root = null;

    private static class TrieNode<V> {
        V val = null;
        TrieNode<V>[] children = new TrieNode[R];
    }

    /***** 增/改 *****/

    // 在 map 中添加或修改键值对
    public void put(String key, V val) {
        if (!containsKey(key)) {
            // 新增键值对
            size++;
        }
        // 需要一个额外的辅助函数，并接收其返回值
        root = put(root, key, val, 0);
    }

    // 定义：向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点
    private TrieNode<V> put(TrieNode<V> node, String key, V val, int i) {
        if (node == null) {        
            // 如果树枝不存在，新建
            node = new TrieNode<>();
        }
        if (i == key.length()) {
            // key 的路径已插入完成，将值 val 存入节点
            node.val = val;
            return node;
        }
        char c = key.charAt(i);
        // 递归插入子节点，并接收返回值
        node.children[c] = put(node.children[c], key, val, i + 1);
        return node;
    }

    /***** 删 *****/

    // 在 Map 中删除 key
    public void remove(String key) {
        if (!containsKey(key)) {
            return;
        }
        // 递归修改数据结构要接收函数的返回值
        root = remove(root, key, 0);
        size--;
    }

    // 定义：在以 node 为根的 Trie 树中删除 key[i..]，返回删除后的根节点
    private TrieNode<V> remove(TrieNode<V> node, String key, int i) {
        if (node == null) {
            return null;
        }
        if (i == key.length()) {
            // 找到了 key 对应的 TrieNode，删除 val
            node.val = null;
        } else {
            char c = key.charAt(i);
            // 递归去子树进行删除
            node.children[c] = remove(node.children[c], key, i + 1);
        }    
        // 后序位置，递归路径上的节点可能需要被清理
        if (node.val != null) {
            // 如果该 TireNode 存储着 val，不需要被清理
            return node;
        }
        // 检查该 TrieNode 是否还有后缀
        for (int c = 0; c < R; c++) {
            if (node.children[c] != null) {
                // 只要存在一个子节点（后缀树枝），就不需要被清理
                return node;
            }
        }
        // 既没有存储 val，也没有后缀树枝，则该节点需要被清理
        return null;
    }

    /***** 查 *****/

    // 搜索 key 对应的值，不存在则返回 null
    public V get(String key) {
        // 从 root 开始搜索 key
        TrieNode<V> x = getNode(root, key);
        if (x == null || x.val == null) {
            // x 为空或 x 的 val 字段为空都说明 key 没有对应的值
            return null;
        }
        return x.val;
    }

    // 判断 key 是否存在在 Map 中
    public boolean containsKey(String key) {
        return get(key) != null;
    }

    // 判断是和否存在前缀为 prefix 的键
    public boolean hasKeyWithPrefix(String prefix) {
        // 只要能找到一个节点，就是存在前缀
        return getNode(root, prefix) != null;
    }

    // 在所有键中寻找 query 的最短前缀
    public String shortestPrefixOf(String query) {
        TrieNode<V> p = root;
        // 从节点 node 开始搜索 key
        for (int i = 0; i < query.length(); i++) {
            if (p == null) {
                // 无法向下搜索
                return "";
            }
            if (p.val != null) {
                // 找到一个键是 query 的前缀
                return query.substring(0, i);
            }
            // 向下搜索
            char c = query.charAt(i);
            p = p.children[c];
        }

        if (p != null && p.val != null) {
            // 如果 query 本身就是一个键
            return query;
        }
        return "";
    }

    // 在所有键中寻找 query 的最长前缀
    public String longestPrefixOf(String query) {
        TrieNode<V> p = root;
        // 记录前缀的最大长度
        int max_len = 0;

        // 从节点 node 开始搜索 key
        for (int i = 0; i < query.length(); i++) {
            if (p == null) {
                // 无法向下搜索
                break;
            }
            if (p.val != null) {
                // 找到一个键是 query 的前缀，更新前缀的最大长度
                max_len = i;
            }
            // 向下搜索
            char c = query.charAt(i);
            p = p.children[c];
        }

        if (p != null && p.val != null) {
            // 如果 query 本身就是一个键
            return query;
        }
        return query.substring(0, max_len);
    }

    // 搜索前缀为 prefix 的所有键
    public List<String> keysWithPrefix(String prefix) {
        List<String> res = new LinkedList<>();
        // 找到匹配 prefix 在 Trie 树中的那个节点
        TrieNode<V> x = getNode(root, prefix);    
        if (x == null) {
            return res;
        }
        // DFS 遍历以 x 为根的这棵 Trie 树
        traverse(x, new StringBuilder(prefix), res);
        return res;
    }

    // 遍历以 node 节点为根的 Trie 树，找到所有键
    private void traverse(TrieNode<V> node, StringBuilder path, List<String> res) {
        if (node == null) {
            // 到达 Trie 树底部叶子结点
            return;
        }

        if (node.val != null) {
            // 找到一个 key，添加到结果列表中
            res.add(path.toString());
        }

        // 回溯算法遍历框架
        for (char c = 0; c < R; c++) {
            // 做选择
            path.append(c);
            traverse(node.children[c], path, res);
            // 撤销选择
            path.deleteCharAt(path.length() - 1);
        }
    }

    // 通配符 . 匹配任意字符
    public List<String> keysWithPattern(String pattern) {
        List<String> res = new LinkedList<>();
        traverse(root, new StringBuilder(), pattern, 0, res);
        return res;
    }

    // 遍历函数，尝试在「以 node 为根的 Trie 树中」匹配 pattern[i..]
    private void traverse(TrieNode<V> node, StringBuilder path, String pattern, int i, List<String> res) {
        if (node == null) {
            // 树枝不存在，即匹配失败
            return;
        }
        if (i == pattern.length()) {
            // pattern 匹配完成
            if (node.val != null) {
                // 如果这个节点存储着 val，则找到一个匹配的键
                res.add(path.toString());
            }
            return;
        }
        char c = pattern.charAt(i);    
        if (c == '.') {
            // pattern[i] 是通配符，可以变化成任意字符
            // 多叉树（回溯算法）遍历框架
            for (char j = 0; j < R; j++) {
                path.append(j);
                traverse(node.children[j], path, pattern, i + 1, res);
                path.deleteCharAt(path.length() - 1);
            }
        } else {
            // pattern[i] 是普通字符 c
            path.append(c);
            traverse(node.children[c], path, pattern, i + 1, res);
            path.deleteCharAt(path.length() - 1);
        }
    }

    // 判断是和否存在前缀为 prefix 的键
    public boolean hasKeyWithPattern(String pattern) {
        // 从 root 节点开始匹配 pattern[0..]
        return hasKeyWithPattern(root, pattern, 0);
    }

    // 函数定义：从 node 节点开始匹配 pattern[i..]，返回是否成功匹配
    private boolean hasKeyWithPattern(TrieNode<V> node, String pattern, int i) {
        if (node == null) {
            // 树枝不存在，即匹配失败
            return false;
        }
        if (i == pattern.length()) {
            // 模式串走到头了，看看匹配到的是否是一个键
            return node.val != null;
        }
        char c = pattern.charAt(i);
        // 没有遇到通配符
        if (c != '.') {
            // 从 node.children[c] 节点开始匹配 pattern[i+1..]
            return hasKeyWithPattern(node.children[c], pattern, i + 1);
        }
        // 遇到通配符
        for (int j = 0; j < R; j++) {
            // pattern[i] 可以变化成任意字符，尝试所有可能，只要遇到一个匹配成功就返回
            if (hasKeyWithPattern(node.children[j], pattern, i + 1)) {
                return true;
            }
        }
        // 都没有匹配
        return false;
    }

    // 从节点 node 开始搜索 key，如果存在返回对应节点，否则返回 null
    private TrieNode<V> getNode(TrieNode<V> node, String key) {    
        TrieNode<V> p = node;
        // 从节点 node 开始搜索 key
        for (int i = 0; i < key.length(); i++) {
            if (p == null) {
                // 无法向下搜索
                return null;
            }
            // 向下搜索
            char c = key.charAt(i);
            p = p.children[c];
        }
        return p;
    }

    public int size() {
        return size;
    }
}
```

接下来我们只要对 TrieMap 做简单的封装，即可实现 TrieSet：

```java
class TrieSet {
    // 底层用一个 TrieMap，键就是 TrieSet，值仅仅起到占位的作用
    // 值的类型可以随便设置，我参考 Java 标准库设置成 Object
    private final TrieMap<Object> map = new TrieMap<>();

    /***** 增 *****/

    // 在集合中添加元素 key
    public void add(String key) {
        map.put(key, new Object());
    }

    /***** 删 *****/

    // 从集合中删除元素 key
    public void remove(String key) {
        map.remove(key);
    }

    /***** 查 *****/

    // 判断元素 key 是否存在集合中
    public boolean contains(String key) {
        return map.containsKey(key);
    }

    // 在集合中寻找 query 的最短前缀
    public String shortestPrefixOf(String query) {
        return map.shortestPrefixOf(query);
    }

    // 在集合中寻找 query 的最长前缀
    public String longestPrefixOf(String query) {
        return map.longestPrefixOf(query);
    }

    // 在集合中搜索前缀为 prefix 的所有元素
    public List<String> keysWithPrefix(String prefix) {
        return map.keysWithPrefix(prefix);
    }

    // 判断集合中是否存在前缀为 prefix 的元素
    public boolean hasKeyWithPrefix(String prefix) {
        return map.hasKeyWithPrefix(prefix);
    }

    // 通配符 . 匹配任意字符，返回集合中匹配 pattern 的所有元素
    public List<String> keysWithPattern(String pattern) {
        return map.keysWithPattern(pattern);
    }

    // 通配符 . 匹配任意字符，判断集合中是否存在匹配 pattern 的元素
    public boolean hasKeyWithPattern(String pattern) {
        return map.hasKeyWithPattern(pattern);
    }

    // 返回集合中元素的个数
    public int size() {
        return map.size();
    }
}
```

**有了 TrieMap 和 TrieSet，力扣上所有前缀树相关的题目都可以直接套用了**，下面我举几个题目实践一下。

### 练习题

#### 208.「[实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/description/?utm_source=LCUS&utm_medium=ip_redirect&utm_campaign=transfer2china)」

> [Trie](https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin)（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。
>
> 请你实现 Trie 类：
>
> - Trie() 初始化前缀树对象。
> - void insert(String word) 向前缀树中插入字符串 word 。
> - boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。
> - boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。
>
> **示例：**
>
> **输入** ["Trie", "insert", "search", "search", "startsWith", "insert", "search"] [[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
>
> **输出** [null, null, true, false, true, null, true]
>
> **解释**  
> Trie trie = new Trie();  
> trie.insert("apple");  
> trie.search("apple");   // 返回 True  
> trie.search("app");     // 返回 False  
> trie.startsWith("app"); // 返回 True  
> trie.insert("app");  
> trie.search("app");     // 返回 True

```java
class Trie {

    private static final int R = 26; // 字符个数

    private TrieNode root = null; // Trie树的根节点

    private int size; // 键值对个数

    private final Object V = new Object();

    private class TrieNode {
        private Object value = null;

        private final TrieNode[] children = new TrieNode[R];
    }

    public Trie() {

    }

    public void insert(String word) {
        if (!search(word)) {
            ++size;
        }
        root = put(root, word, V, 0);
    }

    /**
         * 向以 node 为根的 Trie 树中插入 key[i..]，返回插入完成后的根节点
         *
         * @param node
         * @param key
         * @param value
         * @param i
         */
    private TrieNode put(TrieNode node, String key, Object value, int i) {
        if (node == null) { // 如果树枝不存在，新建
            node = new TrieNode();
        }
        if (i == key.length()) { // key 的路径已插入完成，将值 val 存入节点
            node.value = value;
            return node;
        }
        char ch = key.charAt(i);
        node.children[ch - 97] = put(node.children[ch - 97], key, value, i + 1);
        return node;
    }

    public boolean search(String word) {
        TrieNode node = getNode(root, word);
        return node != null && node.value != null;
    }

    public boolean startsWith(String prefix) {
        return getNode(root, prefix) != null; // 只要能找到一个节点，就是存在前缀
    }

    private TrieNode getNode(TrieNode node, String key) {
        TrieNode p = node;
        for (int i = 0; i < key.length(); i++) {
            if (p == null) return null;
            // 向下搜索
            char ch = key.charAt(i);
            p = p.children[ch - 97];
        }
        return p;
    }
}
```

#### 648.「[单词替换](https://leetcode.cn/problems/replace-words/description/)」

> 在英语中，我们有一个叫做 `词根`​(root) 的概念，可以词根**后面**添加其他一些词组成另一个较长的单词——我们称这个词为 `继承词`​(successor)。例如，词根`an`​，跟随着单词 `other`​(其他)，可以形成新的单词 `another`​(另一个)。
>
> 现在，给定一个由许多**词根**组成的词典 `dictionary`​ 和一个用空格分隔单词形成的句子 `sentence`​。你需要将句子中的所有**继承词**用**词根**替换掉。如果**继承词**有许多可以形成它的**词根**，则用**最短**的词根替换它。
>
> 你需要输出替换之后的句子。
>
> **示例 1：**   
> 输入：dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"  
> 输出："the cat was rat by the bat"

现在你学过 Trie 树结构，应该可以看出来这题就在考察最短前缀问题。  
所以可以把输入的词根列表 dict 存入 TrieSet，然后直接复用我们实现的 shortestPrefixOf 函数就行了：

```java
class Solution {

    class Trie {
        private final Object V = new Object();
        private static final int R = 26;

        private TreeNode root = null;

        class TreeNode {
            private Object value = null;
            private final TreeNode[] children = new TreeNode[R];
        }

        public void put(String key) {
            root = put(root, key, V, 0);
        }

        private TreeNode put(TreeNode node, String key, Object v, int i) {
            if (node == null) {
                node = new TreeNode();
            }
            if (i == key.length()) {
                node.value = v;
                return node;
            }
            char ch = key.charAt(i);
            node.children[ch - 97] = put(node.children[ch - 97], key, v, i + 1);
            return node;
        }

        public String shortestPrefixOf(String query) {
            TreeNode p = root;
            for (int i = 0; i < query.length(); i++) {
                if (p == null) return null;
                if (p.value != null) {
                    return query.substring(0, i);
                }
                char ch = query.charAt(i);
                p = p.children[ch - 97];
            }
            if (p != null && p.value != null) {
                return query;
            }
            return null;
        }
    }

    public String replaceWords(List<String> dictionary, String sentence) {
        Trie trie = new Trie();
        for (String dict : dictionary) {
            trie.put(dict);
        }
        String[] words = sentence.split(" ");
        StringBuilder sb = new StringBuilder();
        for (String word : words) {
            String prefix = trie.shortestPrefixOf(word);
            if (prefix != null) {
                sb.append(prefix);
            } else {
                sb.append(word);
            }
            sb.append(" ");
        }
        return sb.substring(0, sb.length() - 1);
    }
}
```

#### 211.「[添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/description/)」

> 请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。  
> 实现词典类 WordDictionary ：
>
> - WordDictionary() 初始化词典对象
> - void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配
> - bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 '.' ，每个 . 都可以表示任何一个字母。
>
> **示例：**   
> 输入： ["WordDictionary","addWord","addWord","addWord","search","search","search","search"] [[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
>
> 输出： [null,null,null,null,false,true,true,true]
>
> 解释：  
> WordDictionary wordDictionary = new WordDictionary();  
> wordDictionary.addWord("bad");  
> wordDictionary.addWord("dad");  
> wordDictionary.addWord("mad");  
> wordDictionary.search("pad"); // 返回 False  
> wordDictionary.search("bad"); // 返回 True  
> wordDictionary.search(".ad"); // 返回 True  
> wordDictionary.search("b.."); // 返回 True

这道题的考点就在于这个 search 函数进行通配符匹配，其实就是我们给 TrieSet 实现的 hasKeyWithPattern 方法，直接套就行了：

```java
class WordDictionary {

    private TrieNode root = null;
    private final Object V = new Object();

    class TrieNode {
        private Object value = null;
        private final TrieNode[] children = new TrieNode[26];
    }

    public WordDictionary() {

    }

    public void addWord(String word) {
        root = put(root, word, V, 0);
    }

    private TrieNode put(TrieNode node, String key, Object v, int i) {
        if (node == null) {
            node = new TrieNode();
        }
        if (i == key.length()) {
            node.value = v;
            return node;
        }
        char ch = key.charAt(i);
        node.children[ch - 97] = put(node.children[ch - 97], key, v, i + 1);
        return node;
    }

    public boolean search(String word) {
        return hasKeyWithPattern(root, word, 0);
    }

    /**
         * 从 node 节点开始匹配 pattern[i..]，返回是否成功匹配
         *
         * @param node
         * @param key
         * @param i
         * @return
         */
    private boolean hasKeyWithPattern(TrieNode node, String key, int i) {
        if (node == null) return false;
        if (i == key.length()) return node.value != null;
        char ch = key.charAt(i);
        if (ch == '.') {
            for (int j = 0; j < 26; j++) {
                if (hasKeyWithPattern(node.children[j], key, i + 1)) {
                    return true;
                }
            }
        } else {
            return hasKeyWithPattern(node.children[ch - 97], key, i + 1);
        }
        return false;
    }
}
```

#### 677.「[键值映射](https://leetcode.cn/problems/map-sum-pairs/description/)」

> 设计一个 map ，满足以下几点:
>
> - 字符串表示键，整数表示值
> - 返回具有前缀等于给定字符串的键的值的总和
>
> 实现一个 MapSum 类：
>
> - MapSum() 初始化 MapSum 对象
> - void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对 key-value 将被替代成新的键值对。
> - int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。
>
> **示例 1：**
>
> 输入： ["MapSum", "insert", "sum", "insert", "sum"] [[], ["apple", 3], ["ap"], ["app", 2], ["ap"]]
>
> 输出： [null, null, 3, null, 5]
>
> 解释：  
> MapSum mapSum = new MapSum();  
> mapSum.insert("apple", 3);
> mapSum.sum("ap");           // 返回 3 (apple = 3)  
> mapSum.insert("app", 2);
> mapSum.sum("ap");           // 返回 5 (apple + app = 3 + 2 = 5)

这道题还是标准的 TrieMap 的应用，直接看代码吧：

```java
class MapSum {

    private TrieNode root = null;

    class TrieNode {
        private Integer value = null;
        private final TrieNode[] children = new TrieNode[26];
    }

    public MapSum() {

    }

    public void insert(String key, int val) {
        root = put(root, key, val, 0);
    }

    private TrieNode put(TrieNode node, String key, int val, int i) {
        if (node == null) {
            node = new TrieNode();
        }
        if (i == key.length()) {
            node.value = val;
            return node;
        }
        char ch = key.charAt(i);
        node.children[ch - 97] = put(node.children[ch - 97], key, val, i + 1);
        return node;
    }

    public int sum(String prefix) {
        List<String> list = keysWithPrefix(prefix);
        int res = 0;
        for (String it : list) {
            Integer value = get(it);
            if (value != null) {
                res += value;
            }
        }
        return res;
    }

    private List<String> keysWithPrefix(String prefix) {
        List<String> res = new LinkedList<>();
        TrieNode node = getNode(root, prefix); // 先找到该node
        if (node == null) return res;
        traverse(node, new StringBuilder(prefix), res);
        return res;
    }

    private void traverse(TrieNode node, StringBuilder path, List<String> res) {
        if (node == null) return;
        if (node.value != null) {
            res.add(path.toString());
        }
        for (int i = 0; i < 26; i++) {
            if (node.children[i] != null) {
                path.append((char) ('a' + i));
                traverse(node.children[i], path, res);
                path.deleteCharAt(path.length() - 1);
            }
        }
    }

    private Integer get(String key) {
        TrieNode node = getNode(root, key);
        if (node != null && node.value != null) {
            return node.value;
        }
        return null;
    }

    private TrieNode getNode(TrieNode node, String key) {
        TrieNode p = node;
        for (int i = 0; i < key.length(); i++) {
            if (p == null) return null;
            char ch = key.charAt(i);
            p = p.children[ch - 97];
        }
        return p;
    }
}
```

简洁版

```java
class MapSum {
    private TrieNode root = null;

    class TrieNode {
        private Integer val = null;
        private final TrieNode[] children = new TrieNode[26];
    }

    public MapSum() {

    }
  
    public void insert(String key, int val) {
        root = put(root, key, 0, val);
    }
  
    public int sum(String prefix) {
        TrieNode node = getNode(root, prefix);
        if (node == null) return 0;
        return traverse(node);
    }

    public int traverse (TrieNode node) {
        if (node == null) return 0;
        int sum = 0;
        if (node.val != null) sum += node.val;
        for (int i = 0; i < 26; i++) {
            sum += traverse(node.children[i]);
        }
        return sum;
    }

    public TrieNode getNode (TrieNode node, String prefix) {
        TrieNode p = node;
        for (int i = 0; i < prefix.length(); i++) {
            if (p == null) return null;
            p = p.children[prefix.charAt(i) - 97];
        }
        return p;
    }

    public TrieNode put (TrieNode node, String key, int i, int val) {
        if (node == null) node = new TrieNode();
        if (i == key.length()) {
            node.val = val;
            return node;
        }
        int index = key.charAt(i) - 97;
        node.children[index] = put(node.children[index], key, i + 1, val);
        return node;
    }
}
```
