# 数据结构

## 链表

### 链表

#### 练习题

##### **LCR 123.「**​[图书整理 I](https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/description/?orderBy=hot&amp;languageTags=java)​ **」**

> 书店店员有一张链表形式的书单，每个节点代表一本书，节点中的值表示书的编号。为更方便整理书架，店员需要将书单倒过来排列，就可以从最后一本书开始整理，逐一将书放回到书架上。请倒序返回这个书单链表。
>
> **示例 1：**
>
> 输入：head = [1,3,2]  
> 输出：[2,3,1]

**链表特点：**  只能从前至后访问每个节点。 **题目要求：**  倒序输出节点值。 这种 **先入后出** 的需求可以借助 **栈** 来实现。

```java
public int[] reversePrint(ListNode head) {
    LinkedList<Integer> stack = new LinkedList<>();
    while (head != null) {
        stack.offer(head.val);
        head = head.next;
    }
    int[] res = new int[stack.size()];
    for (int i = 0; i < res.length; i++) {
        res[i] = stack.removeLast();
    }
    return res;
}
```

##### **LCR 154.「**​[复杂链表的复制](https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/description/)」

> 请实现 `copyRandomList`​ 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 `next`​ 指针指向下一个节点，还有一个 `random`​ 指针指向链表中的任意节点或者 `null`​。
>
> **示例 1：**   
> ​![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678863656965-01adbe60-f683-4d6d-af8c-5d2992b0b484-20240322151007-27ztvk6.png)  
> 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]  
> 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]

给定链表的头节点 head ，复制普通链表很简单，只需遍历链表，每轮建立新节点 + 构建前驱节点 pre 和当前节点 node 的引用指向即可。

本题链表的节点新增了 random 指针，指向链表中的 任意节点 或者 null。这个 random 指针意味着在复制过程中，除了构建前驱节点和当前节点的引用指向 pre.next ，还要构建前驱节点和其随机节点的引用指向 pre.random 。

本题难点： 在复制链表的过程中构建新链表各节点的 random 引用指向。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678863720249-07b00c38-f465-4262-9103-8a0b1a0a9551-20240322151008-m8bv63h.png)

```java
class Solution {
    public Node copyRandomList(Node head) {
        Node cur = head;
        Node dum = new Node(0), pre = dum;
        while(cur != null) {
            Node node = new Node(cur.val); // 复制节点 cur
            pre.next = node;               // 新链表的 前驱节点 -> 当前节点
            // pre.random = "???";         // 新链表的 「 前驱节点 -> 当前节点 」 无法确定
            cur = cur.next;                // 遍历下一节点
            pre = node;                    // 保存当前新节点
        }
        return dum.next;
    }
}
```

###### 哈希表

利用哈希表的查询特点，考虑构建 原链表节点 和 新链表对应节点 的键值对映射关系，再遍历构建新链表各节点的 next 和 random 引用指向即可。

**算法流程：**

- 若头节点 head 为空节点，直接返回 null ；
- 初始化： 哈希表 dic ， 节点 cur 指向头节点；
- 复制链表：

    - 建立新节点，并向 dic 添加键值对 (原 cur 节点, 新 cur 节点） ；
    - cur 遍历至原链表下一节点；
- 构建新链表的引用指向：

    - 构建新节点的 next 和 random 引用指向；
    - cur 遍历至原链表下一节点；
- 返回值： 新链表的头节点 dic[cur] ；

**复杂度分析：**

- 时间复杂度 O(N) ： 两轮遍历链表，使用 O(N) 时间。
- 空间复杂度 O(N)： 哈希表 dic 使用线性大小的额外空间。

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678864075523-9bbb8bc8-4e2e-4b88-a767-d8d997884b92-20240322151008-v9xqcx7.gif)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        Map<Node, Node> map = new HashMap<>();
        // 3. 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        while(cur != null) {
            map.put(cur, new Node(cur.val));
            cur = cur.next;
        }
        cur = head;
        // 4. 构建新链表的 next 和 random 指向
        while(cur != null) {
            map.get(cur).next = map.get(cur.next);
            map.get(cur).random = map.get(cur.random);
            cur = cur.next;
        }
        // 5. 返回新链表的头节点
        return map.get(head);
    }
}
```

###### 拼接 + 拆分

考虑构建 原节点 1 -> 新节点 1 -> 原节点 2 -> 新节点 2 -> …… 的拼接链表，如此便可在访问原节点的 random 指向节点的同时找到新对应新节点的 random 指向节点。  
**算法流程：**

- 复制各节点，构建拼接链表:

    - 设原链表为 ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678864163453-3542e9fc-2331-45a7-9cdf-fb10c7b10da0-20240322151008-xng0g44.png) ，构建的拼接链表如下所示：![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678864197533-2b160b80-ca67-41b6-9498-3d29f71cb8dd-20240322151008-13c6d66.png)​
- 构建新链表各节点的 random 指向：

    - 当访问原节点 cur 的随机指向节点 cur.random 时，对应新节点 cur.next 的随机指向节点为 cur.random.next 。
- 拆分原 / 新链表：

    - 设置 pre / cur 分别指向原 / 新链表头节点，遍历执行 pre.next = pre.next.next 和 cur.next = cur.next.next 将两链表拆分开。
    - 返回新链表的头节点 res 即可。

**复杂度分析：**

- 时间复杂度 O(N) ： 三轮遍历链表，使用 O(N) 时间。
- 空间复杂度 O(1) ： 节点引用变量使用常数大小的额外空间。

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678864357454-8dd70070-d4c7-4b79-937d-f85980529202-20240322151008-uataq5s.gif)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return null;
        Node cur = head;
        // 1. 复制各节点，并构建拼接链表
        while(cur != null) {
            Node tmp = new Node(cur.val);
            tmp.next = cur.next;
            cur.next = tmp;
            cur = tmp.next;
        }
        // 2. 构建各新节点的 random 指向
        cur = head;
        while(cur != null) {
            if(cur.random != null)
                cur.next.random = cur.random.next;
            cur = cur.next.next;
        }
        // 3. 拆分两链表
        cur = head.next;
        Node pre = head, res = head.next;
        while(cur.next != null) {
            pre.next = pre.next.next;
            cur.next = cur.next.next;
            pre = pre.next;
            cur = cur.next;
        }
        pre.next = null; // 单独处理原链表尾节点
        return res;      // 返回新链表头节点
    }
}
```

### 链表双指针

### 【强化练习】链表双指针经典习题

#### 82.「[删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)」

> 给定一个已排序的链表的头 `head`​ ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。
>
> **示例 1：**
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240421140204-rbxjwux.png)​
>
> 输入：head = [1,2,3,3,4,4,5]  
> 输出：[1,2,5]

这道题是前文 [链表的双指针技巧汇总](https://labuladong.online/algo/essential-technique/array-two-pointers-summary/) 中讲的 [83. 删除排序链表中的重复元素open in new window](https://leetcode.cn/problems/remove-duplicates-from-sorted-list) 的进阶版。如果只让你把多于的重复元素去掉，那么快慢指针可以搞定，但这道题要求你把存在重复的元素全都去掉，一个简单粗暴的解法就是借助像哈希表这样的数据结构记录哪些节点重复了，然后去掉它们。

不过这道题输入的链表是有序的，这意味着重复元素都靠在一起，其实不用额外的空间复杂度来辅助，用两个指针就可以达到去重的目的，只是细节有点多，直接结合代码的详细注释来看吧。

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
       ListNode root = new ListNode(-1);
        ListNode slow = root, fast = head;
        while (fast != null) {
            if (fast.next != null && fast.val == fast.next.val){
                // 发现重复节点，跳过这些重复节点
                while (fast.next != null && fast.val == fast.next.val) {
                    fast = fast.next;
                }
                fast = fast.next;
            } else {
                // 不是重复节点，接到 dummy 后面
                slow.next = falst;
                falst = falst.next;
                slow = slow.next;
                slow.next = null; // 将后面的元素置空
            }
        }
        return root.next;
    }
}
```

### 反转单链表

#### 练习题

##### 206.「 [反转链表](https://leetcode.cn/problems/reverse-linked-list/)」

> 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。
>
> **示例 1：**   
> ​![1677496783980-51a6a0b2-478e-4e8d-a285-f58b9da46722](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677496783980-51a6a0b2-478e-4e8d-a285-f58b9da46722-20240322174807-kprnhub.jpeg)​
>
> 输入：head = [1,2,3,4,5]
>
> 输出：[5,4,3,2,1]

我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。

第二个指针 cur 指向 head，然后不断遍历 cur。

每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。

都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。

动画演示如下：

![a.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677498392828-e4c53cd4-de98-448b-ae6d-f201c7202019-20240322174808-rgu3zr1.gif)首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。

然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。

为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。

接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。

最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        //申请节点，pre和 cur，pre指向null
        ListNode pre = null;
        ListNode cur = head;
        ListNode tmp = null;
        while(cur != null) {
            tmp = cur.next; // 记录当前节点的下一个节点
            cur.next = pre; // 然后将当前节点指向pre
            pre = cur; // pre和cur节点都前进一位
            cur = tmp;
        }
        return pre;
    }
}
```

##### 反转链表前 N 个节点

这次我们实现一个这样的函数：

```java
ListNode reverseN(ListNode head, int n) // 将链表的前 n 个节点反转（n <= 链表长度） 
```

比如说对于下图链表，执行 reverseN(head, 3)：  
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677499157151-88198723-6151-4579-ae70-e145ee817b0f-20240322174808-uuzorke.png)  
解决思路和反转整个链表差不多，只要稍加修改即可：

```java
public ListNode reverseList(ListNode head, int n) {
    ListNode pre = null, cur = head;
    while (cur != null && n-- > 0) {
        ListNode temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```

##### 92.「 [反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)」

> 给你单链表的头指针 `head`​ 和两个整数 `left`​ 和 `right`​ ，其中 `left <= right`​ 。请你反转从位置 `left`​ 到位置 `right`​ 的链表节点，返回 **反转后的链表** 。
>
> **示例 1：**
>
> ![1677496683462-d6ee262e-9051-41ee-942f-f4269be30cf6](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677496683462-d6ee262e-9051-41ee-942f-f4269be30cf6-20240322174808-ons3bw6.jpeg)​
>
> 输入：head = [1,2,3,4,5], left = 2, right = 4
>
> 输出：[1,4,3,2,5]

第一步：找到待反转节点的前一个节点。 第二步：反转 m 到 n 这部分。 第三步：将反转的起点的 next 指向反转的后面一部分。

第四步：将第一步找到的节点指向反转以后的头节点。 如下图所示：  
​![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677501333848-1d8659c3-3bb4-49ca-ac8c-7cef1bd913e9-20240322174808-szm2swz.png)

```java
public ListNode reverseBetween(ListNode head, int left, int right) {
    ListNode dummy = new ListNode(-1, head);
    ListNode root = dummy;
    for (int i = 1; i < left; i++) { // 找到需要反转的那一段的上一个节点。
        root = root.next;
    }
    ListNode pre = null, cur = root.next; // root.next就是需要反转的这段的起点
    for (int i = left; i <= right; i++) { // 反转m到n这一段
        ListNode temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    root.next.next = cur; // 将反转的起点的next指向next
    root.next = pre; // 需要反转的那一段的上一个节点的next节点指向反转后链表的头结点
    return dummy.next;
}
```

##### 25.「 [K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)」

> 给你链表的头节点 `head`​ ，每 `k`​  个节点一组进行翻转，请你返回修改后的链表。
>
> `k`​ 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k`​  的整数倍，那么请将最后剩余的节点保持原有顺序。
>
> 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
>
> **示例 1：**
>
> ![1677658947414-3f72ccc4-1ab7-4f21-adb6-b48d0ddda2cc](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677658947414-3f72ccc4-1ab7-4f21-adb6-b48d0ddda2cc-20240322174808-tbln3m3.jpeg)​
>
> 输入：head = [1,2,3,4,5], k = 2  
> 输出：[2,1,4,3,5]

认真思考一下可以发现**这个问题具有递归性质**。

什么叫递归性质？直接上图理解，比如说我们对这个链表调用 reverseKGroup(head, 2)，即以 2 个节点为一组反转链表：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677660166161-4c7a5f63-3ac8-4e17-9bb3-a112caa5c55b-20240322174808-cije9ls.png)  
如果我设法把前 2 个节点反转，那么后面的那些节点怎么处理？后面的这些节点也是一条链表，而且规模（长度）比原来这条链表小，这就叫**子问题**。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677660166159-caa1f1c3-d496-43ff-8f0a-2af8dc7edbb6-20240322174809-qq3ea14.png)  
我们可以把原先的 head 指针移动到后面这一段链表的开头，然后继续递归调用 reverseKGroup(head, 2)，因为子问题（后面这部分链表）和原问题（整条链表）的结构完全相同，这就是所谓的递归性质。

发现了递归性质，就可以得到大致的算法流程：

**1、先反转以 head 开头的 k 个元素**。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677660180288-34207e8a-280e-4197-954a-b57c0a97abb8-20240322174809-wopwib3.png)

**2、将第 k + 1 个元素作为 head 递归调用 reverseKGroup 函数**。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677660177212-46c16a8d-c174-4855-bd46-72b26b91529e-20240322174809-fp3cvyo.png)

**3、将上述两个过程的结果连接起来**。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677660172943-434a4556-3a44-432b-84a2-1e712737009e-20240322174810-95bal17.png)  
整体思路就是这样了，最后一点值得注意的是，递归函数都有个 base case，对于这个问题是什么呢？

题目说了，如果最后的元素不足 k 个，就保持不变。这就是 base case，待会会在代码里体现。

---

首先，我们要实现一个 reverse 函数反转一个区间之内的元素。在此之前我们再简化一下，给定链表头结点，如何反转整个链表？

参照 [206.「 反转链表」](#KVR4q)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        //申请节点，pre和 cur，pre指向null
        ListNode pre = null;
        ListNode cur = head;
        ListNode tmp = null;
        while(cur != null) {
            tmp = cur.next; // 记录当前节点的下一个节点
            cur.next = pre; // 然后将当前节点指向pre
            pre = cur; // pre和cur节点都前进一位
            cur = tmp;
        }
        return pre;
    }
}
```

「反转以 a 为头结点的链表」其实就是「反转 a 到 null 之间的结点」，那么如果让你「反转 a 到 b 之间的结点」，你会不会？

只要更改函数签名，并把上面的代码中 null 改成 b 即可：

```java
/** 反转区间 [a, b) 的元素，注意是左闭右开 */
ListNode reverse(ListNode a, ListNode b) {
    ListNode pre, cur, nxt;
    pre = null; cur = a; nxt = a;
    // while 终止的条件改一下就行了
    while (cur != b) {
        nxt = cur.next;
        cur.next = pre;
        pre = cur;
        cur = nxt;
    }
    // 返回反转后的头结点
    return pre;
}
```

现在我们迭代实现了反转部分链表的功能，接下来就按照之前的逻辑编写 reverseKGroup 函数即可：

```java
ListNode reverseKGroup(ListNode head, int k) {
    if (head == null) return null;
    // 区间 [a, b) 包含 k 个待反转元素
    ListNode a, b;
    a = b = head;
    for (int i = 0; i < k; i++) {
        // 不足 k 个，不需要反转，base case
        if (b == null) return head;
        b = b.next;
    }
    // 反转前 k 个元素
    ListNode newHead = reverse(a, b);
    // 递归反转后续链表并连接起来
    a.next = reverseKGroup(b, k);
    return newHead;
}
```

解释一下 for 循环之后的几句代码，注意 reverse 函数是反转区间 [a, b)，所以情形是这样的：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677660510250-4443d9cc-0509-4415-89fb-42ef2eb0ca70-20240322174810-b22h1xp.png)  
递归部分就不展开了，整个函数递归完成之后就是这个结果，完全符合题意：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677660513898-59818247-6498-4376-8dc1-e8028f507fee-20240322174810-4u0mbf7.png)

所以最终解法：

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null) return null;
        // 区间 [a, b) 包含 k 个待反转元素
        ListNode a, b;
        a = b = head;
        for (int i = 0; i < k; i++) {
            // 不足 k 个，不需要反转，base case
            if (b == null) return head;
            b = b.next;
        }
        // 反转前 k 个元素
        ListNode newHead = reverse(a, b);
        // 递归反转后续链表并连接起来
        a.next = reverseKGroup(b, k);

        return newHead;
    }

    /* 反转区间 [a, b) 的元素，注意是左闭右开 */
    ListNode reverse(ListNode a, ListNode b) {

        ListNode pre, cur, nxt;
        pre = null;
        cur = a;
        nxt = a;
        // while 终止的条件改一下就行了
        while (cur != b) {
            nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        // 返回反转后的头结点
        return pre;
    }
}
```

### 回文链表

#### 提纲

**寻找**回文串的核心思想是从中心向两端扩展：

```java
// 在 s 中寻找以 s[left] 和 s[right] 为中心的最长回文串
String palindrome(String s, int left, int right) {
    // 防止索引越界
    while (left >= 0 && right < s.length()
            && s.charAt(left) == s.charAt(right)) {
        // 双指针，向两边展开
        left--;
        right++;
    }
    // 返回以 s[left] 和 s[right] 为中心的最长回文串
    return s.substring(left + 1, right);
}
```

因为回文串长度可能为奇数也可能是偶数，长度为奇数时只存在一个中心点，而长度为偶数时存在两个中心点，所以上面这个函数需要传入 l 和 r。

而**判断**一个字符串是不是回文串就简单很多，不需要考虑奇偶情况，只需要 [双指针技巧](https://labuladong.github.io/algo/di-ling-zh-bfe1b/shuang-zhi-fa4bd/)，从两端向中间逼近即可：

```java
boolean isPalindrome(String s) {
    // 一左一右两个指针相向而行
    int left = 0, right = s.length() - 1;
    while (left < right) {
        if (s.charAt(left) != s.charAt(right)) {
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```

#### 练习题

##### **234. 「**​[回文链表](https://leetcode.cn/problems/palindrome-linked-list/description/?orderBy=hot&languageTags=java)​ **」**

> 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。
>
> **示例 1：**
>
> ![1677832706027-53ea34b7-ffee-47f5-8932-316891294aa6](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677832706027-53ea34b7-ffee-47f5-8932-316891294aa6-20240324205221-ei696m2.jpeg)​
>
> 输入：head = [1,2,2,1]  
> 输出：true

**1、先通过** ****[双指针技巧](https://labuladong.github.io/algo/di-ling-zh-bfe1b/shuang-zhi-0f7cc/)**** **中的快慢指针来找到链表的中点**：

```java
ListNode slow, fast;
slow = fast = head;
while (fast != null && fast.next != null) {
    slow = slow.next;
    fast = fast.next.next;
}
// slow 指针现在指向链表中点
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677832896053-4d4df5e8-322a-418b-8084-8403435eb038-20240324205222-bl3n5wg.png)**2、如果fast指针没有指向null，说明链表长度为奇数，slow还要再前进一步**：

```java
if (fast != null)
    slow = slow.next;
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677832921205-7fa0429b-fe7a-47c4-8f8b-6089333fd182-20240324205222-zta86q4.png)**3、从slow开始反转后面的链表，现在就可以开始比较回文串了**：

```java
ListNode left = head;
ListNode right = reverse(slow);

while (right != null) {
    if (left.val != right.val)
        return false;
    left = left.next;
    right = right.next;
}
return true;
```

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677832963279-60486822-432b-4fd0-912b-d3d32b9ab54d-20240324205222-5rfo912.png)  
至此，把上面 3 段代码合在一起就高效地解决这个问题了，其中 reverse 函数很容易实现：

```java
boolean isPalindrome(ListNode head) {
    ListNode slow, fast;
    slow = fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }
  
    if (fast != null)
        slow = slow.next;
  
    ListNode left = head;
    ListNode right = reverse(slow);
    while (right != null) {
        if (left.val != right.val)
            return false;
        left = left.next;
        right = right.next;
    }
  
    return true;
}

ListNode reverse(ListNode head) {
    ListNode pre = null, cur = head;
    while (cur != null) {
        ListNode next = cur.next;
        cur.next = pre;
        pre = cur;
        cur = next;
    }
    return pre;
}
```

算法过程如下 GIF 所示：

![1677833009098-481f8f7e-f142-4c1b-a7a4-1b84f7c4d0b7](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677833009098-481f8f7e-f142-4c1b-a7a4-1b84f7c4d0b7-20240324205222-cn2bs0r.gif)

算法总体的时间复杂度 O(N)，空间复杂度 O(1)，已经是最优的了。

## 数组

### 数组

#### 练习题

##### **LCR 120.** 「[寻找文件副本](https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/description/)」

> 设备中存有 `n`​ 个文件，文件 `id`​ 记于数组 `documents`​。若文件 `id`​ 相同，则定义为该文件存在副本。请返回任一存在副本的文件 `id`​。
>
> **示例 1：**   
> 输入： [2, 3, 1, 0, 2, 5, 3]  
> 输出：2 或 3

题目说明尚未被充分使用，即在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内。此说明含义：数组元素的索引和值是一对多的关系。 因此，可遍历数组并通过交换操作，使元素的索引与值一一对应（即`nums[i] = i`​）。因而，就能通过索引映射对应的值，起到与字典等价的作用。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677592614198-42119b32-1e15-4b80-8a8b-e1c51a7f3955-20240324211707-pa4vlkg.png)  
遍历中，第一次遇到数字 xxx 时，将其交换至索引 xxx 处；而当第二次遇到数字 xxx 时，一定有`nums[x] = x`​ ，此时即可得到一组重复数字。

**算法流程：**

1. 遍历数组 nums ，设索引初始值为 `i = 0`:

    1. 若`nums[i] = i`​：说明此数字已在对应索引位置，无需交换，因此跳过；
    2. 若`nums[nums[i]] = nums[i]`​：代表索引`nums[i]`​处和索引`i `​处的元素值都为`nums[i]`​，即找到一组重复值，返回此值 `nums[i]`​；
    3. 否则：交换索引为`i`​和 `nums[i]`​的元素值，将此数字交换至对应索引位置。
2. 若遍历完毕尚未返回，则返回 −1。

**复杂度分析：**

时间复杂度 O(N)： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1)。  
空间复杂度 O(1) ： 使用常数复杂度的额外空间。

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677636869055-eb5ccb83-cf15-41de-b630-33fc09cd653e-20240324211707-7b1a20s.gif)

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        int i = 0;
        while(i < nums.length) {
            if(nums[i] == i) {
                i++;
                continue;
            }
            if(nums[nums[i]] == nums[i]) return nums[i];
            int tmp = nums[i];
            nums[i] = nums[tmp];
            nums[tmp] = tmp;
        }
        return -1;
    }
}
```

##### **LCR 121.** 「[寻找目标值 - 二维数组](https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/description/?orderBy=hot)」

> `m`​*`n`​ 的二维数组 `plants`​ 记录了园林景观的植物排布情况，具有以下特性：
>
> - 每行中，每棵植物的右侧相邻植物不矮于该植物；
> - 每列中，每棵植物的下侧相邻植物不矮于该植物。
>
> 请判断 `plants`​ 中是否存在目标高度值 `target`​。
>
> **示例:**
>
> 现有矩阵 matrix 如下：  
> [
> [1,   4,  7, 11, 15],
> [2,   5,  8, 12, 19],
> [3,   6,  9, 16, 22],
> [10, 13, 14, 17, 24],
> [18, 21, 23, 26, 30]  
> ]  
> 给定 target = 5，返回 true。  
> 给定 target = 20，返回 false。

> 若使用暴力法遍历矩阵 matrix ，则时间复杂度为 O(NM) 。暴力法未利用矩阵 “从上到下递增、从左到右递增” 的特点，显然不是最优解法。

如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值 target 。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677645488780-71fd3666-0f6c-42ea-8a28-517ca29cd8be-20240324211707-vq6u4t7.png)

“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 标志数 ，以 matrix 中的 左下角元素 为标志数 flag ，则有:

- 若 flag > target ，则 target 一定在 flag 所在 行的上方 ，即 flag 所在行可被消去。
- 若 flag < target ，则 target 一定在 flag 所在 列的右方 ，即 flag 所在列可被消去。

**算法流程：**

1. 从矩阵 matrix 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比：

    1. 当 matrix[i][j] > target 时，执行 i-- ，即消去第 i 行元素；
    2. 当 matrix[i][j] < target 时，执行 j++ ，即消去第 j 列元素；
    3. 当 matrix[i][j] = target 时，返回 true ，代表找到目标值。
2. 若行索引或列索引越界，则代表矩阵中无目标值，返回 false。

> 每轮 i 或 j 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引(i,j) 指向新矩阵的左下角元素（标志数），因此可重复使用以上性质消去行（列）。

**复杂度分析：**

时间复杂度 O(M+N) ：其中，N 和 M分别为矩阵行数和列数，此算法最多循环 M+N次。

空间复杂度 O(1) : i, j 指针使用常数大小额外空间。

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1677646023637-40499d8f-18ed-4917-b68a-5140493c7b92-20240324211707-vwlxjij.gif)

```java
public boolean findNumberIn2DArray(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }
    int row = matrix.length, col = matrix[0].length;
    int i = 0, j = col - 1;
    while (i < row && j >= 0) {
        if (matrix[i][j] == target) return true;
        else if (matrix[i][j] < target) ++i;
        else --j;
    }
    return false;
}
```

##### **LCR 158.「**​[库存管理 II](https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/description/)」

> 仓库管理员以数组 `stock`​ 形式记录商品库存表。`stock[i]`​ 表示商品 `id`​，可能存在重复。请返回库存表中数量大于 `stock.length / 2`​ 的商品 `id`​。
>
> **示例 1:**   
> 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]  
> 输出: 2

本题常见的三种解法：

- 哈希表统计法： 遍历数组 nums ，用 HashMap 统计各数字的数量，即可找出 众数 。此方法时间和空间复杂度均为 O(N)。
- 数组排序法： 将数组 nums 排序，数组中点的元素 一定为众数。
- 摩尔投票法： 核心理念为 票数正负抵消 。此方法时间和空间复杂度分别为 O(N) 和 O(1) ，为本题的最佳解法。

**摩尔投票法：**

设输入数组 nums 的众数为 x ，数组长度为 n 。

- 推论一： 若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的 票数和 >0。
- 推论二： 若数组的前 a 个数字的 票数和 =0，则 数组剩余 (n−a) 个数字的 票数和一定仍 >0 ，即后 (n−a) 个数字的 众数仍为 x 。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679040448237-3bb044ad-3758-46aa-8df3-2e3871a4b682-20240324211707-r9jp99o.png)  
根据以上推论，记数组首个元素为 ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679040494917-0ac01cdd-ae22-460b-ae20-c1f8d6782568-20240324211707-cqenfni.png)，众数为 x ，遍历并统计票数。当发生 票数和 =0 时，剩余数组的众数一定不变 ，这是由于：

- **当 n1=x ：**  抵消的所有数字中，有一半是众数 *x* 。
- **当 n1≠x：**  抵消的所有数字中，众数 x 的数量最少为 0 个，最多为一半。

利用此特性，每轮假设发生 **票数和 =0** 都可以 **缩小剩余数组区间** 。当遍历完成时，最后一轮假设的数字即为众数。

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679040733494-8b1d29e7-17f6-4d5d-8581-d619cf366eb5-20240324211707-ocgai5v.gif)  
复杂度分析：

- 时间复杂度 O(N)： N 为数组 nums 长度。
- 空间复杂度 O(1)： votes 变量使用常数大小的额外空间。

```java
class Solution {
    public int majorityElement(int[] nums) {
        int x = 0, votes = 0;
        for(int num : nums){
            if(votes == 0) x = num;
            votes += num == x ? 1 : -1;
        }
        return x;
    }
}
```

### 数组双指针

### 前缀和

### 差分数组

### 花式遍历

#### 练习题

##### 48.「 [旋转图像](https://leetcode.cn/problems/rotate-image/)」

> 给定一个 _n _× *n* 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。  
> 你必须在[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95) 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。  
> ​![1675084122169-eaf5362e-ff06-453e-a63a-f6ae10aaa7fb](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675084122169-eaf5362e-ff06-453e-a63a-f6ae10aaa7fb-20240325151702-zqe4rfn.png)
>
> **输入：** matrix = [[1,2,3],[4,5,6],[7,8,9]]
>
> **输出：** [[7,4,1],[8,5,2],[9,6,3]]

常规的思路就是去寻找原始坐标和旋转后坐标的映射规律，但我们是否可以让思维跳跃跳跃，尝试把矩阵进行反转、镜像对称等操作，可能会出现新的突破口。

我们可以先将 n x n 矩阵 matrix 按照左上到右下的对角线进行镜像对称：

![1675059895484-615755d5-7711-43bd-8319-f6a722ae3442](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059895484-615755d5-7711-43bd-8319-f6a722ae3442-20240325151702-8m6ejk3.jpeg)  
然后再对矩阵的每一行进行反转：

![1675059897410-955b3673-f32c-40ce-8a6d-a2457bda2b23](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059897410-955b3673-f32c-40ce-8a6d-a2457bda2b23-20240325151702-c0q5olg.jpeg)  
发现结果就是 matrix 顺时针旋转 90 度的结果：

![1675059897490-9f693de1-8ed2-474d-8580-5c78d1eefee5](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059897490-9f693de1-8ed2-474d-8580-5c78d1eefee5-20240325151702-x64gbjf.jpeg)  
将上述思路翻译成代码，即可解决本题：

```java
// 将二维矩阵原地顺时针旋转 90 度
public void rotate(int[][] matrix) {
  int n = matrix.length;
  // 先沿对角线镜像对称二维矩阵
  for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
      // swap(matrix[i][j], matrix[j][i]);
      int temp = matrix[i][j];
      matrix[i][j] = matrix[j][i];
      matrix[j][i] = temp;
    }
  }
  // 然后反转二维矩阵的每一行
  for (int[] row: matrix) {
    reverse(row);
  }
}

// 反转一维数组
void reverse(int[] arr) {
  int i = 0, j = arr.length - 1;
  while (j > i) {
    // swap(arr[i], arr[j]);
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
    i++;
    j--;
  }
}
```

肯定有读者会问，如果没有做过这道题，怎么可能想到这种思路呢？

仔细想想，旋转二维矩阵的难点在于将「行」变成「列」，将「列」变成「行」，而只有按照对角线的对称操作是可以轻松完成这一点的，对称操作之后就很容易发现规律了。

##### 59.「[螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)」

> 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
>
> 示例:
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240325152841-4mirtfd.png)
>
> 输入: 3
>
> 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

由外向内一圈一圈这么画下去。  
可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是一进循环深似海，从此offer是路人。  
这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。  
那么我按照左闭右开的原则，来画一圈，大家看一下：

![1675059898195-c394245f-f819-4837-b9ac-73479ebe3d83](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675059898195-c394245f-f819-4837-b9ac-73479ebe3d83-20240325151702-dkzntc7.png)  
这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。  
这也是坚持了每条边左闭右开的原则。  
一些同学做这道题目之所以一直写不好，代码越写越乱。  
就是因为在画每一条边的时候，一会左开右闭，一会左闭右闭，一会又来左闭右开，岂能不乱。  
代码如下，已经详细注释了每一步的目的，可以看出while循环里判断的情况是很多的，代码里处理的原则也是统一的左闭右开。

```java
class Solution {
  public int[][] generateMatrix(int n) {
    int[][] res = new int[n][n];
    circle(res, 0, 0, n - 1, n - 1, 1);
    return res;
  }
  
  private void circle(int[][] res, int x1, int y1, int x2, int y2, int start) {
    if (x1 > x2 || y1 > y2) return;
  
    if (x1 == x2) { // 只剩下 y1 --> y2
      for (int i = y1; i <= y2; i++) {
        res[x1][i] = start++;
      }
      return;
    }
    if (y1 == y2) { // 只剩下 x1 --> x2
      for (int i = x1; i <= x2; i++) {
        res[i][y1] = start++;
      }
      return;
    }
    // 按照 右 --> 下 --> 左 --> 上 的顺序遍历
    for (int i = y1; i < y2; i++) res[x1][i] = start++;
    for (int i = x1; i < x2; i++) res[i][y2] = start++;
    for (int i = y2; i > y1; i--) res[x2][i] = start++;
    for (int i = x2; i > x1; i--) res[i][y1] = start++;
  
    circle(res, x1 + 1, y1 + 1, x2 - 1, y2 - 1, start); // 缩小圈
  }
}
```

##### 54.「 [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)」

> 给你一个 m 行 n 列的矩阵 matrix ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。
>
> ![1675084280402-0368d77f-83b6-42df-917b-a3d48ab690ca](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1675084280402-0368d77f-83b6-42df-917b-a3d48ab690ca-20240325151702-ii1rvjf.png)
>
> **输入：** matrix = [[1,2,3],[4,5,6],[7,8,9]]
>
> **输出：** [1,2,3,6,9,8,7,4,5]

```java
class Solution {
  public List < Integer > spiralOrder(int[][] matrix) {
    List < Integer > res = new LinkedList < > ();
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
      return res;
    }
    circle(matrix, 0, 0, matrix.length - 1, matrix[0].length - 1, res);
    return res;
  }
  private void circle(int[][] matrix, int x1, int y1, int x2, int y2, List < Integer > res) {
    if (x1 > x2 || y1 > y2) return;
    if (x1 == x2) { // 只剩下y1 -> y2
      for (int i = y1; i <= y2; i++) {
        res.add(matrix[x1][i]);
      }
      return;
    }
    if (y1 == y2) { // 只剩下x1 -> x2
      for (int i = x1; i <= x2; i++) {
        res.add(matrix[i][y1]);
      }
      return;
    }
    for (int i = y1; i < y2; i++) res.add(matrix[x1][i]); // 右
    for (int i = x1; i < x2; i++) res.add(matrix[i][y2]); // 下
    for (int i = y2; i > y1; i--) res.add(matrix[x2][i]); // 左
    for (int i = x2; i > x1; i--) res.add(matrix[i][y1]); // 上
    circle(matrix, x1 + 1, y1 + 1, x2 - 1, y2 - 1, res); // 缩小范围
  }
}
```

### 滑动窗口

### 二分查找

### 前缀和

### 单调栈

### 数组设计类

## 二叉树

### 二叉树纲领

### 二叉树思路

先复述一下前文总结的二叉树解题总纲：

二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

本文就以几道比较简单的题目为例，带你实践运用这几条总纲，理解「遍历」的思维和「分解问题」的思维有何区别和联系。

#### 练习题

##### 226.「 [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)」

> 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。
>
> **示例 1：**
>
> ![1680359029731-0e7b108c-578d-4e5e-b443-894f86211cd8](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680359029731-0e7b108c-578d-4e5e-b443-894f86211cd8-20240325173930-9mgo5z3.jpeg)​
>
> 输入：root = [4,2,7,1,3,6,9]  
> 输出：[4,7,2,9,6,3,1]

那么现在开始在心中默念二叉树解题总纲：

**1、这题能不能用「遍历」的思维模式解决**？

可以，我写一个 traverse 函数遍历每个节点，让每个节点的左右子节点颠倒过来就行了。

单独抽出一个节点，需要让它做什么？让它把自己的左右子节点交换一下。

需要在什么时候做？好像前中后序位置都可以。

综上，可以写出如下解法代码：

```java
// 主函数
TreeNode invertTree(TreeNode root) {
    // 遍历二叉树，交换每个节点的子节点
    traverse(root);
    return root;
}

// 二叉树遍历函数
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }

    /**** 前序位置 ****/
    // 每一个节点需要做的事就是交换它的左右子节点
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;

    // 遍历框架，去遍历左右子树的节点
    traverse(root.left);
    traverse(root.right);
}

```

你把前序位置的代码移到后序位置也可以，但是直接移到中序位置是不行的，需要稍作修改，这应该很容易看出来吧，我就不说了。

按理说，这道题已经解决了，不过为了对比，我们再继续思考下去。

**2、这题能不能用「分解问题」的思维模式解决**？

我们尝试给 invertTree 函数赋予一个定义：

```java
// 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点
TreeNode invertTree(TreeNode root);
```

然后思考，对于某一个二叉树节点 x 执行 invertTree(x)，你能利用这个递归函数的定义做点啥？

我可以用 invertTree(x.left) 先把 x 的左子树翻转，再用 invertTree(x.right) 把 x 的右子树翻转，最后把 x 的左右子树交换，这恰好完成了以 x 为根的整棵二叉树的翻转，即完成了 invertTree(x) 的定义。

直接写出解法代码：

```java
// 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点
TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    // 利用函数定义，先翻转左右子树
    TreeNode left = invertTree(root.left);
    TreeNode right = invertTree(root.right);

    // 然后交换左右子节点
    root.left = right;
    root.right = left;

    // 和定义逻辑自恰：以 root 为根的这棵二叉树已经被翻转，返回 root
    return root;
}
```

这种「分解问题」的思路，核心在于你要给递归函数一个合适的定义，然后用函数的定义来解释你的代码；如果你的逻辑成功自恰，那么说明你这个算法是正确的。

##### 116.「 [填充每个二叉树节点的右侧指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)」

> 给定一个 **完美二叉树**，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```java
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。  
> 初始状态下，所有 next 指针都被设置为 NULL。
>
> **示例 1：**
>
> ![1680360266275-99780e2e-9c41-4a7f-a9fd-86b88619a6b1](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680360266275-99780e2e-9c41-4a7f-a9fd-86b88619a6b1-20240325173930-g4a8j68.png)
>
> 输入：root = [1,2,3,4,5,6,7]  
> 输出：[1,\#,2,3,\#,4,5,6,7,\#]
>
> 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。

**1、这题能不能用「遍历」的思维模式解决**？

很显然，一定可以。

每个节点要做的事也很简单，把自己的 next 指针指向右侧节点就行了。

也许你会模仿上一道题，直接写出如下代码：

```java
// 二叉树遍历函数
void traverse(Node root) {
    if (root == null || root.left == null) {
        return;
    }
    // 把左子节点的 next 指针指向右子节点
    root.left.next = root.right;

    traverse(root.left);
    traverse(root.right);
}
```

节点 5 和节点 6 不属于同一个父节点，那么按照这段代码的逻辑，它俩就没办法被穿起来，这是不符合题意的，但是问题出在哪里？

**传统的 traverse 函数是遍历二叉树的所有节点，但现在我们想遍历的其实是两个相邻节点之间的「空隙」** 。

所以我们需要连接跨越父节点的两个子节点

```java
// 主函数
Node connect(Node root) {
    if (root == null) return null;
    // 遍历「三叉树」，连接相邻节点
    traverse(root.left, root.right);
    return root;
}

// 三叉树遍历框架
void traverse(Node node1, Node node2) {
    if (node1 == null || node2 == null) {
        return;
    }
    /**** 前序位置 ****/
    // 将传入的两个节点穿起来
    node1.next = node2;
  
    // 连接相同父节点的两个子节点
    traverse(node1.left, node1.right);
    traverse(node2.left, node2.right);
    // 连接跨越父节点的两个子节点
    traverse(node1.right, node2.left);
}
```

**2、这题能不能用「分解问题」的思维模式解决**？

嗯，好像没有什么特别好的思路，所以这道题无法使用「分解问题」的思维来解决。

##### 114.「 [将二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)」

> 给你二叉树的根结点 root ，请你将它展开为一个单链表：
>
> - 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
> - 展开后的单链表应该与二叉树 [先序遍历](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin) 顺序相同。
>
> **示例 1：**   
> ​![1680531799378-db25231d-ecd4-4b1b-a762-e2a0224b3f72](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680531799378-db25231d-ecd4-4b1b-a762-e2a0224b3f72-20240325173930-ovae6cq.jpeg)  
> 输入：root = [1,2,5,3,4,null,6]  
> 输出：[1,null,2,null,3,null,4,null,5,null,6]

前文 [手把手刷二叉树总结篇](https://labuladong.github.io/article/fname.html?fname=%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93) 说过二叉树的递归分为「遍历」和「分解问题」两种思维模式，这道题需要用到「分解问题」的思维。

前者较简单，只要运用二叉树的递归遍历框架即可；后者的关键在于明确递归函数的定义，然后利用这个定义，这题就属于后者，flatten 函数的定义如下：

**给 flatten 函数输入一个节点 root，那么以 root 为根的二叉树就会被拉平为一条链表**。

如何利用这个定义来完成算法？你想想怎么把以 root 为根的二叉树拉平为一条链表？

很简单，以下流程：

1、将 root 的左子树和右子树拉平。

2、将 root 的右子树接到左子树下方，然后将整个左子树作为右子树。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1696758547885-8bd6fd81-9c83-4a07-98c3-560fb14f341d-20240325173931-m9uh1se.png)  
至于如何把 root 的左右子树拉平，不用你操心，flatten 函数的定义就是这样，交给他做就行了。

把上面的逻辑翻译成代码，即可解决本题。

```java
class Solution {
    public void flatten(TreeNode root) {
        if (root == null) return;
        flatten(root.left); // 递归拉平左子树
        flatten(root.right); // 递归拉平右子树

        // 后序遍历位置
        TreeNode left = root.left;
        TreeNode right = root.right;

        // 1.左子树覆盖右子树
        root.left = null;
        root.right = left;
        // 2.将原来的右子树，连接到当前右子树最右节点
        TreeNode p = root;
        while (p.right != null) {
            p = p.right;
        }
        p.right = right;
    }
}
```

### 二叉树构造

#### 提纲

先复述一下前文总结的二叉树解题总纲：

二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

**二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。

接下来直接看题。

#### 练习题

##### 654.「 [最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)」

> 给定一个不重复的整数数组 nums 。 **最大二叉树** 可以用下面的算法从 nums 递归地构建:
>
> 1. 创建一个根节点，其值为 nums 中的最大值。
> 2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
> 3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。
>
> 返回 *​`nums`​*​ *构建的* ***最大二叉树***  ****   。
>
> **示例 1：**   
> ​![1680672308047-c6e0c0eb-7909-45ec-8e04-bdc70b5668b4](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680672308047-c6e0c0eb-7909-45ec-8e04-bdc70b5668b4-20240325184328-mlfn22e.jpeg)​
>
> 输入：nums = [3,2,1,6,0,5]  
> 输出：[6,3,5,null,2,0,null,null,1]
>
> 解释：递归调用如下所示：
>
> - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
> - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
    >   -空数组，无子节点。
> - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
> - 空数组，无子节点。
> - 只有一个元素，所以子节点是一个值为 1 的节点。
> - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
> - 只有一个元素，所以子节点是一个值为 0 的节点。
> - 空数组，无子节点。

每个二叉树节点都可以认为是一棵子树的根节点，对于根节点，首先要做的当然是把想办法把自己先构造出来，然后想办法构造自己的左右子树。

所以，我们要遍历数组把找到最大值 maxVal，从而把根节点 root 做出来，然后对 maxVal 左边的数组和右边的数组进行递归构建，作为 root 的左右子树。

按照题目给出的例子，输入的数组为 [3,2,1,6,0,5]，对于整棵树的根节点来说，其实在做这件事：

```java
TreeNode constructMaximumBinaryTree(int[] nums) {
    if (nums is empty) return null;
    // 找到数组中的最大值
    int maxVal = Integer.MIN_VALUE;
    int index = 0;
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > maxVal) {
            maxVal = nums[i];
            index = i;
        }
    }

    TreeNode root = new TreeNode(maxVal);
    // 递归调用构造左右子树
    root.left = constructMaximumBinaryTree(nums[0..index-1]);
    root.right = constructMaximumBinaryTree(nums[index+1..nums.length-1]);
    return root;
}
```

**当前 nums 中的最大值就是根节点，然后根据索引递归调用左右数组构造左右子树即可**。

明确了思路，我们可以重新写一个辅助函数 build，来控制 nums 的索引：

```java
/* 主函数 */
TreeNode constructMaximumBinaryTree(int[] nums) {
    return build(nums, 0, nums.length - 1);
}

// 定义：将 nums[lo..hi] 构造成符合条件的树，返回根节点
TreeNode build(int[] nums, int lo, int hi) {
    // base case
    if (lo > hi) {
        return null;
    }

    // 找到数组中的最大值和对应的索引
    int index = -1, maxVal = Integer.MIN_VALUE;
    for (int i = lo; i <= hi; i++) {
        if (maxVal < nums[i]) {
            index = i;
            maxVal = nums[i];
        }
    }

    // 先构造出根节点
    TreeNode root = new TreeNode(maxVal);
    // 递归调用构造左右子树
    root.left = build(nums, lo, index - 1);
    root.right = build(nums, index + 1, hi);
  
    return root;
}
```

##### 105.「 [从前序和中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)」

> 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的**先序遍历**， inorder 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。
>
> **示例 1:**
>
> ![1680674158978-3d6af0cb-4f95-49a6-909a-1cf473dc17b4](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680674158978-3d6af0cb-4f95-49a6-909a-1cf473dc17b4-20240325184328-mih4w3u.jpeg)​
>
> 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]  
> 输出: [3,9,20,null,null,15,7]

**我们肯定要想办法确定根节点的值，把根节点做出来，然后递归构造左右子树即可**。

preorder 和 inorder 数组中的元素分布有如下特点：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680679622518-88aa103a-5e03-4687-a577-ff53e8fcd7aa-20240325184328-6gf5e2k.png)  
找到根节点是很简单的，前序遍历的第一个值 preorder[0] 就是根节点的值。

关键在于如何通过根节点的值，将 preorder 和 inorder 数组划分成两半，构造根节点的左右子树？

换句话说，对于以下代码中的 ? 部分应该填入什么：

```java
/* 主函数 */
public TreeNode buildTree(int[] preorder, int[] inorder) {
    // 根据函数定义，用 preorder 和 inorder 构造二叉树
    return build(preorder, 0, preorder.length - 1,
                 inorder, 0, inorder.length - 1);
}

/* 
    build 函数的定义：
    若前序遍历数组为 preorder[preStart..preEnd]，
    中序遍历数组为 inorder[inStart..inEnd]，
    构造二叉树，返回该二叉树的根节点 
*/
TreeNode build(int[] preorder, int preStart, int preEnd, 
               int[] inorder, int inStart, int inEnd) {
    // root 节点对应的值就是前序遍历数组的第一个元素
    int rootVal = preorder[preStart];
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }

    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(preorder, ?, ?,
                      inorder, ?, ?);

    root.right = build(preorder, ?, ?,
                       inorder, ?, ?);
    return root;
}
```

对于代码中的 rootVal 和 index 变量，就是下图这种情况：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680679666768-382ccd09-3958-443a-bda0-2b5dd5fe05f5-20240325184328-ow0qrlo.png)  
另外，也有读者注意到，通过 for 循环遍历的方式去确定 index 效率不算高，可以进一步优化。

因为题目说二叉树节点的值不存在重复，所以可以使用一个 HashMap 存储元素到索引的映射，这样就可以直接通过 HashMap 查到 rootVal 对应的 index：

```java
// 存储 inorder 中值到索引的映射
HashMap<Integer, Integer> valToIndex = new HashMap<>();

public TreeNode buildTree(int[] preorder, int[] inorder) {
    for (int i = 0; i < inorder.length; i++) {
        valToIndex.put(inorder[i], i);
    }
    return build(preorder, 0, preorder.length - 1,
                 inorder, 0, inorder.length - 1);
}


TreeNode build(int[] preorder, int preStart, int preEnd, 
               int[] inorder, int inStart, int inEnd) {
    int rootVal = preorder[preStart];
    // 避免 for 循环寻找 rootVal
    int index = valToIndex.get(rootVal);
    // ...
}
```

现在我们来看图做填空题，下面这几个问号处应该填什么：

```java
root.left = build(preorder, ?, ?,
                  inorder, ?, ?);

root.right = build(preorder, ?, ?,
                   inorder, ?, ?);
```

对于左右子树对应的 inorder 数组的起始索引和终止索引比较容易确定：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680679705591-9784bceb-64e7-44ea-be69-0caf477819c7-20240325184328-ztieffc.png)

```java
root.left = build(preorder, ?, ?,
                  inorder, inStart, index - 1);

root.right = build(preorder, ?, ?,
                   inorder, index + 1, inEnd);
```

对于 preorder 数组呢？如何确定左右数组对应的起始索引和终止索引？

这个可以通过左子树的节点数推导出来，假设左子树的节点数为 leftSize，那么 preorder 数组上的索引情况是这样的：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680679734132-854948cf-5190-4fda-be32-5bb0c220966c-20240325184329-syshz6t.png)  
看着这个图就可以把 preorder 对应的索引写进去了：

```java
int leftSize = index - inStart;

root.left = build(preorder, preStart + 1, preStart + leftSize,
                  inorder, inStart, index - 1);

root.right = build(preorder, preStart + leftSize + 1, preEnd,
                   inorder, index + 1, inEnd);
```

至此，整个算法思路就完成了，我们再补一补 base case 即可写出解法代码：

```java
TreeNode build(int[] preorder, int preStart, int preEnd, 
               int[] inorder, int inStart, int inEnd) {
    
    if (preStart > preEnd) {
        return null;
    }

    // root 节点对应的值就是前序遍历数组的第一个元素
    int rootVal = preorder[preStart];
    // rootVal 在中序遍历数组中的索引
    int index = valToIndex.get(rootVal);

    int leftSize = index - inStart;

    // 先构造出当前根节点
    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(preorder, preStart + 1, preStart + leftSize,
                      inorder, inStart, index - 1);

    root.right = build(preorder, preStart + leftSize + 1, preEnd,
                       inorder, index + 1, inEnd);
    return root;
}
```

##### 106.「 [从后序和中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)」

> 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。
>
> **示例 1:**
>
> ![1680680323380-e3545d1b-a990-4679-bab5-fc7effa769ce](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680680323380-e3545d1b-a990-4679-bab5-fc7effa769ce-20240325184329-j01qz9z.jpeg)​
>
> 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]  
> 输出：[3,9,20,null,null,15,7]

postorder 和 inorder 数组中的元素分布有如下特点：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680681778079-03a15ebc-ff5b-4425-9047-91d9727eae36-20240325184329-1fcp5rg.png)  
这道题和上一题的关键区别是，后序遍历和前序遍历相反，根节点对应的值为 postorder 的最后一个元素。

整体的算法框架和上一题非常类似，我们依然写一个辅助函数 build：

```java
// 存储 inorder 中值到索引的映射
HashMap<Integer, Integer> valToIndex = new HashMap<>();

TreeNode buildTree(int[] inorder, int[] postorder) {
    for (int i = 0; i < inorder.length; i++) {
        valToIndex.put(inorder[i], i);
    }
    return build(inorder, 0, inorder.length - 1,
                 postorder, 0, postorder.length - 1);
}

/* 
    build 函数的定义：
    后序遍历数组为 postorder[postStart..postEnd]，
    中序遍历数组为 inorder[inStart..inEnd]，
    构造二叉树，返回该二叉树的根节点 
*/
TreeNode build(int[] inorder, int inStart, int inEnd,
               int[] postorder, int postStart, int postEnd) {
    // root 节点对应的值就是后序遍历数组的最后一个元素
    int rootVal = postorder[postEnd];
    // rootVal 在中序遍历数组中的索引
    int index = valToIndex.get(rootVal);

    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(preorder, ?, ?,
                      inorder, ?, ?);

    root.right = build(preorder, ?, ?,
                       inorder, ?, ?);
    return root;
}
```

现在 postoder 和 inorder 对应的状态如下：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680681818324-b8aa2fe3-56fa-4b75-8679-bb3d69966d7b-20240325184329-h2e3dut.png)  
我们可以按照上图将问号处的索引正确填入：

```java
int leftSize = index - inStart;

root.left = build(inorder, inStart, index - 1,
                  postorder, postStart, postStart + leftSize - 1);

root.right = build(inorder, index + 1, inEnd,
                   postorder, postStart + leftSize, postEnd - 1);
```

综上，可以写出完整的解法代码：

```java
TreeNode build(int[] inorder, int inStart, int inEnd,
               int[] postorder, int postStart, int postEnd) {

    if (inStart > inEnd) {
        return null;
    }
    // root 节点对应的值就是后序遍历数组的最后一个元素
    int rootVal = postorder[postEnd];
    // rootVal 在中序遍历数组中的索引
    int index = valToIndex.get(rootVal);
    // 左子树的节点个数
    int leftSize = index - inStart;
    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(inorder, inStart, index - 1,
                        postorder, postStart, postStart + leftSize - 1);
  
    root.right = build(inorder, index + 1, inEnd,
                        postorder, postStart + leftSize, postEnd - 1);
    return root;
}
```

##### 889.「 [根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)」

> 给定两个整数数组，preorder 和 postorder ，其中 preorder 是一个具有 **无重复** 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。
>
> 如果存在多个答案，您可以返回其中 **任何** 一个。
>
> **示例 1：**
>
> ![1680684016842-8ea5105f-0d00-4a70-82ea-5e38fd5ee952](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680684016842-8ea5105f-0d00-4a70-82ea-5e38fd5ee952-20240325184329-u5az6ck.jpeg)​
>
> 输入：preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]  
> 输出：[1,2,3,4,5,6,7]

这道题和前两道题有一个本质的区别：

**通过前序中序，或者后序中序遍历结果可以确定唯一一棵原始二叉树，但是通过前序后序遍历结果无法确定唯一的原始二叉树**。

题目也说了，如果有多种可能的还原结果，你可以返回任意一种。

为什么呢？我们说过，构建二叉树的套路很简单，先找到根节点，然后找到并递归构造左右子树即可。

前两道题，可以通过前序或者后序遍历结果找到根节点，然后根据中序遍历结果确定左右子树（题目说了树中没有 val 相同的节点）。

这道题，你可以确定根节点，但是无法确切的知道左右子树有哪些节点。

举个例子，比如给你这个输入：

```java
preorder = [1,2,3], postorder = [3,2,1]
```

下面这两棵树都是符合条件的，但显然它们的结构不同：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680686613424-e9afcc8e-d677-4cbb-b60e-5322e3646c73-20240325184329-zker79m.png)  
不过话说回来，用后序遍历和前序遍历结果还原二叉树，解法逻辑上和前两道题差别不大，也是通过控制左右子树的索引来构建：

**1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值**。

**2、然后把前序遍历结果的第二个元素作为左子树的根节点的值**。

**3、在后序遍历结果中寻找左子树根节点的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可**。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1680686573797-a61c3060-1998-4d1a-9d50-632867db794c-20240325184330-rffrc3o.png)

```java
class Solution {
    // 存储 postorder 中值到索引的映射
    HashMap<Integer, Integer> valToIndex = new HashMap<>();

    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        for (int i = 0; i < postorder.length; i++) {
            valToIndex.put(postorder[i], i);
        }
        return build(preorder, 0, preorder.length - 1,
                    postorder, 0, postorder.length - 1);
    }

    // 定义：根据 preorder[preStart..preEnd] 和 postorder[postStart..postEnd]
    // 构建二叉树，并返回根节点。
    TreeNode build(int[] preorder, int preStart, int preEnd,
                   int[] postorder, int postStart, int postEnd) {
        if (preStart > preEnd) {
            return null;
        }
        if (preStart == preEnd) { // 防止后面preorder[preStart + 1]数组越界
            return new TreeNode(preorder[preStart]);
        }

        // root 节点对应的值就是前序遍历数组的第一个元素
        int rootVal = preorder[preStart];
        // root.left 的值是前序遍历第二个元素
        // 通过前序和后序遍历构造二叉树的关键在于通过左子树的根节点
        // 确定 preorder 和 postorder 中左右子树的元素区间
        int leftRootVal = preorder[preStart + 1];
        // leftRootVal 在后序遍历数组中的索引
        int index = valToIndex.get(leftRootVal);
        // 左子树的元素个数
        int leftSize = index - postStart + 1;

        // 先构造出当前根节点
        TreeNode root = new TreeNode(rootVal);
        // 递归构造左右子树
        // 根据左子树的根节点索引和元素个数推导左右子树的索引边界
        root.left = build(preorder, preStart + 1, preStart + leftSize,
                postorder, postStart, index);
        root.right = build(preorder, preStart + leftSize + 1, preEnd,
                postorder, index + 1, postEnd - 1);

        return root;
    }
}
```

代码和前两道题非常类似，我们可以看着代码思考一下，为什么通过前序遍历和后序遍历结果还原的二叉树可能不唯一呢？

关键在这一句：

```
int leftRootVal = preorder[preStart + 1];
```

我们假设前序遍历的第二个元素是左子树的根节点，但实际上左子树有可能是空指针，那么这个元素就应该是右子树的根节点。由于这里无法确切进行判断，所以导致了最终答案的不唯一。

至此，通过前序和后序遍历结果还原二叉树的问题也解决了。

最后呼应下前文，**二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树**。先找出根节点，然后根据根节点的值找到左右子树的元素，进而递归构建出左右子树。

### 二叉树-后序

关于后序遍历的描述：

前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。

**那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。

#### 练习题

##### 652.「[寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)」

> 给你一棵二叉树的根节点 root ，返回所有 **重复的子树**。
>
> 对于同一类的重复子树，你只需要返回其中任意 **一棵**​****的根结点即可。如果两棵树具有**** **相同的结构** 和 **相同的结点值**，则认为二者是 **重复**的。
>
> **示例 1：**
>
> ![1684478320518-e9a4578e-6f80-4d7b-a2db-d0530b2b8cb8](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684478320518-e9a4578e-6f80-4d7b-a2db-d0530b2b8cb8-20240327163058-5c5lzye.jpeg)​
>
> 输入：root = [1,2,3,4,null,2,4,null,null,4]  
> 输出：[[2,4],[4]]

我来简单解释下题目，输入是一棵二叉树的根节点 root，返回的是一个列表，里面装着若干个二叉树节点，这些节点对应的子树在原二叉树中是存在重复的。

说起来比较绕，举例来说，比如输入如下的二叉树：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684479079457-5c7f81e3-9470-4889-9cf7-0450cbb5ec9a-20240327163058-bcor2kq.png)  
首先，节点 4 本身可以作为一棵子树，且二叉树中有多个节点 4：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684479095760-f2fbdf77-ff48-498a-98f9-0ea3b2b9e787-20240327163058-eo3pnpq.png)  
类似的，还存在两棵以 2 为根的重复子树：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684479112637-6c6b3694-6513-483d-b7f2-a6938a5a9c51-20240327163058-zxri3y8.png)  
那么，我们返回的 List 中就应该有两个 TreeNode，值分别为 4 和 2（具体是哪个节点都无所谓）。

这题咋做呢？**还是老套路，先思考，对于某一个节点，它应该做什么**。

比如说，你站在图中这个节点 2 上：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684479130091-8221c5bf-93ba-4a89-8ef8-c5a81e876d47-20240327163058-hx8fq2u.png)  
如果你想知道以自己为根的子树是不是重复的，是否应该被加入结果列表中，你需要知道什么信息？

**你需要知道以下两点**：

**1、以我为根的这棵二叉树（子树)长啥样**？

**2、以其他节点为根的子树都长啥样**？

这就叫知己知彼嘛，我得知道自己长啥样，还得知道别人长啥样，然后才能知道有没有人跟我重复，对不对？好，那我们一个一个来看。

**首先来思考，我如何才能知道以自己为根的这棵二叉树长啥样**？

其实想到这里，就可以判断本题需要在二叉树的后序位置写代码了。

为什么？很简单呀，我要知道以自己为根的子树长啥样，是不是得先知道我的左右子树长啥样，再加上自己，就构成了整棵子树的样子？左右子树的样子，可不就得在后序位置通过递归函数的返回值传递回来吗？

如果你还绕不过来，我再来举个非常简单的例子：计算一棵二叉树有多少个节点。这个代码应该会写吧：

```java
int count(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 先算出左右子树有多少节点
    int left = count(root.left);
    int right = count(root.right);
    // 后序位置，子树加上自己，就是整棵二叉树的节点数
    int res = left + right + 1;
    return res;
}
```

这不就是标准的后序遍历框架嘛，和我们本题在本质上没啥区别对吧。

现在，明确了要用后序遍历，那应该怎么描述一棵二叉树的模样呢？我们前文 [序列化和反序列化二叉树](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_62987967e4b0812e17a1c2f7/1) 其实写过了，二叉树的前序/中序/后序/层序遍历结果可以描述二叉树的结构。

那么，我就以后序遍历结果作为序列化结果吧，可以通过拼接字符串的方式把二叉树序列化，看下代码：

```java
// 定义：输入以 root 为根的二叉树，返回这棵树的序列化字符串
String serialize(TreeNode root) {
    // 对于空节点，可以用一个特殊字符表示
    if (root == null) {
        return "#";
    }
    // 将左右子树序列化成字符串
    String left = serialize(root.left);
    String right = serialize(root.right);
    /* 后序遍历代码位置 */
    // 左右子树加上自己，就是以自己为根的二叉树序列化结果
    String myself = left + "," + right + "," + root.val;
    return myself;
}
```

我们用非数字的特殊符 # 表示空指针，并且用字符 , 分隔每个二叉树节点值，这属于序列化二叉树的套路了，不多说。

注意我们 myself 是按照左子树、右子树、根节点这样的顺序拼接字符串，也就是后序遍历顺序。因为我们这里的目的是通过序列化唯一描述一棵二叉树的结构，所以你也可以用前序顺序来拼接字符串，但是注意不能用中序顺序，具体原因参见前文 [序列化和反序列化二叉树](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_62987967e4b0812e17a1c2f7/1) 的总结。

这样，我们第一个问题就解决了，对于每个节点，递归函数中的 myself 变量就可以描述以该节点为根的二叉树。

**现在我们解决第二个问题，我知道了自己长啥样，怎么知道别人长啥样**？这样我才能知道有没有其他子树跟我重复对吧。

这很简单呀，我们借助一个外部数据结构，让每个节点把自己子树的序列化结果存进去，这样，对于每个节点，不就可以知道有没有其他节点的子树和自己重复了么？

初步思路可以使用 HashSet 记录所有子树的序列化结果，代码如下：

```java
// 记录所有子树
HashSet<String> subTrees = new HashSet<>();
// 记录重复的子树根节点
LinkedList<TreeNode> res = new LinkedList<>();

String serialize(TreeNode root) {
    if (root == null) {
        return "#";
    }

    // 左右子树的序列化结果
    String left = serialize(root.left);
    String right = serialize(root.right);

    // 后序位置，计算以自己为根的二叉树序列化结果
    String myself = left + "," + right+ "," + root.val;
    if (subTrees.contains(myself)) {
        // 有人和我重复，把自己加入结果列表
        res.add(root);
    } else {
        // 暂时没人跟我重复，把自己加入子树集合
        subTrees.add(myself);
    }
    return myself;
}
```

但是呢，这有个问题，如果出现多棵重复的子树，结果集 res 中必然出现重复，而题目要求不希望出现重复。

为了解决这个问题，可以把 HashSet 升级成 HashMap，额外记录每棵子树的出现次数：

```java
class Solution {
    // 记录所有子树以及出现的次数
    HashMap<String, Integer> subTrees = new HashMap<>();
    // 记录重复的子树根节点
    LinkedList<TreeNode> res = new LinkedList<>();

    /* 主函数 */
    List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        serialize(root);
        return res;
    }

    /* 辅助函数 */
    String serialize(TreeNode root) {
        if (root == null) {
            return "#";
        }

        // 先算左右子树的序列化结果
        String left = serialize(root.left);
        String right = serialize(root.right);

        String myself = left + "," + right+ "," + root.val;

        int freq = subTrees.getOrDefault(myself, 0);
        // 多次重复也只会被加入结果集一次
        if (freq == 1) {
            res.add(root);
        }
        // 给子树对应的出现次数加一
        subTrees.put(myself, freq + 1);
        return myself;
    }
}
```

这样，这道题就完全解决了，题目本身算不上难，最后照应一下开头吧：

前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。

那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。

### 二叉树-序列化

要说序列化和反序列化，得先从 JSON 数据格式说起。

JSON 的运用非常广泛，比如我们经常将变成语言中的结构体序列化成 JSON 字符串，存入缓存或者通过网络发送给远端服务，消费者接受 JSON 字符串然后进行反序列化，就可以得到原始数据了。

这就是序列化和反序列化的目的，以某种特定格式组织数据，使得数据可以独立于编程语言。

那么假设现在有一棵用 Java 实现的二叉树，我想把它通过某些方式存储下来，然后用 C++ 读取这棵并还原这棵二叉树的结构，怎么办？这就需要对二叉树进行序列化和反序列化了。

#### 零、前/中/后序和二叉树的唯一性

谈具体的题目之前，我们先思考一个问题：**什么样的序列化的数据可以反序列化出唯一的一棵二叉树**？

比如说，如果给你一棵二叉树的前序遍历结果，你是否能够根据这个结果还原出这棵二叉树呢？

答案是也许可以，也许不可以，具体要看你给的前序遍历结果是否包含空指针的信息。如果包含了空指针，那么就可以唯一确定一棵二叉树，否则就不行。

举例来说，如果我给你这样一个不包含空指针的前序遍历结果 [1,2,3,4,5]，那么如下两棵二叉树都是满足这个前序遍历结果的：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684393841670-e557908a-c097-420c-bf6d-cde1f7408707-20240327170828-0n1jsvz.png)  
但如果我的前序遍历结果包含空指针的信息，那么就能还原出唯一的一棵二叉树了。比如说用 # 表示空指针，上图左侧的二叉树的前序遍历结果就是[1,2,3,\#,\#,4,\#,\#,5,\#,\#]，上图右侧的二叉树的前序遍历结果就是 [1,2,\#,3,\#,\#,4,5,\#,\#,\#]，它俩就区分开了。

那么估计就有聪明的小伙伴说了：东哥我懂了，甭管是前中后序哪一种遍历顺序，只要序列化的结果中包含了空指针的信息，就能还原出唯一的一棵二叉树了。

首先要夸一下这种举一反三的思维，但很不幸，正确答案是，即便你包含了空指针的信息，也只有前序和后序的遍历结果才能唯一还原二叉树，中序遍历结果做不到。

本文后面会具体探讨这个问题，这里只简单说下原因：因为前序/后序遍历的结果中，可以确定根节点的位置，而中序遍历的结果中，根节点的位置是无法确定的。

更直观的，比如如下两棵二叉树显然拥有不同的结构，但它俩的中序遍历结果都是 [\#,1,\#,1,\#] ，无法区分

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684393891658-db82ccb2-9012-4070-ba7e-df240cb0aec6-20240327170828-9ttdpbl.png)**说了这么多，总结下结论**：

1. 如果你的序列化结果中**不包含空指针的信息**，且你只给出**一种**遍历顺序，那么你无法还原出唯一的一棵二叉树。
2. 如果你的序列化结果中**不包含空指针的信息**，且你会给出**两种**遍历顺序，那么按照前文 [东哥手把手带你刷二叉树（构造篇）](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_63a84e1ce4b0fc5d121bba25/1) 所说，分两种情况：

    1. 如果你给出的是前序和中序，或者后序和中序，那么你可以还原出唯一的一棵二叉树。
    2. 如果你给出前序和后序，那么除非你的整棵树中不包含值相同的节点，否则你无法还原出唯一的一棵二叉树。
3. 如果你的序列化结果中**包含空指针的信息**，且你只给出**一种**遍历顺序，也要分两种情况：

    1. 如果你给出的是前序或者后序，那么你可以还原出唯一的一棵二叉树。
    2. 如果你给出的是中序，那么除非你的整棵树中不包含值相同的节点，否则你无法还原出唯一的一棵二叉树。

我在开头提一下这些总结性的认识，可以理解性记忆，之后会遇到一些相关的题目，再回过头来看看这些总结，会有更深的理解，下面看具体的题目吧。

#### 练习题

##### 297.「[二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)」

> 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
>
> **示例 1：**
>
> ![1684394032927-241c8e3e-6ced-4b2a-914f-97b44da59f13](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684394032927-241c8e3e-6ced-4b2a-914f-97b44da59f13-20240327170829-mc4vvhu.jpeg)​
>
> 输入：root = [1,2,3,null,null,4,5]  
> 输出：[1,2,3,null,null,4,5]

我们可以用 serialize 方法将二叉树序列化成字符串，用 deserialize 方法将序列化的字符串反序列化成二叉树，至于以什么格式序列化和反序列化，这个完全由你决定。

比如说输入如下这样一棵二叉树：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684394082909-d93fdd0f-e935-4fd9-a844-6c9c375fcc88-20240327170829-u7izzb7.png)  
serialize 方法也许会把它序列化成字符串 2,1,\#,6,\#,\#,3,\#,\#，其中 # 表示 null 指针，那么把这个字符串再输入 deserialize 方法，依然可以还原出这棵二叉树。

也就是说，这两个方法会成对儿使用，你只要保证他俩能够自洽就行了。

想象一下，二叉树结该是一个二维平面内的结构，而序列化出来的字符串是一个线性的一维结构。**所谓的序列化不过就是把结构化的数据「打平」，本质就是在考察二叉树的遍历方式**。

二叉树的遍历方式有哪些？递归遍历方式有前序遍历，中序遍历，后序遍历；迭代方式一般是层级遍历。本文就把这些方式都尝试一遍，来实现 serialize 方法和 deserialize 方法。

###### 前序遍历解法

前序遍历框架如下：

```java
void traverse(TreeNode root) {
    if (root == null) return;

    // 前序位置的代码
    traverse(root.left);
    traverse(root.right);
}
```

真的很简单，在递归遍历两棵子树之前写的代码就是前序遍历代码，那么请你看一看如下伪码：

```java
LinkedList<Integer> res;
void traverse(TreeNode root) {
    if (root == null) {
        // 暂且用数字 -1 代表空指针 null
        res.addLast(-1);
        return;
    }

    /****** 前序位置 ******/
    res.addLast(root.val);
    /***********************/

    traverse(root.left);
    traverse(root.right);
}
```

调用 traverse 函数之后，你是否可以立即想出这个 res 列表中元素的顺序是怎样的？比如如下二叉树（# 代表空指针 null），可以直观看出前序遍历做的事情：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684394170398-477e8808-1637-4214-a914-0e6901b690b2-20240327170829-xpgc7cd.png)  
那么 res = [1,2,-1,4,-1,-1,3,-1,-1]，这就是将二叉树「打平」到了一个列表中，其中 -1 代表 null。

那么，将二叉树打平到一个字符串中也是完全一样的：

StringBuilder 可以用于高效拼接字符串，所以也可以认为是一个列表，用 , 作为分隔符，用 # 表示空指针 null，调用完 traverse 函数后，sb 中的字符串应该是 1,2,\#,4,\#,\#,3,\#,\#,。

至此，我们已经可以写出序列化函数 serialize 的代码了：

```java
String SEP = ",";
String NULL = "#";

/* 主函数，将二叉树序列化为字符串 */
String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    return sb.toString();
}

/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    /****** 前序位置 ******/
    sb.append(root.val).append(SEP);  
    /***********************/

    serialize(root.left, sb);
    serialize(root.right, sb);
}
```

现在，思考一下如何写 deserialize 函数，将字符串反过来构造二叉树。

首先我们可以把字符串转化成列表：

```java
String data = "1,2,#,4,#,#,3,#,#,";
String[] nodes = data.split(",");
```

这样，nodes 列表就是二叉树的前序遍历结果，问题转化为：如何通过二叉树的前序遍历结果还原一棵二叉树？

> tip：前文 [东哥带你刷二叉树（构造篇）](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_63a84e1ce4b0fc5d121bba25/1) 说过，至少要得到前、中、后序遍历中的两种互相配合才能还原二叉树。那是因为前文的遍历结果没有记录空指针的信息。这里的 node 列表包含了空指针的信息，所以只使用 node 列表就可以还原二叉树。

根据我们刚才的分析，nodes 列表就是一棵打平的二叉树：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684394237028-d7432f66-6261-47f2-9051-0a3c647d59d1-20240327170829-4f6uvef.png)

那么，反序列化过程也是一样，**先确定根节点 root，然后遵循前序遍历的规则，递归生成左右子树即可**：

```java
/* 主函数，将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    // 将字符串转化成列表
    LinkedList<String> nodes = new LinkedList<>();
    for (String s : data.split(SEP)) {
        nodes.addLast(s);
    }
    return deserialize(nodes);
}

/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) return null;

    /****** 前序位置 ******/
    // 列表最左侧就是根节点
    String first = nodes.removeFirst();
    if (first.equals(NULL)) return null;
    TreeNode root = new TreeNode(Integer.parseInt(first));  
    /***********************/

    root.left = deserialize(nodes);
    root.right = deserialize(nodes);

    return root;
}
```

我们发现，根据树的递归性质，nodes 列表的第一个元素就是一棵树的根节点，所以只要将列表的第一个元素取出作为根节点，剩下的交给递归函数去解决即可。

###### 后序遍历解法

二叉树的后序遍历框架：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    traverse(root.left);
    traverse(root.right);

    // 后序位置的代码
}
```

明白了前序遍历的解法，后序遍历就比较容易理解了，我们首先实现 serialize 序列化方法，只需要稍微修改辅助方法即可：

```java
/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    serialize(root.left, sb);
    serialize(root.right, sb);

    /****** 后序位置 ******/
    sb.append(root.val).append(SEP);
    /***********************/
}
```

我们把对 StringBuilder 的拼接操作放到了后序遍历的位置，后序遍历导致结果的顺序发生变化：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684394318510-bf511690-e7a8-4434-91ab-35a775cd98e4-20240327170829-6c0d3y8.png)

关键点在于，如何实现后序遍历的 deserialize 方法呢？是不是也简单地将反序列化的关键代码无脑放到后序遍历的位置就行了呢：

```java
/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) return null;

    root.left = deserialize(nodes);
    root.right = deserialize(nodes);

    /****** 后序位置 ******/
    String first = nodes.removeFirst();
    if (first.equals(NULL)) return null;
    TreeNode root = new TreeNode(Integer.parseInt(first));
    /***********************/

    return root;
}
```

显然上述代码是错误的，变量都没声明呢，就开始用了？生搬硬套肯定是行不通的，回想刚才我们前序遍历方法中的 deserialize 方法，第一件事情在做什么？

**deserialize 方法首先寻找 root 节点的值，然后递归计算左右子节点**。那么我们这里也应该顺着这个基本思路走，后序遍历中，root 节点的值能不能找到？

再看一眼刚才的图：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684394353771-d48197a8-fe7d-4bf6-9ece-d74ae170dfad-20240327170830-7x3rxno.png)

在后序遍历结果中，root 的值是列表的最后一个元素。我们应该从后往前取出列表元素，先用最后一个元素构造 root，然后递归调用生成 root 的左右子树。

**注意，根据上图，从后往前在 nodes 列表中取元素，一定要先构造 root.right 子树，后构造 root.left 子树**。

看完整代码：

```java
/* 主函数，将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    LinkedList<String> nodes = new LinkedList<>();
    for (String s : data.split(SEP)) {
        nodes.addLast(s);
    }
    return deserialize(nodes);
}

/* 辅助函数，通过 nodes 列表构造二叉树 */
TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) return null;
    // 从后往前取出元素
    String last = nodes.removeLast();  
    if (last.equals(NULL)) return null;
    TreeNode root = new TreeNode(Integer.parseInt(last));
    // 先构造右子树，后构造左子树
    root.right = deserialize(nodes);
    root.left = deserialize(nodes);

    return root;
}
```

至此，后序遍历实现的序列化、反序列化方法也都实现了。

###### 中序遍历解法

先说结论，中序遍历的方式行不通，因为无法实现反序列化方法 deserialize。

序列化方法 serialize 依然容易，只要把字符串的拼接操作放到中序遍历的位置就行了：

```java
/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    serialize(root.left, sb);
    /******* 中序位置 *******/
    sb.append(root.val).append(SEP);
    /***********************/
    serialize(root.right, sb);
}
```

但是，我们刚才说了，要想实现反序列方法，首先要构造 root 节点。前序遍历得到的 nodes 列表中，第一个元素是 root 节点的值；后序遍历得到的 nodes 列表中，最后一个元素是 root 节点的值。

你看上面这段中序遍历的代码，root 的值被夹在两棵子树的中间，也就是在 nodes 列表的中间，我们不知道确切的索引位置，所以无法找到 root 节点，也就无法进行反序列化。

###### 层级遍历解法

首先，先写出层级遍历二叉树的代码框架：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    // 初始化队列，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    while (!q.isEmpty()) {
        TreeNode cur = q.poll();

        /* 层级遍历代码位置 */
        System.out.println(root.val);
        /*****************/

        if (cur.left != null) {
            q.offer(cur.left);
        }
        if (cur.right != null) {
            q.offer(cur.right);
        }
    }
}
```

**上述代码是标准的二叉树层级遍历框架**，从上到下，从左到右打印每一层二叉树节点的值，可以看到，队列 q 中不会存在 null 指针。

不过我们在反序列化的过程中是需要记录空指针 null 的，所以可以把标准的层级遍历框架略作修改：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    // 初始化队列，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    while (!q.isEmpty()) {
        TreeNode cur = q.poll();

        /* 层级遍历代码位置 */
        if (cur == null) continue;
        System.out.println(root.val);
        /*****************/

        q.offer(cur.left);
        q.offer(cur.right);
    }
}
```

这样也可以完成层级遍历，只不过我们把对空指针的检验从「将元素加入队列」的时候改成了「从队列取出元素」的时候。

那么我们完全仿照这个框架即可写出序列化方法：

```java
String SEP = ",";
String NULL = "#";

/* 将二叉树序列化为字符串 */
String serialize(TreeNode root) {
    if (root == null) return "";
    StringBuilder sb = new StringBuilder();
    // 初始化队列，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    while (!q.isEmpty()) {
        TreeNode cur = q.poll();

        /* 层级遍历代码位置 */
        if (cur == null) {
            sb.append(NULL).append(SEP);
            continue;
        }
        sb.append(cur.val).append(SEP);
        /*****************/

        q.offer(cur.left);
        q.offer(cur.right);
    }

    return sb.toString();
}
```

层级遍历序列化得出的结果如下图：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684394484195-94f29db6-bbda-4e1c-a46c-745150e32867-20240327170830-khc2ehv.png)

可以看到，每一个非空节点都会对应两个子节点，**那么反序列化的思路也是用队列进行层级遍历，同时用索引 i 记录对应子节点的位置**：

```java
/* 将字符串反序列化为二叉树结构 */
TreeNode deserialize(String data) {
    if (data.isEmpty()) return null;
    String[] nodes = data.split(SEP);
    // 第一个元素就是 root 的值
    TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));

    // 队列 q 记录父节点，将 root 加入队列
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    for (int i = 1; i < nodes.length; ) {
        // 队列中存的都是父节点
        TreeNode parent = q.poll();
        // 父节点对应的左侧子节点的值
        String left = nodes[i++];
        if (!left.equals(NULL)) {
            parent.left = new TreeNode(Integer.parseInt(left));
            q.offer(parent.left);
        } else {
            parent.left = null;
        }
        // 父节点对应的右侧子节点的值
        String right = nodes[i++];
        if (!right.equals(NULL)) {
            parent.right = new TreeNode(Integer.parseInt(right));
            q.offer(parent.right);
        } else {
            parent.right = null;
        }
    }
    return root;
}
```

这段代码可以考验一下你的框架思维。仔细看一看 for 循环部分的代码，发现这不就是标准层级遍历的代码衍生出来的嘛：

```java
while (!q.isEmpty()) {
    TreeNode cur = q.poll();

    if (cur.left != null) {
        q.offer(cur.left);
    }

    if (cur.right != null) {
        q.offer(cur.right);
    }
}
```

只不过，标准的层级遍历在操作二叉树节点 TreeNode，而我们的函数在操作 nodes[i]，这也恰恰是反序列化的目的嘛。

### 二叉搜索树-特性

#### 纲领

首先，BST 的特性大家应该都很熟悉了：

1、对于 BST 的每一个节点 node，左子树节点的值都比 node 的值要小，右子树节点的值都比 node 的值大。

2、对于 BST 的每一个节点 node，它的左侧子树和右侧子树都是 BST。

二叉搜索树并不算复杂，但我觉得它可以算是数据结构领域的半壁江山，直接基于 BST 的数据结构有 AVL 树，红黑树等等，拥有了自平衡性质，可以提供 logN 级别的增删查改效率；还有 B+ 树，线段树等结构都是基于 BST 的思想来设计的。

**从做算法题的角度来看 BST，除了它的定义，还有一个重要的性质：BST 的中序遍历结果是有序的（升序）** 。

也就是说，如果输入一棵 BST，以下代码可以将 BST 中每个节点的值升序打印出来：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    traverse(root.left);
    // 中序遍历代码位置
    print(root.val);
    traverse(root.right);
}
```

#### 练习题

##### **230.「**​[二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)」

> 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k个最小元素（从 1 开始计数）。
>
> **示例 1：**
>
> ![1684678550643-cb0cc932-e224-4c5b-bbf5-8ccd489cb796](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684678550643-cb0cc932-e224-4c5b-bbf5-8ccd489cb796-20240327192622-fwa8d97.jpeg)​
>
> 输入：root = [3,1,4,null,2], k = 1  
> 输出：1

这个需求很常见吧，一个直接的思路就是升序排序，然后找第 k 个元素呗。BST 的中序遍历其实就是升序排序的结果，找第 k 个元素肯定不是什么难事。

按照这个思路，可以直接写出代码：

```java
int kthSmallest(TreeNode root, int k) {
    // 利用 BST 的中序遍历特性
    traverse(root, k);
    return res;
}

// 记录结果
int res = 0;
// 记录当前元素的排名
int rank = 0;
void traverse(TreeNode root, int k) {
    if (root == null) {
        return;
    }
    traverse(root.left, k);
    /* 中序遍历代码位置 */
    rank++;
    if (k == rank) {
        // 找到第 k 小的元素
        res = root.val;
        return;
    }
    /*****************/
    traverse(root.right, k);
}
```

##### **538. 「**​[把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/description/)」

> 给出二叉**搜索**树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
>
> 提醒一下，二叉搜索树满足下列约束条件：
>
> - 节点的左子树仅包含键**小于**节点键的节点。
> - 节点的右子树仅包含键**大于**节点键的节点。
> - 左右子树也必须是二叉搜索树。
>
> **注意：** 本题和 1038: [https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/) 相同
>
> **示例 1：**
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684679578300-cf217375-29f5-4552-8d78-5f12998ce6a1-20240327192622-jprxzhq.png)
>
> 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]  
> 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

按照二叉树的通用思路，需要思考每个节点应该做什么，但是这道题上很难想到什么思路。

BST 的每个节点左小右大，这似乎是一个有用的信息，既然累加和是计算大于等于当前值的所有元素之和，那么每个节点都去计算右子树的和，不就行了吗？

这是不行的。对于一个节点来说，确实右子树都是比它大的元素，但问题是它的父节点也可能是比它大的元素呀？这个没法确定的，我们又没有触达父节点的指针，所以二叉树的通用思路在这里用不了。

**其实，正确的解法很简单，还是利用 BST 的中序遍历特性**。

刚才我们说了 BST 的中序遍历代码可以升序打印节点的值，那如果我想降序打印节点的值怎么办？

很简单，只要把递归顺序改一下就行了：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    // 先递归遍历右子树
    traverse(root.right);
    // 中序遍历代码位置
    print(root.val);
    // 后递归遍历左子树
    traverse(root.left);
}
```

**这段代码可以降序打印 BST 节点的值，如果维护一个外部累加变量 sum，然后把 sum 赋值给 BST 中的每一个节点，不就将 BST 转化成累加树了吗**？

看下代码就明白了：

```java
TreeNode convertBST(TreeNode root) {
    traverse(root);
    return root;
}

// 记录累加和
int sum = 0;
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    traverse(root.right);
    // 维护累加和
    sum += root.val;
    // 将 BST 转化成累加树
    root.val = sum;
    traverse(root.left);
}
```

这道题就解决了，核心还是 BST 的中序遍历特性，只不过我们修改了递归顺序，降序遍历 BST 的元素值，从而契合题目累加树的要求。

简单总结下吧，BST 相关的问题，要么利用 BST 左小右大的特性提升算法效率，要么利用中序遍历的特性满足题目的要求，也就这么些事儿吧。

### 二叉搜索树-基操

#### 提纲

BST 的基本特性，还利用二叉搜索树「中序遍历有序」的特性来解决了几道题目，本文来实现 BST 的基础操作：判断 BST 的合法性、增、删、查。其中「删」和「判断合法性」略微复杂。

BST 的基础操作主要依赖「左小右大」的特性，可以在二叉树中做类似二分搜索的操作，寻找一个元素的效率很高。比如下面这就是一棵合法的二叉树：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684745859899-fb677984-559e-4bfc-b12a-62332eb8e03b-20240327201151-wuoypjg.png)  
对于 BST 相关的问题，你可能会经常看到类似下面这样的代码逻辑：

```java
void BST(TreeNode root, int target) {
    if (root.val == target)
        // 找到目标，做点什么
    if (root.val < target) 
        BST(root.right, target);
    if (root.val > target)
        BST(root.left, target);
}
```

这个代码框架其实和二叉树的遍历框架差不多，无非就是利用了 BST 左小右大的特性而已。接下来看下 BST 这种结构的基础操作是如何实现的。

#### 练习题

##### **98.「**​[验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)」

> 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
>
> **有效** 二叉搜索树定义如下：
>
> - 节点的左子树只包含 **小于** 当前节点的数。
> - 节点的右子树只包含 **大于** 当前节点的数。
> - 所有左子树和右子树自身必须也是二叉搜索树。
>
> **示例 1：**
>
> ![1684745952135-d045355f-a1a0-4289-84f1-c599d64347db](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684745952135-d045355f-a1a0-4289-84f1-c599d64347db-20240327201151-28rmk7j.jpeg)​
>
> 输入：root = [2,1,3]  
> 输出：true

注意，这里是有坑的哦，按照 BST 左小右大的特性，每个节点想要判断自己是否是合法的 BST 节点，要做的事不就是比较自己和左右孩子吗？感觉应该这样写代码：

```java
boolean isValidBST(TreeNode root) {
    if (root == null) return true;
    // root 的左边应该更小
    if (root.left != null && root.left.val >= root.val)
        return false;
    // root 的右边应该更大
    if (root.right != null && root.right.val <= root.val)
        return false;

    return isValidBST(root.left)
        && isValidBST(root.right);
}
```

但是这个算法出现了错误，BST 的每个节点应该要小于右边子树的**所有**节点，下面这个二叉树显然不是 BST，因为节点 10 的右子树中有一个节点 6，但是我们的算法会把它判定为合法 BST：  
​![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684746016524-60b9419f-3912-4772-857d-be18758585e1-20240327201151-aq3bi6u.png)

**出现问题的原因在于，对于每一个节点 root，代码值检查了它的左右孩子节点是否符合左小右大的原则；但是根据 BST 的定义，root 的整个左子树都要小于 root.val，整个右子树都要大于 root.val**。

问题是，对于某一个节点 root，他只能管得了自己的左右子节点，怎么把 root 的约束传递给左右子树呢？请看正确的代码：

```java
boolean isValidBST(TreeNode root) {
    return isValidBST(root, null, null);
}

/* 限定以 root 为根的子树节点必须满足 max.val > root.val > min.val */
boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {
    // base case
    if (root == null) return true;
    // 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST
    if (min != null && root.val <= min.val) return false;
    if (max != null && root.val >= max.val) return false;
    // 限定左子树的最大值是 root.val，右子树的最小值是 root.val
    return isValidBST(root.left, min, root) 
        && isValidBST(root.right, root, max);
}
```

我们通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉树算法的一个小技巧吧。

##### 700.「 [二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)」

> 给定二叉搜索树（BST）的根节点 root 和一个整数值 val。
>
> 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。
>
> **示例 1:**
>
> ![1684746578994-444236b2-140b-4ed7-a0e0-e8b2307ef952](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684746578994-444236b2-140b-4ed7-a0e0-e8b2307ef952-20240327201151-hunvmlz.jpeg)​
>
> 输入：root = [4,2,7,1,3], val = 2  
> 输出：[2,1,3]

如果是在一棵普通的二叉树中寻找，可以这样写代码：

```java
TreeNode searchBST(TreeNode root, int target);
    if (root == null) return null;
    if (root.val == target) return root;
    // 当前节点没找到就递归地去左右子树寻找
    TreeNode left = searchBST(root.left, target);
    TreeNode right = searchBST(root.right, target);

    return left != null ? left : right;
}
```

这样写完全正确，但这段代码相当于穷举了所有节点，适用于所有二叉树。那么应该如何充分利用 BST 的特殊性，把「左小右大」的特性用上？

很简单，其实不需要递归地搜索两边，类似二分查找思想，根据 target 和 root.val 的大小比较，就能排除一边。我们把上面的思路稍稍改动：

```java
TreeNode searchBST(TreeNode root, int target) {
    if (root == null) {
        return null;
    }
    // 去左子树搜索
    if (root.val > target) {
        return searchBST(root.left, target);
    }
    // 去右子树搜索
    if (root.val < target) {
        return searchBST(root.right, target);
    }
    return root;
}
```

### 二叉搜索树-构造

#### 练习题

##### 96.「 [不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)」

> 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。
>
> **示例 1：**
>
> ![1684832122357-d5ea6f92-32de-418f-9d73-be7834a5dc19](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684832122357-d5ea6f92-32de-418f-9d73-be7834a5dc19-20240328105251-ucnc4nd.jpeg)​
>
> 输入：n = 3  
> 输出：5

比如说输入 n = 3，算法返回 5，因为共有如下 5 种不同的 BST 结构存储 {1,2,3}：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684832171432-02cbdcf6-166b-43cf-81b0-7c0d49696b9b-20240328105252-34o1w1d.png)

这就是一个正宗的穷举问题，那么什么方式能够正确地穷举有效 BST 的数量呢？

我们前文说过，不要小看「穷举」，这是一件看起来简单但是比较有技术含量的事情，问题的关键就是不能数漏，也不能数多，你咋整？

之前 [手把手刷二叉树第一期](https://appktavsiei5995.pc.xiaoe-tech.com/detail/i_63a84de7e4b030cacaff66fa/1) 说过，二叉树算法的关键就在于明确根节点需要做什么，其实 BST 作为一种特殊的二叉树，核心思路也是一样的。

举个例子，比如给算法输入 n = 5，也就是说用 {1,2,3,4,5} 这些数字去构造 BST。

首先，这棵 BST 的根节点总共有几种情况？

显然有 5 种情况对吧，因为每个数字都可以作为根节点。

比如说我们固定 3 作为根节点，这个前提下能有几种不同的 BST 呢？

根据 BST 的特性，根节点的左子树都比根节点的值小，右子树的值都比根节点的值大。

所以如果固定 3 作为根节点，左子树节点就是 {1,2} 的组合，右子树就是 {4,5} 的组合。

**左子树的组合数和右子树的组合数乘积**就是 3 作为根节点时的 BST 个数。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684833234505-9878b892-fec5-4758-9690-5beb8b6e0a23-20240328105252-jj9w9yw.png)

我们这是说了 3 为根节点这一种特殊情况，其实其他的节点也是一样的。

那你可能会问，我们可以一眼看出 {1,2} 和 {4,5} 有几种组合，但是怎么让算法进行计算呢？

```java
/* 主函数 */
int numTrees(int n) {
    // 计算闭区间 [1, n] 组成的 BST 个数
    return count(1, n);
}

/* 计算闭区间 [lo, hi] 组成的 BST 个数 */
int count(int lo, int hi) {
    // base case
    if (lo > hi) return 1;

    int res = 0;
    for (int i = lo; i <= hi; i++) {
        // i 的值作为根节点 root
        int left = count(lo, i - 1);
        int right = count(i + 1, hi);
        // 左右子树的组合数乘积是 BST 的总数
        res += left * right;
    }

    return res;
}
```

注意 base case，显然当 lo > hi 闭区间 [lo, hi] 肯定是个空区间，也就对应着空节点 null，虽然是空节点，但是也是一种情况，所以要返回 1 而不能返回 0。

这样，题目的要求已经实现了，但是时间复杂度非常高，肯定存在重叠子问题。

前文动态规划相关的问题多次讲过消除重叠子问题的方法，无非就是加一个备忘录：

```java
// 备忘录
int[][] memo;

int numTrees(int n) {
    // 备忘录的值初始化为 0
    memo = new int[n + 1][n + 1];
    return count(1, n);
}

int count(int lo, int hi) {
    if (lo > hi) return 1;
    // 查备忘录
    if (memo[lo][hi] != 0) {
        return memo[lo][hi];
    }

    int res = 0;
    for (int mid = lo; mid <= hi; mid++) {
        int left = count(lo, mid - 1);
        int right = count(mid + 1, hi);
        res += left * right;
    }
    // 将结果存入备忘录
    memo[lo][hi] = res;

    return res;
}
```

##### 95.「[不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/)」

> 给你一个整数 `n`​ ，请你生成并返回所有由 `n`​ 个节点组成且节点值从 `1`​ 到 `n`​ 互不相同的不同 **二叉搜索树** 。可以按 **任意顺序** 返回答案。
>
> **示例 1：**
>
> ![1684833954222-16d5b6e5-0dd6-4d25-9c46-4b6f481aefe1](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684833954222-16d5b6e5-0dd6-4d25-9c46-4b6f481aefe1-20240328105252-9o6te4y.jpeg)​
>
> 输入：n = 3  
> 输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]

比如说输入 n = 3，算法返回一个列表，列表中存储着如下五棵 BST 的根节点：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1684834017137-ad584845-8502-4cb7-8991-5afcb729e2f8-20240328105252-z5uz4h8.png)

**明白了上道题构造有效 BST 的方法，这道题的思路也是一样的**：

1、穷举 root 节点的所有可能。

2、递归构造出左右子树的所有有效 BST。

3、给 root 节点穷举所有左右子树的组合。

我们可以直接看代码：

```java
/* 主函数 */
public List<TreeNode> generateTrees(int n) {
    if (n == 0) return new LinkedList<>();
    // 构造闭区间 [1, n] 组成的 BST 
    return build(1, n);
}

/* 构造闭区间 [lo, hi] 组成的 BST */
List<TreeNode> build(int lo, int hi) {
    List<TreeNode> res = new LinkedList<>();
    // base case
    if (lo > hi) {
        res.add(null);
        return res;
    }

    // 1、穷举 root 节点的所有可能。
    for (int i = lo; i <= hi; i++) {
        // 2、递归构造出左右子树的所有有效 BST。
        List<TreeNode> leftTree = build(lo, i - 1);
        List<TreeNode> rightTree = build(i + 1, hi);
        // 3、给 root 节点穷举所有左右子树的组合。
        for (TreeNode left : leftTree) {
            for (TreeNode right : rightTree) {
                // i 作为根节点 root 的值
                TreeNode root = new TreeNode(i);
                root.left = left;
                root.right = right;
                res.add(root);
            }
        }
    }

    return res;
}
```

### **最近公共祖先问题**

#### 纲领

先不管最近公共祖先问题，我请你实现一个简单的算法：

给你输入一棵**没有重复元素**的二叉树根节点 root 和一个目标值 val，请你写一个函数寻找树中值为 val 的节点。

函数签名如下：

```java
TreeNode find(TreeNode root, int val);
```

这个函数应该很容易实现对吧，比如我这样写代码：

```java
// 定义：在以 root 为根的二叉树中寻找值为 val 的节点
TreeNode find(TreeNode root, int val) {
    // base case
    if (root == null) {
        return null;
    }
    // 看看 root.val 是不是要找的
    if (root.val == val) {
        return root;
    }
    // root 不是目标节点，那就去左子树找
    TreeNode left = find(root.left, val);
    if (left != null) {
        return left;
    }
    // 左子树找不着，那就去左子树找
    TreeNode right = find(root.right, val);
    if (right != null) {
        return right;
    }
    // 实在找不到了
    return null;
}
```

这段代码应该不用我多解释了，我下面基于这段代码做一些简单的改写，请你分析一下我的改动会造成什么影响。

首先，我修改一下 return 的位置：

```java
TreeNode find(TreeNode root, int val) {
    if (root == null) {
        return null;
    }
    // 前序位置
    if (root.val == val) {
        return root;
    }
    // root 不是目标节点，去左右子树寻找
    TreeNode left = find(root.left, val);
    TreeNode right = find(root.right, val);
    // 看看哪边找到了
    return left != null ? left : right;
}
```

这段代码也可以达到目的，但是实际运行的效率会低一些，原因也很简单，如果你能够在左子树找到目标节点，还有没有必要去右子树找了？没有必要。但这段代码还是会去右子树找一圈，所以效率相对差一些。

更进一步，我把对 root.val 的判断从前序位置移动到后序位置：

```java
TreeNode find(TreeNode root, int val) {
    if (root == null) {
        return null;
    }
    // 先去左右子树寻找
    TreeNode left = find(root.left, val);
    TreeNode right = find(root.right, val);
    // 后序位置，看看 root 是不是目标节点
    if (root.val == val) {
        return root;
    }
    // root 不是目标节点，再去看看哪边的子树找到了
    return left != null ? left : right;
}
```

这段代码相当于你先去左右子树找，然后才检查 root，依然可以到达目的，但是效率会进一步下降。**因为这种写法必然会遍历二叉树的每一个节点**。

对于之前的解法，你在前序位置就检查 root，如果输入的二叉树根节点的值恰好就是目标值 val，那么函数直接结束了，其他的节点根本不用搜索。

但如果你在后序位置判断，那么就算根节点就是目标节点，你也要去左右子树遍历完所有节点才能判断出来。

最后，我再改一下题目，现在不让你找值为 val 的节点，而是寻找值为 val1 **或** val2 的节点，函数签名如下：

```java
TreeNode find(TreeNode root, int val1, int val2);
```

这和我们第一次实现的 find 函数基本上是一样的，而且你应该知道可以有多种写法，我选择这样写代码：

```java
// 定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点
TreeNode find(TreeNode root, int val1, int val2) {
    // base case
    if (root == null) {
        return null;
    }
    // 前序位置，看看 root 是不是目标值
    if (root.val == val1 || root.val == val2) {
        return root;
    }
    // 去左右子树寻找
    TreeNode left = find(root.left, val1, val2);
    TreeNode right = find(root.right, val1, val2);
    // 后序位置，已经知道左右子树是否存在目标值

    return left != null ? left : right;
}
```

**为什么要写这样一个奇怪的 find 函数呢？因为最近公共祖先系列问题的解法都是把这个函数作为框架的**。

下面一道一道题目来看。

#### 练习题

##### **LCR 194.「**​[二叉树的最近公共祖先](https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)」

> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
> [百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”
>
> 例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681118050437-2c911982-aba3-4801-82ba-e7bda31776d7-20240328111007-1tqqk5r.png)
>
> **示例 1:**
>
> 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1  
> 输出: 3  
> 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

比如输入这样一棵二叉树：  
![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681118130695-f7df5ba4-d1dc-4c57-94e2-fcf9f43976b0-20240328111007-z8xc0ko.png)  
如果 p 是节点 6，q 是节点 7，那么它俩的 LCA 就是节点 5：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681118131109-e343f600-3c47-48e9-bd96-4409b804d088-20240328111007-jzjkugw.png)  
当然，p 和 q 本身也可能是 LCA，比如这种情况 q 本身就是 LCA 节点：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681118131008-e022149f-a7da-4ce7-98f6-6f7961c9a50a-20240328111007-wj7gtq6.png)  
两个节点的最近公共祖先其实就是这两个节点向根节点的「延长线」的交汇点，那么对于任意一个节点，它怎么才能知道自己是不是 p 和 q 的最近公共祖先？

**如果一个节点能够在它的左右子树中分别找到 p 和 q，则该节点为 LCA 节点**。

这就要用到之前实现的 find 函数了，只需在后序位置添加一个判断逻辑，即可改造成寻找最近公共祖先的解法代码

```java
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    return find(root, p.val, q.val);
}

// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点
TreeNode find(TreeNode root, int val1, int val2) {
    if (root == null) {
        return null;
    }
    // 前序位置
    if (root.val == val1 || root.val == val2) {
        // 如果遇到目标值，直接返回
        return root;
    }
    TreeNode left = find(root.left, val1, val2);
    TreeNode right = find(root.right, val1, val2);
    // 后序位置，已经知道左右子树是否存在目标值
    if (left != null && right != null) {
        // 当前节点是 LCA 节点
        return root;
    }

    return left != null ? left : right;
}
```

在 find 函数的后序位置，如果发现 left 和 right 都非空，就说明当前节点是 LCA 节点，即解决了第一种情况：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681118461182-7164ab21-77db-4de2-b2b3-b1df923fa6e2-20240328111007-nv3cc12.png)  
在 find 函数的前序位置，如果找到一个值为 val1 或 val2 的节点则直接返回，恰好解决了第二种情况：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681118461462-9b7e537a-0634-45bf-b614-594b97e7d4ee-20240328111007-odbbsmk.png)  
因为题目说了 p 和 q 一定存在于二叉树中(这点很重要)，所以即便我们遇到 q 就直接返回，根本没遍历到 p，也依然可以断定 p 在 q 底下，q 就是 LCA 节点。

这样，标准的最近公共祖先问题就解决了。

##### **LCR 193.「**​[二叉搜索树的最近公共祖先](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)」

> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
>
> [百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”
>
> 例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1681117887914-7c18d5be-736a-407b-ab1a-3d26523fd0e4-20240328111007-fij2jjb.png)
>
> **示例 1:**
>
> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8  
> 输出: 6
> 解释: 节点 2 和节点 8 的最近公共祖先是 6。

把之前的解法代码复制过来肯定也可以解决这道题，但没有用到 BST「左小右大」的性质，显然效率不是最高的。

在标准的最近公共祖先问题中，我们要在后序位置通过左右子树的搜索结果来判断当前节点是不是 LCA：

```java
TreeNode left = find(root.left, val1, val2);
TreeNode right = find(root.right, val1, val2);

// 后序位置，判断当前节点是不是 LCA 节点
if (left != null && right != null) {
    return root;
}
```

**但对于 BST 来说，根本不需要老老实实去遍历子树，由于 BST 左小右大的性质，将当前节点的值与 val1 和 val2 作对比即可判断当前节点是不是 LCA**：

假设 val1 < val2，那么 val1 <= root.val <= val2 则说明当前节点就是 LCA；若 root.val 比 val1 还小，则需要去值更大的右子树寻找 LCA；若 root.val 比 val2 还大，则需要去值更小的左子树寻找 LCA。

依据这个思路就可以写出解法代码：

```java
TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    // 保证 val1 较小，val2 较大
    int val1 = Math.min(p.val, q.val);
    int val2 = Math.max(p.val, q.val);
    return find(root, val1, val2);
}

// 在 BST 中寻找 val1 和 val2 的最近公共祖先节点
TreeNode find(TreeNode root, int val1, int val2) {
    if (root == null) {
        return null;
    }
    if (root.val > val2) {
        // 当前节点太大，去左子树找
        return find(root.left, val1, val2);
    }
    if (root.val < val1) {
        // 当前节点太小，去右子树找
        return find(root.right, val1, val2);
    }
    // val1 <= root.val <= val2
    // 则当前节点就是最近公共祖先
    return root;
}
```

### 计算完全二叉树的节点数

#### 完全二叉树与满二叉树

首先要明确一下两个关于二叉树的名词「完全二叉树」和「满二叉树」。

我们说的**完全二叉树**如下图，每一层都是紧凑靠左排列的：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685428975704-41f534c7-c791-427f-9eff-914f6c53ae49-20240328133246-4ppys0h.png)

我们说的**满二叉树**如下图，是一种特殊的完全二叉树，每层都是是满的，像一个稳定的三角形：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685428992769-6666b0cf-ccb2-43c0-96f2-2b82b36103b9-20240328133246-sd9etot.png)

说句题外话，关于这两个定义，中文语境和英文语境似乎有点区别，我们说的完全二叉树对应英文 Complete Binary Tree，没有问题。但是我们说的满二叉树对应英文 Perfect Binary Tree，而英文中的 Full Binary Tree 是指一棵二叉树的所有节点要么没有孩子节点，要么有两个孩子节点。如下：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685429061153-e03eed79-8bdc-4671-b6b4-678195283c04-20240328133246-8p2bww3.png)

#### 练习题

##### **222.「**​[完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)」

> 给你一棵 **完全二叉树** 的根节点 root ，求出该树的节点个数。
>
> [完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
>
> **示例 1：**
>
> ![1685429409201-66993b45-b445-45ca-9b64-36ade0cd53a2](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685429409201-66993b45-b445-45ca-9b64-36ade0cd53a2-20240328133246-not3nqx.jpeg)​
>
> 输入：root = [1,2,3,4,5,6]  
> 输出：6

如果是一个**普通**二叉树，显然只要向下面这样遍历一边即可，时间复杂度 O(N)：

```java
public int countNodes(TreeNode root) {
    if (root == null) return 0;
    return 1 + countNodes(root.left) + countNodes(root.right);
}
```

那如果是一棵**满**二叉树，节点总数就和树的高度呈指数关系：

```java
public int countNodes(TreeNode root) {
    int h = 0;
    // 计算树的高度
    while (root != null) {
        root = root.left;
        h++;
    }
    // 节点总数就是 2^h - 1
    return (int)Math.pow(2, h) - 1;
}
```

**完全**二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版，先看代码：

```java
public int countNodes(TreeNode root) {
    TreeNode l = root, r = root;
    // 沿最左侧和最右侧分别计算高度
    int hl = 0, hr = 0;
    while (l != null) {
        l = l.left;
        hl++;
    }
    while (r != null) {
        r = r.right;
        hr++;
    }
    // 如果左右侧计算的高度相同，则是一棵满二叉树
    if (hl == hr) {
        return (int)Math.pow(2, hl) - 1;
    }
    // 如果左右侧的高度不同，则按照普通二叉树的逻辑计算
    return 1 + countNodes(root.left) + countNodes(root.right);
}
```

这个算法的时间复杂度是 O(logN*l)，这是怎么算出来的呢？直觉感觉好像最坏情况下是 O(N*logN) 吧，因为之前的 while 需要 logN 的时间，最后要 O(N) 的时间向左右子树递归：

```java
return 1 + countNodes(root.left) + countNodes(root.right);
```

**关键点在于，这两个递归只有一个会真的递归下去，另一个一定会触发 hl == hr 而立即返回，不会递归下去**。

为什么呢？原因如下：

**一棵完全二叉树的两棵子树，至少有一棵是满二叉树**：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685429690673-2cfa02e6-7067-4b1e-8882-eeb067ea17d6-20240328133246-f3ixjx8.png)

看图就明显了吧，由于完全二叉树的性质，其子树一定有一棵是满的，所以一定会触发 hl == hr，只消耗 O(logN) 的复杂度而不会继续递归。

综上，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。

所以说，「完全二叉树」这个概念还是有它存在的原因的，不仅适用于数组实现二叉堆，而且连计算节点总数这种看起来简单的操作都有高效的算法实现。

### 剑指offer - 二叉树

#### LCR 124.「[推理二叉树](https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/)」

> 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。
>
> 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
>
> **示例 1:**
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678086435767-f1aadf2c-5110-4514-8195-6145217cc802-20240328134730-jbdhp0j.png)
>
> Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]  
> Output: [3,9,20,null,null,15,7]

**既然要重建二叉树，那么要重建一颗二叉树需要什么？**

- 根节点
- 左节点
- 右节点

**如何找到第一个根节点？**   
为什么要是第一个根节点呢？因为你是从第一个开始根开始创建的呀。

- 前序遍历： 根节点 -- 左节点 -- 右节点
- 中序遍历： 左节点 -- 根节点 -- 右节点

第一个根节点必然出现在前序遍历的第一个位置！但是对于中序遍历来说，我们不知道第一个根前面左子树的长度，所以无法得知！因此最简单的切入点就是通过前序遍历找到第一个根节点

**如何找到第一个左节点？**

这个在前序遍历中也很好看出来，第一个左节点就在第一个根节点的右边1个单位，即：`pre_root_index + 1`​

**如何找到第一个右节点？**

我们找到了第一个根，第一个左节点，那如何确定第一个右节点呢？

对于前序遍历而言，我们已经知道了根、左节点，那么很显然，**右节点的下标 = 根节点下标 + 左子树的长度 + 1（在前序遍历数组中）** ，现在唯一不确定的就是左子树的长度，这一点可以很简单的从中序遍历中获得，也就是**左子树长度 = 根节点下标 - 左子树的左边界 （在中序遍历数组中）**

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678086719979-39ffe9b7-db8e-4195-bf70-6b70dab425e0-20240328134730-u4t98ed.png)  
现在我们就重建完一个最基础的二叉树了~

```java
class Solution {
    int[] preorder;
    HashMap<Integer, Integer> map = new HashMap<>();
    // 前序遍历 preorder: 根 -- 左 -- 右   第一个肯定是根节点
    // 中序遍历 inorder: 左 -- 根 -- 右
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        this.preorder = preorder;
        for(int i = 0; i < inorder.length; i++){
            map.put(inorder[i], i);
        }
        return rebuild(0, 0, inorder.length - 1);  
    }

    // pre_root_index : 根节点 在 前序遍历中的下标
    // in_left_index: 该节点在中序遍历中的左边界
    // in_right_index: 该节点在中序遍历中的右边界
    public TreeNode rebuild(int pre_root_index, int in_left_index, int in_right_index){
       if(in_left_index > in_right_index)  return null;
       // 根节点在中序遍历中的位置：in_root_index
       int in_root_index = map.get(preorder[pre_root_index]);
       // 创建一个根节点
       TreeNode node = new TreeNode(preorder[pre_root_index]);
       // 寻找node的左节点: 
       // 在前序遍历中的位置就是  根节点的下标 + 1（右边一个单位）
       // 在中序遍历中的位置就是： 1. 左边界不变，2. 右边界就是根节点的左边一个单位 in_root_index - 1
       node.left = rebuild(pre_root_index + 1, in_left_index, in_root_index - 1);
       // 寻找node的右节点: 
       // 在前序遍历中的位置就是  根节点的下标 + 左子树长度 + 1
       // 在中序遍历中的位置就是： 1. 左边界在根节点的右边一个单位  in_root_index + 1, 2. 右边界不变
       node.right = rebuild(pre_root_index + in_root_index - in_left_index + 1, in_root_index + 1, in_right_index);
       return node;
    }
}
```

#### **LCR 143.「**​[子结构判断](https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/description/?orderBy=hot&languageTags=java)」

> 给定两棵二叉树 `tree1`​ 和 `tree2`​，判断 `tree2`​ 是否以 `tree1`​ 的某个节点为根的子树具有 **相同的结构和节点值** 。
>
> 注意，**空树** 不会是以 `tree1`​ 的某个节点为根的子树具有 **相同的结构和节点值** 。
>
> **示例 1：**
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240328135123-17tmmhc.png)​
>
> 输入：tree1 = [1,7,5], tree2 = [6,1]  
> 输出：false  
> 解释：tree2 与 tree1 的一个子树没有相同的结构和节点值。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678282832085-63ce5660-70a4-4577-9bf3-0c86ffe7bca3-20240328134730-imdf74m.png)  
若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：

1. 先序遍历树 A 中的每个节点 nA；（对应函数 isSubStructure(A, B)）
2. 判断树 A 中 以 nA 为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678283232469-c5c474e4-b8b6-4d73-82ba-9ad80e63a5ed-20240328134730-mu79zg1.gif)

```java
class Solution {
    /*
    参考:数据结构与算法的题解比较好懂
    死死记住isSubStructure()的定义:判断B是否为A的子结构
    */
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        // 若A与B其中一个为空,立即返回false
        if(A == null || B == null) {
            return false;
        }
        // B为A的子结构有3种情况,满足任意一种即可:
        // 1.B的子结构起点为A的根节点,此时结果为recur(A,B)
        // 2.B的子结构起点隐藏在A的左子树中,而不是直接为A的根节点,此时结果为isSubStructure(A.left, B)
        // 3.B的子结构起点隐藏在A的右子树中,此时结果为isSubStructure(A.right, B)
        return recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
    }

    /*
    判断B是否为A的子结构,其中B子结构的起点为A的根节点
    */
    private boolean recur(TreeNode A, TreeNode B) {
        // 若B走完了,说明查找完毕,B为A的子结构
        if(B == null) {
            return true;
        }
        // 若B不为空并且A为空或者A与B的值不相等,直接可以判断B不是A的子结构
        if(A == null || A.val != B.val) {
            return false;
        }
        // 当A与B当前节点值相等,若要判断B为A的子结构
        // 还需要判断B的左子树是否为A左子树的子结构 && B的右子树是否为A右子树的子结构
        // 若两者都满足就说明B是A的子结构,并且该子结构以A根节点为起点
        return recur(A.left, B.left) && recur(A.right, B.right);
    }
}
```

复杂度分析：

- 时间复杂度 O(MN)： 其中 M,N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 recur(A, B) 判断占用 O(N) 。
- 空间复杂度 O(M)： 当树 A 和树 B 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树 A 与递归判断的总递归深度为 M ；当 M>N 时，最差情况为遍历至树 A 叶子节点，此时总递归深度为 M。

#### **LCR 144.「**​[翻转二叉树](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/)」

> 给定一棵二叉树的根节点 `root`​，请左右翻转这棵二叉树，并返回其根节点。
>
> **示例 1：**
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240328140134-uv3prln.png)​
>
> 输入：root = [5,7,9,8,3,2,4]  
> 输出：[5,9,7,4,2,3,8]

```java
public TreeNode mirrorTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode leftRoot = mirrorTree(root.right);
    TreeNode rightRoot = mirrorTree(root.left);
    root.left = leftRoot;
    root.right = rightRoot;
    return root;
}
```

#### **LCR 145.「**​[判断对称二叉树](https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/)」

> 请设计一个函数判断一棵二叉树是否 **轴对称** 。
>
> **示例 1：**
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240328140406-vnk0egh.png)​
>
> 输入：root = [6,7,7,8,9,9,8]  
> 输出：true  
> 解释：从图中可看出树是轴对称的。

算法流程：  
​`isSymmetric(root) `​：

- 特例处理： 若根节点 root 为空，则直接返回 true 。
- 返回值： 即 `recur(root.left, root.right) `​;

`recur(L, R) `​：

- 终止条件：

    - 当 L 和 R 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 true ；
    - 当 L 或 R 中只有一个越过叶节点： 此树不对称，因此返回 false ；
    - 当节点 L 值 ≠ 节点 R 值： 此树不对称，因此返回 false ；
- 递推工作：

    - 判断两节点 L.left 和 R.right 是否对称，即 `recur(L.left, R.right) `​；
    - 判断两节点 L.rightL 和 R.left 是否对称，即 `recur(L.right, R.left) `​；
- 返回值： 两对节点都对称时，才是对称树，因此用与逻辑符 && 连接。

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678435054750-5bbf7817-69e8-4fcd-a84d-4ba3484abf58-20240328134730-oynt1ym.gif)

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return root == null ? true : recur(root.left, root.right);
    }
    boolean recur(TreeNode L, TreeNode R) {
        if(L == null && R == null) return true;
        if(L == null || R == null || L.val != R.val) return false;
        return recur(L.left, R.right) && recur(L.right, R.left);
    }
}
```

复杂度分析：

- 时间复杂度 O(N)： 其中 N 为二叉树的节点数量，每次执行 `recur()`​ 可以判断一对节点是否对称，因此最多调用 N/2 次 `recur() `​方法。
- 空间复杂度 O(N) ： 最差情况下，二叉树退化为链表，系统使用 O(N) 大小的栈空间。

#### **LCR 152.「**​[验证二叉搜索树的后序遍历序列](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/description/)」

> 请实现一个函数来判断整数数组 `postorder`​ 是否为二叉搜索树的后序遍历结果。
>
> **示例 1：**
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240328140931-qfpxreg.png)​
>
> 输入: postorder = [4,9,6,5,8]  
> 输出: false  
> 解释：从上图可以看出这不是一颗二叉搜索树

根据二叉搜索树的定义，可以通过递归，判断所有子树的 正确性 （即其后序遍历是否满足二叉搜索树的定义） ，若所有子树都正确，则此序列为二叉搜索树的后序遍历。

递归解析：

- 终止条件： 当 i≥j ，说明此子树节点数量 ≤1（左子树为空），无需判别正确性，因此直接返回 true ；
- 递推工作：

    - 划分左右子树： 遍历后序遍历的 [i,j] 区间元素，寻找 第一个大于根节点 的节点，索引记为 m 。此时，可划分出左子树区间 [i,m−1]、右子树区间 [m,j−1]、根节点索引 j 。
    - 判断是否为二叉搜索树：

        - 左子树区间 [i,m−1] 内的所有节点都应 < postorder[j] 。而第 1.划分左右子树 步骤已经保证左子树区间的正确性，因此只需要判断右子树区间即可。
        - 右子树区间 [m,j−1] 内的所有节点都应 > postorder[j] 。实现方式为遍历，当遇到 ≤postorder[j] 的节点则跳出；则可通过 p=j 判断是否为二叉搜索树。
- 返回值： 所有子树都需正确才可判定正确，因此使用 与逻辑符 && 连接。

    - p=j： 判断 此树 是否正确。
    - recur(i,m−1)： 判断 此树的左子树 是否正确。
    - recur(m,j−1)： 判断 此树的右子树 是否正确。

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678706119695-0a6ff5cc-13dd-4352-8ea5-61a74b890132-20240328134730-6jw837a.gif)

```java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        return recur(postorder, 0, postorder.length - 1);
    }

    private boolean recur(int[] postorder, int start, int end) {
        if (start >= end) return true; // 当左子树为空的时候，start > end
        // 从start节点往右遍历，找到root的左子树分界点（第一个比root节点大的节点）
        int leftEndIndex = start;
        while (postorder[leftEndIndex] < postorder[end]) ++leftEndIndex;
        // 判断右子树是否都比root节点大
        for (int i = leftEndIndex; i < end; i++) if (postorder[i] < postorder[end]) return false;

        return recur(postorder, start, leftEndIndex - 1) && recur(postorder, leftEndIndex, end - 1);
    }
}
```

复杂度分析：

- 时间复杂度 O(N^2)： 每次调用 recur(i,j) 减去一个根节点，因此递归占用 O(N)；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N)。
- 空间复杂度 O(N) ： 最差情况下（即当树退化为链表），递归深度将达到 N 。

#### **LCR 155.「**​[将二叉搜索树转化为排序的双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/description/)」

> 将一个 **二叉搜索树** 就地转化为一个 **已排序的双向循环链表** 。
>
> 对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
>
> 特别地，我们希望可以 **就地** 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。
>
> ![1678864786908-e3d766c6-292e-46f2-9968-897572b01460](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678864786908-e3d766c6-292e-46f2-9968-897572b01460-20240328134730-sm711so.png)​
>
> 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
>
> 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。
>
> ![1678864787458-02fc8525-87ba-49b4-80a8-eca174f36338](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678864787458-02fc8525-87ba-49b4-80a8-eca174f36338-20240328134730-pfz282t.png)​
>
> 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

本文解法基于性质：二叉搜索树的中序遍历为 递增序列 。 将 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：

1. 排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点。
2. 双向链表： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 。
3. 循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left = tail 和 tail.right = head 。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678864916797-815d8494-e42a-44fa-84a5-61eb200d0985-20240328134730-uqlt6u6.png)  
**中序遍历** 为对二叉树作 “左、根、右” 顺序遍历，递归实现如下：

```java
// 打印中序遍历
void dfs(Node root) {
    if(root == null) return;
    dfs(root.left); // 左
    System.out.println(root.val); // 根
    dfs(root.right); // 右
}
```

根据以上分析，考虑使用中序遍历访问树的各节点 cur ；并在访问每个节点时构建 cur 和前驱节点 pre 的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可。

**算法流程：**

dfs(cur): 递归法中序遍历；

- 终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；
- 递归左子树，即 dfs(cur.left) ；
- 构建链表：

    - 当 pre 为空时： 代表正在访问链表头节点，记为 head ；
    - 当 pre 不为空时： 修改双向节点引用，即 pre.right = cur ， cur.left = pre ；
    - 保存 cur ： 更新 pre = cur ，即节点 cur 是后继节点的 pre ；
- 递归右子树，即 dfs(cur.right) ；

`treeToDoublyList(root)`​：

- 特例处理： 若节点 root 为空，则直接返回；
- 初始化： 空节点 pre ；
- 转化为双向链表： 调用 dfs(root) ；
- 构建循环链表： 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可；
- 返回值： 返回链表的头节点 head 即可；

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1678865210816-bca50088-62ed-4208-8260-749b67358be4-20240328134730-u5hr3yj.gif)  
**复杂度分析：**

- 时间复杂度 O(N) ： N 为二叉树的节点数，中序遍历需要访问所有节点。
- 空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N) 栈空间。

```java
class Solution {
    private Node head, pre;

    public Node treeToDoublyList(Node root) {
        if (root == null) return null;
        dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }

    private void dfs(Node cur) {
        if (cur == null) return;
        dfs(cur.left);
        if (pre == null) { // 已经走到最左叶子节点了，记录下head
            head = cur;
        } else {
            pre.right = cur; // 上一个节点的右子树 ==》 当前节点 (左子树)
            cur.left = pre; // 当前节点的左子树 ==》 上一个节点（右子树）
        }
        pre = cur; // 更新当前节点为上一个节点
        dfs(cur.right);
    }
}
```

#### LCR 156. **「**​[序列化与反序列化二叉树](https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/)」

> 请实现两个函数，分别用来序列化和反序列化二叉树。
>
> 你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
>
> **提示：** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://support.leetcode-cn.com/hc/kb/article/1567641/)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
>
> **示例：**
>
> ![1679039180168-700f1a53-7dc8-4422-b223-19977cee69ec](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679039180168-700f1a53-7dc8-4422-b223-19977cee69ec-20240328134730-oio7cwk.jpeg)​
>
> 输入：root = [1,2,3,null,null,4,5]  
> 输出：[1,2,3,null,null,4,5]

前文 [学习数据结构和算法的框架思维](https://labuladong.github.io/article/fname.html?fname=%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E6%96%B9%E6%B3%95) 说过了二叉树的几种遍历方式，前序遍历框架如下：

```java
void traverse(TreeNode root) {
    if (root == null) return;

    // 前序位置的代码
    traverse(root.left);
    traverse(root.right);
}
```

真的很简单，在递归遍历两棵子树之前写的代码就是前序遍历代码，那么请你看一看如下伪码：

```java
LinkedList<Integer> res;
void traverse(TreeNode root) {
    if (root == null) {
        // 暂且用数字 -1 代表空指针 null
        res.addLast(-1);
        return;
    }

    /****** 前序位置 ******/
    res.addLast(root.val);
    /***********************/

    traverse(root.left);
    traverse(root.right);
}
```

调用 traverse 函数之后，你是否可以立即想出这个 res 列表中元素的顺序是怎样的？比如如下二叉树（# 代表空指针 null），可以直观看出前序遍历做的事情：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679039284970-1ced5ba5-879f-41a7-9b82-8120c1054465-20240328134731-82r4u9r.png)

那么 res = [1,2,-1,4,-1,-1,3,-1,-1]，这就是将二叉树「打平」到了一个列表中，其中 -1 代表 null。

那么，将二叉树打平到一个字符串中也是完全一样的：

```java
// 代表分隔符的字符
String SEP = ",";
// 代表 null 空指针的字符
String NULL = "#";
// 用于拼接字符串
StringBuilder sb = new StringBuilder();

/* 将二叉树打平为字符串 */
void traverse(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    /****** 前序位置 ******/
    sb.append(root.val).append(SEP);
    /***********************/

    traverse(root.left, sb);
    traverse(root.right, sb);
}
```

StringBuilder 可以用于高效拼接字符串，所以也可以认为是一个列表，用 , 作为分隔符，用 # 表示空指针 null，调用完 traverse 函数后，sb 中的字符串应该是 1,2,\#,4,\#,\#,3,\#,\#, 。

至此，我们已经可以写出序列化函数 serialize 的代码了：

```java
String SEP = ",";
String NULL = "#";

/* 主函数，将二叉树序列化为字符串 */
String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    return sb.toString();
}

/* 辅助函数，将二叉树存入 StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    /****** 前序位置 ******/
    sb.append(root.val).append(SEP);  



    /***********************/

    serialize(root.left, sb);
    serialize(root.right, sb);
}
```

现在，思考一下如何写 deserialize 函数，将字符串反过来构造二叉树。

首先我们可以把字符串转化成列表：

```java
String data = "1,2,#,4,#,#,3,#,#,";
String[] nodes = data.split(",");
```

这样，nodes 列表就是二叉树的前序遍历结果，问题转化为：如何通过二叉树的前序遍历结果还原一棵二叉树？

根据我们刚才的分析，nodes 列表就是一棵打平的二叉树：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679039407135-503730bb-3862-4e27-a6d4-ccb48283aaa4-20240328134731-i2u9h10.png)

那么，反序列化过程也是一样，**先确定根节点 root，然后遵循前序遍历的规则，递归生成左右子树即可**：

```java
public class Codec {
    String SEP = ",";
    String NULL = "#";

    /* 主函数，将二叉树序列化为字符串 */
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serialize(root, sb);
        return sb.toString();
    }

    /* 辅助函数，将二叉树存入 StringBuilder */
    void serialize(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append(NULL).append(SEP);
            return;
        }

        /******前序遍历位置******/
        sb.append(root.val).append(SEP);
        /***********************/

        serialize(root.left, sb);
        serialize(root.right, sb);
    }

    /* 主函数，将字符串反序列化为二叉树结构 */
    public TreeNode deserialize(String data) {
        // 将字符串转化成列表
        LinkedList<String> nodes = new LinkedList<>();
        for (String s : data.split(SEP)) {
            nodes.addLast(s);
        }
        return deserialize(nodes);
    }

    /* 辅助函数，通过 nodes 列表构造二叉树 */
    TreeNode deserialize(LinkedList<String> nodes) {
        if (nodes.isEmpty()) return null;

        /******前序遍历位置******/
        // 列表最左侧就是根节点
        String first = nodes.removeFirst();
        if (first.equals(NULL)) return null;
        TreeNode root = new TreeNode(Integer.parseInt(first));
        /***********************/

        root.left = deserialize(nodes);
        root.right = deserialize(nodes);

        return root;
    }
}
```

#### **LCR 174.「**​[寻找二叉搜索树中的目标节点](https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)」

> 给某公司组织架构以二叉搜索树形式记录，节点值为处于该职位的员工编号。请返回第 `cnt`​ 大的员工编号。
>
> **示例 1：**
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1699260756716-8af8f629-8d25-4554-875c-a00facfc6731-20240328134731-j00ls5e.png)  
> ​![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1699260780035-efa6dc7c-0920-42ce-bde5-e8888627727d-20240328134731-q6pa10z.png)

本题可以利用 BST 的中序遍历计算第 k 大的元素。只不过常规的中序遍历得到的顺序是从小到大的，而我们想得到从大到小的顺序。

这也很简单，只要把中序遍历框架反过来，先递归遍历右子树，再递归遍历左子树，即可获得降序结果：

```java
class Solution {

    private int topK;
    private int k;

    public int kthLargest(TreeNode root, int k) {
        this.k = k;
        dfs(root);
        return topK;
    }

    private void dfs(TreeNode root) {
        if (root == null || k == 0) {
            return;
        }
        dfs(root.right);
        if(--k == 0) topK = root.val;
        dfs(root.left);
    }
}
```

#### **LCR 176.「**​[判断是否为平衡二叉树](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/description/)」

> 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
>
> **示例 1:**
>
> 输入：root = [3,9,20,null,null,15,7]  
> 输出：true  
> 解释：如下图
>
> ![image](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/image-20240328145508-0zz6ht2.png)​

**后序遍历 + 剪枝 （从底至顶）**

思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。

**算法流程：**

**dfs(root) 函数：**

**返回值：**

1. 当节点root 左 / 右子树的深度差 ≤1：则返回当前子树的深度，即节点 root 的左 / 右子树的深度最大值 +1（`max(left, right) + 1`​）
2. 当节点root 左 / 右子树的深度差 >2：则返回 −1，代表 **此子树不是平衡树** 。

**终止条件：**

- 当 root 为空：说明越过叶节点，因此返回高度 0 ；
- 当左（右）子树深度为 −1 ：代表此树的 左（右）子树 不是平衡树，因此剪枝，直接返回 −1；

复杂度分析：

- 时间复杂度 O(N)： N 为树的节点数；最差情况下，需要递归遍历树的所有节点。
- 空间复杂度 O(N)： 最差情况下（树退化为链表时），系统递归需要使用 O(N)的栈空间。

![test.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1679911802395-3cef6651-1eb5-40c3-8e5a-979b2bc314db-20240328134731-n6rgb7u.gif)

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return dfs(root) != -1;
    }

    private int dfs(TreeNode root) {
        if (root == null) return 0;
        int left = dfs(root.left);
        if (left == -1) return -1;
        int right = dfs(root.right);
        if (right == -1) return -1;
        return Math.abs(left - right) > 1 ? -1 : Math.max(left, right) + 1;
    }
}
```

## 栈

### 提纲

### 练习题

#### **LCR 148.「**​[验证图书取出顺序](https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)」

> 现在图书馆有一堆图书需要放入书架，并且图书馆的书架是一种特殊的数据结构，只能按照 **一定** 的顺序 **放入** 和 **拿取** 书籍。
>
> 给定一个表示图书放入顺序的整数序列 putIn，请判断序列 takeOut 是否为按照正确的顺序拿取书籍的操作序列。你可以假设放入书架的所有书籍编号都不相同。
>
> **示例 1：**
>
> 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]  
> 输出：true  
> 解释：我们可以按以下顺序执行：  
> push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1

‍

思路很简单，我们尝试按照 popped 中的顺序模拟一下出栈操作，如果符合则返回 true，否则返回 false。这里用到的贪心法则是如果栈顶元素等于 popped 序列中下一个要 pop 的值，则应立刻将该值 pop 出来。

我们使用一个栈 st 来模拟该操作。将 pushed 数组中的每个数依次入栈，同时判断这个数是不是 popped 数组中下一个要 pop 的值，如果是就把它 pop 出来。最后检查栈是否为空。

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        Stack<Integer> stack = new Stack<>();
        int i = 0;
        for(int num : pushed) {
            stack.push(num); // num 入栈
            while(!stack.isEmpty() && stack.peek() == popped[i]) { // 循环判断与出栈
                stack.pop();
                i++;
            }
        }
        return stack.isEmpty();
    }
}
```

复杂度分析：

- 时间复杂度 O(N)： 其中 N为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。
- 空间复杂度 O(N) ： 辅助栈 stack 最多同时存储 N个元素。

## 字符串

### 练习题

#### **LCR 138.「**​[有效数字](https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/description/)」

> 请实现一个函数用来判断字符串是否表示**数值**（包括整数和小数）。  
> **数值**（按顺序）可以分成以下几个部分：
>
> 1. 若干空格
> 2. 一个 **小数** 或者 **整数**
> 3. （可选）一个 'e' 或 'E' ，后面跟着一个 **整数**
> 4. 若干空格
>
> **小数**（按顺序）可以分成以下几个部分：
>
> 1. （可选）一个符号字符（'+' 或 '-'）
> 2. 下述格式之一：
     >
     >     1. 至少一位数字，后面跟着一个点 '.'
>     2. 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字
>     3. 一个点 '.' ，后面跟着至少一位数字
>
> **整数**（按顺序）可以分成以下几个部分：
>
> 1. （可选）一个符号字符（'+' 或 '-'）
> 2. 至少一位数字
>
> 部分**数值**列举如下：
>
> - ["+100", "5e2", "-123", "3.1416", "-1E-16", "0123"]
>
> 部分**非数值**列举如下：
>
> - ["12e", "1a3.14", "1.2.3", "+-5", "12e+5.4"]
>
> **示例 1：**   
> 输入：s = "    .1  "  
> 输出：true

1. 首先定义了四个flag，对应四种字符

    1. 是否有数字：hasNum
    2. 是否有e：hasE
    3. 是否有正负符号：hasSign
    4. 是否有点：hasDot
2. 其余还定义了字符串长度n以及字符串索引index
3. 先处理一下开头的空格，index相应的后移
4. 然后进入循环，遍历字符串

    1. 如果当前字符c是数字：将hasNum置为true，index往后移动一直到非数字或遍历到末尾位置；如果已遍历到末尾(index == n)，结束循环
    2. 如果当前字符c是'e'或'E'：如果e已经出现或者当前e之前没有出现过数字，返回fasle；否则令hasE = true，并且将其他3个flag全部置为false，因为要开始遍历e后面的新数字了
    3. 如果当前字符c是+或-：如果已经出现过+或-或者已经出现过数字或者已经出现过'.'，返回flase；否则令hasSign = true
    4. 如果当前字符c是'.'：如果已经出现过'.'或者已经出现过'e'或'E'，返回false；否则令hasDot = true
    5. 如果当前字符c是' '：结束循环，因为可能是末尾的空格了，但也有可能是字符串中间的空格，在循环外继续处理
    6. 如果当前字符c是除了上面5种情况以外的其他字符，直接返回false
5. 处理空格，index相应的后移
6. 如果当前索引index与字符串长度相等，说明遍历到了末尾，但是还要满足hasNum为true才可以最终返回true，因为如果字符串里全是符号没有数字的话是不行的，而且e后面没有数字也是不行的，但是没有符号是可以的，所以4个flag里只要判断一下hasNum就行；所以最后返回的是hasNum && index == n
7. 如果字符串中间有空格，按以上思路是无法遍历到末尾的，index不会与n相等，返回的就是false

```java
public boolean validNumber(String s) {
    boolean hasNum = false; // 标记是否有数字
    boolean hasE = false; // 标记是否有E
    boolean hasSign = false; // 标记是否有+-
    boolean hasDot = false; // 标记是否有.
    char[] chars = s.trim().toCharArray();
    for (char ch : chars) {
        if (ch >= '0' && ch <= '9') {
            hasNum = true;
        } else if (ch == 'e' || ch == 'E') {
            if (hasE || !hasNum) { // 前面出现了e或者前面没有数字
                return false;
            }
            hasE = true;
            // 重置数字、符号和.标识
            hasNum = false;
            hasDot = false;
            hasSign = false;
        } else if (ch == '+' || ch == '-') {
            if (hasSign || hasDot || hasNum) { // 前面有数字或者.或者+-
                return false;
            }
            hasSign = true;
        } else if (ch == '.') {
            if (hasDot || hasE) { // 前面出现过.或者前面有E
                return false;
            }
            hasDot = true;
        } else {
            return false; // 其他情况一律是false
        }
    }
    return hasNum;
}
```

## 二叉堆

### 一、二叉堆概览

首先，二叉堆和二叉树有啥关系呢，为什么人们总是把二叉堆画成一棵二叉树？

因为，二叉堆在逻辑上其实是一种特殊的二叉树（完全二叉树），只不过存储在数组里。一般的链表二叉树，我们操作节点的指针，而在数组里，我们把数组索引作为指针：

```java
// 父节点的索引
int parent(int root) {
    return root / 2;
}
// 左孩子的索引
int left(int root) {
    return root * 2;
}
// 右孩子的索引
int right(int root) {
    return root * 2 + 1;
}
```

画个图你立即就能理解了，比如 arr 是一个字符数组，注意数组的第一个索引 0 空着不用：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686901624582-6555fe3a-06ae-4487-b626-5baabfd8c08a-20240328155726-hv8cu2f.png)

你看到了，因为这棵二叉树是「完全二叉树」，所以把 arr[1] 作为整棵树的根的话，每个节点的父节点和左右孩子的索引都可以通过简单的运算得到，这就是二叉堆设计的一个巧妙之处。

为了方便讲解，下面都会画的图都是二叉树结构，相信你能把树和数组对应起来。

二叉堆还分为最大堆和最小堆。**最大堆的性质是：每个节点都大于等于它的两个子节点**。类似的，最小堆的性质是：每个节点都小于等于它的子节点。

两种堆核心思路都是一样的，本文以最大堆为例讲解。

对于一个最大堆，根据其性质，显然堆顶，也就是 arr[1] 一定是所有元素中最大的元素。

### 二、优先级队列概览

优先级队列这种数据结构有一个很有用的功能，你插入或者删除元素的时候，元素会自动排序，这底层的原理就是二叉堆的操作。

数据结构的功能无非增删查改，优先级队列有两个主要 API，分别是 insert 插入一个元素和 delMax 删除最大元素（如果底层用最小堆，那么就是 delMin）。

下面我们实现一个简化的优先级队列，先看下代码框架：

```java
public class MaxPQ
    <Key extends Comparable<Key>> {
    // 存储元素的数组
    private Key[] pq;
    // 当前 Priority Queue 中的元素个数
    private int size = 0;

    public MaxPQ(int cap) {
        // 索引 0 不用，所以多分配一个空间
        pq = (Key[]) new Comparable[cap + 1];
    }

    /* 返回当前队列中最大元素 */
    public Key max() {
        return pq[1];
    }

    /* 插入元素 e */
    public void insert(Key e) {...}

    /* 删除并返回当前队列中最大元素 */
    public Key delMax() {...}

    /* 上浮第 x 个元素，以维护最大堆性质 */
    private void swim(int x) {...}

    /* 下沉第 x 个元素，以维护最大堆性质 */
    private void sink(int x) {...}

    /* 交换数组的两个元素 */
    private void swap(int i, int j) {
        Key temp = pq[i];
        pq[i] = pq[j];
        pq[j] = temp;
    }

    /* pq[i] 是否比 pq[j] 小？ */
    private boolean less(int i, int j) {
        return pq[i].compareTo(pq[j]) < 0;
    }

    /* 还有 left, right, parent 三个方法 */
}
```

空出来的四个方法是二叉堆和优先级队列的奥妙所在，下面用图文来逐个理解。

### 三、实现 swim 和 sink

为什么要有上浮 swim 和下沉 sink 的操作呢？为了维护堆结构。

我们要讲的是最大堆，每个节点都比它的两个子节点大，但是在插入元素和删除元素时，难免破坏堆的性质，这就需要通过这两个操作来恢复堆的性质了。

对于最大堆，会破坏堆性质的有两种情况：

1、如果某个节点 A 比它的子节点（中的一个）小，那么 A 就不配做父节点，应该下去，下面那个更大的节点上来做父节点，这就是对 A 进行**下沉**。

2、如果某个节点 A 比它的父节点大，那么 A 不应该做子节点，应该把父节点换下来，自己去做父节点，这就是对 A 的**上浮**。

当然，错位的节点 A 可能要上浮（或下沉）很多次，才能到达正确的位置，恢复堆的性质。所以代码中肯定有一个 while 循环。

细心的读者也许会问，这两个操作不是互逆吗，所以上浮的操作一定能用下沉来完成，为什么我还要费劲写两个方法？

是的，操作是互逆等价的，但是最终我们的操作只会在堆底和堆顶进行（等会讲原因），显然堆底的「错位」元素需要上浮，堆顶的「错位」元素需要下沉。

**上浮的代码实现：**

```java
public class MaxPQ <Key extends Comparable<Key>> {
    // 为了节约篇幅，省略上文给出的代码部分...

    private void swim(int x) {
        // 如果浮到堆顶，就不能再上浮了
        while (x > 1 && less(parent(x), x)) {
            // 如果第 x 个元素比上层大
            // 将 x 换上去
            swap(parent(x), x);
            x = parent(x);
        }
    }
}
```

画个 GIF 看一眼就明白了：

![1.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686901723512-5310cb8f-0172-4d4d-9276-0ba9591b7f95-20240328155726-i2t5asz.gif)

**下沉的代码实现：**

下沉比上浮略微复杂一点，因为上浮某个节点 A，只需要 A 和其父节点比较大小即可；但是下沉某个节点 A，需要 A 和其**两个子节点**比较大小，如果 A 不是最大的就需要调整位置，要把较大的那个子节点和 A 交换。

```java
public class MaxPQ <Key extends Comparable<Key>> {
    // 为了节约篇幅，省略上文给出的代码部分...

    private void sink(int x) {
        // 如果沉到堆底，就沉不下去了
        while (left(x) <= size) {
            // 先假设左边节点较大
            int max = left(x);
            // 如果右边节点存在，比一下大小
            if (right(x) <= size && less(max, right(x)))
                max = right(x);
            // 结点 x 比俩孩子都大，就不必下沉了
            if (less(max, x)) break;
            // 否则，不符合最大堆的结构，下沉 x 结点
            swap(x, max);
            x = max;
        }
    }
}
```

画个 GIF 看一眼就明白了：

![1.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686901785461-cc94fa45-d4e8-4a0c-9e07-27fa7e719bac-20240328155726-1xt6gh0.gif)

至此，二叉堆的主要操作就讲完了，一点都不难吧，代码加起来也就十行。明白了 sink 和 swim 的行为，下面就可以实现优先级队列了。

### 四、实现 delMax 和 insert

这两个方法就是建立在 swim 和 sink 上的。

**insert 方法先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置**。

![1.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686901838471-d81093f7-10da-4033-8be5-10c5a838cc08-20240328155726-sb8j6nz.gif)

```java
public class MaxPQ <Key extends Comparable<Key>> {
    // 为了节约篇幅，省略上文给出的代码部分...

    public void insert(Key e) {
        size++;
        // 先把新元素加到最后
        pq[size] = e;
        // 然后让它上浮到正确的位置
        swim(size);
    }
}
```

**delMax 方法先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B 下沉到正确位置**。

```java
public class MaxPQ <Key extends Comparable<Key>> {
    // 为了节约篇幅，省略上文给出的代码部分...

    public Key delMax() {
        // 最大堆的堆顶就是最大元素
        Key max = pq[1];
        // 把这个最大元素换到最后，删除之
        swap(1, size);
        pq[size] = null;
        size--;
        // 让 pq[1] 下沉到正确位置
        sink(1);
        return max;
    }
}
```

![1.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686901881039-d65ff1da-5a33-438c-9cf3-c62a2591a49a-20240328155726-tebd3t7.gif)  
至此，一个优先级队列就实现了，插入和删除元素的时间复杂度为 O(logK)，K 为当前二叉堆（优先级队列）中的元素总数。因为我们时间复杂度主要花费在 sink 或者 swim 上，而不管上浮还是下沉，最多也就树（堆)的高度，也就是 log 级别。

### 五、最后总结

二叉堆就是一种完全二叉树，所以适合存储在数组中，而且二叉堆拥有一些特殊性质。

二叉堆的操作很简单，主要就是上浮和下沉，来维护堆的性质（堆有序），核心代码也就十行。

优先级队列是基于二叉堆实现的，主要操作是插入和删除。插入是先插到最后，然后上浮到正确位置；删除是调换位置后再删除，然后下沉到正确位置。核心代码也就十行。

也许这就是数据结构的威力，简单的操作就能实现巧妙的功能，真心佩服发明二叉堆算法的人！

## 图

### 图论基础

#### 图的逻辑结构和具体实现

一幅图是由**节点**和**边**构成的，逻辑结构如下：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685526302678-b4024b70-87ec-4e85-a7de-57779ffbb89d-20240328160033-rk4ee9k.png)

**什么叫「逻辑结构」？就是说为了方便研究，我们把图抽象成这个样子**。

根据这个逻辑结构，我们可以认为每个节点的实现如下：

```java
/* 图节点的逻辑结构 */
class Vertex {
    int id;
    Vertex[] neighbors;
}
```

看到这个实现，你有没有很熟悉？它和我们之前说的多叉树节点几乎完全一样：

```java
/* 基本的 N 叉树节点 */
class TreeNode {
    int val;
    TreeNode[] children;
}
```

所以说，图真的没啥高深的，本质上就是个高级点的多叉树而已，适用于树的 DFS/BFS 遍历算法，全部适用于图。

不过呢，上面的这种实现是「逻辑上的」，实际上我们很少用这个 Vertex 类实现图，而是用常说的**邻接表和邻接矩阵**来实现。  
比如还是刚才那幅图：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685526364031-909f56bd-c8b1-451f-94ee-dc3973566472-20240328160033-7w5hnwa.png)

用邻接表和邻接矩阵的存储方式如下：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685526384690-526501b4-a410-43f7-8646-f5329463e5b5-20240328160033-5o2ek3e.png)  
邻接表很直观，我把每个节点 x 的邻居都存到一个列表里，然后把 x 和这个列表关联起来，这样就可以通过一个节点 x 找到它的所有相邻节点。

邻接矩阵则是一个二维布尔数组，我们权且称为 matrix，如果节点 x 和 y 是相连的，那么就把 matrix[x][y] 设为 true（上图中绿色的方格代表 true)。如果想找节点 x 的邻居，去扫一圈 matrix[x][..] 就行了。

如果用代码的形式来表现，邻接表和邻接矩阵大概长这样：

```java
// 邻接表
// graph[x] 存储 x 的所有邻居节点
List<Integer>[] graph;

// 邻接矩阵
// matrix[x][y] 记录 x 是否有一条指向 y 的边
boolean[][] matrix;
```

**那么，为什么有这两种存储图的方式呢？肯定是因为他们各有优劣**。

对于邻接表，好处是占用的空间少。

你看邻接矩阵里面空着那么多位置，肯定需要更多的存储空间。

但是，邻接表无法快速判断两个节点是否相邻。

比如说我想判断节点 1 是否和节点 3 相邻，我要去邻接表里 1 对应的邻居列表里查找 3 是否存在。但对于邻接矩阵就简单了，只要看看 matrix[1][3] 就知道了，效率高。

所以说，使用哪一种方式实现图，要看具体情况。

最后，我们再明确一个图论中特有的**度**（degree）的概念，在无向图中，「度」就是每个节点相连的边的条数。

由于有向图的边有方向，所以有向图中每个节点「度」被细分为**入度**（indegree）和**出度**（outdegree），比如下图：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685526494467-f0c68652-4b23-481a-867f-58a7090a9206-20240328160033-wdyhiv8.png)

其中节点 3 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点)。

好了，对于「图」这种数据结构，能看懂上面这些就绰绰够用了。

那你可能会问，我们上面说的这个图的模型仅仅是「有向无权图」，不是还有什么加权图，无向图，等等……

**其实，这些更复杂的模型都是基于这个最简单的图衍生出来的**。

**有向加权图怎么实现**？很简单呀：

如果是邻接表，我们不仅仅存储某个节点 x 的所有邻居节点，还存储 x 到每个邻居的权重，不就实现加权有向图了吗？

如果是邻接矩阵，matrix[x][y] 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重，不就变成加权有向图了吗？

如果用代码的形式来表现，大概长这样：

```java
// 邻接表
// graph[x] 存储 x 的所有邻居节点以及对应的权重
List<int[]>[] graph;

// 邻接矩阵
// matrix[x][y] 记录 x 指向 y 的边的权重，0 表示不相邻
int[][] matrix;
```

**无向图怎么实现**？也很简单，所谓的「无向」，是不是等同于「双向」？

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685526535468-2b9f319c-a4f5-4b7e-9525-21378863b23c-20240328160033-pb9hpcn.png)

如果连接无向图中的节点 x 和 y，把 matrix[x][y] 和 matrix[y][x] 都变成 true 不就行了；邻接表也是类似的操作，在 x 的邻居列表里添加 y，同时在 y 的邻居列表里添加 x。

把上面的技巧合起来，就变成了无向加权图……

#### 图的遍历

图怎么遍历？还是那句话，参考多叉树，多叉树的 DFS 遍历框架如下：

```java
/* 多叉树遍历框架 */
void traverse(TreeNode root) {
    if (root == null) return;
    // 前序位置
    for (TreeNode child : root.children) {
        traverse(child);
    }
    // 后序位置
}
```

图和多叉树最大的区别是，图是可能包含环的，你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点，而树不会出现这种情况，从某个节点出发必然走到叶子节点，绝不可能回到它自身。

所以，如果图包含环，遍历框架就要一个 visited 数组进行辅助：

```java
// 记录被遍历过的节点
boolean[] visited;
// 记录从起点到当前节点的路径
boolean[] onPath;

/* 图遍历框架 */
void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // 经过节点 s，标记为已遍历
    visited[s] = true;
    // 做选择：标记节点 s 在路径上
    onPath[s] = true;
    for (int neighbor : graph.neighbors(s)) {
        traverse(graph, neighbor);
    }
    // 撤销选择：节点 s 离开路径
    onPath[s] = false;
}
```

注意 visited 数组和 onPath 数组的区别，因为二叉树算是特殊的图，所以用遍历二叉树的过程来理解下这两个数组的区别：

![1.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685526721158-7928e3c6-3f70-482a-83ac-ead1882cd893-20240328160033-4y69gsl.gif)

**上述 GIF 描述了递归遍历二叉树的过程，在 visited 中被标记为 true 的节点用灰色表示，在 onPath 中被标记为 true 的节点用绿色表示**，类比贪吃蛇游戏，visited 记录蛇经过过的格子，而 onPath 仅仅记录蛇身。在图的遍历过程中，onPath 用于判断是否成环，类比当贪吃蛇自己咬到自己（成环）的场景，这下你可以理解它们二者的区别了吧。

如果让你处理路径相关的问题，这个 onPath 变量是肯定会被用到的，比如 [拓扑排序](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/) 中就有运用。

另外，你应该注意到了，这个 onPath 数组的操作很像前文 [回溯算法核心套路](https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 中做「做选择」和「撤销选择」，区别在于位置：回溯算法的「做选择」和「撤销选择」在 for 循环里面，而对 onPath 数组的操作在 for 循环外面。

为什么有这个区别呢？这就是前文 [回溯算法核心套路](https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 中讲到的回溯算法和 DFS 算法的区别所在：回溯算法关注的不是节点，而是树枝。不信你看前文画的回溯树，我们需要在「树枝」上做选择和撤销选择：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685526758557-eb6cf94a-8e41-4e8c-b28e-a13121881c4c-20240328160033-nblzzmj.png)

他们的区别可以这样反应到代码上：

```java
// DFS 算法，关注点在节点
void traverse(TreeNode root) {
    if (root == null) return;
    printf("进入节点 %s", root);
    for (TreeNode child : root.children) {
        traverse(child);
    }
    printf("离开节点 %s", root);
}

// 回溯算法，关注点在树枝
void backtrack(TreeNode root) {
    if (root == null) return;
    for (TreeNode child : root.children) {
        // 做选择
        printf("从 %s 到 %s", root, child);
        backtrack(child);
        // 撤销选择
        printf("从 %s 到 %s", child, root);
    }
}
```

如果执行这段代码，你会发现根节点被漏掉了：

```java
void traverse(TreeNode root) {
    if (root == null) return;
    for (TreeNode child : root.children) {
        printf("进入节点 %s", child);
        traverse(child);
        printf("离开节点 %s", child);
    }
}
```

所以对于这里「图」的遍历，我们应该用 DFS 算法，即把 onPath 的操作放到 for 循环外面，否则会漏掉记录起始点的遍历。  
说了这么多 onPath 数组，再说下 visited 数组，其目的很明显了，由于图可能含有环，visited 数组就是防止递归重复遍历同一个节点进入死循环的。

当然，如果题目告诉你图中不含环，可以把 visited 数组都省掉，基本就是多叉树的遍历。

#### 练习题

##### 797.「 [所有可能路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)」

> 给你一个有 `n`​ 个节点的 **有向无环图（DAG）** ，请你找出所有从节点 `0`​ 到节点 `n-1`​ 的路径并输出（**不要求按特定顺序**）
>
> `graph[i]`​ 是一个从节点 `i`​ 可以访问的所有节点的列表（即从节点 `i`​ 到节点 `graph[i][j]`​存在一条有向边）。
>
> **示例 1：**
>
> ![1685527240889-7b96748d-87c3-466a-9a2e-5126789a9d41](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685527240889-7b96748d-87c3-466a-9a2e-5126789a9d41-20240328160033-qdsobei.jpeg)​
>
> 输入：graph = [[1,2],[3],[3],[]]  
> 输出：[[0,1,3],[0,2,3]]  
> 解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3

题目输入一幅**有向无环图**，这个图包含 n 个节点，标号为 0, 1, 2,..., n - 1，请你计算所有从节点 0 到节点 n - 1 的路径。

输入的这个 graph 其实就是「邻接表」表示的一幅图，graph[i] 存储这节点 i 的所有邻居节点。

比如输入 graph = [[1,2],[3],[3],[]]，就代表下面这幅图：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685527301089-d304a4f9-35b0-4c53-9090-eeb1485b9c6a-20240328160034-y5rxk56.png)

算法应该返回 [[0,1,3],[0,2,3]]，即 0 到 3 的所有路径。

**解法很简单，以 0 为起点遍历图，同时记录遍历过的路径，当遍历到终点时将路径记录下来即可**。

既然输入的图是无环的，我们就不需要 visited 数组辅助了，直接套用图的遍历框架：

```java
class Solution {
    // 记录所有路径
    List<List<Integer>> res = new LinkedList<>();
    
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        // 维护递归过程中经过的路径
        LinkedList<Integer> path = new LinkedList<>();
        traverse(graph, 0, path);
        return res;
    }

    /* 图的遍历框架 */
    void traverse(int[][] graph, int s, LinkedList<Integer> path) {
        // 添加节点 s 到路径
        path.addLast(s);

        int n = graph.length;
        if (s == n - 1) {
            // 到达终点
            res.add(new LinkedList<>(path));
            // 可以在这直接 return，但要 removeLast 正确维护 path
            // path.removeLast();
            // return;
            // 不 return 也可以，因为图中不包含环，不会出现无限递归
        }

        // 递归每个相邻节点
        for (int v : graph[s]) {
            traverse(graph, v, path);
        }
    
        // 从路径移出节点 s
        path.removeLast();
    }
}
```

### 环检测算法以及拓扑排序算法

#### 环检测算法

##### 练习题

###### 207.「 [课程表](https://leetcode.cn/problems/course-schedule/)」

> 你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。
>
> 在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 **必须** 先学习课程  bi 。
>
> - 例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
>
> 请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。
>
> **示例 1：**   
> 输入：numCourses = 2, prerequisites = [[1,0]]  
> 输出：true  
> 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。

###### DFS版

我们可以根据题目输入的 prerequisites 数组生成一幅类似这样的图：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685696085081-d80e811e-b29c-4faa-abdc-185398340112-20240328163701-ms47fdt.png)

**如果发现这幅有向图中存在环，那就说明课程之间存在循环依赖，肯定没办法全部上完；反之，如果没有环，那么肯定能上完全部课程**。

好，那么想解决这个问题，首先我们要把题目的输入转化成一幅有向图，然后再判断图中是否存在环。

如何转换成图呢？我们前文 [图论基础](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/) 写过图的两种存储形式，邻接矩阵和邻接表。

以我刷题的经验，常见的存储方式是使用邻接表，比如下面这种结构：

```java
List<Integer>[] graph;
```

**graph[s] 是一个列表，存储着节点 s 所指向的节点**。

所以我们首先可以写一个建图函数：

```java
List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
    // 图中共有 numCourses 个节点
    List<Integer>[] graph = new LinkedList[numCourses];
    for (int i = 0; i < numCourses; i++) {
        graph[i] = new LinkedList<>();
    }
    for (int[] edge : prerequisites) {
        int from = edge[1], to = edge[0];
        // 添加一条从 from 指向 to 的有向边
        // 边的方向是「被依赖」关系，即修完课程 from 才能修课程 to
        graph[from].add(to);
    }
    return graph;
}
```

图建出来了，怎么判断图中有没有环呢？

**先不要急，我们先来思考如何遍历这幅图，只要会遍历，就可以判断图中是否存在环了**。

前文 [图论基础](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/) 写了 DFS 算法遍历图的框架，无非就是从多叉树遍历框架扩展出来的，加了个 visited 数组罢了：

```java
// 防止重复遍历同一个节点
boolean[] visited;
// 从节点 s 开始 DFS 遍历，将遍历过的节点标记为 true
void traverse(List<Integer>[] graph, int s) {
    if (visited[s]) {
        return;
    }
    /* 前序遍历代码位置 */
    // 将当前节点标记为已遍历
    visited[s] = true;
    for (int t : graph[s]) {
        traverse(graph, t);
    }
    /* 后序遍历代码位置 */
}
```

那么我们就可以直接套用这个遍历代码：

```java
// 防止重复遍历同一个节点
boolean[] visited;

boolean canFinish(int numCourses, int[][] prerequisites) {
    List<Integer>[] graph = buildGraph(numCourses, prerequisites);
  
    visited = new boolean[numCourses];
    for (int i = 0; i < numCourses; i++) {
        traverse(graph, i);
    }
}

void traverse(List<Integer>[] graph, int s) {
    // 代码见上文
}
```

注意图中并不是所有节点都相连，所以要用一个 for 循环将所有节点都作为起点调用一次 DFS 搜索算法。

这样，就能遍历这幅图中的所有节点了，你打印一下 visited 数组，应该全是 true。

前文 [学习数据结构和算法的框架思维](https://labuladong.github.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/) 说过，图的遍历和遍历多叉树差不多，所以到这里你应该都能很容易理解。

现在可以思考如何判断这幅图中是否存在环。

我们前文 [回溯算法核心套路详解](https://labuladong.github.io/algo/di-ling-zh-bfe1b/hui-su-sua-c26da/) 说过，你可以把递归函数看成一个在递归树上游走的指针，这里也是类似的：

你也可以把 traverse 看做在图中节点上游走的指针，只需要再添加一个布尔数组 onPath 记录当前 traverse 经过的路径：

```java
boolean[] onPath;
boolean[] visited;

boolean hasCycle = false;

void traverse(List<Integer>[] graph, int s) {
    if (onPath[s]) {
        // 发现环！！！
        hasCycle = true;
    }
    if (visited[s] || hasCycle) {
        return;
    }
    // 将节点 s 标记为已遍历
    visited[s] = true;
    // 开始遍历节点 s
    onPath[s] = true;
    for (int t : graph[s]) {
        traverse(graph, t);
    }
    // 节点 s 遍历完成
    onPath[s] = false;
}
```

这里就有点回溯算法的味道了，在进入节点 s 的时候将 onPath[s] 标记为 true，离开时标记回 false，如果发现 onPath[s] 已经被标记，说明出现了环。

注意 visited 数组和 onPath 数组的区别，因为二叉树算是特殊的图，所以用遍历二叉树的过程来理解下这两个数组的区别：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685696906106-0b66ff5c-e1ab-418f-b909-045d90e23253-20240328163701-xaanbeo.png)

**上述 GIF 描述了递归遍历二叉树的过程，在 visited 中被标记为 true 的节点用灰色表示，在 onPath 中被标记为 true 的节点用绿色表示**。

> 类比贪吃蛇游戏，visited 记录蛇经过过的格子，而 onPath 仅仅记录蛇身。onPath 用于判断是否成环，类比当贪吃蛇自己咬到自己（成环）的场景。

这样，就可以在遍历图的过程中顺便判断是否存在环了，完整代码如下：

```java
class Solution {
    // 记录一次递归堆栈中的节点
    boolean[] onPath;
    // 记录遍历过的节点，防止走回头路
    boolean[] visited;
    // 记录图中是否有环
    boolean hasCycle = false;

    boolean canFinish(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
    
        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];
    
        for (int i = 0; i < numCourses; i++) {
            // 遍历图中的所有节点
            traverse(graph, i);
        }
        // 只要没有循环依赖可以完成所有课程
        return !hasCycle;
    }

    void traverse(List<Integer>[] graph, int s) {
        if (onPath[s]) {
            // 出现环
            hasCycle = true;
        }
    
        if (visited[s] || hasCycle) {
            // 如果已经找到了环，也不用再遍历了
            return;
        }
        // 前序代码位置
        visited[s] = true;
        onPath[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        // 后序代码位置
        onPath[s] = false;
    }

    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        // 代码见前文
    }
}
```

###### BFS版

刚才讲了用 DFS 算法利用 onPath 数组判断是否存在环；也讲了用 DFS 算法利用逆后序遍历进行拓扑排序。

其实 BFS 算法借助 indegree 数组记录每个节点的「入度」，也可以实现这两个算法。不熟悉 BFS 算法的读者可阅读前文 [BFS 算法核心框架](https://labuladong.github.io/algo/di-ling-zh-bfe1b/bfs-suan-f-463fd/)。

所谓「出度」和「入度」是「有向图」中的概念，很直观：如果一个节点 x 有 a 条边指向别的节点，同时被 b 条边所指，则称节点 x 的出度为 a，入度为 b。

先说环检测算法，直接看 BFS 的解法代码：

```java
// 主函数
public boolean canFinish(int numCourses, int[][] prerequisites) {
    // 建图，有向边代表「被依赖」关系
    List<Integer>[] graph = buildGraph(numCourses, prerequisites);
    // 构建入度数组
    int[] indegree = new int[numCourses];
    for (int[] edge : prerequisites) {
        int from = edge[1], to = edge[0];
        // 节点 to 的入度加一
        indegree[to]++;
    }

    // 根据入度初始化队列中的节点
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (indegree[i] == 0) {
            // 节点 i 没有入度，即没有依赖的节点
            // 可以作为拓扑排序的起点，加入队列
            q.offer(i);
        }
    }

    // 记录遍历的节点个数
    int count = 0;
    // 开始执行 BFS 循环
    while (!q.isEmpty()) {
        // 弹出节点 cur，并将它指向的节点的入度减一
        int cur = q.poll();
        count++;
        for (int next : graph[cur]) {
            indegree[next]--;
            if (indegree[next] == 0) {
                // 如果入度变为 0，说明 next 依赖的节点都已被遍历
                q.offer(next);
            }
        }
    }

    // 如果所有节点都被遍历过，说明不成环
    return count == numCourses;
}


// 建图函数
List<Integer>[] buildGraph(int n, int[][] edges) {
    // 见前文
}
```

我先总结下这段 BFS 算法的思路：

1、构建邻接表，和之前一样，边的方向表示「被依赖」关系。

2、构建一个 indegree 数组记录每个节点的入度，即 indegree[i] 记录节点 i 的入度。

3、对 BFS 队列进行初始化，将入度为 0 的节点首先装入队列。

**4、开始执行 BFS 循环，不断弹出队列中的节点，减少相邻节点的入度，并将入度变为 0 的节点加入队列**。

**5、如果最终所有节点都被遍历过（count 等于节点数），则说明不存在环，反之则说明存在环**。

我画个图你就容易理解了，比如下面这幅图，节点中的数字代表该节点的入度：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685947699801-d480b9f4-a259-468e-93a3-f43e41cc3bd8-20240328163702-6b4kvu9.png)

队列进行初始化后，入度为 0 的节点首先被加入队列：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685947717678-20014eae-ca2f-44ab-86ed-abdac02edcb8-20240328163702-rpirr0q.png)

开始执行 BFS 循环，从队列中弹出一个节点，减少相邻节点的入度，同时将新产生的入度为 0 的节点加入队列：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685947743061-34a147b1-e4bc-4ac0-8a5c-4bbbe9e78cd6-20240328163703-gkdd70w.png)  
继续从队列弹出节点，并减少相邻节点的入度，这一次没有新产生的入度为 0 的节点：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685947769370-5ccb1543-c7c1-47b5-8317-de1cba14f0fd-20240328163703-0hv2h0e.png)

继续从队列弹出节点，并减少相邻节点的入度，同时将新产生的入度为 0 的节点加入队列：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685947780679-3af21d71-e6a3-4a16-8289-858e7e53d612-20240328163703-p9a08rn.png)

继续弹出节点，直到队列为空：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685947790751-14a11d2a-5db3-4f23-b3b7-6e494f23af70-20240328163704-bgzd121.png)

这时候，所有节点都被遍历过一遍，也就说明图中不存在环。

反过来说，如果按照上述逻辑执行 BFS 算法，存在节点没有被遍历，则说明成环。

比如下面这种情况，队列中最初只有一个入度为 0 的节点：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685947807251-d156cabd-642d-411f-a092-2eebac8b93aa-20240328163704-b6ygag1.png)

当弹出这个节点并减小相邻节点的入度之后队列为空，但并没有产生新的入度为 0 的节点加入队列，所以 BFS 算法终止：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685947819367-fdd65891-8028-44a1-9ec7-4a8609dd716b-20240328163705-sqxmbm1.png)

你看到了，如果存在节点没有被遍历，那么说明图中存在环，现在回头去看 BFS 的代码，你应该就很容易理解其中的逻辑了。

#### 拓扑排序算法

##### 练习题

###### 210.「 [课程表 II](https://leetcode.cn/problems/course-schedule-ii/)」

> 现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1。给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi] ，表示在选修课程 ai 前 **必须** 先选修 bi 。
>
> - 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1] 。
>
> 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。
>
> **示例 1：**   
> 输入：numCourses = 2, prerequisites = [[1,0]]  
> 输出：[0,1]  
> 解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。

###### DFS版

用百度百科的一幅图来让你直观地感受下拓扑排序（Topological Sorting）：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685945488492-685b90ea-6184-4edd-9dce-d669d7b73fcd-20240328163705-kmtix5w.png)

> 图片中拓扑排序的结果有误，C7->C8->C6 应该改为 C6->C7->C8。

**直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的**，比如上图所有箭头都是朝右的。

很显然，如果一幅有向图中存在环，是无法进行拓扑排序的，因为肯定做不到所有箭头方向一致；反过来，如果一幅图是「有向无环图」，那么一定可以进行拓扑排序。

但是我们这道题和拓扑排序有什么关系呢？

**其实也不难看出来，如果把课程抽象成节点，课程之间的依赖关系抽象成有向边，那么这幅图的拓扑排序结果就是上课顺序**。

首先，我们先判断一下题目输入的课程依赖是否成环，成环的话是无法进行拓扑排序的，所以我们可以复用上一道题的主函数：

```java
public int[] findOrder(int numCourses, int[][] prerequisites) {
    if (!canFinish(numCourses, prerequisites)) {
        // 不可能完成所有课程
        return new int[]{};
    }
    // ...
}
```

那么关键问题来了，如何进行拓扑排序？是不是又要秀什么高大上的技巧了？

**其实特别简单，将后序遍历的结果进行反转，就是拓扑排序的结果**。

> 有的读者提到，他在网上看到的拓扑排序算法不用对后序遍历结果进行反转，这是为什么呢？
>
> 你确实可以看到这样的解法，原因是他建图的时候对边的定义和我不同。我建的图中箭头方向是「被依赖」关系，比如节点 1 指向 2，含义是节点 1 被节点 2 依赖，即做完 1 才能去做 2，

如果你反过来，把有向边定义为「依赖」关系，那么整幅图中边全部反转，就可以不对后序遍历结果反转。具体来说，就是把我的解法代码中 graph[from].add(to); 改成 graph[to].add(from); 就可以不反转了。

**不过呢，现实中一般都是从初级任务指向进阶任务，所以像我这样把边定义为「被依赖」关系可能比较符合我们的认知习惯**。

直接看解法代码吧，在上一题环检测的代码基础上添加了记录后序遍历结果的逻辑：

**为什么不能用前序遍历？？？**

前序遍历会产生的问题是，当一个节点有两个依赖时，前序遍历会在第一个依赖完成后就加入有两个或多个依赖的节点。后续可以保证  **&amp;&amp;**  的关系，前序只能保证** || **的关系。

且看没有通过的例子：

> 测试用例:4  
> [[1,0],[2,0],[3,1],[3,2]]  
> 测试结果:[0,1,3,2]  
> 期望结果:[0,2,1,3]

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1699511062087-a4038c67-e4ce-4d94-9809-954c63d55ebc-20240328163705-m05jprd.png)

前序的结果是 0 -> 1 -> 3 -> 2

但是大前提是学习 3 之前，必须学习 1 和 2，只保证了 1，并没有保证 2，所以采取后续遍历，然后逆序

```java
class Solution {
    // 记录后序遍历结果
    List<Integer> postorder = new ArrayList<>();
    // 记录是否存在环
    boolean hasCycle = false;
    boolean[] visited, onPath;

    // 主函数
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        List<Integer>[] graph = buildGraph(numCourses, prerequisites);
        visited = new boolean[numCourses];
        onPath = new boolean[numCourses];
        // 遍历图
        for (int i = 0; i < numCourses; i++) {
            traverse(graph, i);
        }
        // 有环图无法进行拓扑排序
        if (hasCycle) {
            return new int[]{};
        }
        // 逆后序遍历结果即为拓扑排序结果
        Collections.reverse(postorder);
        int[] res = new int[numCourses];
        for (int i = 0; i < numCourses; i++) {
            res[i] = postorder.get(i);
        }
        return res;
    }

    // 图遍历函数
    void traverse(List<Integer>[] graph, int s) {
        if (onPath[s]) {
            // 发现环
            hasCycle = true;
        }
        if (visited[s] || hasCycle) {
            return;
        }
        // 前序遍历位置
        onPath[s] = true;
        visited[s] = true;
        for (int t : graph[s]) {
            traverse(graph, t);
        }
        // 后序遍历位置
        postorder.add(s);
        onPath[s] = false;
    }

    // 建图函数
    List<Integer>[] buildGraph(int numCourses, int[][] prerequisites) {
        // 代码见前文
    }
}
```

代码虽然看起来多，但是逻辑应该是很清楚的，只要图中无环，那么我们就调用 traverse 函数对图进行 DFS 遍历，记录后序遍历结果，最后把后序遍历结果反转，作为最终的答案。

**那么为什么后序遍历的反转结果就是拓扑排序呢**？

我这里也避免数学证明，用一个直观地例子来解释，我们就说二叉树，这是我们说过很多次的二叉树遍历框架：

```java
void traverse(TreeNode root) {
    // 前序遍历代码位置
    traverse(root.left)
    // 中序遍历代码位置
    traverse(root.right)
    // 后序遍历代码位置
}
```

二叉树的后序遍历是什么时候？遍历完左右子树之后才会执行后序遍历位置的代码。换句话说，当左右子树的节点都被装到结果列表里面了，根节点才会被装进去。

**后序遍历的这一特点很重要，之所以拓扑排序的基础是后序遍历，是因为一个任务必须等到它依赖的所有任务都完成之后才能开始开始执行**。

你把二叉树理解成一幅有向图，边的方向是由父节点指向子节点，那么就是下图这样：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685945698615-49a469d1-2166-47a7-8f05-d8f573b213f9-20240328163705-gl3e7f0.png)

按照我们的定义，边的含义是「被依赖」关系，那么上图的拓扑排序应该首先是节点 1，然后是 2, 3，以此类推。

但显然标准的后序遍历结果不满足拓扑排序，而如果把后序遍历结果反转，就是拓扑排序结果了：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685945776671-8e21b735-e8d3-4128-97a0-ee67b01c2ac8-20240328163706-mh8uku6.png)

以上，我直观解释了一下为什么「拓扑排序的结果就是反转之后的后序遍历结果」，当然，我的解释并没有严格的数学证明，有兴趣的读者可以自己查一下。

###### BFS版

**如果你能看懂 BFS 版本的环检测算法，那么就很容易得到 BFS 版本的拓扑排序算法，因为节点的遍历顺序就是拓扑排序的结果**。

比如刚才举的第一个例子，下图每个节点中的值即入队的顺序：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1685947912935-08e8f163-6b8c-4af1-8b53-012d4523e417-20240328163706-mp9b6m1.png)

显然，这个顺序就是一个可行的拓扑排序结果。

所以，我们稍微修改一下 BFS 版本的环检测算法，记录节点的遍历顺序即可得到拓扑排序的结果：

```java
// 主函数
public int[] findOrder(int numCourses, int[][] prerequisites) {
    // 建图，和环检测算法相同
    List<Integer>[] graph = buildGraph(numCourses, prerequisites);
    // 计算入度，和环检测算法相同
    int[] indegree = new int[numCourses];
    for (int[] edge : prerequisites) {
        int from = edge[1], to = edge[0];
        indegree[to]++;
    }

    // 根据入度初始化队列中的节点，和环检测算法相同
    Queue<Integer> q = new LinkedList<>();
    for (int i = 0; i < numCourses; i++) {
        if (indegree[i] == 0) {
            q.offer(i);
        }
    }

    // 记录拓扑排序结果
    int[] res = new int[numCourses];
    // 记录遍历节点的顺序（索引）
    int count = 0;
    // 开始执行 BFS 算法
    while (!q.isEmpty()) {
        int cur = q.poll();
        // 弹出节点的顺序即为拓扑排序结果
        res[count] = cur;
        count++;
        for (int next : graph[cur]) {
            indegree[next]--;
            if (indegree[next] == 0) {
                q.offer(next);
            }
        }
    }

    if (count != numCourses) {
        // 存在环，拓扑排序不存在
        return new int[]{};
    }
  
    return res;
}

// 建图函数
List<Integer>[] buildGraph(int n, int[][] edges) {
    // 见前文
}
```

按道理， [图的遍历](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/) 都需要 visited 数组防止走回头路，这里的 BFS 算法其实是通过 indegree 数组实现的 visited 数组的作用，只有入度为 0 的节点才能入队，从而保证不会出现死循环。

### 二分图

#### 二分图简介

在讲二分图的判定算法之前，我们先来看下百度百科对「二分图」的定义：

> 二分图的顶点集可分割为两个互不相交的子集，图中每条边依附的两个顶点都分属于这两个子集，且两个子集内的顶点不相邻。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686037842384-a476badf-c2fa-4e23-ac27-7eb4a9dc833d-20240328164537-hd1bqrw.png)

其实图论里面很多术语的定义都比较拗口，不容易理解。我们甭看这个死板的定义了，来玩个游戏吧：

**给你一幅「图」，请你用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同，你能做到吗**？

这就是图的「双色问题」，其实这个问题就等同于二分图的判定问题，如果你能够成功地将图染色，那么这幅图就是一幅二分图，

反之则不是：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686037844311-6821ee44-a74b-4c34-9859-cff1d2085046-20240328164537-ve1ucij.png)

在具体讲解二分图判定算法之前，我们先来说说计算机大佬们闲着无聊解决双色问题的目的是什么。

首先，二分图作为一种特殊的图模型，会被很多高级图算法（比如最大流算法）用到，不过这些高级算法我们不是特别有必要去掌握，有兴趣的读者可以自行搜索。

从简单实用的角度来看，二分图结构在某些场景可以更高效地存储数据。

比如说我们需要一种数据结构来储存电影和演员之间的关系：某一部电影肯定是由多位演员出演的，且某一位演员可能会出演多部电影。你使用什么数据结构来存储这种关系呢？

既然是存储映射关系，最简单的不就是使用哈希表嘛，我们可以使用一个 HashMap<String, List<String>> 来存储电影到演员列表的映射，如果给一部电影的名字，就能快速得到出演该电影的演员。

但是如果给出一个演员的名字，我们想快速得到该演员演出的所有电影，怎么办呢？这就需要「反向索引」，对之前的哈希表进行一些操作，新建另一个哈希表，把演员作为键，把电影列表作为值。

显然，如果用哈希表存储，需要两个哈希表分别存储「每个演员到电影列表」的映射和「每部电影到演员列表」的映射。但如果用「图」结构存储，将电影和参演的演员连接，很自然地就成为了一幅二分图：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686037844426-ec27e84b-3231-472b-a66f-8efdeee0adfc-20240328164538-wh7tt7u.png)

每个电影节点的相邻节点就是参演该电影的所有演员，每个演员的相邻节点就是该演员参演过的所有电影，非常方便直观。

#### 练习题

##### 785「 [判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)」

> 存在一个 **无向图** ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：
>
> - 不存在自环（graph[u] 不包含 u）。
> - 不存在平行边（graph[u] 不包含重复值）。
> - 如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）
> - 这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。
>
> **二分图** 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 **二分图** 。
>
> 如果图是二分图，返回 true_ _；否则，返回 false 。
>
> **示例 1：**
>
> ![1686037944600-2cd23b88-42e1-4b87-8bb4-418be918ae82](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686037944600-2cd23b88-42e1-4b87-8bb4-418be918ae82-20240328164538-z5r8nyl.jpeg)​
>
> 输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]]  
> 输出：false  
> 解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。

```java
class Solution {

    private boolean[] visited; // 记录图中节点是否被访问过
    private boolean[] color; // 记录图中节点的颜色，false 和 true 代表两种不同颜色

    public boolean isBipartite(int[][] graph) {
        visited = new boolean[graph.length];
        color = new boolean[graph.length];
        // 因为图不一定是联通的，可能存在多个子图
        // 所以要把每个节点都作为起点进行一次遍历
        // 如果发现任何一个子图不是二分图，整幅图都不算二分图
        for (int i = 0; i < graph.length; i++) {
            if (!traverse(graph, i)) return false;
        }
        return true;
    }

    private boolean traverse(int[][] graph, int v) {
        if (visited[v]) return true;
        visited[v] = true;

        for (int s : graph[v]) {
            if (!visited[s]) { // 相邻节点 w 没有被访问过，那么应该给节点 w 涂上和节点 v 不同的颜色
                color[s] = !color[v];
                if (!traverse(graph, s)) return false;
            } else { // 相邻节点 w 已经被访问过，根据 v 和 w 的颜色判断是否是二分图
                if (color[s] == color[v]) return false; // 若相同，则此图不是二分图
            }
        }
        return true;
    }
}
```

##### 886.「 [可能的二分法](https://leetcode.cn/problems/possible-bipartition/)」

> 给定一组 n 人（编号为 1, 2, ..., n）， 我们想把每个人分进**任意**大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。
>
> 给定整数 n 和数组 dislikes ，其中 dislikes[i] = [ai, bi] ，表示不允许将编号为 ai 和  bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。
>
> **示例 1：**   
> 输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]  
> 输出：true  
> 解释：group1 [1,4], group2 [2,3]

**其实这题考察的就是二分图的判定**：

如果你把每个人看做图中的节点，相互讨厌的关系看做图中的边，那么 dislikes 数组就可以构成一幅图；

又因为题目说互相讨厌的人不能放在同一组里，相当于图中的所有相邻节点都要放进两个不同的组；

那就回到了「双色问题」，如果能够用两种颜色着色所有节点，且相邻节点颜色都不同，那么你按照颜色把这些节点分成两组不就行了嘛。

所以解法就出来了，我们把 dislikes 构造成一幅图，然后执行二分图的判定算法即可：

```java
class Solution {

    private boolean[] visited;

    private boolean[] color;

    public boolean possibleBipartition(int n, int[][] dislikes) {
        visited = new boolean[n + 1]; // 图节点编号从 1 开始
        color = new boolean[n + 1];

        List<Integer>[] graph = buildGraph(n, dislikes);

        for (int i = 0; i <= n; i++) {
            if (!traverse(graph, i)) return false;
        }

        return true;
    }

    private boolean traverse(List<Integer>[] graph, int v) {
        if (visited[v]) return true;
        visited[v] = true;
        for (int t : graph[v]) {
            if (!visited[t]) {
                color[t] = !color[v];
                if (!traverse(graph, t)) return false;
            } else {
                if (color[t] == color[v]) return false;
            }
        }
        return true;
    }

    private List<Integer>[] buildGraph(int n, int[][] dislikes) {
        List<Integer>[] graph = new LinkedList[n + 1];
        for (int i = 0; i <= n; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : dislikes) { // 「无向图」相当于「双向图」
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }
        return graph;
    }
}
```

### 并查集（UNION-FIND）

并查集（Union-Find）算法是一个专门针对「动态连通性」的算法。

#### 技巧

##### 一、动态连通性

简单说，动态连通性其实可以抽象成给一幅图连线。比如下面这幅图，总共有 10 个节点，他们互不相连，分别用 0~9 标记：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686127940199-40a6f895-df88-4ee5-ad60-c31031e1d620-20240328165135-zvzn93c.png)

现在我们的 Union-Find 算法主要需要实现这两个 API：

```java
class UF {
    /* 将 p 和 q 连接 */
    public void union(int p, int q);
    /* 判断 p 和 q 是否连通 */
    public boolean connected(int p, int q);
    /* 返回图中有多少个连通分量 */
    public int count();
}
```

这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：

1、自反性：节点 p 和 p 是连通的。

2、对称性：如果节点 p 和 q 连通，那么 q 和 p 也连通。

3、传递性：如果节点 p 和 q 连通，q 和 r 连通，那么 p 和 r 也连通。

比如说之前那幅图，0～9 任意两个**不同**的点都不连通，调用 connected 都会返回 false，连通分量为 10 个。

如果现在调用 union(0, 1)，那么 0 和 1 被连通，连通分量降为 9 个。

再调用 union(1, 2)，这时 0,1,2 都被连通，调用 connected(0, 2) 也会返回 true，连通分量变为 8 个。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686127983709-67a0dfda-65e4-456e-8826-ea28a688e8fc-20240328165135-u6tptet.png)

判断这种「等价关系」非常实用，比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。

这样，你应该大概明白什么是动态连通性了，Union-Find 算法的关键就在于 union 和 connected 函数的效率。那么用什么模型来表示这幅图的连通状态呢？用什么数据结构来实现代码呢？

##### 二、基本思路

注意我刚才把「模型」和具体的「数据结构」分开说，这么做是有原因的。因为我们使用森林（若干棵树）来表示图的动态连通性，用数组来具体实现这个森林。

怎么用森林来表示连通性呢？我们设定树的每个节点有一个指针指向其父节点，如果是根节点的话，这个指针指向自己。比如说刚才那幅 10 个节点的图，一开始的时候没有相互连通，就是这样：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686128007062-b07bd1d0-0eed-488c-941c-2cec01d49e1c-20240328165135-gaimc69.png)

```java
class UF {
    // 记录连通分量
    private int count;
    // 节点 x 的父节点是 parent[x]
    private int[] parent;

    /* 构造函数，n 为图的节点总数 */
    public UF(int n) {
        // 一开始互不连通
        this.count = n;
        // 父节点指针初始指向自己
        parent = new int[n];
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }

    /* 其他函数 */
}
```

**如果某两个节点被连通，则让其中的（任意）一个节点的根节点接到另一个节点的根节点上**：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686128057225-3bad4efd-8ecc-4b7c-a1a8-e031c664e9bc-20240328165136-fszs2oi.png)

```java
class UF {
    // 为了节约篇幅，省略上文给出的代码部分...

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        // 将两棵树合并为一棵
        parent[rootP] = rootQ;
        // parent[rootQ] = rootP 也一样
        count--; // 两个分量合二为一
    }

    /* 返回某个节点 x 的根节点 */
    private int find(int x) {
        // 根节点的 parent[x] == x
        while (parent[x] != x)
            x = parent[x];
        return x;
    }

    /* 返回当前的连通分量个数 */
    public int count() { 
        return count;
    }
}
```

**这样，如果节点 p 和 q 连通的话，它们一定拥有相同的根节点**：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686128218253-c2c847ee-70d5-456f-83e8-0f7af357c80d-20240328165136-hta9pp9.png)

```java
class UF {
    // 为了节约篇幅，省略上文给出的代码部分...

    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }
}
```

至此，Union-Find 算法就基本完成了。是不是很神奇？竟然可以这样使用数组来模拟出一个森林，如此巧妙的解决这个比较复杂的问题！

那么这个算法的复杂度是多少呢？我们发现，主要 API connected 和 union 中的复杂度都是 find 函数造成的，所以说它们的复杂度和 find 一样。

find 主要功能就是从某个节点向上遍历到树根，其时间复杂度就是树的高度。我们可能习惯性地认为树的高度就是 logN，但这并不一定。logN 的高度只存在于平衡二叉树，对于一般的树可能出现极端不平衡的情况，使得「树」几乎退化成「链表」，树的高度最坏情况下可能变成 N。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686128256950-5a2106d8-41ee-45d6-b53c-6c62f3c67e28-20240328165136-x0lfsol.png)

所以说上面这种解法，find , union , connected 的时间复杂度都是 O(N)。这个复杂度很不理想的，你想图论解决的都是诸如社交网络这样数据规模巨大的问题，对于 union 和 connected 的调用非常频繁，每次调用需要线性时间完全不可忍受。

**问题的关键在于，如何想办法避免树的不平衡呢**？只需要略施小计即可。

##### 三、平衡性优化

我们要知道哪种情况下可能出现不平衡现象，关键在于 union 过程：

```java
class UF {
    // 为了节约篇幅，省略上文给出的代码部分...

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        // 将两棵树合并为一棵
        parent[rootP] = rootQ;
        // parent[rootQ] = rootP 也可以
        count--;
    }
}
```

我们一开始就是简单粗暴的把 p 所在的树接到 q 所在的树的根节点下面，那么这里就可能出现「头重脚轻」的不平衡状况，比如下面这种局面：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686128342732-8502b0c8-16a8-4861-9e73-b00a6f41b5a9-20240328165137-2bbp0f5.png)

长此以往，树可能生长得很不平衡。**我们其实是希望，小一些的树接到大一些的树下面，这样就能避免头重脚轻，更平衡一些**。解决方法是额外使用一个 size 数组，记录每棵树包含的节点数，我们不妨称为「重量」：

```java
class UF {
    private int count;
    private int[] parent;
    // 新增一个数组记录树的“重量”
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        // 最初每棵树只有一个节点
        // 重量应该初始化 1
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    /* 其他函数 */
}
```

比如说 size[3] = 5 表示，以节点 3 为根的那棵树，总共有 5 个节点。这样我们可以修改一下 union 方法：

```java
class UF {
    // 为了节约篇幅，省略上文给出的代码部分...

    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
    
        // 小树接到大树下面，较平衡
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }
}
```

这样，通过比较树的重量，就可以保证树的生长相对平衡，树的高度大致在 logN 这个数量级，极大提升执行效率。

此时，find , union , connected 的时间复杂度都下降为 O(logN)，即便数据规模上亿，所需时间也非常少。

##### 四、路径压缩

这步优化虽然代码很简单，但原理非常巧妙。

**其实我们并不在乎每棵树的结构长什么样，只在乎根节点**。

因为无论树长啥样，树上的每个节点的根节点都是相同的，所以能不能进一步压缩每棵树的高度，使树高始终保持为常数？

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686128451268-191c2977-11e2-4470-b294-1f67ad381cea-20240328165137-oriuw9w.png)

这样每个节点的父节点就是整棵树的根节点，find 就能以 O(1) 的时间找到某一节点的根节点，相应的，connected 和 union 复杂度都下降为 O(1)。

要做到这一点主要是修改 find 函数逻辑，非常简单，但你可能会看到两种不同的写法。

第一种是在 find 中加一行代码：

```java
class UF {
    // 为了节约篇幅，省略上文给出的代码部分...

    private int find(int x) {
        while (parent[x] != x) {
            // 这行代码进行路径压缩
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
}
```

这个操作有点匪夷所思，看个 GIF 就明白它的作用了（为清晰起见，这棵树比较极端）：

![1.gif](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686128582841-cb0cfd4b-4464-410c-8a0c-1f28b5498263-20240328165137-pbvonc4.gif)

路径压缩的第二种写法是这样：

```java
class UF {
    // 为了节约篇幅，省略上文给出的代码部分...
  
    // 第二种路径压缩的 find 方法
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }
}
```

我一度认为这种递归写法和第一种迭代写法做的事情一样，但实际上是我大意了，有读者指出这种写法进行路径压缩的效率是高于上一种解法的。

这个递归过程有点不好理解，你可以自己手画一下递归过程。我把这个函数做的事情翻译成迭代形式，方便你理解它进行路径压缩的原理：

```java
// 这段迭代代码方便你理解递归代码所做的事情
public int find(int x) {
    // 先找到根节点
    int root = x;
    while (parent[root] != root) {
        root = parent[root];
    }
    // 然后把 x 到根节点之间的所有节点直接接到根节点下面
    int old_parent = parent[x];
    while (x != root) {
        parent[x] = root;
        x = old_parent;
        old_parent = parent[old_parent];
    }
    return root;
}
```

这种路径压缩的效果如下：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686128749995-e582f4d8-bf42-48f3-83c6-d6b8b6d1dcb3-20240328165138-u7pdosq.png)

比起第一种路径压缩，显然这种方法压缩得更彻底，直接把一整条树枝压平，一点意外都没有。就算一些极端情况下产生了一棵比较高的树，只要一次路径压缩就能大幅降低树高，从 [摊还分析](https://labuladong.github.io/algo/di-ling-zh-bfe1b/suan-fa-sh-05f25/) 的角度来看，所有操作的平均时间复杂度依然是 O(1)，所以从效率的角度来说，推荐你使用这种路径压缩算法。

**另外，如果使用路径压缩技巧，那么 size 数组的平衡优化就不是特别必要了**。所以你一般看到的 Union Find 算法应该是如下实现：

```java
class UF {
    // 连通分量个数
    private int count;
    // 存储每个节点的父节点
    private int[] parent;

    // n 为图中节点的个数
    public UF(int n) {
        this.count = n;
        parent = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
    }
  
    // 将节点 p 和节点 q 连通
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
    
        if (rootP == rootQ)
            return;
    
        parent[rootQ] = rootP;
        // 两个连通分量合并成一个连通分量
        count--;
    }

    // 判断节点 p 和节点 q 是否连通
    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    // 返回图中的连通分量个数
    public int count() {
        return count;
    }
}
```

Union-Find 算法的复杂度可以这样分析：构造函数初始化数据结构需要 O(N) 的时间和空间复杂度；连通两个节点 union、判断两个节点的连通性 connected、计算连通分量 count 所需的时间复杂度均为 O(1)。

到这里，相信你已经掌握了 Union-Find 算法的核心逻辑，总结一下我们优化算法的过程：

1、用 parent 数组记录每个节点的父节点，相当于指向父节点的指针，所以 parent 数组内实际存储着一个森林（若干棵多叉树）。

2、用 size 数组记录着每棵树的重量，目的是让 union 后树依然拥有平衡性，保证各个 API 时间复杂度为 O(logN)，而不会退化成链表影响操作效率。

3、在 find 函数中进行路径压缩，保证任意树的高度保持在常数，使得各个 API 时间复杂度为 O(1)。使用了路径压缩之后，可以不使用 size 数组的平衡优化。

#### 练习题

##### 990.「 [等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)」

> 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 `equations[i]`​ 的长度为 `4`​，并采用两种不同的形式之一：`"a==b"`​ 或 `"a!=b"`​。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。
>
> 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 `true`​，否则返回 `false`​。
>
> **示例 1：**
>
> 输入：["a==b","b!=a"]  
> 输出：false  
> 解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。

比如说，输入\["a == b","b != c","c == a"\]，算法返回 false，因为这三个算式不可能同时正确。

再比如，输入 \["c == c","b == d","x != z"\]，算法返回 true，因为这三个算式并不会造成逻辑冲突。

我们前文说过，动态连通性其实就是一种等价关系，具有「自反性」「传递性」和「对称性」，其实 == 关系也是一种等价关系，具有这些性质。所以这个问题用 Union-Find 算法就很自然。

**核心思想是，将 equations 中的算式根据 == 和 != 分成两部分，先处理 == 算式，使得他们通过相等关系各自勾结成门派（连通分量）；然后处理 != 算式，检查不等关系是否破坏了相等关系的连通性**。

```java
boolean equationsPossible(String[] equations) {
    // 26 个英文字母
    UF uf = new UF(26);
    // 先让相等的字母形成连通分量
    for (String eq : equations) {
        if (eq.charAt(1) == '=') {
            char x = eq.charAt(0);
            char y = eq.charAt(3);
            uf.union(x - 'a', y - 'a');
        }
    }
    // 检查不等关系是否打破相等关系的连通性
    for (String eq : equations) {
        if (eq.charAt(1) == '!') {
            char x = eq.charAt(0);
            char y = eq.charAt(3);
            // 如果相等关系成立，就是逻辑冲突
            if (uf.connected(x - 'a', y - 'a'))
                return false;
        }
    }
    return true;
}

class UF {
    // 见上文
}
```

至此，这道判断算式合法性的问题就解决了，借助 Union-Find 算法，是不是很简单呢？  
最后，Union-Find 算法也会在一些其他经典图论算法中用到，比如判断「图」和「树」，以及最小生成树的计算，详情见 [Kruskal 最小生成树算法](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/kruskal-zu-e6b5b/)。

### **最小生成树之 Kruskal 算法**

#### 什么是最小生成树

**先说「树」和「图」的根本区别：树不会包含环，图可以包含环**。

如果一幅图没有环，完全可以拉伸成一棵树的模样。说的专业一点，树就是「无环连通图」。

那么什么是图的「生成树」呢，其实按字面意思也好理解，就是在图中找一棵包含图中的所有节点的树。专业点说，生成树是含有图中所有顶点的「无环连通子图」。

容易想到，一幅图可以有很多不同的生成树，比如下面这幅图，红色的边就组成了两棵不同的生成树：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1686294132321-0e5cc4f8-882b-4b41-a251-4a6dc13f796b-20240328165834-kv2pml5.png)

对于加权图，每条边都有权重，所以每棵生成树都有一个权重和。比如上图，右侧生成树的权重和显然比左侧生成树的权重和要小。  
**那么最小生成树很好理解了，所有可能的生成树中，权重和最小的那棵生成树就叫「最小生成树」** 。

PS：一般来说，我们都是在**无向加权图**中计算最小生成树的，所以使用最小生成树算法的现实场景中，图的边权重一般代表成本、距离这样的标量。

在讲 Kruskal 算法之前，需要回顾一下 Union-Find 并查集算法。

#### Union-Find 并查集算法

刚才说了，图的生成树是含有其所有顶点的「无环连通子图」，最小生成树是权重和最小的生成树。

那么说到连通性，相信老读者应该可以想到 Union-Find 并查集算法，用来高效处理图中联通分量的问题。

前文 [Union-Find 并查集算法](https://www.yuque.com/lun-fei-forever/leetcode/qg5dv5y6dtohx7xw) 详细介绍了 Union-Find 算法的实现原理和一些应用场景，主要运用路径压缩技巧提高连通分量的判断效率。

#### Kruskal 算法

所谓最小生成树，就是图中若干边的集合（我们后文称这个集合为 mst，最小生成树的英文缩写），你要保证这些边：

1、包含图中的所有节点。

2、形成的结构是树结构（即不存在环）。

3、权重和最小。

有之前题目的铺垫，前两条其实可以很容易地利用 Union-Find 算法做到，关键在于第 3 点，如何保证得到的这棵生成树是权重和最小的。

这里就用到了贪心思路：

**将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和 mst 中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入 mst 集合；否则，这条边不是最小生成树的一部分，不要把它加入 mst 集合**。

这样，最后 mst 集合中的边就形成了最小生成树，下面我们看两道例题来运用一下 Kruskal 算法。

#### 练习题

##### 1584.「[连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)」

> 给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。
>
> 连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 **曼哈顿距离** ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。
>
> 请你返回将所有点连接的最小总费用。只有任意两点之间 **有且仅有** 一条简单路径时，才认为所有点都已连接。
>
> **示例 1：**
>
> ![](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1686294993056-938deb4d-e0d5-43d6-a619-770d606a9cfb-20240328165835-bspgu47.png)
>
> 输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]  
> 输出：20  
> 解释：  
> ​![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/network-asset-1686295031428-5739a66f-42ed-40eb-843c-3fa40e77533e-20240328165835-oa9y0of.png)
>
> 我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。 注意到任意两个点之间只有唯一一条路径互相到达。

很显然这也是一个标准的最小生成树问题：每个点就是无向加权图中的节点，边的权重就是曼哈顿距离，连接所有点的最小费用就是最小生成树的权重和。

所以解法思路就是先生成所有的边以及权重，然后对这些边执行 Kruskal 算法即可：

```java
int minCostConnectPoints(int[][] points) {
    int n = points.length;
    // 生成所有边及权重
    List<int[]> edges = new ArrayList<>();
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int xi = points[i][0], yi = points[i][1];
            int xj = points[j][0], yj = points[j][1];
            // 用坐标点在 points 中的索引表示坐标点
            edges.add(new int[] {
                i, j, Math.abs(xi - xj) + Math.abs(yi - yj)
            });
        }
    }
    // 将边按照权重从小到大排序
    Collections.sort(edges, (a, b) -> {
        return a[2] - b[2];
    });
    // 执行 Kruskal 算法
    int mst = 0;
    UF uf = new UF(n);
    for (int[] edge : edges) {
        int u = edge[0];
        int v = edge[1];
        int weight = edge[2];
        // 若这条边会产生环，则不能加入 mst
        if (uf.connected(u, v)) {
            continue;
        }
        // 若这条边不会产生环，则属于最小生成树
        mst += weight;
        uf.union(u, v);
    }
    return mst;
}

class UF {
    // 见上文代码实现
}
```

这道题做了一个小的变通：每个坐标点是一个二元组，那么按理说应该用五元组表示一条带权重的边，但这样的话不便执行 Union-Find 算法；所以我们用 points 数组中的索引代表每个坐标点，这样就可以直接复用之前的 Kruskal 算法逻辑了。

最后说下 Kruskal 算法的复杂度分析：

- 假设一幅图的节点个数为 V，边的条数为 E，首先需要 O(E) 的空间装所有边，而且 Union-Find 算法也需要 O(V) 的空间，所以 Kruskal 算法总的空间复杂度就是 O(V + E)。
- 时间复杂度主要耗费在排序，需要 O(ElogE) 的时间，Union-Find 算法所有操作的复杂度都是 O(1)，套一个 for 循环也不过是 O(E)，所以总的时间复杂度为 O(ElogE)。

### PRIM 最小生成树

#### 对比 Kruskal 算法

图论的最小生成树问题，就是让你从图中找若干边形成一个边的集合 mst，这些边有以下特性：

1、这些边组成的是一棵树（树和图的区别在于不能包含环）。

2、这些边形成的树要包含所有节点。

3、这些边的权重之和要尽可能小。

那么 Kruskal 算法是使用什么逻辑满足上述条件，计算最小生成树的呢？

**首先，Kruskal 算法用到了贪心思想**，来满足权重之和尽可能小的问题：

先对所有边按照权重从小到大排序，从权重最小的边开始，选择合适的边加入 mst 集合，这样挑出来的边组成的树就是权重和最小的。

其次，Kruskal 算法用到了 **[Union-Find 并查集算法](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/bing-cha-j-323f3/)，来保证挑选出来的这些边组成的一定是一棵「树」，而不会包含环或者形成一片「森林」：

如果一条边的两个节点已经是连通的，则这条边会使树中出现环；如果最后的连通分量总数大于 1，则说明形成的是「森林」而不是一棵「树」。

那么，本文的主角 Prim 算法是使用什么逻辑来计算最小生成树的呢？

**首先，Prim 算法也使用贪心思想来让生成树的权重尽可能小**，也就是「切分定理」，这个后文会详细解释。

**其次，Prim 算法使用** ****[BFS 算法思想](https://labuladong.github.io/algo/di-ling-zh-bfe1b/bfs-suan-f-463fd/)**** **和 visited 布尔数组避免成环**，来保证选出来的边最终形成的一定是一棵树。

Prim 算法不需要事先对所有边排序，而是利用优先级队列动态实现排序的效果，所以我觉得 Prim 算法类似于 Kruskal 的动态过程。

下面介绍一下 Prim 算法的核心原理：切分定理。

#### 切分定理

「切分」这个术语其实很好理解，就是将一幅图分为两个**不重叠且非空**的节点集合：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686464154379-5ca78f71-78fd-43d8-875b-2dcf10876abc-20240328170351-kn1nmuu.png)

红色的这一刀把图中的节点分成了两个集合，就是一种「**切分**」，其中被红线切中的的边（标记为蓝色）叫做「**横切边**」。

当然，一幅图肯定可以有若干种切分，因为根据切分的定义，只要你能一刀把节点分成两部分就行。

接下来我们引入「切分定理」：

**对于任意一种「切分」，其中权重最小的那条「横切边」一定是构成最小生成树的一条边**。

这应该很容易证明，如果一幅加权无向图存在最小生成树，假设下图中用绿色标出来的边就是最小生成树：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686464195687-de8cf095-25b6-4adc-9d59-6a70406bfd55-20240328170352-uyghzrt.png)

那么，你肯定可以找到若干「切分」方式，将这棵最小生成树切成两棵子树。比如下面这种切分：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686464218376-0e240d65-2104-456a-be25-3dae6e9413b8-20240328170352-yvbap4n.png)

你会发现，任选一条蓝色的「横切边」都可以将这两棵子树连接起来，构成一棵生成树。

那么为了让最终这棵生成树的权重和最小，你说你要怎么选？

肯定选权重最小的那条「横切边」对吧，这就证明了切分定理。

关于切分定理，你也可以用反证法证明：

给定一幅图的最小生成树，那么随便给一种「切分」，一定至少有一条「横切边」属于最小生成树。

假设这条「横切边」不是权重最小的，那说明最小生成树的权重和就还有再减小的余地，那这就矛盾了，最小生成树的权重和本来就是最小的，怎么再减？所以切分定理是正确的。

有了这个切分定理，你大概就有了一个计算最小生成树的算法思路了：

**既然每一次「切分」一定可以找到最小生成树中的一条边，那我就随便切呗，每次都把权重最小的「横切边」拿出来加入最小生成树，直到把构成最小生成树的所有边都切出来为止**。

嗯，可以说这就是 Prim 算法的核心思路，不过具体实现起来，还是要有些技巧的。

因为你没办法让计算机理解什么叫「随便切」，所以应该设计机械化的规则和章法来调教你的算法，并尽量减少无用功。

#### Prim 算法实现

我们思考算法问题时，如果问题的一般情况不好解决，可以从比较简单的特殊情况入手，Prim 算法就是使用的这种思路。

按照「切分」的定义，只要把图中的节点切成两个**不重叠且非空**的节点集合即可算作一个合法的「切分」，那么我只切出来一个节点，是不是也算是一个合法的「切分」？

是的，这是最简单的「切分」，而且「横切边」也很好确定，就是这个节点的边。

那我们就随便选一个点，假设就从 A 点开始切分：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686464274422-1152cc15-5198-4448-acf5-3deb449b45c0-20240328170353-iil9l61.png)

既然这是一个合法的「切分」，那么按照切分定理，这些「横切边」AB, AF 中权重最小的边一定是最小生成树中的一条边：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686464296469-f638b226-d1dd-456a-a0b5-c8babbd1e080-20240328170354-i6bcut2.png)

好，现在已经找到最小生成树的第一条边（边 AB），然后呢，如何安排下一次「切分」？

按照 Prim 算法的逻辑，我们接下来可以围绕 A 和 B 这两个节点做切分：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686464346685-4cf5373d-6a7b-4b89-8176-dc613ab7e5c3-20240328170354-0jul8jr.png)

然后又可以从这个切分产生的横切边（图中蓝色的边）中找出权重最小的一条边，也就又找到了最小生成树中的第二条边 BC：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686464366630-186a1f4d-cf6c-4fcb-9607-d29da1c097a3-20240328170355-j42n8fy.png)

接下来呢？也是类似的，再围绕着 A, B, C 这三个点做切分，产生的横切边中权重最小的边是 BD，那么 BD 就是最小生成树的第三条边：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686464387217-2b9bab07-cb16-43cc-be78-ce922aa59960-20240328170355-mu49que.png)

接下来再围绕 A, B, C, D 这四个点做切分……

**Prim 算法的逻辑就是这样，每次切分都能找到最小生成树的一条边，然后又可以进行新一轮切分，直到找到最小生成树的所有边为止**。

这样设计算法有一个好处，就是比较容易确定每次新的「切分」所产生的「横切边」。

比如回顾刚才的图，当我知道了节点 A, B 的所有「横切边」（不妨表示为 cut({A, B})），也就是图中蓝色的边：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686464404750-c47cdb6d-7837-4622-b279-3378617d8456-20240328170356-88d06px.png)

是否可以快速算出 cut({A, B, C})，也就是节点 A, B, C 的所有「横切边」有哪些？

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686464424049-c3b0e0d0-5235-4646-abd9-2510d48b52e3-20240328170356-ubypfw4.png)

是可以的，因为我们发现：

> cut({A, B, C}) = cut({A, B}) + cut({C})

而 cut({C}) 就是节点 C 的所有邻边：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686464455694-9dea76ca-66da-4fee-b7e1-3306672d2593-20240328170357-9gjci0m.png)

这个特点使我们用我们写代码实现「切分」和处理「横切边」成为可能：

在进行切分的过程中，我们只要不断把新节点的邻边加入横切边集合，就可以得到新的切分的所有横切边。

当然，细心的读者肯定发现了，cut({A, B}) 的横切边和 cut({C}) 的横切边中 BC 边重复了。

不过这很好处理，用一个布尔数组 inMST 辅助，防止重复计算横切边就行了。

最后一个问题，我们求横切边的目的是找权重最小的横切边，怎么做到呢？

很简单，用一个优先级队列存储这些横切边，就可以动态计算权重最小的横切边了。

**明白了上述算法原理，下面来看一下 Prim 算法的代码实现**：

```java
class Prim {
    // 核心数据结构，存储「横切边」的优先级队列
    private PriorityQueue<int[]> pq;
    // 类似 visited 数组的作用，记录哪些节点已经成为最小生成树的一部分
    private boolean[] inMST;
    // 记录最小生成树的权重和
    private int weightSum = 0;
    // graph 是用邻接表表示的一幅图，
    // graph[s] 记录节点 s 所有相邻的边，
    // 三元组 int[]{from, to, weight} 表示一条边
    private List<int[]>[] graph;

    public Prim(List<int[]>[] graph) {
        this.graph = graph;
        this.pq = new PriorityQueue<>((a, b) -> {
            // 按照边的权重从小到大排序
            return a[2] - b[2];
        });
        // 图中有 n 个节点
        int n = graph.length;
        this.inMST = new boolean[n];

        // 随便从一个点开始切分都可以，我们不妨从节点 0 开始
        inMST[0] = true;
        cut(0);
        // 不断进行切分，向最小生成树中添加边
        while (!pq.isEmpty()) {
            int[] edge = pq.poll();
            int to = edge[1];
            int weight = edge[2];
            if (inMST[to]) {
                // 节点 to 已经在最小生成树中，跳过
                // 否则这条边会产生环
                continue;
            }
            // 将边 edge 加入最小生成树
            weightSum += weight;
            inMST[to] = true;
            // 节点 to 加入后，进行新一轮切分，会产生更多横切边
            cut(to);
        }
    }

    // 将 s 的横切边加入优先队列
    private void cut(int s) {
        // 遍历 s 的邻边
        for (int[] edge : graph[s]) {
            int to = edge[1];
            if (inMST[to]) {
                // 相邻接点 to 已经在最小生成树中，跳过
                // 否则这条边会产生环
                continue;
            }
            // 加入横切边队列
            pq.offer(edge);
        }
    }

    // 最小生成树的权重和
    public int weightSum() {
        return weightSum;
    }

    // 判断最小生成树是否包含图中的所有节点
    public boolean allConnected() {
        for (int i = 0; i < inMST.length; i++) {
            if (!inMST[i]) {
                return false;
            }
        }
        return true;
    }
}
```

明白了切分定理，加上详细的代码注释，你应该能够看懂 Prim 算法的代码了。

这里我们可以再回顾一下本文开头说的 Prim 算法和 [Kruskal 算法](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/kruskal-zu-e6b5b/) 的联系：

Kruskal 算法是在一开始的时候就把所有的边排序，然后从权重最小的边开始挑选属于最小生成树的边，组建最小生成树。

Prim 算法是从一个起点的切分（一组横切边）开始执行类似 BFS 算法的逻辑，借助切分定理和优先级队列动态排序的特性，从这个起点「生长」出一棵最小生成树。

**说到这里，Prim 算法的时间复杂度是多少呢**？

这个不难分析，复杂度主要在优先级队列 pq 的操作上，由于 pq 里面装的是图中的「边」，假设一幅图边的条数为 E，那么最多操作 O(E) 次 pq。每次操作优先级队列的时间复杂度取决于队列中的元素个数，取最坏情况就是 O(logE)。

所以这种 Prim 算法实现的总时间复杂度是 O(ElogE)。回想一下 [Kruskal 算法](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/kruskal-zu-e6b5b/)，它的时间复杂度主要是给所有边按照权重排序，也是 O(ElogE)。

不过话说回来，和后文 [Dijkstra 算法](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/dijkstra-s-6d0b2/) 类似，Prim 算法的时间复杂度也是可以优化的，但优化点在于优先级队列的实现上，和 Prim 算法本身的算法思想关系不大，所以我们这里就不做讨论了，有兴趣的读者可以自行搜索。

接下来，我们实操一波，把之前用 Kruskal 算法解决的力扣题目运用 Prim 算法再解决一遍。

#### 练习题

##### 1584.「[连接所有点的最小费用](https://leetcode.cn/problems/min-cost-to-connect-all-points/)」

> 给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。
>
> 连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 **曼哈顿距离** ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。
>
> 请你返回将所有点连接的最小总费用。只有任意两点之间 **有且仅有** 一条简单路径时，才认为所有点都已连接。
>
> **示例 1：**   
> ​![1686294993056-938deb4d-e0d5-43d6-a619-770d606a9cfb](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686294993056-938deb4d-e0d5-43d6-a619-770d606a9cfb-20240328170357-e2xijjd.png)
>
> 输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]  
> 输出：20  
> 解释：
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686295031428-5739a66f-42ed-40eb-843c-3fa40e77533e-20240328170357-r9rinft.png)
>
> 我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。 注意到任意两个点之间只有唯一一条路径互相到达。

很显然这也是一个标准的最小生成树问题：每个点就是无向加权图中的节点，边的权重就是曼哈顿距离，连接所有点的最小费用就是最小生成树的权重和。

所以我们只要把 points 数组转化成邻接表的形式，即可复用之前实现的 Prim 算法类：

```java
public int minCostConnectPoints(int[][] points) {
    int n = points.length;
    List<int[]>[] graph = buildGraph(n, points);
    return new Prim(graph).weightSum();
}

// 构造无向图
List<int[]>[] buildGraph(int n, int[][] points) {
    List<int[]>[] graph = new LinkedList[n];
    for (int i = 0; i < n; i++) {
        graph[i] = new LinkedList<>();
    }
    // 生成所有边及权重
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int xi = points[i][0], yi = points[i][1];
            int xj = points[j][0], yj = points[j][1];
            int weight = Math.abs(xi - xj) + Math.abs(yi - yj);
            // 用 points 中的索引表示坐标点
            graph[i].add(new int[]{i, j, weight});
            graph[j].add(new int[]{j, i, weight});
        }
    }
    return graph;
}

class Prim { /* 见上文 */ }
```

这道题做了一个小的变通：每个坐标点是一个二元组，那么按理说应该用五元组表示一条带权重的边，但这样的话不便执行 Prim 算法；所以我们用 points 数组中的索引代表每个坐标点，这样就可以直接复用之前的 Prim 算法逻辑了。

### DIJKSTRA 最短路径算法

#### 图的抽象

前文 [图论第一期：遍历基础](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/) 说过「图」这种数据结构的基本实现，图中的节点一般就抽象成一个数字（索引），图的具体实现一般是「邻接矩阵」或者「邻接表」。

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686558469398-5904e41f-0811-410a-885d-1cb3efb6deef-20240328170935-31wrqcf.png)

比如上图这幅图用邻接表和邻接矩阵的存储方式如下：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686558484290-5a859613-87d4-4c28-9373-c1c066d79207-20240328170935-ktcvqr6.png)

前文 [图论第二期：拓扑排序](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/) 告诉你，我们用邻接表的场景更多，结合上图，一幅图可以用如下 Java 代码表示：

```java
// graph[s] 存储节点 s 指向的节点（出度）
List<Integer>[] graph;
```

**如果你想把一个问题抽象成「图」的问题，那么首先要实现一个 API adj**：

```java
// 输入节点 s 返回 s 的相邻节点
List<Integer> adj(int s);
```

类似多叉树节点中的 children 字段记录当前节点的所有子节点，adj(s) 就是计算一个节点 s 的相邻节点。

比如上面说的用邻接表表示「图」的方式，adj 函数就可以这样表示：

```java
List<Integer>[] graph;

// 输入节点 s，返回 s 的相邻节点
List<Integer> adj(int s) {
    return graph[s];
}
```

当然，对于「加权图」，我们需要知道两个节点之间的边权重是多少，所以还可以抽象出一个 weight 方法：

```java
// 返回节点 from 到节点 to 之间的边的权重
int weight(int from, int to);
```

这个 weight 方法可以根据实际情况而定，因为不同的算法题，题目给的「权重」含义可能不一样，我们存储权重的方式也不一样。

有了上述基础知识，就可以搞定 Dijkstra 算法了，下面我给你从二叉树的层序遍历开始推演出 Dijkstra 算法的实现。

#### 二叉树层级遍历和 BFS 算法

我们之前说过二叉树的层级遍历框架：

```java
// 输入一棵二叉树的根节点，层序遍历这棵二叉树
void levelTraverse(TreeNode root) {
    if (root == null) return 0;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    int depth = 1;
    // 从上到下遍历二叉树的每一层
    while (!q.isEmpty()) {
        int sz = q.size();
        // 从左到右遍历每一层的每个节点
        for (int i = 0; i < sz; i++) {
            TreeNode cur = q.poll();
            printf("节点 %s 在第 %s 层", cur, depth);

            // 将下一层节点放入队列
            if (cur.left != null) {
                q.offer(cur.left);
            }
            if (cur.right != null) {
                q.offer(cur.right);
            }
        }
        depth++;
    }
}
```

我们先来思考一个问题，注意二叉树的层级遍历 while 循环里面还套了个 for 循环，为什么要这样？

while 循环和 for 循环的配合正是这个遍历框架设计的巧妙之处：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686558663831-3f4b7509-99d4-43bb-b305-2f15b341b7fc-20240328170935-4k7zzre.png)

**while 循环控制一层一层往下走，for 循环利用 sz 变量控制从左到右遍历每一层二叉树节点**。

注意我们代码框架中的 depth 变量，其实就记录了当前遍历到的层数。换句话说，每当我们遍历到一个节点 cur，都知道这个节点属于第几层。

算法题经常会问二叉树的最大深度呀，最小深度呀，层序遍历结果呀，等等问题，所以记录下来这个深度 depth 是有必要的。

基于二叉树的遍历框架，我们又可以扩展出多叉树的层序遍历框架：

```java
// 输入一棵多叉树的根节点，层序遍历这棵多叉树
void levelTraverse(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    int depth = 1;
    // 从上到下遍历多叉树的每一层
    while (!q.isEmpty()) {
        int sz = q.size();
        // 从左到右遍历每一层的每个节点
        for (int i = 0; i < sz; i++) {
            TreeNode cur = q.poll();
            printf("节点 %s 在第 %s 层", cur, depth);

            // 将下一层节点放入队列
            for (TreeNode child : cur.children) {
                q.offer(child);
            }
        }
        depth++;
    }
}
```

基于多叉树的遍历框架，我们又可以扩展出 BFS（广度优先搜索）的算法框架：

```java
// 输入起点，进行 BFS 搜索
int BFS(Node start) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路
  
    q.offer(start); // 将起点加入队列
    visited.add(start);

    int step = 0; // 记录搜索的步数
    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散一步 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            printf("从 %s 到 %s 的最短距离是 %s", start, cur, step);

            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj()) {
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
            }
        }
        step++;
    }
}
```

如果对 BFS 算法不熟悉，可以看前文 [BFS 算法框架](https://labuladong.github.io/algo/di-ling-zh-bfe1b/bfs-suan-f-463fd/)，这里只是为了让你做个对比，所谓 BFS 算法，就是把算法问题抽象成一幅「无权图」，然后继续玩二叉树层级遍历那一套罢了。

**注意，我们的 BFS 算法框架也是 while 循环嵌套 for 循环的形式，也用了一个 step 变量记录 for 循环执行的次数，无非就是多用了一个 visited 集合记录走过的节点，防止走回头路罢了**。

为什么这样呢？

所谓「无权图」，与其说每条「边」没有权重，不如说每条「边」的权重都是 1，从起点 start 到任意一个节点之间的路径权重就是它们之间「边」的条数，那可不就是 step 变量记录的值么？

再加上 BFS 算法利用 for 循环一层一层向外扩散的逻辑和 visited 集合防止走回头路的逻辑，当你每次从队列中拿出节点 cur 的时候，从 start 到 cur 的最短权重就是 step 记录的步数。

但是，到了「加权图」的场景，事情就没有这么简单了，因为你不能默认每条边的「权重」都是 1 了，这个权重可以是任意正数（Dijkstra 算法要求不能存在负权重边），比如下图的例子：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686558810285-e7a50162-a523-4407-a027-90db4c488671-20240328170936-brvc5pn.png)

如果沿用 BFS 算法中的 step 变量记录「步数」，显然红色路径一步就可以走到终点，但是这一步的权重很大；正确的最小权重路径应该是绿色的路径，虽然需要走很多步，但是路径权重依然很小。

其实 Dijkstra 和 BFS 算法差不多，不过在讲解 Dijkstra 算法框架之前，我们首先需要对之前的框架进行如下改造：

**想办法去掉 while 循环里面的 for 循环**。

为什么？有了刚才的铺垫，这个不难理解，刚才说 for 循环是干什么用的来着？

是为了让二叉树一层一层往下遍历，让 BFS 算法一步一步向外扩散，因为这个层数 depth，或者这个步数 step，在之前的场景中有用。

但现在我们想解决「加权图」中的最短路径问题，「步数」已经没有参考意义了，「路径的权重之和」才有意义，所以这个 for 循环可以被去掉。

怎么去掉？就拿二叉树的层级遍历来说，其实你可以直接去掉 for 循环相关的代码：

```java
// 输入一棵二叉树的根节点，遍历这棵二叉树所有节点
void levelTraverse(TreeNode root) {
    if (root == null) return 0;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    // 遍历二叉树的每一个节点
    while (!q.isEmpty()) {
        TreeNode cur = q.poll();
        printf("我不知道节点 %s 在第几层", cur);

        // 将子节点放入队列
        if (cur.left != null) {
            q.offer(cur.left);
        }
        if (cur.right != null) {
            q.offer(cur.right);
        }
    }
}
```

但问题是，没有 for 循环，你也没办法维护 depth 变量了。

如果你想同时维护 depth 变量，让每个节点 cur 知道自己在第几层，可以想其他办法，比如新建一个 State 类，记录每个节点所在的层数：

```java
class State {
    // 记录 node 节点的深度
    int depth;
    TreeNode node;

    State(TreeNode node, int depth) {
        this.depth = depth;
        this.node = node;
    }
}

// 输入一棵二叉树的根节点，遍历这棵二叉树所有节点
void levelTraverse(TreeNode root) {
    if (root == null) return 0;
    Queue<State> q = new LinkedList<>();
    q.offer(new State(root, 1));

    // 遍历二叉树的每一个节点
    while (!q.isEmpty()) {
        State cur = q.poll();
        TreeNode cur_node = cur.node;
        int cur_depth = cur.depth;
        printf("节点 %s 在第 %s 层", cur_node, cur_depth);

        // 将子节点放入队列
        if (cur_node.left != null) {
            q.offer(new State(cur_node.left, cur_depth + 1));
        }
        if (cur_node.right != null) {
            q.offer(new State(cur_node.right, cur_depth + 1));
        }
    }
}
```

这样，我们就可以不使用 for 循环也确切地知道每个二叉树节点的深度了。

**如果你能够理解上面这段代码，我们就可以来看 Dijkstra 算法的代码框架了**。

#### Dijkstra 算法框架

**首先，我们先看一下 Dijkstra 算法的签名**：

```java
// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离
int[] dijkstra(int start, List<Integer>[] graph);
```

输入是一幅图 graph 和一个起点 start，返回是一个记录最短路径权重的数组。

比方说，输入起点 start = 3，函数返回一个 int[] 数组，假设赋值给 distTo 变量，那么从起点 3 到节点 6 的最短路径权重的值就是 distTo[6]。

是的，标准的 Dijkstra 算法会把从起点 start 到所有其他节点的最短路径都算出来。

当然，如果你的需求只是计算从起点 start 到某一个终点 end 的最短路径，那么在标准 Dijkstra 算法上稍作修改就可以更高效地完成这个需求，这个我们后面再说。

**其次，我们也需要一个 State 类来辅助算法的运行**：

```java
class State {
    // 图节点的 id
    int id;
    // 从 start 节点到当前节点的距离
    int distFromStart;

    State(int id, int distFromStart) {
        this.id = id;
        this.distFromStart = distFromStart;
    }
}
```

类似刚才二叉树的层序遍历，我们也需要用 State 类记录一些额外信息，也就是使用 distFromStart 变量记录从起点 start 到当前这个节点的距离。

刚才说普通 BFS 算法中，根据 BFS 的逻辑和无权图的特点，第一次遇到某个节点所走的步数就是最短距离，所以用一个 visited 数组防止走回头路，每个节点只会经过一次。

加权图中的 Dijkstra 算法和无权图中的普通 BFS 算法不同，在 Dijkstra 算法中，你第一次经过某个节点时的路径权重，不见得就是最小的，所以对于同一个节点，我们可能会经过多次，而且每次的 distFromStart 可能都不一样，比如下图：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686559011695-caae5759-574f-49bb-ba04-b9d2aef72ac7-20240328170936-r8n24p4.png)

我会经过节点 5 三次，每次的 distFromStart 值都不一样，那我取 distFromStart 最小的那次，不就是从起点 start 到节点 5 的最短路径权重了么？

好了，明白上面的几点，我们可以来看看 Dijkstra 算法的代码模板。

**其实，Dijkstra 可以理解成一个带 dp table（或者说备忘录)的 BFS 算法，伪码如下**：

```java
// 返回节点 from 到节点 to 之间的边的权重
int weight(int from, int to);

// 输入节点 s 返回 s 的相邻节点
List<Integer> adj(int s);

// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离
int[] dijkstra(int start, List<Integer>[] graph) {
    // 图中节点的个数
    int V = graph.length;
    // 记录最短路径的权重，你可以理解为 dp table
    // 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重
    int[] distTo = new int[V];
    // 求最小值，所以 dp table 初始化为正无穷
    Arrays.fill(distTo, Integer.MAX_VALUE);
    // base case，start 到 start 的最短距离就是 0
    distTo[start] = 0;

    // 优先级队列，distFromStart 较小的排在前面
    Queue<State> pq = new PriorityQueue<>((a, b) -> {
        return a.distFromStart - b.distFromStart;
    });

    // 从起点 start 开始进行 BFS
    pq.offer(new State(start, 0));

    while (!pq.isEmpty()) {
        State curState = pq.poll();
        int curNodeID = curState.id;
        int curDistFromStart = curState.distFromStart;

        if (curDistFromStart > distTo[curNodeID]) {
            // 已经有一条更短的路径到达 curNode 节点了
            continue;
        }
        // 将 curNode 的相邻节点装入队列
        for (int nextNodeID : adj(curNodeID)) {
            // 看看从 curNode 达到 nextNode 的距离是否会更短
            int distToNextNode = distTo[curNodeID] + weight(curNodeID, nextNodeID);
            if (distTo[nextNodeID] > distToNextNode) {
                // 更新 dp table
                distTo[nextNodeID] = distToNextNode;
                // 将这个节点以及距离放入队列
                pq.offer(new State(nextNodeID, distToNextNode));
            }
        }
    }
    return distTo;
}
```

**对比普通的 BFS 算法，你可能会有以下疑问**：

**1、没有 visited 集合记录已访问的节点，所以一个节点会被访问多次，会被多次加入队列，那会不会导致队列永远不为空，造成死循环**？

**2、为什么用优先级队列 PriorityQueue 而不是 LinkedList 实现的普通队列？为什么要按照 distFromStart 的值来排序**？

**3、如果我只想计算起点 start 到某一个终点 end 的最短路径，是否可以修改算法，提升一些效率**？

我们先回答第一个问题，为什么这个算法不用 visited 集合也不会死循环。

对于这类问题，我教你一个思考方法：

循环结束的条件是队列为空，那么你就要注意看什么时候往队列里放元素（调用 offer）方法，再注意看什么时候从队列往外拿元素（调用 poll 方法）。

while 循环每执行一次，都会往外拿一个元素，但想往队列里放元素，可就有很多限制了，必须满足下面这个条件：

```java
// 看看从 curNode 达到 nextNode 的距离是否会更短
if (distTo[nextNodeID] > distToNextNode) {
    // 更新 dp table
    distTo[nextNodeID] = distToNextNode;
    pq.offer(new State(nextNodeID, distToNextNode));
}
```

这也是为什么我说 distTo 数组可以理解成我们熟悉的 dp table，因为这个算法逻辑就是在不断的最小化 distTo 数组中的元素：  
如果你能让到达 nextNodeID 的距离更短，那就更新 distTo[nextNodeID] 的值，让你入队，否则的话对不起，不让入队。

**因为两个节点之间的最短距离（路径权重）肯定是一个确定的值，不可能无限减小下去，所以队列一定会空，队列空了之后，distTo 数组中记录的就是从 start 到其他节点的最短距离**。

接下来解答第二个问题，为什么要用 PriorityQueue 而不是 LinkedList 实现的普通队列？

如果你非要用普通队列，其实也没问题的，你可以直接把 PriorityQueue 改成 LinkedList，也能得到正确答案，但是效率会低很多。

**Dijkstra 算法使用优先级队列，主要是为了效率上的优化，类似一种贪心算法的思路**。

为什么说是一种贪心思路呢，比如说下面这种情况，你想计算从起点 start 到终点 end 的最短路径权重：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686559166736-91f69723-c9c0-44b0-91b4-9b21f77a00c5-20240328170936-h1e1pc5.png)

假设你当前只遍历了图中的这几个节点，那么你下一步准备遍历那个节点？这三条路径都可能成为最短路径的一部分，**但你觉得哪条路径更有「潜力」成为最短路径中的一部分**？

从目前的情况来看，显然橙色路径的可能性更大嘛，所以我们希望节点 2 排在队列靠前的位置，优先被拿出来向后遍历。

所以我们使用 PriorityQueue 作为队列，让 distFromStart 的值较小的节点排在前面，这就类似我们之前讲 [贪心算法](https://labuladong.github.io/algo/di-er-zhan-a01c6/tan-xin-le-9bedf/ru-he-yun--48a7c/) 说到的贪心思路，可以很大程度上优化算法的效率。

大家应该听过 Bellman-Ford 算法，这个算法是一种更通用的最短路径算法，因为它可以处理带有负权重边的图，Bellman-Ford 算法逻辑和 Dijkstra 算法非常类似，用到的就是普通队列，本文就提一句，后面有空再具体写。

接下来说第三个问题，如果只关心起点 start 到某一个终点 end 的最短路径，是否可以修改代码提升算法效率。

肯定可以的，因为我们标准 Dijkstra 算法会算出 start 到所有其他节点的最短路径，你只想计算到 end 的最短路径，相当于减少计算量，当然可以提升效率。

需要在代码中做的修改也非常少，只要改改函数签名，再加个 if 判断就行了：

```java
// 输入起点 start 和终点 end，计算起点到终点的最短距离
int dijkstra(int start, int end, List<Integer>[] graph) {

    // ...

    while (!pq.isEmpty()) {
        State curState = pq.poll();
        int curNodeID = curState.id;
        int curDistFromStart = curState.distFromStart;

        // 在这里加一个判断就行了，其他代码不用改
        if (curNodeID == end) {
            return curDistFromStart;
        }

        if (curDistFromStart > distTo[curNodeID]) {
            continue;
        }

        // ...
    }

    // 如果运行到这里，说明从 start 无法走到 end
    return Integer.MAX_VALUE;
}
```

因为优先级队列自动排序的性质，**每次**从队列里面拿出来的都是 distFromStart 值最小的，所以当你**第一次**从队列中拿出终点 end 时，此时的 distFromStart 对应的值就是从 start 到 end 的最短距离。

这个算法较之前的实现提前 return 了，所以效率有一定的提高。

#### 时间复杂度分析

Dijkstra 算法的时间复杂度是多少？你去网上查，可能会告诉你是 O(ElogV)，其中 E 代表图中边的条数，V 代表图中节点的个数。

因为理想情况下优先级队列中最多装 V 个节点，对优先级队列的操作次数和 E 成正比，所以整体的时间复杂度就是 O(ElogV)。

不过这是理想情况，Dijkstra 算法的代码实现有很多版本，不同编程语言或者不同数据结构 API 都会导致算法的时间复杂度发生一些改变。

比如本文实现的 Dijkstra 算法，使用了 Java 的 PriorityQueue 这个数据结构，这个容器类底层使用二叉堆实现，但没有提供通过索引操作队列中元素的 API，所以队列中会有重复的节点，最多可能有 E 个节点存在队列中。

所以本文实现的 Dijkstra 算法复杂度并不是理想情况下的 O(ElogV)，而是 O(ElogE)，可能会略大一些，因为图中边的条数一般是大于节点的个数的。

不过就对数函数来说，就算真数大一些，对数函数的结果也大不了多少，所以这个算法实现的实际运行效率也是很高的，以上只是理论层面的时间复杂度分析，供大家参考。

#### 练习题

##### 743.「 [网络延迟时间](https://leetcode.cn/problems/network-delay-time/)」

> 有 n 个网络节点，标记为 1 到 n。
>
> 给你一个列表 times，表示信号经过 **有向** 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。
>
> 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。
>
> **示例 1：**
>
> ![1686562565046-2082bbf4-e32a-4bf6-83e0-a7750ce0806b](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686562565046-2082bbf4-e32a-4bf6-83e0-a7750ce0806b-20240328170936-0any4zt.png)
>
> 输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2  
> 输出：2

让你求所有节点都收到信号的时间，你把所谓的传递时间看做距离，实际上就是问你「从节点 k 到其他所有节点的最短路径中，最长的那条最短路径距离是多少」，说白了就是让你算从节点 k 出发到其他所有节点的最短路径，就是标准的 Dijkstra 算法。

在用 Dijkstra 之前，别忘了要满足一些条件，加权有向图，没有负权重边，OK，可以用 Dijkstra 算法计算最短路径。

根据我们之前 Dijkstra 算法的框架，我们可以写出下面代码：

```java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        List<int[]>[] graph = buildGraph(times, n);
        int[] disTo = dijkstra(k, graph);
        int res = 0;
        for (int i = 1; i < n + 1; i++) {
            if (disTo[i] == Integer.MAX_VALUE) {
                return -1;
            }
            res = Math.max(res, disTo[i]);
        }
        return res;
    }

    private int[] dijkstra(int start, List<int[]>[] graph) {
        int v = graph.length; // 节点个数
        int[] disTo = new int[v]; // disTo[i] start节点 -》 i节点的最短距离
        Arrays.fill(disTo, Integer.MAX_VALUE);
        disTo[start] = 0;
        Queue<int[]> queue = new PriorityQueue<>((a, b) -> a[1] - b[1]);
        queue.offer(new int[]{start, 0});

        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int curId = cur[0];
            int startToCurDis = cur[1]; // start节点 -》 cur节点的最短距离

            if (startToCurDis > disTo[curId]) { // 已经有一条更短的路径到达 curNode 节点了
                continue;
            }

            for (int[] neighbor : graph[curId]) {
                int neighborId = neighbor[0];
                int startToNeighborDis = disTo[curId] + neighbor[1];
                if (startToNeighborDis < disTo[neighborId]) {
                    disTo[neighborId] = startToNeighborDis; // 更新 dp table
                    queue.offer(new int[]{neighborId, startToNeighborDis}); // 将这个节点以及距离放入队列
                }
            }
        }
        return disTo;
    }

    private List<int[]>[] buildGraph(int[][] times, int n) {
        List<int[]>[] graph = new LinkedList[n + 1]; // 节点从1开始
        for (int i = 1; i < n + 1; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int[] edge : times) {
            int from = edge[0];
            int to = edge[1];
            int weight = edge[2];
            graph[from].add(new int[]{to, weight});
        }
        return graph;
    }
}
```

##### 1631.「 [最小体力消耗路径](https://leetcode.cn/problems/path-with-minimum-effort/)」

> 你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 **0** 开始编号）。你每次可以往 **上**，**下**，**左**，**右** 四个方向之一移动，你想要找到耗费 **体力** 最小的一条路径。
>
> 一条路径耗费的 **体力值** 是路径上相邻格子之间 **高度差绝对值** 的 **最大值** 决定的。
>
> 请你返回从左上角走到右下角的最小**体力消耗值** 。
>
> **示例 1：**
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686564954436-e75d3ab6-46ac-4c87-a96a-6b0aa04ce7c1-20240328170936-05uvx8t.png)​
>
> 输入：heights = [[1,2,2],[3,8,2],[5,3,5]]  
> 输出：2  
> 解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。 这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。

我们常见的二维矩阵题目，如果让你从左上角走到右下角，比较简单的题一般都会限制你只能向右或向下走，但这道题可没有限制哦，你可以上下左右随便走，只要路径的「体力消耗」最小就行。

如果你把二维数组中每个 (x, y) 坐标看做一个节点，它的上下左右坐标就是相邻节点，它对应的值和相邻坐标对应的值之差的绝对值就是题目说的「体力消耗」，你就可以理解为边的权重。

这样一想，是不是就在让你以左上角坐标为起点，以右下角坐标为终点，计算起点到终点的最短路径？Dijkstra 算法是不是可以做到？

**只不过，这道题中评判一条路径是长还是短的标准不再是路径经过的权重总和，而是路径经过的权重最大值**。

明白这一点，再想一下使用 Dijkstra 算法的前提，加权有向图，没有负权重边，求最短路径，OK，可以使用，咱们来套框架。  
二维矩阵抽象成图，我们先实现一下图的 adj 方法，之后的主要逻辑会清晰一些：

```java
// 方向数组，上下左右的坐标偏移量
int[][] dirs = new int[][]{{0,1}, {1,0}, {0,-1}, {-1,0}};

// 返回坐标 (x, y) 的上下左右相邻坐标
List<int[]> adj(int[][] matrix, int x, int y) {
    int m = matrix.length, n = matrix[0].length;
    // 存储相邻节点
    List<int[]> neighbors = new ArrayList<>();
    for (int[] dir : dirs) {
        int nx = x + dir[0];
        int ny = y + dir[1];
        if (nx >= m || nx < 0 || ny >= n || ny < 0) {
            // 索引越界
            continue;
        }
        neighbors.add(new int[]{nx, ny});
    }
    return neighbors;
}
```

接下来，就可以套用 Dijkstra 算法的代码模板了：

```java
class Solution {

    private final int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

    public int minimumEffortPath(int[][] heights) {
        int m = heights.length, n = heights[0].length;
        int[][] cost = new int[m][n]; // (0,0) -> (i,j) 最小体力消耗
        for (int i = 0; i < m; i++) {
            Arrays.fill(cost[i], Integer.MAX_VALUE);
        }
        // int[]{x, y, cost}
        Queue<int[]> queue = new PriorityQueue<>((a, b) -> a[2] - b[2]);
        cost[0][0] = 0;
        queue.offer(new int[]{0, 0, cost[0][0]});

        while (!queue.isEmpty()) {
            int[] cur = queue.poll();
            int x = cur[0];
            int y = cur[1];
            int xyCost = cur[2];

            if (x == m - 1 && y == n - 1) {
                return xyCost;
            }

            if (xyCost > cost[x][y]) {
                continue;
            }

            for (int[] neighbor : buildNeighbor(heights, x, y)) {
                int nextX = neighbor[0];
                int nextY = neighbor[1];
                int nextCost = Math.max(cost[x][y], Math.abs(heights[x][y] - heights[nextX][nextY]));
                if (nextCost < cost[nextX][nextY]) {
                    cost[nextX][nextY] = nextCost;
                    queue.offer(new int[]{nextX, nextY, nextCost});
                }
            }
        }
        return -1;
    }

    private List<int[]> buildNeighbor(int[][] heights, int x, int y) {
        int m = heights.length, n = heights[0].length;
        List<int[]> res = new ArrayList<>(4);
        for (int[] dir : dirs) {
            int x1 = x + dir[0];
            int y1 = y + dir[1];
            if (x1 < 0 || x1 >= m || y1 < 0 || y1 >= n) {
                continue;
            }
            res.add(new int[]{x1, y1});
        }
        return res;
    }
}
```

##### 1514.「 [概率最大的路径](https://leetcode.cn/problems/path-with-maximum-probability/)」

> 给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。
>
> 指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。
>
> 如果不存在从 start 到 end 的路径，请 **返回 0** 。只要答案与标准答案的误差不超过 **1e-5**，就会被视作正确答案。
>
> **示例 1：**
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1686567535447-c9478205-fbe4-43a9-ac6f-e5bedd85bc51-20240328170936-dn7nx81.png)
>
> 输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2  
> 输出：0.25000  
> 解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25

我说这题一看就是 Dijkstra 算法，但聪明的你肯定会反驳我：

**1、这题给的是无向图，也可以用 Dijkstra 算法吗**？

**2、更重要的是，Dijkstra 算法计算的是最短路径，计算的是最小值，这题让你计算最大概率是一个最大值，怎么可能用 Dijkstra 算法呢**？

问得好！

首先关于有向图和无向图，前文 [图算法基础](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/tu-lun-ji--d55b2/) 说过，无向图本质上可以认为是「双向图」，从而转化成有向图。

重点说说最大值和最小值这个问题，其实 Dijkstra 和很多最优化算法一样，计算的是「最优值」，这个最优值可能是最大值，也可能是最小值。

标准 Dijkstra 算法是计算最短路径的，但你有想过为什么 Dijkstra 算法不允许存在负权重边么？

**因为 Dijkstra 计算最短路径的正确性依赖一个前提：路径中每增加一条边，路径的总权重就会增加**。

这个前提的数学证明大家有兴趣可以自己搜索一下，我这里只说结论，其实你把这个结论反过来也是 OK 的：

如果你想计算最长路径，路径中每增加一条边，路径的总权重就会减少，要是能够满足这个条件，也可以用 Dijkstra 算法。

你看这道题是不是符合这个条件？边和边之间是乘法关系，每条边的概率都是小于 1 的，所以肯定会越乘越小。

只不过，这道题的解法要把优先级队列的排序顺序反过来，一些 if 大小判断也要反过来，我们直接看解法代码吧：

```java
class Solution {
    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
        List<double[]>[] graph = buildGraph(n, edges, succProb);
        double[] cost = new double[n]; // cost[i] : 节点 start 到达节点 i 的最大概率
        Arrays.fill(cost, -1); // dp table 初始化为一个取不到的最小值
        cost[start] = 1; // base case，start 到 start 的概率就是 1

        Queue<double[]> queue = new PriorityQueue<>((a, b) -> Double.compare(b[1], a[1]));
        queue.add(new double[]{start, cost[start]});

        while (!queue.isEmpty()) {
            double[] cur = queue.poll();
            int id = (int) cur[0];
            double v = cur[1];

            if (id == end) { // 遇到终点提前返回
                return v;
            }

            if (v < cost[id]) { // 已经有一条概率更大的路径到达 curNode 节点了
                continue;
            }

            for (double[] neighbor : graph[id]) { // 将 curNode 的相邻节点装入队列
                int neighborId = (int) neighbor[0];
                double neighborV = cost[id] * neighbor[1];
                if (neighborV > cost[neighborId]) {
                    cost[neighborId] = neighborV;
                    queue.add(new double[]{neighborId, neighborV});
                }
            }
        }
        return 0.0f;
    }

    private List<double[]>[] buildGraph(int n, int[][] edges, double[] succProb) {
        List<double[]>[] graph = new LinkedList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new LinkedList<>();
        }
        for (int i = 0; i < edges.length; i++) {
            int from = edges[i][0];
            int to = edges[i][1];
            double value = succProb[i];
            graph[from].add(new double[]{to, value}); // 无向图就是双向图
            graph[to].add(new double[]{from, value});
        }
        return graph;
    }
}
```

### 岛屿类问题

**岛屿系列题目的核心考点就是用 DFS/BFS 算法遍历二维数组**。

本文主要来讲解如何用 DFS 算法来秒杀岛屿系列题目，不过用 BFS 算法的核心思路是完全一样的，无非就是把 DFS 改写成 BFS 而已。

那么如何在二维矩阵中使用 DFS 搜索呢？如果你把二维矩阵中的每一个位置看做一个节点，这个节点的上下左右四个位置就是相邻节点，那么整个矩阵就可以抽象成一幅网状的「图」结构。

根据 [学习数据结构和算法的框架思维](https://labuladong.github.io/algo/di-ling-zh-bfe1b/xue-xi-sua-01220/)，完全可以根据二叉树的遍历框架改写出二维矩阵的 DFS 代码框架：

```java
// 二叉树遍历框架
void traverse(TreeNode root) {
    traverse(root.left);
    traverse(root.right);
}

// 二维矩阵遍历框架
void dfs(int[][] grid, int i, int j, boolean[][] visited) {
    int m = grid.length, n = grid[0].length;
    if (i < 0 || j < 0 || i >= m || j >= n) {
        // 超出索引边界
        return;
    }
    if (visited[i][j]) {
        // 已遍历过 (i, j)
        return;
    }
    // 进入节点 (i, j)
    visited[i][j] = true;
    dfs(grid, i - 1, j, visited); // 上
    dfs(grid, i + 1, j, visited); // 下
    dfs(grid, i, j - 1, visited); // 左
    dfs(grid, i, j + 1, visited); // 右
}
```

因为二维矩阵本质上是一幅「图」，所以遍历的过程中需要一个 visited 布尔数组防止走回头路，如果你能理解上面这段代码，那么搞定所有岛屿系列题目都很简单。

这里额外说一个处理二维数组的常用小技巧，你有时会看到使用「方向数组」来处理上下左右的遍历，和前文 [union-find 算法详解](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/bing-cha-j-323f3/) 的代码很类似：

```java
// 方向数组，分别代表上、下、左、右
int[][] dirs = new int[][]{{-1,0}, {1,0}, {0,-1}, {0,1}};

void dfs(int[][] grid, int i, int j, boolean[][] visited) {
    int m = grid.length, n = grid[0].length;
    if (i < 0 || j < 0 || i >= m || j >= n) {
        // 超出索引边界
        return;
    }
    if (visited[i][j]) {
        // 已遍历过 (i, j)
        return;
    }

    // 进入节点 (i, j)
    visited[i][j] = true;
    // 递归遍历上下左右的节点
    for (int[] d : dirs) {
        int next_i = i + d[0];
        int next_j = j + d[1];
        dfs(grid, next_i, next_j, visited);
    }
    // 离开节点 (i, j)
}
```

这种写法无非就是用 for 循环处理上下左右的遍历罢了，你可以按照个人喜好选择写法。

#### 练习题

##### 200.「[岛屿数量](https://leetcode.cn/problems/number-of-islands/)」

> 给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。
>
> 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
>
> 此外，你可以假设该网格的四条边均被水包围。
>
> **示例 1：**   
> 输入：grid = [
> ["1","1","1","1","0"],
> ["1","1","0","1","0"],
> ["1","1","0","0","0"],
> ["0","0","0","0","0"]  
> ]  
> 输出：1

比如说题目给你输入下面这个 grid 有四片岛屿，算法应该返回 4：

![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687591387536-36b8a22b-b5e8-41d7-ab09-ddaf1c81c415-20240328181024-s4hr2f4.png)

思路很简单，关键在于如何寻找并标记「岛屿」，这就要 DFS 算法发挥作用了，我们直接看解法代码：

```java
class Solution {
    // 主函数，计算岛屿数量
    int numIslands(char[][] grid) {
        int res = 0;
        int m = grid.length, n = grid[0].length;
        // 遍历 grid
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    // 每发现一个岛屿，岛屿数量加一
                    res++;
                    // 然后使用 DFS 将岛屿淹了
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }

    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    void dfs(char[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // 超出索引边界
            return;
        }
        if (grid[i][j] == '0') {
            // 已经是海水了
            return;
        }
        // 将 (i, j) 变成海水
        grid[i][j] = '0';
        // 淹没上下左右的陆地
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
}
```

##### 1254.「[统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/)」

> 二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 完全 由1包围（左、上、右、下）的岛。
>
> 请返回 *封闭岛屿* 的数目。
>
> **示例 1：**
>
> ![image.png](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687591872996-9a779c4c-b566-4890-8ac5-68f33a2dbd75-20240328181024-6dwctqd.png)​
>
> 输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]  
> 输出：2  
> 解释： 灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围)。

和上一题有两点不同：

1、用 0 表示陆地，用 1 表示海水。

2、让你计算「封闭岛屿」的数目。所谓「封闭岛屿」就是上下左右全部被 1 包围的 0，也就是说**靠边的陆地不算作「封闭岛屿」** 。

**那么如何判断「封闭岛屿」呢？其实很简单，把上一题中那些靠边的岛屿排除掉，剩下的不就是「封闭岛屿」了吗**？

有了这个思路，就可以直接看代码了，注意这题规定 0 表示陆地，用 1 表示海水：

```java
class Solution {
    // 主函数：计算封闭岛屿的数量
    int closedIsland(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        for (int j = 0; j < n; j++) {
            // 把靠上边的岛屿淹掉
            dfs(grid, 0, j);
            // 把靠下边的岛屿淹掉
            dfs(grid, m - 1, j);
        }
        for (int i = 0; i < m; i++) {
            // 把靠左边的岛屿淹掉
            dfs(grid, i, 0);
            // 把靠右边的岛屿淹掉
            dfs(grid, i, n - 1);
        }
        // 遍历 grid，剩下的岛屿都是封闭岛屿
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) {
                    res++;
                    dfs(grid, i, j);
                }
            }
        }
        return res;
    }

    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    void dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        if (grid[i][j] == 1) {
            // 已经是海水了
            return;
        }
        // 将 (i, j) 变成海水
        grid[i][j] = 1;
        // 淹没上下左右的陆地
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
}
```

##### 1020.「[飞地的数量](https://leetcode.cn/problems/number-of-enclaves/)」

> 给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。
>
> 一次 **移动** 是指从一个陆地单元格走到另一个相邻（**上、下、左、右**）的陆地单元格或跨过 grid 的边界。
>
> 返回网格中**无法**在任意次数的移动中离开网格边界的陆地单元格的数量。
>
> **示例 1：**   
> 输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]  
> 输出：3  
> 解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。

其实思路都是一样的，先把靠边的陆地淹掉，然后去数剩下的陆地数量就行了，注意第 1020 题中 1 代表陆地，0 代表海水：

```java
class Solution {
    int numEnclaves(int[][] grid) {
        int m = grid.length, n = grid[0].length;
        // 淹掉靠边的陆地
        for (int i = 0; i < m; i++) {
            dfs(grid, i, 0);
            dfs(grid, i, n - 1);
        }
        for (int j = 0; j < n; j++) {
            dfs(grid, 0, j);
            dfs(grid, m - 1, j);
        }

        // 数一数剩下的陆地
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    res += 1;
                }
            }
        }

        return res;
    }

    // 和之前的实现类似
    void dfs(int[][] grid, int i, int j) {
        // ...
    }
}
```

##### 695.「[岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)」

> 给你一个大小为 m x n 的二进制矩阵 grid 。
>
> **岛屿** 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 **水平或者竖直的四个方向上**相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
>
> 岛屿的面积是岛上值为 1 的单元格的数目。
>
> 计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。
>
> **示例 1：**
>
> ![1687592900554-61c82d36-ec6b-41e5-99c3-84bf91148ae3](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687592900554-61c82d36-ec6b-41e5-99c3-84bf91148ae3-20240328181024-y2w5p89.jpeg)​
>
> 输入：grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]  
> 输出：6  
> 解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。

**这题的大体思路和之前完全一样，只不过 dfs 函数淹没岛屿的同时，还应该想办法记录这个岛屿的面积**。

我们可以给 dfs 函数设置返回值，记录每次淹没的陆地的个数，直接看解法吧：

```java
class Solution {
    int maxAreaOfIsland(int[][] grid) {
        // 记录岛屿的最大面积
        int res = 0;
        int m = grid.length, n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    // 淹没岛屿，并更新最大岛屿面积
                    res = Math.max(res, dfs(grid, i, j));
                }
            }
        }
        return res;
    }

    // 淹没与 (i, j) 相邻的陆地，并返回淹没的陆地面积
    int dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            // 超出索引边界
            return 0;
        }
        if (grid[i][j] == 0) {
            // 已经是海水了
            return 0;
        }
        // 将 (i, j) 变成海水
        grid[i][j] = 0;

        return 1 + dfs(grid, i + 1, j)
            + dfs(grid, i, j + 1)
            + dfs(grid, i - 1, j)
            + dfs(grid, i, j - 1);
    }
}
```

##### 1905.「[统计子岛屿](https://leetcode.cn/problems/count-sub-islands/)」

> 给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 **岛屿** 是由 **四个方向** （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。
>
> 如果 grid2 的一个岛屿，被 grid1 的一个岛屿 **完全** 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 **子岛屿** 。
>
> 请你返回 grid2 中 **子岛屿** 的 **数目** 。
>
> **示例 1：**
>
> ![1687593665640-6d0388e5-727f-4bd6-91ed-e1441704b172](https://gitee.com/JBL_lun/tuchuang/raw/master/assets/net-img-1687593665640-6d0388e5-727f-4bd6-91ed-e1441704b172-20240328181024-y53j1um.png)
>
> 输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]  
> 输出：3  
> 解释：如上图所示，左边为 grid1 ，右边为 grid2 。 grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。

**这道题的关键在于，如何快速判断子岛屿**？肯定可以借助 [Union Find 并查集算法](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/bing-cha-j-323f3/) 来判断，不过本文重点在 DFS 算法，就不展开并查集算法了。

什么情况下 grid2 中的一个岛屿 B 是 grid1 中的一个岛屿 A 的子岛？

当岛屿 B 中所有陆地在岛屿 A 中也是陆地的时候，岛屿 B 是岛屿 A 的子岛。

**反过来说，如果岛屿 B 中存在一片陆地，在岛屿 A 的对应位置是海水，那么岛屿 B 就不是岛屿 A 的子岛**。

那么，我们只要遍历 grid2 中的所有岛屿，把那些不可能是子岛的岛屿排除掉，剩下的就是子岛。

依据这个思路，可以直接写出下面的代码：

```java
class Solution {
    int countSubIslands(int[][] grid1, int[][] grid2) {
        int m = grid1.length, n = grid1[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid1[i][j] == 0 && grid2[i][j] == 1) {
                    // 这个岛屿肯定不是子岛，淹掉
                    dfs(grid2, i, j);
                }
            }
        }
        // 现在 grid2 中剩下的岛屿都是子岛，计算岛屿数量
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid2[i][j] == 1) {
                    res++;
                    dfs(grid2, i, j);
                }
            }
        }
        return res;
    }

    // 从 (i, j) 开始，将与之相邻的陆地都变成海水
    void dfs(int[][] grid, int i, int j) {
        int m = grid.length, n = grid[0].length;
        if (i < 0 || j < 0 || i >= m || j >= n) {
            return;
        }
        if (grid[i][j] == 0) {
            return;
        }

        grid[i][j] = 0;
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
}
```