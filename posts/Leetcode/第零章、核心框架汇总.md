---
title: 第零章、核心框架汇总
tags:
  - Leetcode
categories:
  - Leetcode
date: '2025-01-03'
description: 欢迎使用 Curve 主题，这是你的第一篇文章
articleGPT: 这是一篇初始化文章，旨在告诉用户一些使用说明和须知。
#cover: "/images/logo/logo.webp"
---

# 第零章、核心框架汇总

从本章开始，就要开始以刷题为主了，你将学习若干核心算法框架，然后通过大量的习题来运用巩固这些框架。

本章内容很硬核，整个网站的所有文章、习题都是基于本章总结的这些算法框架展开的。

就连我自己也会在刷题过程中从本章获得新的灵感，从而不断更新和优化本章的内容。

所以我建议读者在未来的学习过程中时常来回顾本章的内容，相信你每次回顾都会有新的收获。

## 双指针
### 数组双指针
#### 概念

> 在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：**左右指针** 和 **快慢指针**。
> - 所谓左右指针，就是两个指针相向而行或者相背而行； 
> - 而所谓快慢指针，就是两个指针同向而行，一快一慢。

#### 练习题
##### 快慢指针

###### 27.「 [移除元素](https://leetcode.cn/problems/remove-element/)」

> 给你一个数组 `nums`  和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 移除所有数值等于 `val`  的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** **修改输入数组**。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>
> **示例 1：**
> 输入：nums = [3,2,2,3], val = 3
> 输出：2, nums = [2,2]
>
> 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。

删除过程如下：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%E3%80%81%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E6%B1%87%E6%80%BB.assets/002b21359aba412f9e40039d8ba755d7-9958317.png" alt="" style="zoom:30%;" />

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast = 0, slow = 0; // 保证 nums[0..slow) 不包含 val
        while (fast < nums.length) {
            if (nums[fast] == val) {
                ++fast;
            } else {
                nums[slow++] = nums[fast++];
            }
        }
        return slow;
    }
}
```

```go
func removeElement(nums []int, val int) int {
    slow := 0
    for fast := 0; fast < len(nums); fast++ {
        if (nums[fast] != val) {
            nums[slow] = nums[fast]
            slow++
        }
    }
    return slow
}
```

- 时间复杂度：O(n) 
- 空间复杂度：O(1)

###### 26.「 [删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)」

> 给你一个 **非严格递增排列** 的数组 `nums` ，请你 **[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。
>
> 考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：
>
> * 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
> * 返回 `k` 。
>
> **示例 1：**
>
> 输入：nums = [1,1,2]  
> 输出：2, nums = [1,2,_]
>
> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

高效解决这道题就要用到快慢指针技巧：

我们让 `慢指针 slow` 走在后面，`快指针 fast` 走在前面探路，找到一个不重复的元素就赋值给 `slow` 并让 `slow` 前进一步。

这样，就保证了 `nums[0..slow]` 都是无重复的元素，当 `fast` 指针遍历完整个数组 `nums` 后，`nums[0..slow]` 就是整个数组去重之后的结果。

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%E3%80%81%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E6%B1%87%E6%80%BB.assets/d1dc503fe48b4591b9950780b2a3c9c4.png" alt="每日一题——删除有序数组中的重复项" style="zoom:33%;" />

```java
int removeDuplicates(int[] nums) {
    int slow = 0, fast = 0;
    int n = nums.length;
    while (fast < n) {
       if (nums[slow] == nums[fast]) {
          ++fast;
       } else {
          ++slow; // 去掉重复，保留第一位，所以slow指向下一个重复项
          nums[slow] = nums[fast++];
       }
    }
    return slow + 1; // 数组长度为索引 + 1
}
```

```go
func removeDuplicates(nums []int) int {
	slow := 0
	for fast := 0; fast < len(nums); fast++ {
		if nums[fast] != nums[slow] {
			slow++
			nums[slow] = nums[fast]
		}
	}
	return slow + 1
}
```

###### 83.「 [删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)」

> 给定一个已排序的链表的头 head ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。  
> **示例 1：**
>
> <img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%E3%80%81%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E6%B1%87%E6%80%BB.assets/image-20250222211304272.png" alt="image-20250222211304272" style="zoom:70%;" />   
>
>  输入：head = [1,1,2]  
> 输出：[1,2]

其实和数组去重是一模一样的，唯一的区别是把数组赋值操作变成操作指针而已。

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%E3%80%81%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E6%B1%87%E6%80%BB.assets/network-asset-1675059883363-8a5c764e-643f-451a-86c9-5aab77c28c66-20240221152050-7cvjsc1.gif" alt="network-asset-1675059883363-8a5c764e-643f-451a-86c9-5aab77c28c66-20240221152050-7cvjsc1" style="zoom:50%;" />

```java
public ListNode deleteDuplicates(ListNode head) {
	if(head == null) return null;
	ListNode fast = head, slow = head;
	while (fast != null) {
		if (fast.val == slow.val) {
			fast = fast.next;
		} else {
			slow.next = fast;
			slow = slow.next;
			fast = fast.next;
		}
	}
	slow.next = null;
	return head;
}
```

```go
func deleteDuplicates(head *ListNode) *ListNode {
	if head == nil {
		return nil
	}
	slow, fast := head, head
	for fast != nil {
		if slow.Val == fast.Val {
			fast = fast.Next
		} else {
			slow.Next = fast
			slow = slow.Next
			fast = fast.Next
		}
	}
	slow.Next = nil
	return head
}
```

###### 283.「 [移动零](https://leetcode.cn/problems/move-zeroes/)」

> 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。
>
> **示例 1:**   
> 输入: nums = [0,1,0,3,12]  
> 输出: [1,3,12,0,0]

比如说给你输入 nums = [0,1,4,0,2]，你的算法没有返回值，但是会把 nums 数组原地修改成 [1,4,2,0,0]。

```java
public void moveZeroes(int[] nums) {
	int slow = 0, fast = 0;
	int n = nums.length;
	while (fast < n) {
		if (nums[fast] == 0) {
			++fast;
		} else {
			nums[slow++] = nums[fast++];
		}
	}
	while (slow < n) {
		nums[slow++] = 0;
	}
}
```

```go
func moveZeroes(nums []int)  {
    slow, fast, n := 0, 0, len(nums)
    for fast < n {
        if nums[fast] == 0 {
            fast++
        } else {
            nums[slow] = nums[fast]
            slow++
            fast++
        }
    }
    for ;slow < n; slow++ {
        nums[slow] = 0
    }
}
```

##### 左右指针

###### 二分查找

```java
int binarySearch(int[] nums, int target) {
  int left = 0, right = nums.length - 1; // 一左一右两个指针相向而行
  while(left <= right) {
    int mid = (right + left) / 2;
    if(nums[mid] == target) return mid;
    else if(nums[mid] < target) left = mid + 1;
    else if(nums[mid] > target) right = mid - 1;
  }
  return -1;
}
```

###### 167.「 [两数之和 II](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)」

> 给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列**，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。
>
> 以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`。
>
> 你可以假设每个输入 **只对应唯一的答案** ，而且你 **不可以** 重复使用相同的元素。
> 你所设计的解决方案必须只使用常量级的额外空间。
> **示例 1：** 
> 输入：numbers = [2,7,11,15], target = 9
> 输出：[1,2]
> 解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。

只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 就可以调整 sum 的大小：

```java
int[] twoSum(int[] nums, int target) {
  int left = 0, right = nums.length - 1; // 一左一右两个指针相向而行
  while(left < right) {
    int sum = nums[left] + nums[right];
    if(sum == target) {
      return new int[] {left + 1, right + 1}; // 题目要求的索引是从 1 开始的
    } else if(sum < target) { // 让 sum 大一点
      left++;
    } else if(sum > target) { // 让 sum 小一点
      right--;
    }
  }
  return new int[] {-1, -1};
}
```

```go
func twoSum(numbers []int, target int) []int {
    left, right := 0, len(numbers) - 1
    for left <= right {
        sum := numbers[left] + numbers[right]
        if sum == target {
            return []int {left + 1, right + 1}
        } else if sum < target {
            left++
        } else {
            right--
        }
    }
    return []int {-1, -1}
}
```

###### 344.「 [反转字符串](https://leetcode.cn/problems/reverse-string/)」

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。
> 不要给另外的数组分配额外的空间，你必须[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)**修改输入数组**、使用 O(1) 的额外空间解决这一问题。
> **示例 1：** 
> 输入：s = ["h","e","l","l","o"]
> 输出：["o","l","l","e","h"]

让你反转一个 char[] 类型的字符数组。

```java
void reverseString(char[] s) {
  int left = 0, right = s.length - 1; // 一左一右两个指针相向而行
  while(left < right) { // 交换 s[left] 和 s[right]
    char temp = s[left];
    s[left] = s[right];
    s[right] = temp;
    left++;
    right--;
  }
}
```

```go
func reverseString(s []byte) {
	for left, right := 0, len(s) - 1; left <= right; left, right = left + 1, right - 1 {
		s[left], s[right] = s[right], s[left]
	}
}
```

###### 5.「 [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)」

> 给你一个字符串 s，找到 s 中最长的回文子串。
> 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。
> **示例 1：** 
> 输入：s = "babad"
> 输出："bab"
> 解释："aba" 同样是符合题意的答案。

首先明确一下，回文串就是正着读和反着读都一样的字符串。

比如说字符串 aba 和 abba 都是回文串，因为它们对称，反过来还是和本身一样；反之，字符串 abac 就不是回文串。

找回文串的难点在于，回文串的的长度可能是奇数也可能是偶数，解决该问题的核心是**从中心向两端扩散的双指针技巧**。

如果回文串的长度为奇数，则它有一个中心字符；如果回文串的长度为偶数，则可以认为它有两个中心字符。所以我们可以先实现这样一个函数：

```java
String palindrome(String s, int l, int r) { // 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串
  while(l >= 0 && r < s.length() 
        && s.charAt(l) == s.charAt(r)) { // 防止索引越界
    l--;
    r++; // 双指针，向两边展开
  }
  return s.substring(l + 1, r); // 返回以 s[l] 和 s[r] 为中心的最长回文串
}
```

这样，如果输入相同的 l 和 r，就相当于寻找长度为奇数的回文串，如果输入相邻的 l 和 r，则相当于寻找长度为偶数的回文串。
那么回到最长回文串的问题，解法的大致思路就是：

```java
for 0 <= i < len(s):
    找到以 s[i] 为中心的回文串
    找到以 s[i] 和 s[i+1] 为中心的回文串
    更新答案
```

翻译成代码，就可以解决最长回文子串这个问题：

```java
String longestPalindrome(String s) {
  String res = "";
  for(int i = 0; i < s.length(); i++) { // 以 s[i] 为中心的最长回文子串
    // 以 s[i] 和 s[i+1] 为中心的最长回文子串
    String s1 = palindrome(s, i, i);
    String s2 = palindrome(s, i, i + 1);
    // res = longest(res, s1, s2)
    res = res.length() > s1.length() ? res : s1;
    res = res.length() > s2.length() ? res : s2;
  }
  return res;
}
```

```go
func longestPalindrome(s string) string {
    res := ""
    for i := 0; i < len(s); i++ {
        s1 := palindrome(s, i, i)
        s2 := palindrome(s, i, i + 1)
        if len(res) < len(s1) {
            res = s1
        }
        if len(res) < len(s2) {
            res = s2
        }
    }
    return res
}

func palindrome(s string, left int, right int) string {
    for left >=0 && right < len(s) && s[left] == s[right] {
        left--
        right++
    }
    return s[left + 1 : right]
}
```

你应该能发现最长回文子串使用的左右指针和之前题目的左右指针有一些不同：之前的左右指针都是从两端向中间相向而行，而回文子串问题则是让左右指针从中心向两端扩展。不过这种情况也就回文串这类问题会遇到，所以我也把它归为左右指针了。

###### 977.[「有序数组的平方」](https://leetcode.cn/problems/squares-of-a-sorted-array/)

> 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
>
> 示例 1：  
> 输入：nums = [-4,-1,0,3,10]  
> 输出：[0,1,9,16,100]  
> 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

数组其实是有序的， 只不过负数平方之后可能成为最大数了。

那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

此时可以考虑双指针法了，i 指向起始位置，j 指向终止位置。

定义一个新数组 result，和 A 数组一样的大小，让 k 指向 result 数组终止位置。

如果 A[i] * A[i] < A[j] * A[j] 那么 result[k--] = A[j] * A[j]; 。

如果 A[i] * A[i] >= A[j] * A[j] 那么 result[k--] = A[i] * A[i]; 。

如动画所示：

<img src="./%E7%AC%AC%E9%9B%B6%E7%AB%A0%E3%80%81%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6%E6%B1%87%E6%80%BB.assets/network-asset-1675059883444-45ed9874-2d76-4a3d-9e3d-54da5c8c8175-20240221152052-2vefnmf.gif" alt="network-asset-1675059883444-45ed9874-2d76-4a3d-9e3d-54da5c8c8175-20240221152052-2vefnmf" style="zoom:80%;" />

```java
class Solution {
  public int[] sortedSquares(int[] nums) {
    int right = nums.length - 1;
    int left = 0;
    int[] result = new int[nums.length];
    int index = result.length - 1;
    while(left <= right) {
      if(nums[left] * nums[left] > nums[right] * nums[right]) { // 正数的相对位置是不变的， 需要调整的是负数平方后的相对位置
        result[index--] = nums[left] * nums[left];
        ++left;
      } else {
        result[index--] = nums[right] * nums[right];
        --right;
      }
    }
    return result;
  }
}
```

```go
func sortedSquares(nums []int) []int {
    left, right, i := 0, len(nums) - 1, len(nums) - 1
    res := make([]int, len(nums))
    for left <= right {
        sqrt1, sqrt2 := nums[left] * nums[left], nums[right] * nums[right]
        if sqrt1 < sqrt2 {
            res[i] = sqrt2
            right--
        } else {
            res[i] = sqrt1
            left++
        }
        i--
    }
    return res
}
```

此时的时间复杂度为 O(n)。
