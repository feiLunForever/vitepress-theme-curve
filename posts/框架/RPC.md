# RPC

RPC 可以帮助我们调用远程计算机上某个服务的方法，屏蔽掉底层网络编程的具体细节。

**RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。**

## 流程

- 服务消费端（client）以本地调用的方式调用远程服务
- 客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：RpcRequest
- 客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端
- 服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: RpcRequest
- 服务端 Stub（桩）根据 RpcRequest 中的类、方法、方法参数等信息调用本地的方法
- 服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：RpcResponse（序列化）发送至消费方；
- 客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:RpcResponse ，这样也就得到了最终结果

## HTTP 和 RPC

### 服务发现

- http：DNS 服务解析 ip，端口默认 80
- RPC：第三方存储 ip 和端口，Consul，Nacos，zk

### 底层连接形式

- HTTP1.1 ：建立底层 TCP 连接之后会一直保持这个连接（keep alive），之后的请求和响应都会复用这条连接
- RPC 协议，也跟 HTTP 类似，一般还会再建个连接池

### 传输的内容

- http：header，body 很啰嗦
- grpc：定制化更高，protobuf，性能会好

## rpc 框架

### 代理层

- 负责对底层调用细节的封装

### 路由层

- 负责在集群目标服务中的调用筛选策略

### 协议层

- 负责请求数据的转码封装等作用

### 链路层

- 负责执行一些自定义的过滤链路，可以供后期二次扩展

### 注册中心层

- 关注服务的上下线，以及一些权重，配置动态调整等功能

### 序列化层

- 负责将不同的序列化技术嵌套在框架中

### 容错层

- 当服务调用出现失败之后需要有容错层的兜底辅助

### 接入层

- 考虑如何与常用框架 Spring 的接入

### 公共层

- 主要存放一些通用配置，工具类，缓存等信息
