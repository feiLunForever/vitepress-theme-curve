---
title: bk 自我介绍
tags:
  - 项目
categories:
  - 项目
date: '2025-01-03'
description: 欢迎使用 Curve 主题，这是你的第一篇文章
articleGPT: 这是一篇初始化文章，旨在告诉用户一些使用说明和须知。
#cover: "/images/logo/logo.webp"
---

# bk 自我介绍

大家好，我叫XXX  
我现在开发三年了，平常也加班比较多，周末时间喜欢去读一些书籍或专栏来加深一下自己的知识深度，也会去刷一些leetcode来提升一下自己的逻辑思维。我目前还在秉坤数码科技有限公司工作，已两年有余，简单介绍一下两个主要项目吧。

当我还在saas团队的时候，主要负责订单平台的开发，主要就是收集并接收线上线下的订单，根据客户的不同需求，定制开发不同的单据流程。主要有五个亮点吧：  
一、定制化协议，不同的单据，根据配置协议的不同，走不同的流程  
二、定义标准的SPI，支持订阅事件，通过自定义注解和AOP技术实现了通知订阅用户的标准流程  
三、通过PriorityBlockingQueue同步队列，配合RocketMq和线程池技术实现订单的收集，并通过RateLimiter实现了推送下游单据速率的控制  
四、动态设置规则，使用Debezium实现CDC功能，简单来说订阅了bin_log日志，然后发送了mq，发送mq刷新规则结果集  
五、使用quartz 作业框架，实现对大数据量的信息的定时监控和告警

逐步细说。。。。。（待整理）  
1、定制化协议：自定义了一个operator接口，可以理解为单据流转的原子操作，比如扣减库存，生成普通销售单等等，然后在页面上配置一些路由规则，根据单据的类型啊，商品的类型啊，可以匹配一条优先级最高的协议，里面绑定了制定好的operator，这样就实现了定制化协议的低代码开发，比如小众品牌的简单流程，基本上不用怎么开发，配置一些协议即可实现单据的流转  
2、标准SPI：通过自定义注解和AOP实现，发送相应事件mq，在消费者端判断当前环境是否订阅了事件（url、秘钥等参数，或者integration），然后就会去dopost，请求第三方url，实现事件的通知  
3、提供了订单收集的接口，第三方会定期推送一些订单给到订单平台，除了必要的校验和异步保存（mq），剩下的就能全部放到PriorityBlockingQueue同步队列中去了，  
SynchroOrder实现了CommandLineRunner，初始化线程池，不断循环，同步队列中ratePoll出来，private RateLimiter limiter = RateLimiter.create(100);每秒100个令牌，（limiter.acquire(100);）每次消耗100个令牌，然后发送mq推送下游  
4、动态设置规则，使用Debezium实现CDC功能，比如说设置的规则是ssf类型门店，那有一个结果集就是计算出来所有ssf门店的oid，可是如果后面新增了门店怎么办，那就需要cdc了。订阅了bin_log日志，然后发送了mq，发送mq刷新规则结果集  
5、

第二个主要项目就是进入到了PAAS团队，开发公司自己的paas平台。  
主要为saas提供了很多基础服务，可以减少代码开发，这边只要提供的服务有  
可视化建模、job在线配置、沙盒体系、加载和发布自定义代码、缓存和多租户数据隔离等功能。  
一、可视化建模，就是在页面上托拉拽一些组件，即可完成简单页面的编排。  
二、沙盒体系就是说，比如开发一个功能，大家都在一个基础租户上开发，会造成相互影响，那就在这个租户上切出不同沙盒（copy），这样就不会相互影响了，再加上会定时回收租户和沙盒，减少资源的浪费  
三、提供了打包和安装加载自定义代码的功能，通过重新构建ClassLoader和重建容器，添加新的BeanDefinition实现热部署  
四、提供了redis和内存缓存多种缓存能力  
五、基于Quartz，提供了定时作业的能力  
六、多租户隔离架构，通过公用超级租户，实现多数据源的切换，指定租户数据源，实现了数据的隔离性

1、可视化建模  
2、沙盒体系就是说，比如开发一个功能，大家都在一个基础租户上开发，会造成相互影响，那就在这个租户上切出不同沙盒（copy），这样就不会相互影响了，再加上会定时回收租户和沙盒，减少资源的浪费  
3、打包和安装元数据，以及加载自定义代码：  
比如我在开发环境新建了页面和一些表结构，可以通过打包的功能，生成XML文件，然后根据xml文件，再重新安装到新的环境，那新的环境就有了那些表结构和页面  
打包其实就是从数据库中查出来，然后根据自己的规则解析成xml，然后安装这个规则，解析并安装到新的环境中去

加载自定义代码：saas团队发布代码其实就是将jar包scp到服务器上去，然后重新构建classloader（new URLClassLoader()）// 加载外部的jar包 然后创建新的spring上下文，即每个租户一套独立的spring上下文，获取bean到时候，优先根据租户的上下文获取，然后再根据kk获取  
springMVC(待整理吧)

4、数据源切换：

继承了AbstractDataSource
重写了 getConnection()，每次执行sql前，都会执行这个方法，这边大致逻辑就是  
首先计算一下一个数据源的唯一标识（超级租户oid+"_"+当前租户的oid），查看resolvedDataSources缓存中是否存在，如果不存在就创建一个新的数据源DruidDataSource，设置url，密码等参数
